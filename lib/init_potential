Advection_diffusion.c:    int m=E->parallel.me;
Advection_diffusion.c:    input_boolean("ADV",&(E->advection.ADVECTION),"on",m);
Advection_diffusion.c:    input_boolean("filter_temp",&(E->advection.filter_temperature),"off",m);
Advection_diffusion.c:    input_boolean("monitor_max_T",&(E->advection.monitor_max_T),"on",m);
Advection_diffusion.c:    input_int("minstep",&(E->advection.min_timesteps),"1",m);
Advection_diffusion.c://    input_int("maxstep",&(E->advection.max_timesteps),"1000",m);
Advection_diffusion.c://    input_int("maxtotstep",&(E->advection.max_total_timesteps),"1000000",m);
Advection_diffusion.c:    input_float("finetunedt",&(E->advection.fine_tune_dt),"0.9",m);
Advection_diffusion.c:    input_float("fixed_timestep",&(E->advection.fixed_timestep),"0.0",m);
Advection_diffusion.c:    input_float("adv_gamma",&(E->advection.gamma),"0.5",m);
Advection_diffusion.c:    input_int("adv_sub_iterations",&(E->advection.temp_iterations),"2,1,nomax",m);
Advection_diffusion.c:    input_float("inputdiffusivity",&(E->control.inputdiff),"1.0",m);
Advection_diffusion.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Advection_diffusion.c:    E->Tdot[m]= (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Advection_diffusion.c:    for(i=1;i<=E->lmesh.nno;i++)
Advection_diffusion.c:      E->Tdot[m][i]=0.0;
Advection_diffusion.c:    const int dims=E->mesh.nsd;
Advection_diffusion.c:    const int dofs=E->mesh.dof;
Advection_diffusion.c:    const int nno=E->lmesh.nno;
Advection_diffusion.c:    const int lev=E->mesh.levmax;
Advection_diffusion.c:    nel=E->lmesh.nel;
Advection_diffusion.c:    if(E->advection.fixed_timestep != 0.0) {
Advection_diffusion.c:      E->advection.timestep = E->advection.fixed_timestep;
Advection_diffusion.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:	  uc1 += E->N.ppt[GNPINDEX(i,1)]*VV[1][i];
Advection_diffusion.c:	  uc2 += E->N.ppt[GNPINDEX(i,1)]*VV[2][i];
Advection_diffusion.c:	  uc3 += E->N.ppt[GNPINDEX(i,1)]*VV[3][i];
Advection_diffusion.c:	uc = fabs(uc1)/E->eco[m][el].size[1] + fabs(uc2)/E->eco[m][el].size[2] + fabs(uc3)/E->eco[m][el].size[3];
Advection_diffusion.c:    adv_timestep = E->advection.dt_reduced * adv_timestep;
Advection_diffusion.c:    adv_timestep = 1.0e-32 + min(E->advection.fine_tune_dt*adv_timestep,
Advection_diffusion.c:				 E->advection.diff_timestep);
Advection_diffusion.c:    E->advection.timestep = global_fmin(E,adv_timestep);
Advection_diffusion.c:/*     if (E->parallel.me==0) */
Advection_diffusion.c:/*       fprintf(stderr, "adv_timestep=%g diff_timestep=%g\n",adv_timestep,E->advection.diff_timestep); */
Advection_diffusion.c:  E->advection.timesteps++;
Advection_diffusion.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:    DTdot[m]= (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Advection_diffusion.c:  if(E->advection.monitor_max_T) {
Advection_diffusion.c:     for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Advection_diffusion.c:         T1[m]= (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Advection_diffusion.c:         Tdot1[m]= (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Advection_diffusion.c:     for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:         for (i=1;i<=E->lmesh.nno;i++)   {
Advection_diffusion.c:             T1[m][i] = E->T[m][i];
Advection_diffusion.c:             Tdot1[m][i] = E->Tdot[m][i];
Advection_diffusion.c:     T_interior1 = Tmaxd(E,E->T);
Advection_diffusion.c:  E->advection.dt_reduced = 1.0;
Advection_diffusion.c:  E->advection.last_sub_iterations = 1;
Advection_diffusion.c:    E->advection.timestep *= E->advection.dt_reduced;
Advection_diffusion.c:    if (E->advection.ADVECTION) {
Advection_diffusion.c:      predictor(E,E->T,E->Tdot);
Advection_diffusion.c:      for(psc_pass=0;psc_pass<E->advection.temp_iterations;psc_pass++)   {
Advection_diffusion.c:        if(E->control.disptn_number != 0)
Advection_diffusion.c:	pg_solver(E,E->T,E->Tdot,DTdot,&(E->convection.heat_sources),E->control.inputdiff,1,E->node);
Advection_diffusion.c:	corrector(E,E->T,E->Tdot,DTdot);
Advection_diffusion.c:      if(E->advection.monitor_max_T) {
Advection_diffusion.c:          E->monitor.T_interior = Tmaxd(E,E->T);
Advection_diffusion.c:          if (E->monitor.T_interior/T_interior1 > E->monitor.T_maxvaried) {
Advection_diffusion.c:              if(E->parallel.me==0) {
Advection_diffusion.c:                          T_interior1, E->monitor.T_interior);
Advection_diffusion.c:                  fprintf(E->fp, "max T varied from %e to %e\n",
Advection_diffusion.c:                          T_interior1, E->monitor.T_interior);
Advection_diffusion.c:              for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:                  for (i=1;i<=E->lmesh.nno;i++)   {
Advection_diffusion.c:                      E->T[m][i] = T1[m][i];
Advection_diffusion.c:                      E->Tdot[m][i] = Tdot1[m][i];
Advection_diffusion.c:              E->advection.dt_reduced *= 0.5;
Advection_diffusion.c:              E->advection.last_sub_iterations ++;
Advection_diffusion.c:  }  while ( iredo==1 && E->advection.last_sub_iterations <= 5);
Advection_diffusion.c:  if(E->advection.filter_temperature)
Advection_diffusion.c:  E->advection.total_timesteps++;
Advection_diffusion.c:  E->monitor.elapsed_time += E->advection.timestep;
Advection_diffusion.c:  if (E->advection.last_sub_iterations==5)
Advection_diffusion.c:    E->control.keep_going = 0;
Advection_diffusion.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Advection_diffusion.c:  if(E->advection.monitor_max_T) {
Advection_diffusion.c:      for(m=1;m<=E->sphere.caps_per_proc;m++) {
Advection_diffusion.c:  if(E->control.lith_age) {
Advection_diffusion.c:      if(E->parallel.me==0) fprintf(stderr,"PG_timestep_solve\n");
Advection_diffusion.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:    for(el=1;el<=E->lmesh.nel;el++)  {
Advection_diffusion.c:      for(d=1;d<=E->mesh.nsd;d++)    {
Advection_diffusion.c:	ts = E->eco[m][el].size[d] * E->eco[m][el].size[d];
Advection_diffusion.c:  E->advection.diff_timestep = 0.5 * diff_timestep;
Advection_diffusion.c:  multiplier = (1.0-E->advection.gamma) * E->advection.timestep;
Advection_diffusion.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:    for(node=1;node<=E->lmesh.nno;node++)  {
Advection_diffusion.c:  multiplier = E->advection.gamma * E->advection.timestep;
Advection_diffusion.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:    for(node=1;node<=E->lmesh.nno;node++) {
Advection_diffusion.c:    const int dims=E->mesh.nsd;
Advection_diffusion.c:    const int dofs=E->mesh.dof;
Advection_diffusion.c:    const int lev=E->mesh.levmax;
Advection_diffusion.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:      for(i=1;i<=E->lmesh.nno;i++)
Advection_diffusion.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:       for(el=1;el<=E->lmesh.nel;el++)    {
Advection_diffusion.c:          pg_shape_fn(E, el, &PG, &(E->gNX[m][el]), VV,
Advection_diffusion.c:          element_residual(E, el, &PG, &(E->gNX[m][el]), &(E->gDA[m][el]),
Advection_diffusion.c:                           Q0, Eres, rtf, diff, E->sphere.cap[m].TB,
Advection_diffusion.c:	    a1 = E->ien[m][el].node[a];
Advection_diffusion.c:    (E->exchange_node_d)(E,DTdot,lev);
Advection_diffusion.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:      for(i=1;i<=E->lmesh.nno;i++) {
Advection_diffusion.c:        if(!(E->node[m][i] & (TBX | TBY | TBZ))){
Advection_diffusion.c:	  DTdot[m][i] *= E->TMass[m][i];         /* lumped mass matrix */
Advection_diffusion.c:    ienm=E->ien[m][el].node;
Advection_diffusion.c:      uc1 +=  E->N.ppt[GNPINDEX(i,1)]*VV[1][i];
Advection_diffusion.c:      uc2 +=  E->N.ppt[GNPINDEX(i,1)]*VV[2][i];
Advection_diffusion.c:      uc3 +=  E->N.ppt[GNPINDEX(i,1)]*VV[3][i];
Advection_diffusion.c:    uxse = fabs(uc1*E->eco[m][el].size[1]);
Advection_diffusion.c:    ueta = fabs(uc2*E->eco[m][el].size[2]);
Advection_diffusion.c:    ufai = fabs(uc3*E->eco[m][el].size[3]);
Advection_diffusion.c:		u1 += VV[1][j] * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:		u2 += VV[2][j] * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:	   	u3 += VV[3][j] * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:	    PG->vpt[GNVINDEX(j,i)] = E->N.vpt[GNVINDEX(j,i)] + adiff * prod1;
Advection_diffusion.c:    const int dims=E->mesh.nsd;
Advection_diffusion.c:    const int dofs=E->mesh.dof;
Advection_diffusion.c:    const int nno=E->lmesh.nno;
Advection_diffusion.c:    const int lev=E->mesh.levmax;
Advection_diffusion.c:      node = E->ien[m][el].node[j];
Advection_diffusion.c:      if(E->node[m][node] & (TBX | TBY | TBZ))
Advection_diffusion.c:          dT[i] += DT * E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:          sfn = E->N.vpt[GNVINDEX(j,i)];
Advection_diffusion.c:	  Q += Q0->Q[i] * exp(-Q0->lambda[i] * (E->monitor.elapsed_time+Q0->t_offset));
Advection_diffusion.c:    Q = E->control.Q0;
Advection_diffusion.c:    if(E->control.tracer_enriched){
Advection_diffusion.c:      Q *= (1.0 - E->composition.comp_el[m][0][el]);
Advection_diffusion.c:      Q += E->composition.comp_el[m][0][el] * E->control.Q0ER;
Advection_diffusion.c:    nz = ((el-1) % E->lmesh.elz) + 1;
Advection_diffusion.c:    rho = 0.5 * (E->refstate.rho[nz] + E->refstate.rho[nz+1]);
Advection_diffusion.c:    cp = 0.5 * (E->refstate.heat_capacity[nz] + E->refstate.heat_capacity[nz+1]);
Advection_diffusion.c:    if(E->control.disptn_number == 0)
Advection_diffusion.c:        /* E->heating_latent is actually the inverse of latent heating */
Advection_diffusion.c:        heating = (rho * Q - E->heating_adi[m][el] + E->heating_visc[m][el])
Advection_diffusion.c:            * E->heating_latent[m][el];
Advection_diffusion.c:              + diff * dOmega->vpt[i] * E->heating_latent[m][el]
Advection_diffusion.c:      if (FLAGS[m][E->ien[m][el].node[1]] & FBZ) {   // only check for the 1st node
Advection_diffusion.c:      else if (FLAGS[m][E->ien[m][el].node[5]] & FBZ) {   // only check for the 5th node
Advection_diffusion.c:              dT[j] += E->M.vpt[GMVINDEX(k,j)]*BC[3][E->ien[m][el].node[k+aid*onedvpts]];
Advection_diffusion.c:		E->M.vpt[GMVINDEX(a,j)] * g_1d[j].weight[dims-1] *
Advection_diffusion.c:    lev=E->mesh.levmax;
Advection_diffusion.c:    rhocp = (double *)malloc((E->lmesh.noz+1)*sizeof(double));
Advection_diffusion.c:    for(i=1;i<=E->lmesh.noz;i++)
Advection_diffusion.c:        rhocp[i] = E->refstate.rho[i] * E->refstate.heat_capacity[i];
Advection_diffusion.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:        for(i=1;i<=E->lmesh.nno;i++)  {
Advection_diffusion.c:            nz = ((i-1) % E->lmesh.noz) + 1;
Advection_diffusion.c:            if(!(E->NODE[lev][m][i] & SKIP))
Advection_diffusion.c:                Tsum0 += E->T[m][i]*rhocp[nz];
Advection_diffusion.c:            if(E->T[m][i]<Tmin)  Tmin=E->T[m][i];
Advection_diffusion.c:            if(E->T[m][i]<Tmin0) E->T[m][i]=Tmin0;
Advection_diffusion.c:            if(E->T[m][i]>Tmax) Tmax=E->T[m][i];
Advection_diffusion.c:            if(E->T[m][i]>Tmax0) E->T[m][i]=Tmax0;
Advection_diffusion.c:    MPI_Allreduce(&Tmin,&Tmin1,1,MPI_DOUBLE,MPI_MIN,E->parallel.world);
Advection_diffusion.c:    MPI_Allreduce(&Tmax,&Tmax1,1,MPI_DOUBLE,MPI_MAX,E->parallel.world);
Advection_diffusion.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:        for(i=1;i<=E->lmesh.nno;i++)  {
Advection_diffusion.c:            nz = ((i-1) % E->lmesh.noz) + 1;
Advection_diffusion.c:            if(E->T[m][i]<=fabs(2*Tmin0-Tmin1))   E->T[m][i]=Tmin0;
Advection_diffusion.c:            if(E->T[m][i]>=(2*Tmax0-Tmax1))   E->T[m][i]=Tmax0;
Advection_diffusion.c:            if (!(E->NODE[lev][m][i] & SKIP))  {
Advection_diffusion.c:                Tsum1 += E->T[m][i]*rhocp[nz];
Advection_diffusion.c:                if(E->T[m][i]!=Tmin0 && E->T[m][i]!=Tmax0) {
Advection_diffusion.c:    MPI_Allreduce(&TDIST,&TDIST1,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Advection_diffusion.c:    MPI_Allreduce(&sum_rhocp,&total_sum_rhocp,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Advection_diffusion.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Advection_diffusion.c:        for(i=1;i<=E->lmesh.nno;i++)   {
Advection_diffusion.c:            if(E->T[m][i]!=Tmin0 && E->T[m][i]!=Tmax0)
Advection_diffusion.c:                E->T[m][i] +=TDIST;
Advection_diffusion.c:    strain_sqr = (float*) malloc((E->lmesh.nel+1)*sizeof(float));
Advection_diffusion.c:    temp = E->control.disptn_number / E->control.Atemp / vpts;
Advection_diffusion.c:    for(e=1; e<=E->lmesh.nel; e++) {
Advection_diffusion.c:            visc += E->EVi[m][(e-1)*vpts + i];
Advection_diffusion.c:    temp2 = E->control.disptn_number / ends;
Advection_diffusion.c:    for(e=1; e<=E->lmesh.nel; e++) {
Advection_diffusion.c:        ez = (e - 1) % E->lmesh.elz + 1;
Advection_diffusion.c:            * (E->refstate.thermal_expansivity[ez] +
Advection_diffusion.c:               E->refstate.thermal_expansivity[ez + 1])
Advection_diffusion.c:            * (E->refstate.rho[ez] + E->refstate.rho[ez + 1])
Advection_diffusion.c:            * (E->refstate.gravity[ez] + E->refstate.gravity[ez + 1]);
Advection_diffusion.c:            j = E->ien[m][e].node[i];
Advection_diffusion.c:            temp1 += E->sphere.cap[m].V[3][j]
Advection_diffusion.c:                * (E->T[m][j] + E->control.surface_temp);
Advection_diffusion.c:    temp0 = 2.0 * inv_width * clapeyron * E->control.disptn_number * Ra / E->control.Atemp / ends;
Advection_diffusion.c:    for(e=1; e<=E->lmesh.nel; e++) {
Advection_diffusion.c:        ez = (e - 1) % E->lmesh.elz + 1;
Advection_diffusion.c:            * (E->refstate.thermal_expansivity[ez] +
Advection_diffusion.c:               E->refstate.thermal_expansivity[ez + 1])
Advection_diffusion.c:            * (E->refstate.rho[ez] + E->refstate.rho[ez + 1])
Advection_diffusion.c:            * (E->refstate.gravity[ez] + E->refstate.gravity[ez + 1]);
Advection_diffusion.c:            j = E->ien[m][e].node[i];
Advection_diffusion.c:                * (E->T[m][j] + E->control.surface_temp);
Advection_diffusion.c:            temp2 += temp * E->sphere.cap[m].V[3][j];
Advection_diffusion.c:    for(e=1; e<=E->lmesh.nel; e++)
Advection_diffusion.c:    if(E->control.Ra_410 != 0.0) {
Advection_diffusion.c:                       E->Fas410, E->control.Ra_410,
Advection_diffusion.c:                       E->control.clapeyron410, E->viscosity.z410,
Advection_diffusion.c:                       E->control.transT410, E->control.inv_width410);
Advection_diffusion.c:    if(E->control.Ra_670 != 0.0) {
Advection_diffusion.c:                       E->Fas670, E->control.Ra_670,
Advection_diffusion.c:                       E->control.clapeyron670, E->viscosity.zlm,
Advection_diffusion.c:                       E->control.transT670, E->control.inv_width670);
Advection_diffusion.c:    if(E->control.Ra_cmb != 0.0) {
Advection_diffusion.c:                       E->Fascmb, E->control.Ra_cmb,
Advection_diffusion.c:                       E->control.clapeyroncmb, E->viscosity.zcmb,
Advection_diffusion.c:                       E->control.transTcmb, E->control.inv_widthcmb);
Advection_diffusion.c:    if(E->control.Ra_410 != 0 || E->control.Ra_670 != 0.0 ||
Advection_diffusion.c:       E->control.Ra_cmb != 0) {
Advection_diffusion.c:        for(e=1; e<=E->lmesh.nel; e++)
Advection_diffusion.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Advection_diffusion.c:        for(e=1; e<=E->lmesh.nel; e++)
Advection_diffusion.c:            sum += heating[m][e] * E->eco[m][e].area;
Advection_diffusion.c:                  MPI_DOUBLE, MPI_SUM, E->parallel.world);
Advection_diffusion.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Advection_diffusion.c:            process_visc_heating(E, m, E->heating_visc[m]);
Advection_diffusion.c:        process_adi_heating(E, m, E->heating_adi[m]);
Advection_diffusion.c:        process_latent_heating(E, m, E->heating_latent[m], E->heating_adi[m]);
Advection_diffusion.c:    if(psc_pass == (E->advection.temp_iterations-1)) {
Advection_diffusion.c:        total_visc_heating = total_heating(E, E->heating_visc);
Advection_diffusion.c:        total_adi_heating = total_heating(E, E->heating_adi);
Advection_diffusion.c:        if(E->parallel.me == 0) {
Advection_diffusion.c:            fprintf(E->fp, "Step: %d, Total_heating(visc, adi): %g %g\n",
Advection_diffusion.c:                    E->monitor.solution_cycles,
Advection_diffusion.c:                    E->monitor.solution_cycles,
BC_util.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
BC_util.c:    if (E->num_zero_resid[level][m])
BC_util.c:      for(i=1;i<=E->num_zero_resid[level][m];i++)
BC_util.c:         Res[m][E->zero_resid[level][m][i]] = 0.0;
BC_util.c:  if(E->control.lith_age) {
BC_util.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)
BC_util.c:    for(node=1;node<=E->lmesh.nno;node++)  {
BC_util.c:        type = (E->node[j][node] & (TBX | TBZ | TBY));
BC_util.c:            E->T[j][node] = E->sphere.cap[j].TB[1][node];
BC_util.c:            E->T[j][node] = E->sphere.cap[j].TB[3][node];
BC_util.c:            E->T[j][node] = E->sphere.cap[j].TB[2][node];
BC_util.c:            E->T[j][node] = 0.5 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[3][node]);
BC_util.c:            E->T[j][node] = 0.5 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[2][node]);
BC_util.c:            E->T[j][node] = 0.5 * (E->sphere.cap[j].TB[3][node] + E->sphere.cap[j].TB[2][node]);
BC_util.c:            E->T[j][node] = 0.3333333 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[2][node] + E->sphere.cap[j].TB[3][node]);
BC_util.c:    const int nno = E->lmesh.nno;
BC_util.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)   {
BC_util.c:        if (E->node[m][node] & typex)
BC_util.c:	      U[m][E->id[m][node].doff[1]] = E->sphere.cap[m].VB[1][node];
BC_util.c: 	if (E->node[m][node] & typey)
BC_util.c:	      U[m][E->id[m][node].doff[2]] = E->sphere.cap[m].VB[2][node];
BC_util.c:	if (E->node[m][node] & typez)
BC_util.c:	      U[m][E->id[m][node].doff[3]] = E->sphere.cap[m].VB[3][node];
Checkpoints.c:    sprintf(output_file, "%s.chkpt.%d.%d", E->control.data_file,
Checkpoints.c:            E->parallel.me, E->monitor.solution_cycles);
Checkpoints.c:    if(E->control.tracer) {
Checkpoints.c:        if(E->composition.on)
Checkpoints.c:    snprintf(output_file, 254, "%s.chkpt.%d.%d", E->control.old_P_file,
Checkpoints.c:             E->parallel.me, E->monitor.solution_cycles_init);
Checkpoints.c:    if(E->parallel.me == 0)
Checkpoints.c:    /* init E->mat */
Checkpoints.c:    if(E->control.tracer) {
Checkpoints.c:      if(E->trace.ic_method_for_flavors == 99){
Checkpoints.c:	if(E->parallel.me == 0)
Checkpoints.c:        if(E->composition.on)
Checkpoints.c:    fwrite(&(E->lmesh.nox), sizeof(int), 1, fp);
Checkpoints.c:    fwrite(&(E->lmesh.noy), sizeof(int), 1, fp);
Checkpoints.c:    fwrite(&(E->lmesh.noz), sizeof(int), 1, fp);
Checkpoints.c:    fwrite(&(E->parallel.nprocx), sizeof(int), 1, fp);
Checkpoints.c:    fwrite(&(E->parallel.nprocy), sizeof(int), 1, fp);
Checkpoints.c:    fwrite(&(E->parallel.nprocz), sizeof(int), 1, fp);
Checkpoints.c:    fwrite(&(E->sphere.caps_per_proc), sizeof(int), 1, fp);
Checkpoints.c:    fwrite(&(E->monitor.solution_cycles), sizeof(int), 1, fp);
Checkpoints.c:    fwrite(&(E->monitor.elapsed_time), sizeof(float), 1, fp);
Checkpoints.c:    fwrite(&(E->advection.timestep), sizeof(float), 1, fp);
Checkpoints.c:    fwrite(&(E->control.start_age), sizeof(float), 1, fp);
Checkpoints.c:    if((tmp[0] != E->lmesh.nox) ||
Checkpoints.c:       (tmp[1] != E->lmesh.noy) ||
Checkpoints.c:       (tmp[2] != E->lmesh.noz) ||
Checkpoints.c:       (tmp[3] != E->parallel.nprocx) ||
Checkpoints.c:       (tmp[4] != E->parallel.nprocy) ||
Checkpoints.c:       (tmp[5] != E->parallel.nprocz) ||
Checkpoints.c:       (tmp[6] != E->sphere.caps_per_proc)) {
Checkpoints.c:                E->parallel.me);
Checkpoints.c:    tmp[0] = fread(&(E->monitor.solution_cycles), sizeof(int), 1, fp);
Checkpoints.c:    tmp[0]+= fread(&(E->monitor.elapsed_time), sizeof(float), 1, fp);
Checkpoints.c:    tmp[0]+= fread(&(E->advection.timestep), sizeof(float), 1, fp);
Checkpoints.c:    tmp[0]+= fread(&(E->control.start_age), sizeof(float), 1, fp);
Checkpoints.c:    E->advection.timesteps = E->monitor.solution_cycles;
Checkpoints.c:    fwrite(&(E->trace.number_of_basic_quantities), sizeof(int), 1, fp);
Checkpoints.c:    fwrite(&(E->trace.number_of_extra_quantities), sizeof(int), 1, fp);
Checkpoints.c:    fwrite(&(E->trace.nflavors), sizeof(int), 1, fp);
Checkpoints.c:    fwrite(&(E->trace.ilast_tracer_count), sizeof(int), 1, fp);
Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Checkpoints.c:        fwrite(&(E->trace.ntracers[m]), sizeof(int), 1, fp);
Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:            fwrite(E->trace.basicq[m][i], sizeof(double),
Checkpoints.c:                   E->trace.ntracers[m]+1, fp);
Checkpoints.c:        for(i=0; i<E->trace.number_of_extra_quantities; i++) {
Checkpoints.c:            fwrite(E->trace.extraq[m][i], sizeof(double),
Checkpoints.c:                   E->trace.ntracers[m]+1, fp);
Checkpoints.c:        fwrite(E->trace.ielement[m], sizeof(int),
Checkpoints.c:               E->trace.ntracers[m]+1, fp);
Checkpoints.c:    read_sentinel(fp, E->parallel.me);
Checkpoints.c:    if (itmp != E->trace.number_of_basic_quantities) {
Checkpoints.c:                E->parallel.me);
Checkpoints.c:    if (itmp != E->trace.number_of_extra_quantities) {
Checkpoints.c:                E->parallel.me);
Checkpoints.c:    if (itmp != E->trace.nflavors) {
Checkpoints.c:                E->parallel.me);
Checkpoints.c:    E->trace.ilast_tracer_count = itmp;
Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:        E->trace.ntracers[m] = itmp;
Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:            fread(E->trace.basicq[m][i], sizeof(double),
Checkpoints.c:                  E->trace.ntracers[m]+1, fp);
Checkpoints.c:        for(i=0; i<E->trace.number_of_extra_quantities; i++) {
Checkpoints.c:            fread(E->trace.extraq[m][i], sizeof(double),
Checkpoints.c:                  E->trace.ntracers[m]+1, fp);
Checkpoints.c:        fread(E->trace.ielement[m], sizeof(int),
Checkpoints.c:              E->trace.ntracers[m]+1, fp);
Checkpoints.c:    /* init E->trace.ntracer_flavor */
Checkpoints.c:    fwrite(&(E->composition.ncomp), sizeof(int), 1, fp);
Checkpoints.c:    fwrite(E->composition.bulk_composition, sizeof(double),
Checkpoints.c:           E->composition.ncomp, fp);
Checkpoints.c:    fwrite(E->composition.initial_bulk_composition, sizeof(double),
Checkpoints.c:           E->composition.ncomp, fp);
Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:        for(i=0; i<E->composition.ncomp; i++)
Checkpoints.c:            fwrite(E->composition.comp_el[m][i], sizeof(double),
Checkpoints.c:                   E->lmesh.nel+1, fp);
Checkpoints.c:    read_sentinel(fp, E->parallel.me);
Checkpoints.c:    if (itmp != E->composition.ncomp) {
Checkpoints.c:                E->parallel.me);
Checkpoints.c:    fread(E->composition.bulk_composition, sizeof(double),
Checkpoints.c:          E->composition.ncomp, fp);
Checkpoints.c:    fread(E->composition.initial_bulk_composition, sizeof(double),
Checkpoints.c:          E->composition.ncomp, fp);
Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:        for(i=0; i<E->composition.ncomp; i++)
Checkpoints.c:            fread(E->composition.comp_el[m][i], sizeof(double),
Checkpoints.c:                  E->lmesh.nel+1, fp);
Checkpoints.c:    /* init E->composition.comp_node */
Checkpoints.c:    E->trace.istat_iempty = 0;
Checkpoints.c:    for (i=0; i<E->composition.ncomp; i++) {
Checkpoints.c:        E->composition.error_fraction[i] = E->composition.bulk_composition[i]
Checkpoints.c:        / E->composition.initial_bulk_composition[i] - 1.0;
Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:        fwrite(E->T[m], sizeof(double), E->lmesh.nno+1, fp);
Checkpoints.c:        fwrite(E->Tdot[m], sizeof(double), E->lmesh.nno+1, fp);
Checkpoints.c:    read_sentinel(fp, E->parallel.me);
Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:      if(fread(E->T[m], sizeof(double), E->lmesh.nno+1, fp)!= E->lmesh.nno+1)
Checkpoints.c:      if(fread(E->Tdot[m], sizeof(double), E->lmesh.nno+1, fp)!=E->lmesh.nno+1)
Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:        fwrite(E->P[m], sizeof(double), E->lmesh.npno+1, fp);
Checkpoints.c:        fwrite(E->U[m], sizeof(double), E->lmesh.neq, fp);
Checkpoints.c:    int lev = E->mesh.levmax;
Checkpoints.c:    read_sentinel(fp, E->parallel.me);
Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Checkpoints.c:      if(fread(E->P[m], sizeof(double), E->lmesh.npno+1, fp) !=  E->lmesh.npno+1)
Checkpoints.c:      if(fread(E->U[m], sizeof(double), E->lmesh.neq, fp) != E->lmesh.neq)
Checkpoints.c:    E->monitor.vdotv = global_v_norm2(E, E->U);
Checkpoints.c:    E->monitor.pdotp = global_p_norm2(E, E->P);
Checkpoints.c:    /* init E->NP */
Checkpoints.c:    p_to_nodes(E, E->P, E->NP, lev);
Citcom_init.c:  E->control.PID = get_process_identifier();
Citcom_init.c:  E->parallel.world = *world;
Citcom_init.c:  E->parallel.nproc = nproc;
Citcom_init.c:  E->parallel.me = rank;
Citcom_init.c:          rank, nproc, E, E->control.PID); */
Citcom_init.c:  E->monitor.solution_cycles=0;
Citcom_init.c:  E->control.keep_going=1;
Citcom_init.c:  E->control.total_iteration_cycles=0;
Citcom_init.c:  E->control.total_v_solver_calls=0;
Composition_related.c:    int m = E->parallel.me;
Composition_related.c:		  &(E->composition.ichemical_buoyancy),
Composition_related.c:    if (E->control.tracer && E->composition.ichemical_buoyancy) {
Composition_related.c:        input_int("buoy_type",&(E->composition.ibuoy_type),"1,0,nomax",m);
Composition_related.c:        if (E->composition.ibuoy_type!=1) {
Composition_related.c:        if (E->composition.ibuoy_type==0)
Composition_related.c:            E->composition.ncomp = E->trace.nflavors;
Composition_related.c:        else if (E->composition.ibuoy_type==1)
Composition_related.c:            E->composition.ncomp = E->trace.nflavors - 1;
Composition_related.c:        E->composition.buoyancy_ratio = (double*) malloc(E->composition.ncomp
Composition_related.c:        for (i=0; i<E->composition.ncomp; i++)
Composition_related.c:            E->composition.buoyancy_ratio[i] = 1.0;
Composition_related.c:        input_double_vector("buoyancy_ratio", E->composition.ncomp,
Composition_related.c:                            E->composition.buoyancy_ratio,m);
Composition_related.c:    E->composition.icompositional_rheology = 0;
Composition_related.c:              &(E->composition.icompositional_rheology),"1,0,nomax",m);
Composition_related.c:    if (E->composition.icompositional_rheology==1) {
Composition_related.c:                     &(E->composition.compositional_rheology_prefactor),
Composition_related.c:    if (E->composition.ichemical_buoyancy ||
Composition_related.c:        E->composition.icompositional_rheology)
Composition_related.c:        E->composition.on = 1;
Composition_related.c:    if (E->composition.on) {
Composition_related.c:        if (E->trace.nflavors < 1) {
Composition_related.c:            fprintf(E->trace.fpt, "Tracer flavors must be greater than 1 to track composition\n");
Composition_related.c:        if (!E->composition.ichemical_buoyancy)
Composition_related.c:	  fprintf(E->trace.fpt,"Passive Tracers\n");
Composition_related.c:	  fprintf(E->trace.fpt,"Active Tracers\n");
Composition_related.c:        if (E->composition.ibuoy_type==1)
Composition_related.c:	  fprintf(E->trace.fpt,"Ratio Method\n");
Composition_related.c:        if (E->composition.ibuoy_type==0)
Composition_related.c:	  fprintf(E->trace.fpt,"Absolute Method\n");
Composition_related.c:        for(k=0; k<E->composition.ncomp; k++) {
Composition_related.c:            fprintf(E->trace.fpt,"Buoyancy Ratio: %f\n", E->composition.buoyancy_ratio[k]);
Composition_related.c:        if (E->composition.icompositional_rheology==0) {
Composition_related.c:            fprintf(E->trace.fpt,"Compositional Rheology - OFF\n");
Composition_related.c:        else if (E->composition.icompositional_rheology>0) {
Composition_related.c:            fprintf(E->trace.fpt,"Compositional Rheology - ON\n");
Composition_related.c:            fprintf(E->trace.fpt,"Compositional Prefactor: %f\n",
Composition_related.c:            E->composition.compositional_rheology_prefactor);
Composition_related.c:        fflush(E->trace.fpt);
Composition_related.c:    if (E->composition.ibuoy_type==1) {
Composition_related.c:    if (E->composition.ibuoy_type!=1) {
Composition_related.c:        fprintf(E->trace.fpt,"Error(compute...)-only ratio method now\n");
Composition_related.c:        fflush(E->trace.fpt);
Composition_related.c:    for (i=0; i<E->composition.ncomp; i++) {
Composition_related.c:        E->composition.bulk_composition = (double*) malloc(E->composition.ncomp*sizeof(double));
Composition_related.c:        E->composition.initial_bulk_composition = (double*) malloc(E->composition.ncomp*sizeof(double));
Composition_related.c:        E->composition.error_fraction = (double*) malloc(E->composition.ncomp*sizeof(double));
Composition_related.c:    E->Have.C = (float **)malloc((E->composition.ncomp+1)*sizeof(float*));
Composition_related.c:    for (i=0; i<E->composition.ncomp; i++) {
Composition_related.c:        E->Have.C[i] = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Composition_related.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Composition_related.c:        if ((E->composition.comp_el[j]=(double **)malloc((E->composition.ncomp)*sizeof(double*)))==NULL) {
Composition_related.c:            fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 8987y\n");
Composition_related.c:            fflush(E->trace.fpt);
Composition_related.c:        if ((E->composition.comp_node[j]=(double **)malloc((E->composition.ncomp)*sizeof(double*)))==NULL) {
Composition_related.c:            fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 8988y\n");
Composition_related.c:            fflush(E->trace.fpt);
Composition_related.c:        for (i=0; i<E->composition.ncomp; i++) {
Composition_related.c:            if ((E->composition.comp_el[j][i]=(double *)malloc((E->lmesh.nel+1)*sizeof(double)))==NULL) {
Composition_related.c:                fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 8989y\n");
Composition_related.c:                fflush(E->trace.fpt);
Composition_related.c:            if ((E->composition.comp_node[j][i]=(double *)malloc((E->lmesh.nno+1)*sizeof(double)))==NULL) {
Composition_related.c:                fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 983rk\n");
Composition_related.c:                fflush(E->trace.fpt);
Composition_related.c:    if (E->composition.ibuoy_type==1) {
Composition_related.c:    if (E->composition.ibuoy_type!=1) {
Composition_related.c:        fprintf(E->trace.fpt,"Error(compute...)-only ratio method now\n");
Composition_related.c:        fflush(E->trace.fpt);
Composition_related.c:    if (E->composition.ibuoy_type == 1) {
Composition_related.c:        if (E->trace.istat_iempty) {
Composition_related.c:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Composition_related.c:        for (e=1; e<=E->lmesh.nel; e++) {
Composition_related.c:            for (flavor=0; flavor<E->trace.nflavors; flavor++)
Composition_related.c:                numtracers += E->trace.ntracer_flavor[j][flavor][e];
Composition_related.c:                /* fprintf(E->trace.fpt, "No tracer in element %d!\n", e); */
Composition_related.c:            for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:                E->composition.comp_el[j][i][e] =
Composition_related.c:                    E->trace.ntracer_flavor[j][flavor][e] / (double)numtracers;
Composition_related.c:            if ((1.0*iempty/E->lmesh.nel)>0.80) {
Composition_related.c:                fprintf(E->trace.fpt,"WARNING(compute_elemental...)-number of tracers is REALLY LOW\n");
Composition_related.c:                fflush(E->trace.fpt);
Composition_related.c:                if (E->trace.itracer_warnings) exit(10);
Composition_related.c:    E->trace.istat_iempty += iempty;
Composition_related.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Composition_related.c:        for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:            for (kk=1;kk<=E->lmesh.nno;kk++)
Composition_related.c:                E->composition.comp_node[j][i][kk]=0.0;
Composition_related.c:        for (nelem=1;nelem<=E->lmesh.nel;nelem++) {
Composition_related.c:                n = E->ien[j][nelem].node[nodenum];
Composition_related.c:                for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:                    E->composition.comp_node[j][i][n] +=
Composition_related.c:                        E->composition.comp_el[j][i][nelem]*
Composition_related.c:                        E->TWW[E->mesh.levmax][j][nelem].node[nodenum];
Composition_related.c:    for(i=0;i<E->composition.ncomp;i++) {
Composition_related.c:        for (j=1;j<=E->sphere.caps_per_proc;j++)
Composition_related.c:            tmp[j] = E->composition.comp_node[j][i];
Composition_related.c:        (E->exchange_node_d)(E,tmp,E->mesh.levmax);
Composition_related.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Composition_related.c:        for(i=0;i<E->composition.ncomp;i++)
Composition_related.c:            for (kk=1;kk<=E->lmesh.nno;kk++)
Composition_related.c:                E->composition.comp_node[j][i][kk] *= E->MASS[E->mesh.levmax][j][kk];
Composition_related.c:        for(i=0;i<E->composition.ncomp;i++)
Composition_related.c:            for (kk=1;kk<=E->lmesh.nel;kk++) {
Composition_related.c:                fprintf(E->trace.fpt,"%d %f\n",kk,E->composition.comp_el[j][i][kk]);
Composition_related.c:        for(i=0;i<E->composition.ncomp;i++)
Composition_related.c:            for (kk=1;kk<=E->lmesh.nno;kk++) {
Composition_related.c:                fprintf(E->trace.fpt,"%d %f %f\n",kk,E->sx[j][3][kk],E->composition.comp_node[j][i][kk]);
Composition_related.c:        fflush(E->trace.fpt);
Composition_related.c:    fprintf(E->trace.fpt,"WARNING(check_initial_composition)-number of tracers is low, %d elements contain no tracer initially\n", E->trace.istat_iempty);
Composition_related.c:    fprintf(E->trace.fpt,"Using neighboring elements for initial composition...\n");
Composition_related.c:    nghbrs[0] = E->lmesh.elz;
Composition_related.c:    nghbrs[1] = -E->lmesh.elz;
Composition_related.c:    nghbrs[2] = E->lmesh.elz * E->lmesh.elx;
Composition_related.c:    nghbrs[3] = -E->lmesh.elz * E->lmesh.elx;
Composition_related.c:    is_empty = (int *)calloc(E->lmesh.nel+1, sizeof(int));
Composition_related.c:    sum = (double *)malloc(E->composition.ncomp * sizeof(double));
Composition_related.c:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Composition_related.c:        for (e=1; e<=E->lmesh.nel; e++) {
Composition_related.c:            for (flavor=0; flavor<E->trace.nflavors; flavor++)
Composition_related.c:                numtracers += E->trace.ntracer_flavor[j][flavor][e];
Composition_related.c:        for (e=1; e<=E->lmesh.nel; e++) {
Composition_related.c:                for (i=0; i<E->composition.ncomp; i++)
Composition_related.c:                    if((ee>0) && (ee<=E->lmesh.nel) && (!is_empty[ee])) {
Composition_related.c:                        for (i=0; i<E->composition.ncomp; i++)
Composition_related.c:                            sum[i] += E->composition.comp_el[j][i][ee];
Composition_related.c:                    fprintf(E->trace.fpt,"Error(fill_composition_from_neighbors)-all neighboring elements are empty\n");
Composition_related.c:                    fflush(E->trace.fpt);
Composition_related.c:                for (i=0; i<E->composition.ncomp; i++)
Composition_related.c:                    E->composition.comp_el[j][i][e] = sum[i] / count;
Composition_related.c:    fprintf(E->trace.fpt,"Done.\n");
Composition_related.c:    fflush(E->trace.fpt);
Composition_related.c:    for (i=0; i<E->composition.ncomp; i++) {
Composition_related.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Composition_related.c:            tmp[m] = E->composition.comp_node[m][i];
Composition_related.c:        E->composition.bulk_composition[i] = volume;
Composition_related.c:        E->composition.initial_bulk_composition[i] = volume;
Composition_related.c:    for (i=0; i<E->composition.ncomp; i++) {
Composition_related.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Composition_related.c:            tmp[m] = E->composition.comp_node[m][i];
Composition_related.c:        E->composition.bulk_composition[i] = volume;
Composition_related.c:        E->composition.error_fraction[i] = (volume - E->composition.initial_bulk_composition[i]) / E->composition.initial_bulk_composition[i];
Construct_arrays.c:  const int dims=E->mesh.nsd;
Construct_arrays.c:  for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)  {
Construct_arrays.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Construct_arrays.c:      elx = E->lmesh.ELX[lev];
Construct_arrays.c:      elz = E->lmesh.ELZ[lev];
Construct_arrays.c:      ely = E->lmesh.ELY[lev];
Construct_arrays.c:      nox = E->lmesh.NOX[lev];
Construct_arrays.c:      noz = E->lmesh.NOZ[lev];
Construct_arrays.c:      noy = E->lmesh.NOY[lev];
Construct_arrays.c:      nel=E->lmesh.NEL[lev];
Construct_arrays.c:      nno=E->lmesh.NNO[lev];
Construct_arrays.c:               E->IEN[lev][j][element].node[rr]= start
Construct_arrays.c:/* if(E->control.verbose)  { */
Construct_arrays.c:/*   for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)  { */
Construct_arrays.c:/*     fprintf(E->fp_out,"output_IEN_arrays me=%d lev=%d \n",E->parallel.me,lev); */
Construct_arrays.c:/*   for (j=1;j<=E->sphere.caps_per_proc;j++) { */
Construct_arrays.c:/*     fprintf(E->fp_out,"output_IEN_arrays me=%d %d %d\n",E->parallel.me,j,E->sphere.capid[j]); */
Construct_arrays.c:/*     for (i=1;i<=E->lmesh.NEL[lev];i++) */
Construct_arrays.c:/*        fprintf(E->fp_out,"%d %d %d %d %d %d %d %d %d\n",i,E->IEN[lev][j][i].node[1],E->IEN[lev][j][i].node[2],E->IEN[lev][j][i].node[3],E->IEN[lev][j][i].node[4],E->IEN[lev][j][i].node[5],E->IEN[lev][j][i].node[6],E->IEN[lev][j][i].node[7],E->IEN[lev][j][i].node[8]); */
Construct_arrays.c:/*   fflush (E->fp_out); */
Construct_arrays.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Construct_arrays.c:    for(element=1;element<=E->lmesh.nel;element++)
Construct_arrays.c:      if ( element%E->lmesh.elz==0) { /* top */
Construct_arrays.c:        E->sien[j][e].node[1] = E->ien[j][element].node[5]/E->lmesh.noz;
Construct_arrays.c:        E->sien[j][e].node[2] = E->ien[j][element].node[6]/E->lmesh.noz;
Construct_arrays.c:        E->sien[j][e].node[3] = E->ien[j][element].node[7]/E->lmesh.noz;
Construct_arrays.c:        E->sien[j][e].node[4] = E->ien[j][element].node[8]/E->lmesh.noz;
Construct_arrays.c:        E->surf_element[j][e] = element;
Construct_arrays.c:    E->lmesh.snel = e;
Construct_arrays.c:    for (i=1;i<=E->lmesh.nsf;i++)
Construct_arrays.c:      E->surf_node[j][i] = i*E->lmesh.noz;
Construct_arrays.c:  if(E->control.verbose) {
Construct_arrays.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Construct_arrays.c:      for(e=1;e<=E->lmesh.snel;e++) {
Construct_arrays.c:        fprintf(E->fp_out, "sien sel=%d node=%d %d %d %d\n",
Construct_arrays.c:		e, E->sien[j][e].node[1], E->sien[j][e].node[2], E->sien[j][e].node[3], E->sien[j][e].node[4]);
Construct_arrays.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)  {
Construct_arrays.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Construct_arrays.c:      for(node=1;node<=E->lmesh.NNO[lev];node++)
Construct_arrays.c:          E->ID[lev][j][node].doff[doff] = eqn_count;
Construct_arrays.c:      E->lmesh.NEQ[lev] = eqn_count;
Construct_arrays.c:      for(node=1;node<=E->lmesh.NNO[lev];node++) {
Construct_arrays.c:        if (E->NODE[lev][j][node] & SKIP)
Construct_arrays.c:          E->parallel.Skip_id[lev][j][i] = E->ID[lev][j][node].doff[doff];
Construct_arrays.c:      E->parallel.Skip_neq[lev][j] = i;
Construct_arrays.c:      neq = E->lmesh.NEQ[lev] - E->parallel.Skip_neq[lev][j];
Construct_arrays.c:      MPI_Allreduce(&neq, &gneq, 1, MPI_INT, MPI_SUM, E->parallel.world);
Construct_arrays.c:      E->mesh.NEQ[lev] = gneq;
Construct_arrays.c:    E->lmesh.neq = E->lmesh.NEQ[E->mesh.levmax];
Construct_arrays.c:    E->mesh.neq = E->mesh.NEQ[E->mesh.levmax];
Construct_arrays.c:/*     if (E->control.verbose) { */
Construct_arrays.c:/*       fprintf(E->fp_out,"output_ID_arrays \n"); */
Construct_arrays.c:/*       for(j=1;j<=E->sphere.caps_per_proc;j++)    */
Construct_arrays.c:/*         for (i=1;i<=E->lmesh.nno;i++) */
Construct_arrays.c:/*           fprintf(E->fp_out,"%d %d %d %d %d\n",eqn_count,i,E->ID[lev][j][i].doff[1],E->ID[lev][j][i].doff[2],E->ID[lev][j][i].doff[3]); */
Construct_arrays.c:/*       fflush(E->fp_out); */
Construct_arrays.c:    const int nno=E->lmesh.NNO[level];
Construct_arrays.c:      if ( (E->NODE[level][m][i] & VBX) != 0 )  {
Construct_arrays.c:        E->zero_resid[level][m][j] = E->ID[level][m][i].doff[1];
Construct_arrays.c:      if ( (E->NODE[level][m][i] & VBY) != 0 )  {
Construct_arrays.c:        E->zero_resid[level][m][j] = E->ID[level][m][i].doff[2];
Construct_arrays.c:      if ( (E->NODE[level][m][i] & VBZ) != 0 )  {
Construct_arrays.c:        E->zero_resid[level][m][j] = E->ID[level][m][i].doff[3];
Construct_arrays.c:    E->num_zero_resid[level][m] = j;
Construct_arrays.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Construct_arrays.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)             {
Construct_arrays.c:       neq=E->lmesh.NEQ[lev];
Construct_arrays.c:       nno=E->lmesh.NNO[lev];
Construct_arrays.c:       noxz = E->lmesh.NOX[lev]*E->lmesh.NOZ[lev];
Construct_arrays.c:       noz = E->lmesh.NOZ[lev];
Construct_arrays.c:       noy = E->lmesh.NOY[lev];
Construct_arrays.c:       nox = E->lmesh.NOX[lev];
Construct_arrays.c:       E->Node_map[lev][m]=(int *) malloc (matrix*sizeof(int));
Construct_arrays.c:	   E->Node_map[lev][m][i] = neq;  /* neq indicates an invalid eqn # */
Construct_arrays.c:	   E->Node_map[lev][m][(nn-1)*max_eqn+doff-1] = E->ID[lev][m][nn].doff[doff];
Construct_arrays.c:                   E->Node_map[lev][m][(nn-1)*max_eqn+ia*dims+doff-1]=E->ID[lev][m][ja].doff[doff];
Construct_arrays.c:       E->Eqn_k1[lev][m] = (higher_precision *)malloc(matrix*sizeof(higher_precision));
Construct_arrays.c:       E->Eqn_k2[lev][m] = (higher_precision *)malloc(matrix*sizeof(higher_precision));
Construct_arrays.c:       E->Eqn_k3[lev][m] = (higher_precision *)malloc(matrix*sizeof(higher_precision));
Construct_arrays.c:       E->mesh.matrix_size[lev] = matrix;
Construct_arrays.c:       if(E->control.verbose) {
Construct_arrays.c:           fprintf(E->fp_out, "output Node_map lev=%d m=%d\n", lev, m);
Construct_arrays.c:           fprintf(E->fp_out, "neq=%d nno=%d max_eqn=%d matrix=%d\n", neq, nno, max_eqn, matrix);
Construct_arrays.c://               fprintf(E->fp_out, "%d %d\n", i, E->Node_map[lev][m][i]);
Construct_arrays.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:    const int lms=loc_mat_size[E->mesh.nsd];
Construct_arrays.c:   for(level=E->mesh.gridmax;level>=E->mesh.gridmin;level--)   {
Construct_arrays.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Construct_arrays.c:        neq=E->lmesh.NEQ[level];
Construct_arrays.c:        nel=E->lmesh.NEL[level];
Construct_arrays.c:        nno=E->lmesh.NNO[level];
Construct_arrays.c:	    E->BI[level][m][i] = zero;
Construct_arrays.c:        for(i=0;i<E->mesh.matrix_size[level];i++) {
Construct_arrays.c:            E->Eqn_k1[level][m][i] = zero;
Construct_arrays.c:            E->Eqn_k2[level][m][i] = zero;
Construct_arrays.c:            E->Eqn_k3[level][m][i] = zero;
Construct_arrays.c:	    if (E->control.augmented_Lagr && !E->ve_data_cont.compressible)
Construct_arrays.c:	       node=E->IEN[level][m][element].node[i];
Construct_arrays.c:	       if(E->NODE[level][m][node] & VBX) w1=0.0;
Construct_arrays.c:	       if(E->NODE[level][m][node] & VBZ) w3=0.0;
Construct_arrays.c:	       if(E->NODE[level][m][node] & VBY) w2=0.0;
Construct_arrays.c:	         node1=E->IEN[level][m][element].node[j];
Construct_arrays.c:		    eqn1=E->ID[level][m][node1].doff[1];
Construct_arrays.c:		    eqn2=E->ID[level][m][node1].doff[2];
Construct_arrays.c:		    eqn3=E->ID[level][m][node1].doff[3];
Construct_arrays.c:		    if(E->NODE[level][m][node1] & VBX) ww1=0.0;
Construct_arrays.c:		    if(E->NODE[level][m][node1] & VBZ) ww3=0.0;
Construct_arrays.c:		    if(E->NODE[level][m][node1] & VBY) ww2=0.0;
Construct_arrays.c:		      if(E->Node_map[level][m][loc0+k] == eqn1) { /* found, index next equation */
Construct_arrays.c:		    E->Eqn_k1[level][m][loc0+index] +=  w1*ww1*elt_K[pp*lms+qq]; /* direction 1 */
Construct_arrays.c:		    E->Eqn_k2[level][m][loc0+index] +=  w2*ww1*elt_K[(pp+1)*lms+qq]; /* direction 1 */
Construct_arrays.c:		    E->Eqn_k3[level][m][loc0+index] +=  w3*ww1*elt_K[(pp+2)*lms+qq]; /* direction 1 */
Construct_arrays.c:			if(E->Node_map[level][m][loc0+k] == eqn2) { /* found, index next equation */
Construct_arrays.c:		    E->Eqn_k1[level][m][loc0+index] += w1*ww2*elt_K[pp*lms+qq+1]; /* direction 1 */
Construct_arrays.c:		    E->Eqn_k2[level][m][loc0+index] += w2*ww2*elt_K[(pp+1)*lms+qq+1]; /* direction 2 */
Construct_arrays.c:		    E->Eqn_k3[level][m][loc0+index] += w3*ww2*elt_K[(pp+2)*lms+qq+1]; /* direction 3 */
Construct_arrays.c:		    if(E->Node_map[level][m][loc0+k] == eqn3) { /* found, index next equation */
Construct_arrays.c:		    E->Eqn_k1[level][m][loc0+index] += w1*ww3*elt_K[pp*lms+qq+2]; /* direction 1 */
Construct_arrays.c:                    E->Eqn_k2[level][m][loc0+index] += w2*ww3*elt_K[(pp+1)*lms+qq+2]; /* direction 2 */
Construct_arrays.c:		    E->Eqn_k3[level][m][loc0+index] += w3*ww3*elt_K[(pp+2)*lms+qq+2]; /* direction 3 */
Construct_arrays.c:     (E->solver.exchange_id_d)(E, E->BI[level], level);
Construct_arrays.c:     for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Construct_arrays.c:        neq=E->lmesh.NEQ[level];
Construct_arrays.c:            if(E->BI[level][m][j] ==0.0)  fprintf(stderr,"me= %d level %d, equation %d/%d has zero diagonal term\n",E->parallel.me,level,j,neq);
Construct_arrays.c:	    assert( E->BI[level][m][j] != 0 /* diagonal of matrix = 0, not acceptable */);
Construct_arrays.c:            E->BI[level][m][j]  = (double) 1.0/E->BI[level][m][j];
Construct_arrays.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:   for(level=E->mesh.gridmax;level>=E->mesh.gridmin;level--)   {
Construct_arrays.c:     for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Construct_arrays.c:        for(j=0;j<=E->lmesh.NEQ[level];j++)
Construct_arrays.c:            E->temp[m][j]=0.0;
Construct_arrays.c:        for(i=1;i<=E->lmesh.NNO[level];i++)  {
Construct_arrays.c:            eqn1=E->ID[level][m][i].doff[1];
Construct_arrays.c:            eqn2=E->ID[level][m][i].doff[2];
Construct_arrays.c:            eqn3=E->ID[level][m][i].doff[3];
Construct_arrays.c:            C=E->Node_map[level][m] + (i-1)*max_eqn;
Construct_arrays.c:            B1=E->Eqn_k1[level][m]+(i-1)*max_eqn;
Construct_arrays.c:            B2=E->Eqn_k2[level][m]+(i-1)*max_eqn;
Construct_arrays.c:            B3=E->Eqn_k3[level][m]+(i-1)*max_eqn;
Construct_arrays.c:                E->temp[m][eqn1] += fabs(B1[j]);
Construct_arrays.c:                E->temp[m][eqn2] += fabs(B2[j]);
Construct_arrays.c:                E->temp[m][eqn3] += fabs(B3[j]);
Construct_arrays.c:                E->temp[m][C[j]] += fabs(B1[j]) + fabs(B2[j]) + fabs(B3[j]);
Construct_arrays.c:     (E->solver.exchange_id_d)(E, E->temp, level);
Construct_arrays.c:     for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Construct_arrays.c:        for(i=0;i<E->lmesh.NEQ[level];i++)  {
Construct_arrays.c:            E->temp[m][i] = E->temp[m][i] - 1.0/E->BI[level][m][i];
Construct_arrays.c:        for(i=1;i<=E->lmesh.NNO[level];i++)
Construct_arrays.c:          if (E->NODE[level][m][i] & OFFSIDE)   {
Construct_arrays.c:            eqn1=E->ID[level][m][i].doff[1];
Construct_arrays.c:            eqn2=E->ID[level][m][i].doff[2];
Construct_arrays.c:            eqn3=E->ID[level][m][i].doff[3];
Construct_arrays.c:            E->BI[level][m][eqn1] = (double) 1.0/E->temp[m][eqn1];
Construct_arrays.c:            E->BI[level][m][eqn2] = (double) 1.0/E->temp[m][eqn2];
Construct_arrays.c:            E->BI[level][m][eqn3] = (double) 1.0/E->temp[m][eqn3];
Construct_arrays.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Construct_arrays.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)           {
Construct_arrays.c:      elz = E->lmesh.ELZ[lev];
Construct_arrays.c:      ely = E->lmesh.ELY[lev];
Construct_arrays.c:      noy = E->lmesh.NOY[lev];
Construct_arrays.c:      noz = E->lmesh.NOZ[lev];
Construct_arrays.c:      nno = E->lmesh.NNO[lev];
Construct_arrays.c:        if (E->parallel.me_loc[3]==0 )
Construct_arrays.c:          for (i=1;i<=E->parallel.NUM_NNO[lev][j].bound[5];i++)   {
Construct_arrays.c:            node = E->parallel.NODE[lev][j][i].bound[5];
Construct_arrays.c: 	    E->NODE[lev][j][node] = E->NODE[lev][j][node] | TZEDGE;
Construct_arrays.c:        if ( E->parallel.me_loc[3]==E->parallel.nprocz-1 )
Construct_arrays.c:          for (i=1;i<=E->parallel.NUM_NNO[lev][j].bound[6];i++)   {
Construct_arrays.c:  	    node = E->parallel.NODE[lev][j][i].bound[6];
Construct_arrays.c:	    E->NODE[lev][j][node] = E->NODE[lev][j][node] | TZEDGE;
Construct_arrays.c:/*   if (E->control.verbose) { */
Construct_arrays.c:/*     for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)  */
Construct_arrays.c:/*       for (j=1;j<=E->sphere.caps_per_proc;j++)           { */
Construct_arrays.c:/*         for (i=1;i<=E->parallel.NUM_NNO[lev][j].bound[5];i++)   {  */
Construct_arrays.c:/* 	  node = E->parallel.NODE[lev][j][i].bound[5]; */
Construct_arrays.c:/* 	  fprintf(E->fp_out,"bound=5  NODE[lev=%1d][node=%3d]=%d\n",lev,node,E->NODE[lev][j][node]); */
Construct_arrays.c:/*         for (i=1;i<=E->parallel.NUM_NNO[lev][j].bound[6];i++)   {  */
Construct_arrays.c:/* 	  node = E->parallel.NODE[lev][j][i].bound[6]; */
Construct_arrays.c:/* 	  fprintf(E->fp_out,"bound=6  NODE[lev=%1d][node=%3d]=%d\n",lev,node,E->NODE[lev][j][node]); */
Construct_arrays.c:/*     fflush(E->fp_out); */
Construct_arrays.c:  for(lev=E->mesh.levmax-1;lev>=E->mesh.levmin;lev--)
Construct_arrays.c:     for (m=1;m<=E->sphere.caps_per_proc;m++)       {
Construct_arrays.c:          elx = E->lmesh.ELX[lev];
Construct_arrays.c:	  elz = E->lmesh.ELZ[lev];
Construct_arrays.c:	  ely = E->lmesh.ELY[lev];
Construct_arrays.c:          nox = E->lmesh.NOX[lev];
Construct_arrays.c:          noy = E->lmesh.NOY[lev];
Construct_arrays.c:          noz = E->lmesh.NOZ[lev];
Construct_arrays.c:	  elz = E->lmesh.ELZ[lev];
Construct_arrays.c:	  ely = E->lmesh.ELY[lev];
Construct_arrays.c:          if (!E->control.NMULTIGRID)  {
Construct_arrays.c:             if (lev == E->mesh.levmax-1)
Construct_arrays.c:                 elzu = E->lmesh.ELZ[E->mesh.levmax];
Construct_arrays.c:		  for(l=1;l<=enodes[E->mesh.nsd];l++)   {
Construct_arrays.c:		      E->EL[lev][m][elt].sub[l] = eltu
Construct_arrays.c:    const int dims=E->mesh.nsd;
Construct_arrays.c:    const int n=loc_mat_size[E->mesh.nsd];
Construct_arrays.c:/*     if(E->parallel.me==0) */
Construct_arrays.c:    for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Construct_arrays.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Construct_arrays.c:	for(el=1;el<=E->lmesh.NEL[lev];el++)    {
Construct_arrays.c:	    get_elt_k(E,el,E->elt_k[lev][m][el].k,lev,m,0);
Construct_arrays.c:	    if (E->control.augmented_Lagr)
Construct_arrays.c:	        get_aug_k(E,el,E->elt_k[lev][m][el].k,lev,m);
Construct_arrays.c:            build_diagonal_of_K(E,el,E->elt_k[lev][m][el].k,lev,m);
Construct_arrays.c:      (E->solver.exchange_id_d)(E, E->BI[lev], lev);    /*correct BI   */
Construct_arrays.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)
Construct_arrays.c:            for(j=0;j<E->lmesh.NEQ[lev];j++) {
Construct_arrays.c:	       if(E->BI[lev][m][j] ==0.0)  fprintf(stderr,"me= %d level %d, equation %d/%d has zero diagonal term\n",E->parallel.me,lev,j,E->lmesh.NEQ[lev]);
Construct_arrays.c:               assert( E->BI[lev][m][j] != 0 /* diagonal of matrix = 0, not acceptable */);
Construct_arrays.c:               E->BI[lev][m][j]  = (double) 1.0/E->BI[lev][m][j];
Construct_arrays.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:/*   if(E->control.verbose && E->parallel.me==0) */
Construct_arrays.c:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Construct_arrays.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Construct_arrays.c:      for(el=1;el<=E->lmesh.NEL[lev];el++)
Construct_arrays.c:        get_elt_g(E,el,E->elt_del[lev][m][el].g,lev,m);
Construct_arrays.c:/*     if(E->control.verbose && E->parallel.me==0) */
Construct_arrays.c:    for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Construct_arrays.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Construct_arrays.c:            for(el=1;el<=E->lmesh.NEL[lev];el++) {
Construct_arrays.c:                get_elt_c(E,el,E->elt_c[lev][m][el].c,lev,m);
Construct_arrays.c:  if (E->control.NMULTIGRID)
Construct_arrays.c:  if (E->control.NMULTIGRID || E->control.NASSEMBLE) {
Construct_arrays.c:  if (E->control.NMULTIGRID || (E->control.NASSEMBLE && !E->control.CONJ_GRAD))
Construct_arrays.c:if E->viscosity.z... set to Earth values, and old, num_mat=4 style is
Construct_arrays.c:  rl = r + E->sphere.ro;
Construct_arrays.c:  if (r> (E->sphere.ro - E->viscosity.zbase_layer[E->viscosity.rheol_layers-1])){
Construct_arrays.c:    i = E->viscosity.rheol_layers;
Construct_arrays.c:    for(i=0;i<E->viscosity.rheol_layers-1;i++)
Construct_arrays.c:      if(r >= (E->sphere.ro - E->viscosity.zbase_layer[i] - 1e-6) && r<(E->sphere.ro - E->viscosity.zbase_layer[i+1]+1e-6)){
Construct_arrays.c:  return(layers_r(E,E->sx[m][3][node]));
Construct_arrays.c:  if (kk >= E->viscosity.nbase_layer[E->viscosity.rheol_layers-1])  {
Construct_arrays.c:     i = E->viscosity.rheol_layers;
Construct_arrays.c:    for(i=0;i<E->viscosity.rheol_layers-1;i++)
Construct_arrays.c:      if (kk >= E->viscosity.nbase_layer[i]&&kk<E->viscosity.nbase_layer[i+1]){
Construct_arrays.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:/*  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Construct_arrays.c:    for(el=1;el<=E->lmesh.nel;el++) {
Construct_arrays.c:      E->mat[m][el] = 1;
Construct_arrays.c:      nodea = E->ien[m][el].node[2];
Construct_arrays.c:	E->mat[m][el] = llayer;
Construct_arrays.c: for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Construct_arrays.c:   for (k=1;k<=E->lmesh.elz;k++)  {
Construct_arrays.c:     kk = k + E->lmesh.ezs; 
Construct_arrays.c:     for (j=1;j<=E->lmesh.ely;j++)
Construct_arrays.c:     for (i=1;i<=E->lmesh.elx;i++)   {
Construct_arrays.c:        el = k + (i-1)*E->lmesh.elz+(j-1)*E->lmesh.elx*E->lmesh.elz;
Construct_arrays.c:        E->mat[m][el] = llayer;
Construct_arrays.c:  if (E->ve_data_cont.variable_te) {
Construct_arrays.c:     read_reg_grids(E,E->ve_data_cont.te_file,E->slice_ve.elast_thick);
Construct_arrays.c:     modify_mat_te(E,E->slice_ve.elast_thick);
Construct_arrays.c:  if (E->ve_data_cont.plate_margins) {
Construct_arrays.c:     read_reg_grids(E,E->ve_data_cont.platemargins_file,E->slice_ve.plate_margins);
Construct_arrays.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Construct_arrays.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   
Construct_arrays.c:  for (i=1;i<=E->lmesh.nsf;i++) {
Construct_arrays.c:    elast_thick[m][i] = E->sphere.ro - elast_thick[m][i]*1000.0/E->sphere.dradius;
Construct_arrays.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   
Construct_arrays.c:    for (j=1;j<=E->lmesh.ely;j++)  
Construct_arrays.c:    for (i=1;i<=E->lmesh.elx;i++)  {
Construct_arrays.c:      els = i + (j-1)*E->lmesh.elx;
Construct_arrays.c:      te_ele = 0.25*(elast_thick[m][E->sien[m][els].node[1]]
Construct_arrays.c:                    +elast_thick[m][E->sien[m][els].node[2]]
Construct_arrays.c:                    +elast_thick[m][E->sien[m][els].node[3]]
Construct_arrays.c:                    +elast_thick[m][E->sien[m][els].node[4]]);
Construct_arrays.c:      for (k=1;k<=E->lmesh.elz;k++)   {
Construct_arrays.c:        el = k + (i-1)*E->lmesh.elz + (j-1)*E->lmesh.elz*E->lmesh.elx;
Construct_arrays.c:           center_r += E->sx[m][3][E->ien[m][el].node[a]];
Construct_arrays.c:        E->mat[m][el] = 1;
Construct_arrays.c:        kk = k + E->lmesh.ezs; 
Construct_arrays.c: 	   E->mat[m][el] = 2;   // elastic lithosphere
Construct_arrays.c://        else if (kk>=E->viscosity.nlith1) 
Construct_arrays.c://           E->mat[m][el] = 3;
Construct_arrays.c:        else if (kk>=E->viscosity.n410) 
Construct_arrays.c:           E->mat[m][el] = 4;
Construct_arrays.c:        else if (kk>=E->viscosity.nlm) 
Construct_arrays.c:           E->mat[m][el] = 5;
Construct_arrays.c:        else if (kk>=E->viscosity.nlm1) 
Construct_arrays.c:           E->mat[m][el] = 6;
Convection.c:    E->control.CONVECTION = 1;
Convection.c:    E->advection.timestep = 0.0;
Convection.c:    E->advection.timesteps = 0;
Convection.c:    E->advection.temp_iterations = 2; /* petrov-galerkin iterations: minimum value. */
Convection.c:    E->advection.total_timesteps = 1;
Convection.c:    E->advection.sub_iterations = 1;
Convection.c:    E->advection.last_sub_iterations = 1;
Convection.c:    E->advection.gamma = 0.5;
Convection.c:    E->advection.dt_reduced = 1.0;
Convection.c:    E->monitor.T_maxvaried = 1.05;
Convection.c:    E->next_buoyancy_field = PG_timestep;
Convection.c:    E->next_buoyancy_field_init = PG_timestep_init;
Convection.c:    E->special_process_new_buoyancy = twiddle_thumbs;
Convection.c:    E->problem_settings = read_convection_settings;
Convection.c:    E->problem_derived_values = convection_derived_values;
Convection.c:    E->problem_allocate_vars = convection_allocate_memory;
Convection.c:    E->problem_boundary_conds = convection_boundary_conditions;
Convection.c:    E->problem_initial_fields = convection_initial_fields;
Convection.c:    E->problem_update_node_positions = twiddle_thumbs;
Convection.c:    E->problem_update_bcs = twiddle_thumbs;
Convection.c:    (E->solver.velocity_boundary_conditions)(E);      /* universal */
Convection.c:    (E->solver.temperature_boundary_conditions)(E);
Determine_net_rotation.c:  const int dims = E->mesh.nsd;
Determine_net_rotation.c:  elz = E->lmesh.elz;elx = E->lmesh.elx;ely = E->lmesh.ely;
Determine_net_rotation.c:    for (m=1;m <= E->sphere.caps_per_proc;m++)
Determine_net_rotation.c:          lnode[1] = E->ien[m][el].node[1];
Determine_net_rotation.c:          lnode[2] = E->ien[m][el].node[2];
Determine_net_rotation.c:          lnode[3] = E->ien[m][el].node[3];
Determine_net_rotation.c:          lnode[4] = E->ien[m][el].node[4];
Determine_net_rotation.c:          for(nint=1;nint <= onedvpoints[E->mesh.nsd];nint++)   {
Determine_net_rotation.c:            for(d=1;d <= onedvpoints[E->mesh.nsd];d++){
Determine_net_rotation.c:	      vtmp = E->M.vpt[GMVINDEX(d,nint)] * dGamma.vpt[GMVGAMMA(0,nint)];
Determine_net_rotation.c:	      x[0] += E->x[m][1][lnode[d]] * vtmp; /* coords */
Determine_net_rotation.c:	      x[1] += E->x[m][2][lnode[d]] * vtmp;
Determine_net_rotation.c:	      x[2] += E->x[m][3][lnode[d]] * vtmp;
Determine_net_rotation.c:              v[0] += E->sphere.cap[m].V[1][lnode[d]] * vtmp; /* theta */
Determine_net_rotation.c:              v[1] += E->sphere.cap[m].V[2][lnode[d]] * vtmp; /* phi */
Determine_net_rotation.c:            lnode[1] = E->ien[m][el].node[5];
Determine_net_rotation.c:            lnode[2] = E->ien[m][el].node[6];
Determine_net_rotation.c:            lnode[3] = E->ien[m][el].node[7];
Determine_net_rotation.c:            lnode[4] = E->ien[m][el].node[8];
Determine_net_rotation.c:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Determine_net_rotation.c:              for(d=1;d<=onedvpoints[E->mesh.nsd];d++){
Determine_net_rotation.c:		vtmp = E->M.vpt[GMVINDEX(d,nint)] * dGamma.vpt[GMVGAMMA(1,nint)];
Determine_net_rotation.c:		x[0] += E->x[m][1][lnode[d]] * vtmp; /* coords */
Determine_net_rotation.c:		x[1] += E->x[m][2][lnode[d]] * vtmp;
Determine_net_rotation.c:		x[2] += E->x[m][3][lnode[d]] * vtmp;
Determine_net_rotation.c:		v[0] += E->sphere.cap[m].V[1][lnode[d]] * vtmp;
Determine_net_rotation.c:		v[1] += E->sphere.cap[m].V[2][lnode[d]] * vtmp;
Determine_net_rotation.c:  MPI_Allreduce(coef,acoef,elz9,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Determine_net_rotation.c:  rr = E->sx[1][3][E->ien[1][elz].node[5]] - E->sx[1][3][E->ien[1][1].node[1]];
Determine_net_rotation.c:    r1 = E->sx[1][3][E->ien[1][i+1].node[1]]; /* nodal radii for the
Determine_net_rotation.c:    r2 = E->sx[1][3][E->ien[1][i+1].node[5]];
Determine_net_rotation.c:    //if(E->parallel.me == 0)
Determine_net_rotation.c:  if(E->parallel.me == 0)
Determine_net_rotation.c://   ADDED BY -OrbData-, AND NODE-VELOCITY OUTPUT FROM -SHELLS-,
Drive_solvers.c:  if (E->control.NMULTIGRID || E->control.NASSEMBLE)
Drive_solvers.c:    for (i=E->mesh.gridmin;i<=E->mesh.gridmax;i++)
Drive_solvers.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Drive_solvers.c:	E->elt_k[i][m]=(struct EK *)malloc((E->lmesh.NEL[i]+1)*sizeof(struct EK));
Drive_solvers.c: if (E->parallel.me==0) fprintf(stderr,"done for stokes_solver_setup\n");
Drive_solvers.c:  const int nno = E->lmesh.nno;
Drive_solvers.c:  const int nel = E->lmesh.nel;
Drive_solvers.c:  const int neq = E->lmesh.neq;
Drive_solvers.c:  const int vpts = vpoints[E->mesh.nsd];
Drive_solvers.c:  const int dims = E->mesh.nsd;
Drive_solvers.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Drive_solvers.c:  for (m=1;m<=E->sphere.caps_per_proc;m++) 
Drive_solvers.c:  if(E->parallel.me==0)  time=CPU_time0();
Drive_solvers.c:  E->viscosity.iterate=0;
Drive_solvers.c:  velocities_conform_bcs(E,E->U);
Drive_solvers.c:if (  !E->viscosity.SDEPV  )   {
Drive_solvers.c:      get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Drive_solvers.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Drive_solvers.c:	  delta_U[m][i] = E->U[m][i] - oldU[m][i];
Drive_solvers.c:	  oldU[m][i] = E->U[m][i];
Drive_solvers.c:      if (E->ve_data_cont.polar_wander) {
Drive_solvers.c:        dPW_mag = sqrt( ((E->ve_data_cont.PW_incr[0]-pwold[0])*(E->ve_data_cont.PW_incr[0]-pwold[0]))
Drive_solvers.c:                      + ((E->ve_data_cont.PW_incr[1]-pwold[1])*(E->ve_data_cont.PW_incr[1]-pwold[1])) );
Drive_solvers.c:        pwold[0] = E->ve_data_cont.PW_incr[0];
Drive_solvers.c:        pwold[1] = E->ve_data_cont.PW_incr[1];
Drive_solvers.c:      Udot_mag  = sqrt(global_vdot(E,oldU,oldU,E->mesh.levmax));
Drive_solvers.c:      dUdot_mag = sqrt(global_vdot(E,delta_U,delta_U,E->mesh.levmax));
Drive_solvers.c:      if(E->parallel.me==0) {
Drive_solvers.c:	fprintf(E->fp,"!!! iteration=%d relative change %g  %g m0 m1 %g %g potl_d %g timestep %d elapse time %g\n",
Drive_solvers.c:		count,dUdot_mag,dPW_mag,pwold[0],pwold[1],E->ve_data_cont.potential_vary_PW,E->monitor.solution_cycles,time);
Drive_solvers.c:        fflush(E->fp);
Drive_solvers.c://     } while ( (count<50) && ((dUdot_mag > E->viscosity.sdepv_misfit) || (dPW_mag > (E->viscosity.sdepv_misfit*3))) && E->ve_data_cont.SELFG);     // for BM
Drive_solvers.c://     } while ( (count<50) && ((dUdot_mag > E->viscosity.sdepv_misfit) || (dPW_mag > 0.03)) && E->ve_data_cont.SELFG);
Drive_solvers.c:     } while ( (count<50) && ((dUdot_mag > E->viscosity.sdepv_misfit) || (E->ve_data_cont.potential_vary_PW > 3*E->viscosity.sdepv_misfit)) && E->ve_data_cont.SELFG);
Drive_solvers.c://     } while ( (count<50) && (dUdot_mag > E->viscosity.sdepv_misfit) && E->ve_data_cont.SELFG);
Drive_solvers.c:else if (E->viscosity.SDEPV ) {
Drive_solvers.c:   E->viscosity.iterate=0;
Drive_solvers.c:       get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Drive_solvers.c:       for (m=1;m<=E->sphere.caps_per_proc;m++)
Drive_solvers.c:	  delta_U[m][i] = E->U[m][i] - oldU[m][i];
Drive_solvers.c:	  oldU[m][i] = E->U[m][i];
Drive_solvers.c:       if (E->ve_data_cont.polar_wander) {
Drive_solvers.c:         dPW_mag = sqrt( ((E->ve_data_cont.PW_incr[0]-pwold[0])*(E->ve_data_cont.PW_incr[0]-pwold[0]))
Drive_solvers.c:                       + ((E->ve_data_cont.PW_incr[1]-pwold[1])*(E->ve_data_cont.PW_incr[1]-pwold[1])) );
Drive_solvers.c:         pwold[0] = E->ve_data_cont.PW_incr[0];
Drive_solvers.c:         pwold[1] = E->ve_data_cont.PW_incr[1];
Drive_solvers.c:       Udot_mag  = sqrt(global_vdot(E,oldU,oldU,E->mesh.levmax));
Drive_solvers.c:       dUdot_mag = sqrt(global_vdot(E,delta_U,delta_U,E->mesh.levmax));
Drive_solvers.c:       Udot_mag1  = sqrt(global_vdot_e(E,oldU,oldU,E->mesh.levmax));
Drive_solvers.c:       dUdot_mag1 = sqrt(global_vdot_e(E,delta_U,delta_U,E->mesh.levmax));
Drive_solvers.c:       if(E->parallel.me==0) {
Drive_solvers.c:	 fprintf(E->fp,"!!! iteration=%d relative change %g %g %g m0 m1 %g %g timestep %d elapse time %g\n",
Drive_solvers.c:		count,dUdot_mag,dUdot_mag1,dPW_mag,pwold[0],pwold[1],E->monitor.solution_cycles,time);
Drive_solvers.c:       fflush(E->fp);
Drive_solvers.c:      E->viscosity.iterate++;
Drive_solvers.c://      } while ( (count<50) && ((dUdot_mag1 > E->viscosity.sdepv_misfit) || (dPW_mag >0.03)) && E->ve_data_cont.SELFG);
Drive_solvers.c:      } while ( (count<50) && ((dUdot_mag1 > E->viscosity.sdepv_misfit) ) && E->ve_data_cont.SELFG);
Drive_solvers.c:  if((E->sphere.caps == 12) &&
Drive_solvers.c:     (E->control.remove_rigid_rotation || E->control.remove_angular_momentum)) {
Drive_solvers.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Drive_solvers.c:  if(E->ve_data_cont.DIRECT){
Drive_solvers.c:    if(E->control.restart){	
Drive_solvers.c:      if(E->monitor.solution_cycles ==  E->monitor.solution_cycles_init + 1)
Drive_solvers.c:      if(E->monitor.solution_cycles == 0)
Drive_solvers.c:  const int nno = E->lmesh.nno;
Drive_solvers.c:  const int nel = E->lmesh.nel;
Drive_solvers.c:  const int neq = E->lmesh.neq;
Drive_solvers.c:  const int vpts = vpoints[E->mesh.nsd];
Drive_solvers.c:  const int dims = E->mesh.nsd;
Drive_solvers.c:  velocities_conform_bcs(E,E->U);
Drive_solvers.c:  E->monitor.stop_topo_loop = 0;
Drive_solvers.c:  E->monitor.topo_loop = 0;
Drive_solvers.c:  if(E->monitor.solution_cycles==0) std_timestep(E);
Drive_solvers.c:  while(E->monitor.stop_topo_loop == 0) {
Drive_solvers.c:	    get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Drive_solvers.c:	  if (E->viscosity.SDEPV || E->viscosity.PDEPV) {
Drive_solvers.c:		  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Drive_solvers.c:			  for (m=1;m<=E->sphere.caps_per_proc;m++)
Drive_solvers.c:					  delta_U[m][i] = E->U[m][i] - oldU[m][i];
Drive_solvers.c:					  oldU[m][i] = E->U[m][i];
Drive_solvers.c:			  Udot_mag  = sqrt(global_vdot(E,oldU,oldU,E->mesh.levmax));
Drive_solvers.c:			  dUdot_mag = vnorm_nonnewt(E,delta_U,oldU,E->mesh.levmax);
Drive_solvers.c:			  if(E->parallel.me==0){
Drive_solvers.c:				  fprintf(E->fp,"Stress dependent viscosity: DUdot = %.4e (%.4e) for iteration %d\n",dUdot_mag,Udot_mag,count);
Drive_solvers.c:				  fflush(E->fp);
Drive_solvers.c:			  if (count>50 || dUdot_mag<E->viscosity.sdepv_misfit)
Drive_solvers.c:			  get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Drive_solvers.c:		  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Drive_solvers.c:	  E->monitor.topo_loop++;
Drive_solvers.c:  if((E->sphere.caps == 12) &&
Drive_solvers.c:     (E->control.remove_rigid_rotation || E->control.remove_angular_momentum)) {
Drive_solvers.c:  get_STD_freesurf(E,E->slice.freesurf);
Element_calculations.c:  const int dims=E->mesh.nsd;
Element_calculations.c:  const int ends=enodes[E->mesh.nsd];
Element_calculations.c:    node = E->ien[m][e].node[a];
Element_calculations.c:    a1=E->id[m][node].doff[1];
Element_calculations.c:    E->F[m][a1] += elt_f[p];
Element_calculations.c:    a2=E->id[m][node].doff[2];
Element_calculations.c:    E->F[m][a2] += elt_f[p+1];
Element_calculations.c:    a3=E->id[m][node].doff[3];
Element_calculations.c:    E->F[m][a3] += elt_f[p+2];
Element_calculations.c:  const int neq=E->lmesh.neq;
Element_calculations.c:  const int nel=E->lmesh.nel;
Element_calculations.c:  const int lev=E->mesh.levmax;
Element_calculations.c:  const int ends = enodes[E->mesh.nsd];
Element_calculations.c:  const int dims = E->mesh.nsd;
Element_calculations.c://  get_buoyancy(E,E->buoyancy);
Element_calculations.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)   {
Element_calculations.c:   if (E->ve_data_cont.SELFG)
Element_calculations.c:      //Sets E->potential[1][m][j] and E->potential[0][m][j]
Element_calculations.c:   if (E->ve_data_cont.SLE)
Element_calculations.c:       // calculate E->slice.oceanload according to sea level equation
Element_calculations.c:       //  (based on E->potential[0] and E->slice.surf[3])
Element_calculations.c:    //   E->slice.load[1][m][j]  and   E->slice.load[3][m][j]
Element_calculations.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Element_calculations.c:                node = E->ien[m][e].node[a];
Element_calculations.c:                a1=E->id[m][node].doff[1];
Element_calculations.c:                a2=E->id[m][node].doff[2];
Element_calculations.c:                a3=E->id[m][node].doff[3];
Element_calculations.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Element_calculations.c:      E->F[m][a] = 0.0;
Element_calculations.c:                node = E->ien[m][e].node[a];
Element_calculations.c:                a1=E->id[m][node].doff[1];
Element_calculations.c:                E->F[m][a1] += elt_f[p];
Element_calculations.c:                a2=E->id[m][node].doff[2];
Element_calculations.c:                E->F[m][a2] += elt_f[p+1];
Element_calculations.c:                a3=E->id[m][node].doff[3];
Element_calculations.c:                E->F[m][a3] += elt_f[p+2];
Element_calculations.c:  E->monitor.fdotf = sqrt(global_vdot(E, E->F, E->F, lev));
Element_calculations.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Element_calculations.c:        E->F[m][a] = E->F[m][a] + F0[m][a];
Element_calculations.c:  (E->solver.exchange_id_d)(E, E->F, lev);
Element_calculations.c:  strip_bcs_from_residual(E,E->F,lev);
Element_calculations.c:  /* compute the norm of E->F */
Element_calculations.c:  if(E->parallel.me==0) {
Element_calculations.c:              E->monitor.fdotf,temp1);
Element_calculations.c:      fprintf(E->fp, "Momentum equation force %.9e %.9e\n",
Element_calculations.c:              E->monitor.fdotf,temp1);
Element_calculations.c:  const int neq=E->lmesh.neq;
Element_calculations.c:  const int nel=E->lmesh.nel;
Element_calculations.c:  const int lev=E->mesh.levmax;
Element_calculations.c:  get_buoyancy(E,E->buoyancy);
Element_calculations.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Element_calculations.c:      E->F[m][a] = 0.0;
Element_calculations.c:    for(i=1; i<=E->boundary.nel; i++) {
Element_calculations.c:      e = E->boundary.element[m][i];
Element_calculations.c:  (E->solver.exchange_id_d)(E, E->F, lev);
Element_calculations.c:  strip_bcs_from_residual(E,E->F,lev);
Element_calculations.c:    const int nn=loc_mat_size[E->mesh.nsd];
Element_calculations.c:    const int dims=E->mesh.nsd;
Element_calculations.c:    stress_scaling = E->data.density*E->data.grav_acc*E->sphere.dradius/E->ve_data_cont.shear_mod;
Element_calculations.c:    if (iconv || (el-1)%E->lmesh.ELZ[lev]==0)
Element_calculations.c:      construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,lev,m,0);
Element_calculations.c:      W[k]=g_point[k].weight[dims-1]*E->GDA[lev][m][el].vpt[k]*E->EVI[lev][m][(el-1)*vpts+k];
Element_calculations.c:   if(E->ve_data_cont.compressible)  {
Element_calculations.c:       W1[k]=g_point[k].weight[dims-1]*E->GDA[lev][m][el].vpt[k]*E->elambda[lev][m][el];
Element_calculations.c:       W2[k]=g_point[k].weight[dims-1]*E->GDA[lev][m][el].vpt[k]*E->erho[lev][m][el]*E->egrav[lev][m][el]*stress_scaling;
Element_calculations.c:    get_ba(&(E->N), &(E->GNX[lev][m][el]), &E->element_Cc, &E->element_Ccx,
Element_calculations.c:           rtf, E->mesh.nsd, ba);
Element_calculations.c:/*      if(E->control.inv_gruneisen != 0)
Element_calculations.c:      if(E->ve_data_cont.compressible)  {
Element_calculations.c:                                 E->N.vpt[GNVINDEX(b,k)]*E->element_Cc.vpt[BVINDEX(3,j,b,k)];
Element_calculations.c:                                 E->N.vpt[GNVINDEX(a,k)]*E->element_Cc.vpt[BVINDEX(3,i,a,k)];
Element_calculations.c:  if(E->control.NMULTIGRID||E->control.NASSEMBLE)
Element_calculations.c:  const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:  const int ends=enodes[E->mesh.nsd];
Element_calculations.c:  const int dims=E->mesh.nsd;
Element_calculations.c:  const int nel=E->lmesh.NEL[level];
Element_calculations.c:  const int neq=E->lmesh.NEQ[level];
Element_calculations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Element_calculations.c:	ii = E->IEN[level][m][e].node[a];
Element_calculations.c:	a1 = E->ID[level][m][ii].doff[1];
Element_calculations.c:	a2 = E->ID[level][m][ii].doff[2];
Element_calculations.c:	a3 = E->ID[level][m][ii].doff[3];
Element_calculations.c:	        nodeb = E->IEN[level][m][e].node[b];
Element_calculations.c:		        E->elt_k[level][m][e].k[ii] *
Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[1]]
Element_calculations.c:		      + E->elt_k[level][m][e].k[ii+1] *
Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[2]]
Element_calculations.c:		      + E->elt_k[level][m][e].k[ii+2] *
Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[3]];
Element_calculations.c:		        E->elt_k[level][m][e].k[ii+n] *
Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[1]]
Element_calculations.c:		      + E->elt_k[level][m][e].k[ii+n+1] *
Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[2]]
Element_calculations.c:		      + E->elt_k[level][m][e].k[ii+n+2] *
Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[3]];
Element_calculations.c:		        E->elt_k[level][m][e].k[ii+n+n] *
Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[1]]
Element_calculations.c:		      + E->elt_k[level][m][e].k[ii+n+n+1] *
Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[2]]
Element_calculations.c:		      + E->elt_k[level][m][e].k[ii+n+n+2] *
Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[3]];
Element_calculations.c:    (E->solver.exchange_id_d)(E, Au, level);
Element_calculations.c:    const int neq=E->lmesh.NEQ[level];
Element_calculations.c:    const int nno=E->lmesh.NNO[level];
Element_calculations.c:    const int dims=E->mesh.nsd;
Element_calculations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Element_calculations.c:       eqn1=E->ID[level][m][e].doff[1];
Element_calculations.c:       eqn2=E->ID[level][m][e].doff[2];
Element_calculations.c:       eqn3=E->ID[level][m][e].doff[3];
Element_calculations.c:       C=E->Node_map[level][m] + (e-1)*max_eqn;
Element_calculations.c:       B1=E->Eqn_k1[level][m]+(e-1)*max_eqn;
Element_calculations.c:       B2=E->Eqn_k2[level][m]+(e-1)*max_eqn;
Element_calculations.c:       B3=E->Eqn_k3[level][m]+(e-1)*max_eqn;
Element_calculations.c:     (E->solver.exchange_id_d)(E, Au, level);
Element_calculations.c:    const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:    const int dims=E->mesh.nsd;
Element_calculations.c:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:	    node=E->IEN[level][m][el].node[a];
Element_calculations.c:	    a1 = E->ID[level][m][node].doff[1];
Element_calculations.c:	    E->BI[level][m][a1] += elt_k[p*n+p];
Element_calculations.c:	    a2 = E->ID[level][m][node].doff[2];
Element_calculations.c:	    E->BI[level][m][a2] += elt_k[p*n+p];
Element_calculations.c:	    a1 = E->ID[level][m][node].doff[3];
Element_calculations.c:	    E->BI[level][m][a1] += elt_k[p*n+p];
Element_calculations.c: for (level=E->mesh.gridmin;level<=E->mesh.gridmax;level++)
Element_calculations.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Element_calculations.c:     npno = E->lmesh.NPNO[level];
Element_calculations.c:     neq=E->lmesh.NEQ[level];
Element_calculations.c:	E->BPI[level][m][e]=1.0;
Element_calculations.c:     if(!E->control.precondition)
Element_calculations.c:	    E->BPI[level][m][e] = 1.0/BU;
Element_calculations.c:	    E->BPI[level][m][e] = 1.0;
Element_calculations.c:    const int nel = E->lmesh.NEL[level];
Element_calculations.c:    const int ends = enodes[E->mesh.nsd];
Element_calculations.c:    const int dims = E->mesh.nsd;
Element_calculations.c:    const int npno = E->lmesh.NPNO[level];
Element_calculations.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Element_calculations.c:                b = E->IEN[level][m][e].node[a];
Element_calculations.c:                j1= E->ID[level][m][b].doff[1];
Element_calculations.c:                j2= E->ID[level][m][b].doff[2];
Element_calculations.c:                j3= E->ID[level][m][b].doff[3];
Element_calculations.c:                result[m][e] += E->elt_c[level][m][e].c[p  ][0] * U[m][j1]
Element_calculations.c:                              + E->elt_c[level][m][e].c[p+1][0] * U[m][j2]
Element_calculations.c:                              + E->elt_c[level][m][e].c[p+2][0] * U[m][j3];
Element_calculations.c:    const int nel=E->lmesh.NEL[level];
Element_calculations.c:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:    const int dims=E->mesh.nsd;
Element_calculations.c:    const int npno=E->lmesh.NPNO[level];
Element_calculations.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Element_calculations.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Element_calculations.c:	    b = E->IEN[level][m][e].node[a];
Element_calculations.c:	    j1= E->ID[level][m][b].doff[1];
Element_calculations.c:            j2= E->ID[level][m][b].doff[2];
Element_calculations.c:	    j3= E->ID[level][m][b].doff[3];
Element_calculations.c:	    divU[m][e] += E->elt_del[level][m][e].g[p  ][0] * U[m][j1]
Element_calculations.c:	                + E->elt_del[level][m][e].g[p+1][0] * U[m][j2]
Element_calculations.c:	                + E->elt_del[level][m][e].g[p+2][0] * U[m][j3];
Element_calculations.c:  const int ends=enodes[E->mesh.nsd];
Element_calculations.c:  const int dims=E->mesh.nsd;
Element_calculations.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Element_calculations.c:    nel=E->lmesh.NEL[lev];
Element_calculations.c:    neq=E->lmesh.NEQ[lev];
Element_calculations.c:	     b = E->IEN[lev][m][e].node[a];
Element_calculations.c:	     j1= E->ID[lev][m][b].doff[1];
Element_calculations.c:	     j2= E->ID[lev][m][b].doff[2];
Element_calculations.c:	     j3= E->ID[lev][m][b].doff[3];
Element_calculations.c:		        /*for(b=0;b<ploc_mat_size[E->mesh.nsd];b++)  */
Element_calculations.c:             gradP[m][j1] += E->elt_del[lev][m][e].g[p  ][0] * P[m][e];
Element_calculations.c:             gradP[m][j2] += E->elt_del[lev][m][e].g[p+1][0] * P[m][e];
Element_calculations.c:             gradP[m][j3] += E->elt_del[lev][m][e].g[p+2][0] * P[m][e];
Element_calculations.c:  (E->solver.exchange_id_d)(E, gradP,  lev); /*  correct gradP   */
Element_calculations.c:    const int ends=enodes[E->mesh.nsd];
Element_calculations.c:    const int dims=E->mesh.nsd;
Element_calculations.c:    npno=E->lmesh.NPNO[level];
Element_calculations.c:      node = E->IEN[level][m][e].node[a];
Element_calculations.c:      j=E->ID[level][m][node].doff[1];
Element_calculations.c:      gradP[p] += E->BI[level][m][j]*E->elt_del[level][m][e].g[p][0];
Element_calculations.c:      j=E->ID[level][m][node].doff[2];
Element_calculations.c:      gradP[p+1] += E->BI[level][m][j]*E->elt_del[level][m][e].g[p+1][0];
Element_calculations.c:      j=E->ID[level][m][node].doff[3];
Element_calculations.c:      gradP[p+2] += E->BI[level][m][j]*E->elt_del[level][m][e].g[p+2][0];
Element_calculations.c:      divU +=E->elt_del[level][m][e].g[p][0] * gradP[p];
Element_calculations.c:      divU +=E->elt_del[level][m][e].g[p+1][0] * gradP[p+1];
Element_calculations.c:      divU +=E->elt_del[level][m][e].g[p+2][0] * gradP[p+2];
Element_calculations.c:    const int dims = E->mesh.nsd;
Element_calculations.c:    if ((el-1)%E->lmesh.ELZ[lev]==0)
Element_calculations.c:        construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,lev,m,1);
Element_calculations.c:    temp = p_point[1].weight[dims-1] * E->GDA[lev][m][el].ppt[1];
Element_calculations.c:    switch (E->refstate.choice) {
Element_calculations.c:        beta = - E->control.disptn_number * E->control.inv_gruneisen;
Element_calculations.c:                x[i] = E->N.ppt[GNPINDEX(a,1)]
Element_calculations.c:                    * E->element_Cc.ppt[BPINDEX(3,i,a,1)];
Element_calculations.c:            j = E->IEN[lev][m][el].node[a];
Element_calculations.c:            nz = (j - 1) % E->lmesh.noz + 1;
Element_calculations.c:            rho[a] = E->refstate.rho[nz];
Element_calculations.c:                x[i] = rho[a] * E->GNX[lev][m][el].ppt[GNPXINDEX(2,a,1)]
Element_calculations.c:                    * E->N.ppt[GNPINDEX(a,1)]
Element_calculations.c:                    * E->element_Cc.ppt[BPINDEX(3,i,a,1)];
Element_calculations.c:   const int dims=E->mesh.nsd;
Element_calculations.c:   if ((el-1)%E->lmesh.ELZ[lev]==0)
Element_calculations.c:      construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,lev,m,1);
Element_calculations.c:   temp=p_point[1].weight[dims-1] * E->GDA[lev][m][el].ppt[1];
Element_calculations.c:       x[i]=E->GNX[lev][m][el].ppt[GNPXINDEX(2,a,1)]*E->element_Cc.ppt[BPINDEX(3,i,a,1)]
Element_calculations.c:        + 2.0*ra*E->N.ppt[GNPINDEX(a,1)]*E->element_Cc.ppt[BPINDEX(3,i,a,1)]
Element_calculations.c:        + ra*(E->GNX[lev][m][el].ppt[GNPXINDEX(0,a,1)]*E->element_Cc.ppt[BPINDEX(1,i,a,1)]
Element_calculations.c:        +E->N.ppt[GNPINDEX(a,1)]*E->element_Ccx.ppt[BPXINDEX(1,i,1,a,1)]
Element_calculations.c:        +ct*E->N.ppt[GNPINDEX(a,1)]*E->element_Cc.ppt[BPINDEX(1,i,a,1)]
Element_calculations.c:        +si*(E->GNX[lev][m][el].ppt[GNPXINDEX(1,a,1)]*E->element_Cc.ppt[BPINDEX(2,i,a,1)]
Element_calculations.c:        +E->N.ppt[GNPINDEX(a,1)]*E->element_Ccx.ppt[BPXINDEX(2,i,2,a,1)]));
Element_calculations.c:      /* fprintf (E->fp,"B= %d %d %g %g %g %g %g\n",el,a,E->GDA[lev][m][el].ppt[1],E->GNX[lev][m][el].ppt[GNPXINDEX(0,a,1)],E->GNX[lev][m][el].ppt[GNPXINDEX(1,a,1)],elt_del[p][0],elt_del[p+1][0]);
Element_calculations.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:    const int lev=E->mesh.levmax;
Element_calculations.c:    gnxx = E->gNX[m][el].vpt;
Element_calculations.c:    gnda = E->gDA[m][el].vpt;
Element_calculations.c:    es = (el-1)/E->lmesh.elz + 1;
Element_calculations.c:            ss[1][j] = E->Sxx[m][(el-1)*vpts+j]*E->Maxwelltime[m][el];
Element_calculations.c:            ss[2][j] = E->Syy[m][(el-1)*vpts+j]*E->Maxwelltime[m][el];
Element_calculations.c:            ss[3][j] = E->Szz[m][(el-1)*vpts+j]*E->Maxwelltime[m][el];
Element_calculations.c:            ss[4][j] = E->Sxy[m][(el-1)*vpts+j]*E->Maxwelltime[m][el];
Element_calculations.c:            ss[5][j] = E->Sxz[m][(el-1)*vpts+j]*E->Maxwelltime[m][el];
Element_calculations.c:            ss[6][j] = E->Szy[m][(el-1)*vpts+j]*E->Maxwelltime[m][el];
Element_calculations.c:                               + ss[2][j]*ct[j]*E->N.vpt[GNVINDEX(a,j)]
Element_calculations.c:                                            - E->N.vpt[GNVINDEX(a,j)]) )
Element_calculations.c:                                          *E->N.vpt[GNVINDEX(a,j)])+
Element_calculations.c:                                          /rtf[3][j]-E->N.vpt[GNVINDEX(a,j)])) 
Element_calculations.c:               elt_f[p+2] -= ((ss[1][j]+ss[2][j])*E->N.vpt[GNVINDEX(a,j)]+
Element_calculations.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Element_calculations.c:    const int lev=E->mesh.levmax;
Element_calculations.c:   stress_scaling = E->data.density*E->data.grav_acc*E->sphere.dradius/E->ve_data_cont.shear_mod;
Element_calculations.c:   if (E->control.SELFG)
Element_calculations.c:      con = E->ve_data_cont.Rsg;
Element_calculations.c:    gnxx = E->gNX[m][el].vpt;
Element_calculations.c:    gnda = E->gDA[m][el].vpt;
Element_calculations.c:    es = (el-1)/E->lmesh.elz + 1;
Element_calculations.c:   if (E->ve_data_cont.compressible)   {
Element_calculations.c:      if ((el-1)%E->lmesh.elz==0)
Element_calculations.c:         construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,E->mesh.levmax,m,0);
Element_calculations.c:        VV[1][i] = E->sphere.cap[m].total_VS[1][E->ien[m][el].node[i]];
Element_calculations.c:        VV[2][i] = E->sphere.cap[m].total_VS[2][E->ien[m][el].node[i]];
Element_calculations.c:        VV[3][i] = E->sphere.cap[m].total_VS[3][E->ien[m][el].node[i]];
Element_calculations.c:      maxwelltime = E->Maxwelltime[m][el]; 
Element_calculations.c:      esmu = E->esmu[E->mesh.levmax][el];
Element_calculations.c:      erho = E->erho[E->mesh.levmax][el];
Element_calculations.c:      egrav= E->egrav[E->mesh.levmax][el];
Element_calculations.c:        skk[j] = E->Sxx[m][(el-1)*vpts+j] + E->Syy[m][(el-1)*vpts+j] + E->Szz[m][(el-1)*vpts+j];
Element_calculations.c:            Ur[j] += VV[k][i]*E->N.vpt[GNVINDEX(i,j)]*E->E->element_Cc.vpt[BVINDEX(3,k,i,j)];
Element_calculations.c:                 (gnxx[GNVXINDEX(0,i,j)]*E->element_Cc.vpt[BVINDEX(1,k,i,j)]
Element_calculations.c:                 +E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(1,k,1,i,j)]
Element_calculations.c:                 +E->N.vpt[GNVINDEX(i,j)]*E->element_Cc.vpt[BVINDEX(3,k,i,j)])
Element_calculations.c:                (E->N.vpt[GNVINDEX(i,j)]*E->element_Cc.vpt[BVINDEX(1,k,i,j)]*ct[j]
Element_calculations.c:                +E->N.vpt[GNVINDEX(i,j)]*E->element_Cc.vpt[BVINDEX(3,k,i,j)]
Element_calculations.c:                +(gnxx[GNVXINDEX(1,i,j)]*E->element_Cc.vpt[BVINDEX(2,k,i,j)]
Element_calculations.c:                +E->N.vpt[GNVINDEX(i,j)]*E->element_Ccx.vpt[BVXINDEX(2,k,2,i,j)])/sinaa[j])
Element_calculations.c:                          +gnxx[GNVXINDEX(2,i,j)]*E->element_Cc.vpt[BVINDEX(3,k,i,j)];
Element_calculations.c:       ss[1][j] = E->Sxx[m][(el-1)*vpts+j]*maxwelltime;
Element_calculations.c:       ss[2][j] = E->Syy[m][(el-1)*vpts+j]*maxwelltime;
Element_calculations.c:       ss[3][j] = E->Szz[m][(el-1)*vpts+j]*maxwelltime;
Element_calculations.c:       ss[4][j] = E->Sxy[m][(el-1)*vpts+j]*maxwelltime;
Element_calculations.c:       ss[5][j] = E->Sxz[m][(el-1)*vpts+j]*maxwelltime;
Element_calculations.c:       ss[6][j] = E->Szy[m][(el-1)*vpts+j]*maxwelltime;
Element_calculations.c:       if (E->ve_data_cont.compressible)   {
Element_calculations.c:                          + ss[2][j]*ct[j]*E->N.vpt[GNVINDEX(a,j)]
Element_calculations.c:                                            - E->N.vpt[GNVINDEX(a,j)]) )
Element_calculations.c:                                     *E->N.vpt[GNVINDEX(a,j)])+
Element_calculations.c:                                     /rtf[3][j]-E->N.vpt[GNVINDEX(a,j)])) 
Element_calculations.c:           elt_f[p+2] -= ((ss[1][j]+ss[2][j])*E->N.vpt[GNVINDEX(a,j)]+
Element_calculations.c:        if (E->ve_data_cont.compressible)   {
Element_calculations.c:             (E->Ekk[m][(el-1)*vpts+j]*E->N.vpt[GNVINDEX(a,j)]*E->element_Cc.vpt[BVINDEX(3,1,a,j)]
Element_calculations.c:             (E->Ekk[m][(el-1)*vpts+j]*E->N.vpt[GNVINDEX(a,j)]*E->element_Cc.vpt[BVINDEX(3,2,a,j)]
Element_calculations.c:             (E->Ekk[m][(el-1)*vpts+j]*E->N.vpt[GNVINDEX(a,j)]*E->element_Cc.vpt[BVINDEX(3,3,a,j)]
Element_calculations.c:  const int dims=E->mesh.nsd;
Element_calculations.c:  es = (el-1)/E->lmesh.elz + 1;
Element_calculations.c:  if ((el-1)%E->lmesh.elz==0)
Element_calculations.c:      construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,E->mesh.levmax,m,0);
Element_calculations.c:    force[p] = E->buoyancy[m][E->ien[m][el].node[p]];
Element_calculations.c:      force_at_gs[j] += force[k] * E->N.vpt[GNVINDEX(k,j)] ;
Element_calculations.c:      nodea=E->ien[m][el].node[a];
Element_calculations.c:        elt_f[p] += force_at_gs[j] * E->N.vpt[GNVINDEX(a,j)]
Element_calculations.c:           *E->gDA[m][el].vpt[j]*g_point[j].weight[dims-1]
Element_calculations.c:           *E->element_Cc.vpt[BVINDEX(3,i,a,j)];
Element_calculations.c:            nodeb=E->ien[m][el].node[b];
Element_calculations.c:            if ((E->node[m][nodeb]&type)&&(E->sphere.cap[m].VB[j][nodeb]!=0.0)){
Element_calculations.c:                get_elt_k(E,el,elt_k,E->mesh.levmax,m,1);
Element_calculations.c:                elt_f[p] -= elt_k[p*n+q] * E->sphere.cap[m].VB[j][nodeb];
Element_calculations.c:	const int dims=E->mesh.nsd;
Element_calculations.c:	int el = E->boundary.element[m][bel];
Element_calculations.c:	const float rho = E->data.density;
Element_calculations.c:	const float g = E->data.grav_acc;
Element_calculations.c:	const float eta = E->data.ref_viscosity;
Element_calculations.c:	const float kappa = E->data.therm_diff;
Element_calculations.c:	if(E->control.side_sbcs)
Element_calculations.c:			nodea = E->ien[m][el].node[ sidenodes[side][a] ];
Element_calculations.c:				value = E->sbc.SB[m][side][d][ E->sbc.node[m][nodea] ];
Element_calculations.c:				flagged = (E->node[m][nodea] & sbc_flag[d]) && (value);
Element_calculations.c:				nodea = E->ien[m][el].node[ sidenodes[side][a] ];
Element_calculations.c:					value = E->sphere.cap[m].VB[d][nodea];
Element_calculations.c:					flagged = (E->node[m][nodea] & sbc_flag[d]) && (value);
Element_calculations.c:				     E->mesh.levmax,m,0,side);
Element_calculations.c:				traction_at_gs[d][k] += traction[d][j] * E->M.vpt[GMVINDEX(j,k)] ;
Element_calculations.c:				elt_tr[p] += tmp * E->M.vpt[GMVINDEX(j,k)]
Element_calculations.c:					* E->boundary.det[m][side][k][bel] * g_1d[k].weight[dims-1];
Element_calculations.c:	const int dims=E->mesh.nsd;
Element_calculations.c:	int el = E->boundary.element[m][bel];
Element_calculations.c:	const float rho = E->data.density;
Element_calculations.c:	const float g = E->data.grav_acc;
Element_calculations.c:	const float eta = E->data.ref_viscosity;
Element_calculations.c:	const float kappa = E->data.therm_diff;
Element_calculations.c:	if(E->control.side_sbcs)
Element_calculations.c:			nodea = E->ien[m][el].node[ sidenodes[side][a] ];
Element_calculations.c:				value = E->sbc.SB[m][side][d][ E->sbc.node[m][nodea] ];
Element_calculations.c:				flagged = (E->node[m][nodea] & sbc_flag[d]) && (value);
Element_calculations.c:		if( side == SIDE_TOP && E->parallel.me_loc[3]==E->parallel.nprocz-1 && (el%E->lmesh.elz==0)) {
Element_calculations.c:				nodea = E->ien[m][el].node[ sidenodes[side][a] ];
Element_calculations.c:				nodeas = E->ien[m][el].node[ sidenodes[side][a] ]/E->lmesh.noz;
Element_calculations.c:					*(E->slice.freesurf[m][nodeas]+E->sphere.cap[m].V[3][nodea]*E->advection.timestep);
Element_calculations.c:				if(E->parallel.me==11 && nodea==3328)
Element_calculations.c:					fprintf(stderr,"traction=%e vnew=%e timestep=%e coeff=%e\n",traction[3][a],E->sphere.cap[m].V[3][nodea],E->advection.timestep,-1.0*factor*rho*g*(R*R*R)/(eta*kappa));
Element_calculations.c:				if(found && E->parallel.me==1)
Element_calculations.c:						E->parallel.me,bel,el,side,SIDE_TOP,a,sidenodes[side][a],
Element_calculations.c:						E->ien[m][el].node[ sidenodes[side][a] ],E->lmesh.noz,
Element_calculations.c:				nodea = E->ien[m][el].node[ sidenodes[side][a] ];
Element_calculations.c:					value = E->sphere.cap[m].VB[d][nodea];
Element_calculations.c:					flagged = (E->node[m][nodea] & sbc_flag[d]) && (value);
Element_calculations.c:				     E->mesh.levmax,m,0,side);
Element_calculations.c:				traction_at_gs[d][k] += traction[d][j] * E->M.vpt[GMVINDEX(j,k)] ;
Element_calculations.c:				elt_tr[p] += tmp * E->M.vpt[GMVINDEX(j,k)]
Element_calculations.c:					* E->boundary.det[m][side][k][bel] * g_1d[k].weight[dims-1];
Element_calculations.c:     const int n=loc_mat_size[E->mesh.nsd];
Element_calculations.c:     const int ends=enodes[E->mesh.nsd];
Element_calculations.c:     const int vpts=vpoints[E->mesh.nsd];
Element_calculations.c:     const int dims=E->mesh.nsd;
Element_calculations.c:	  Visc += E->EVI[level][m][(el-1)*vpts+a];
Element_calculations.c:        nodea=E->IEN[level][m][el].node[a];
Element_calculations.c:           nodeb=E->IEN[level][m][el].node[b];      /* for Kab dims*dims  */
Element_calculations.c:	   elt_k[i  ] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]][0]*
Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]][0];   /*for 11 */
Element_calculations.c:	   elt_k[i+1] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]][0]*
Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]+1][0];  /* for 12 */
Element_calculations.c:	   elt_k[i+n] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]+1][0]*
Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]][0];    /* for 21 */
Element_calculations.c:	   elt_k[i+n+1] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]+1][0]*
Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]+1][0];  /* for 22 */
Element_calculations.c:	       elt_k[i+2] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]][0]*
Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]+2][0];  /* for 13 */
Element_calculations.c:	       elt_k[i+n+2] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]+1][0]*
Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]+2][0];  /* for 23 */
Element_calculations.c:	       elt_k[i+n+n] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]+2][0]*
Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]][0];    /* for 31 */
Element_calculations.c:	       elt_k[i+n+n+1] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]+2][0]*
Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]+1][0];  /* for 32 */
Element_calculations.c:	       elt_k[i+n+n+2] += Visc*E->control.augmented*
Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]+2][0]*
Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]+2][0];  /* for 33 */
Free_surfaces.c:    if (E->parallel.me_loc[3] == 0)                      { 
Free_surfaces.c:        for (lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)  
Free_surfaces.c:        for (i=1;i<=E->lmesh.NEL[lev];i++)    
Free_surfaces.c:        if ((i-1)%E->lmesh.ELZ[lev]==0)   {
Free_surfaces.c:            E->ELEMENT[lev][m][i] = E->ELEMENT[lev][m][i] | BOUNDARIES;
Free_surfaces.c:            E->ELEMENT[lev][m][i] = E->ELEMENT[lev][m][i] | BOUNDARY2;    /*CMB*/
Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[1]] = E->NODE[lev][m][E->IEN[lev][m][i].node[1]] | RESTORE;    /*CMB*/
Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[2]] = E->NODE[lev][m][E->IEN[lev][m][i].node[2]] | RESTORE;    /*CMB*/
Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[3]] = E->NODE[lev][m][E->IEN[lev][m][i].node[3]] | RESTORE;    /*CMB*/
Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[4]] = E->NODE[lev][m][E->IEN[lev][m][i].node[4]] | RESTORE;    /*CMB*/
Free_surfaces.c:    if (E->parallel.me_loc[3] == E->parallel.nprocz-1)   {
Free_surfaces.c:        for (lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)  
Free_surfaces.c:        for (i=1;i<=E->lmesh.NEL[lev];i++)    
Free_surfaces.c:        if (i%E->lmesh.ELZ[lev]==0)   {
Free_surfaces.c:            E->ELEMENT[lev][m][i] = E->ELEMENT[lev][m][i] | BOUNDARIES;
Free_surfaces.c:            E->ELEMENT[lev][m][i] = E->ELEMENT[lev][m][i] | BOUNDARY1;    /*Surface*/
Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[5]] = E->NODE[lev][m][E->IEN[lev][m][i].node[5]] | RESTORE;
Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[6]] = E->NODE[lev][m][E->IEN[lev][m][i].node[6]] | RESTORE;
Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[7]] = E->NODE[lev][m][E->IEN[lev][m][i].node[7]] | RESTORE;
Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[8]] = E->NODE[lev][m][E->IEN[lev][m][i].node[8]] | RESTORE;
Free_surfaces.c:    density_cmb = (E->data.density_below-E->data.density)/E->data.density;
Free_surfaces.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Free_surfaces.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:            for (j=1;j<=E->lmesh.nsf;j++)    {
Free_surfaces.c:                i = j*E->lmesh.noz;
Free_surfaces.c:                E->slice_ve.surf[2][m][j] = E->U[m][E->id[m][i].doff[3]]
Free_surfaces.c:                                               * E->ve_data_cont.surf_scaling
Free_surfaces.c:                                        + E->slice_ve.dynamic_oceanload[m][j];
Free_surfaces.c:            remove_average(E,E->slice_ve.surf[2],1);
Free_surfaces.c:        if (E->parallel.me_loc[3]==0)   {
Free_surfaces.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:            for (j=1;j<=E->lmesh.nsf;j++)    {
Free_surfaces.c:                i = (j-1)*E->lmesh.noz + 1;
Free_surfaces.c:                E->slice_ve.botm[2][m][j] = E->U[m][E->id[m][i].doff[3]];
Free_surfaces.c:                E->slice_ve.botm[2][m][j] *= E->ve_data_cont.botm_scaling;
Free_surfaces.c:            remove_average(E,E->slice_ve.botm[2],0);
Free_surfaces.c:        load_to_CM_grav( E, E->slice_ve.surf[2], E->slice_ve.botm[2], 0 );
Free_surfaces.c:    const int lev = E->mesh.levmax;
Free_surfaces.c:    const int onedp = onedvpoints[E->mesh.nsd];
Free_surfaces.c:    const int vpts=vpoints[E->mesh.nsd];
Free_surfaces.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Free_surfaces.c:  if (!E->ve_data_cont.compressible)  {
Free_surfaces.c:    if (E->parallel.me_loc[3]==0 || E->parallel.me_loc[3]==E->parallel.nprocz-1)  {
Free_surfaces.c:        if (el%E->lmesh.elz==0 && E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Free_surfaces.c:            e = el/E->lmesh.elz;
Free_surfaces.c:            for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Free_surfaces.c:                lnode[k] = E->sien[m][e].node[k];
Free_surfaces.c:                force[k] = E->slice_ve.load[1][m][ lnode[k] ];
Free_surfaces.c:        else if ((el-1)%E->lmesh.elz==0 && E->parallel.me_loc[3]==0)  {
Free_surfaces.c:            e = (el-1)/E->lmesh.elz+1;
Free_surfaces.c:            for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Free_surfaces.c:                lnode[k] = E->sien[m][e].node[k];
Free_surfaces.c:                force[k] = E->slice_ve.load[3][m][ lnode[k] ];
Free_surfaces.c:        for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   
Free_surfaces.c:        for (i=1;i<=onedvpoints[E->mesh.nsd];i++)   {
Free_surfaces.c:            for(k=1;k<=onedvpoints[E->mesh.nsd];k++)
Free_surfaces.c:                force_at_gs[i] += force[k] * E->M.vpt[GMVINDEX(k,i)];
Free_surfaces.c:                elt_f[3*nn[k]-1] += E->B_R[lev][m][nn[k]][(e-1)*onedp+i] * force_at_gs[i];
Free_surfaces.c:  else if (E->ve_data_cont.compressible) {
Free_surfaces.c:    if (E->ve_data_cont.SELFG)
Free_surfaces.c:       con = E->ve_data_cont.Rsg;
Free_surfaces.c:    e = (el-1)/E->lmesh.elz+1;
Free_surfaces.c:    for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Free_surfaces.c:      lnode[k] = E->ien[m][el].node[k+onedp];
Free_surfaces.c:      force[k] = E->all_load[m][lnode[k]];
Free_surfaces.c:    radius2 = E->sx[m][3][lnode[1]]*E->sx[m][3][lnode[1]];
Free_surfaces.c:    for (i=1;i<=onedvpoints[E->mesh.nsd];i++)   {
Free_surfaces.c:      for(k=1;k<=onedvpoints[E->mesh.nsd];k++)
Free_surfaces.c:        force_at_gs[i] += force[k] * E->M.vpt[GMVINDEX(k,i)];
Free_surfaces.c:        elt_f[3*(k+onedp)-1] += radius2*E->B_R[lev][m][k+onedp][(e-1)*onedp+i] * force_at_gs[i];
Free_surfaces.c:    if ((el-1)%E->lmesh.elz==0 && E->parallel.me_loc[3]==0)  {
Free_surfaces.c:      for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Free_surfaces.c:        lnode[k] = E->ien[m][el].node[k];
Free_surfaces.c:        force[k] = E->all_load[m][lnode[k]];
Free_surfaces.c:      for (i=1;i<=onedvpoints[E->mesh.nsd];i++)   {
Free_surfaces.c:        for(k=1;k<=onedvpoints[E->mesh.nsd];k++)
Free_surfaces.c:          force_at_gs[i] += force[k] * E->M.vpt[GMVINDEX(k,i)];
Free_surfaces.c:          elt_f[3*k-1] += E->B_R[lev][m][k][(e-1)*onedp+i] * force_at_gs[i];
Free_surfaces.c:      node[a] = E->ien[m][el].node[a];
Free_surfaces.c:      force[a] = con*E->total_potential[m][node[a]];
Free_surfaces.c:        force_at_gs[i] += E->erho[lev][m][el]*force[k]*E->N.vpt[GNVINDEX(k,i)];
Free_surfaces.c:    gnxx = E->gNX[m][el].vpt;
Free_surfaces.c:    gnda = E->gDA[m][el].vpt;
Free_surfaces.c:    get_rtf_at_vpts(E,m,E->mesh.levmax,el,rtf);
Free_surfaces.c:    if ((el-1)%E->lmesh.elz==0)
Free_surfaces.c:      construct_c3x3matrix_el(E,el,&Cc,&Ccx,E->mesh.levmax,m,0);
Free_surfaces.c:                 +E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(1,k,1,i,j)]
Free_surfaces.c:                 +E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(3,k,i,j)])
Free_surfaces.c:                (E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(1,k,i,j)]*ct[j]
Free_surfaces.c:                +E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(3,k,i,j)]
Free_surfaces.c:                 +E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(2,k,2,i,j)])/sinaa[j])
Free_surfaces.c:    int m1 = E->parallel.me;
Free_surfaces.c:    E->ve_data_cont.potential_scaling = 4.0*M_PI*E->data.grav_const*E->data.density
Free_surfaces.c:        *E->sphere.dradius*E->sphere.dradius;
Free_surfaces.c:    E->ve_data_cont.rotation_rate = E->ve_data_cont.rotation_rate*2.0*M_PI/(24.0*3600.0);
Free_surfaces.c:        E->ve_data_cont.Rsg = 4.0*M_PI*E->data.grav_const*E->data.density
Free_surfaces.c:            *E->data.density*E->sphere.dradius*E->sphere.dradius
Free_surfaces.c:            /E->ve_data_cont.shear_mod;
Free_surfaces.c:        E->ve_data_cont.botm_scaling = (E->data.density_below-E->data.density)
Free_surfaces.c:                              *E->data.grav_acc
Free_surfaces.c:                              *E->sphere.dradius/E->ve_data_cont.shear_mod;
Free_surfaces.c:        E->ve_data_cont.surf_scaling = E->data.density*E->data.grav_acc
Free_surfaces.c:                              *E->sphere.dradius /E->ve_data_cont.shear_mod;
Free_surfaces.c:    E->ve_data_cont.ice_stress_scale = E->ve_data_cont.surf_scaling*density_ice/E->data.density;
Free_surfaces.c:    if (E->parallel.me==0)  {
Free_surfaces.c:        fprintf(E->fp,"scale %.5e %.5e %.5e %.5e\n",
Free_surfaces.c:                      E->ve_data_cont.botm_scaling,
Free_surfaces.c:                      E->ve_data_cont.surf_scaling,
Free_surfaces.c:                      E->ve_data_cont.ice_stress_scale,E->ve_data_cont.tau);
Free_surfaces.c:        fflush(E->fp); 
Free_surfaces.c://    input_int("stages",&(E->ve_data_cont.stages),"1",m1);
Free_surfaces.c://    input_int_vector("step",E->ve_data_cont.stages,(E->ve_data_cont.stages_step),m1);
Free_surfaces.c://    input_double_vector("timestep",E->ve_data_cont.stages,(E->ve_data_cont.stages_time),m1);
Free_surfaces.c:    for (i=0;i<E->ve_data_cont.stages;i++)  {
Free_surfaces.c:        if (E->ve_data_cont.Heaviside==1)
Free_surfaces.c:            E->ve_data_cont.stages_timestep[i] = E->ve_data_cont.stages_time[i]
Free_surfaces.c:                /((E->ve_data_cont.stages_step[i]-oldstep));
Free_surfaces.c:            E->ve_data_cont.stages_timestep[i] = E->ve_data_cont.stages_time[i]
Free_surfaces.c:                /(E->ve_data_cont.tau*(E->ve_data_cont.stages_step[i]-oldstep));
Free_surfaces.c:        oldstep = E->ve_data_cont.stages_step[i];
Free_surfaces.c:    if (E->ve_data_cont.Heaviside==1)   { 
Free_surfaces.c:        E->monitor.elapsed_time=0.0;
Free_surfaces.c:        E->ve_data_cont.DIRECT=1;
Free_surfaces.c:        E->monitor.elapsed_time=E->ve_data_cont.stages_timestep[0];
Free_surfaces.c:        E->advection.timestep=E->ve_data_cont.stages_timestep[0];
Free_surfaces.c:        E->monitor.solution_cycles = 1;
Free_surfaces.c:        E->ve_data_cont.DIRECT=1;
Free_surfaces.c:    E->ve_data_cont.change_of_load = 1;  // used by apply_new_loads
Free_surfaces.c:    if (E->ve_data_cont.Heaviside==1)    {
Free_surfaces.c:        mm = E->convection.perturb_mm[0];
Free_surfaces.c:        ll = E->convection.perturb_ll[0];
Free_surfaces.c:        con = E->convection.perturb_mag[0];
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)    {
Free_surfaces.c:            i = j*E->lmesh.noz;
Free_surfaces.c:            t1 = E->SX[E->mesh.levmax][m][1][i];
Free_surfaces.c:            f1 = E->SX[E->mesh.levmax][m][2][i];
Free_surfaces.c:            if (E->ve_data_cont.apply_potential==0)
Free_surfaces.c:                E->Xsurf[3][m][j] = con*modified_plgndr_a(ll,mm,t1)*cos(mm*f1);
Free_surfaces.c:            else if (E->ve_data_cont.apply_potential==1) { 
Free_surfaces.c:                E->Xsurf[3][m][j] = 0.0;
Free_surfaces.c:                E->init_potential[0][m][j] = con*E->sphere.ro*E->sphere.ro*modified_plgndr_a(ll,mm,t1)*cos(mm*f1);
Free_surfaces.c:                E->init_potential[1][m][j] = con*E->sphere.ri*E->sphere.ri*modified_plgndr_a(ll,mm,t1)*cos(mm*f1);
Free_surfaces.c:        remove_average(E,E->Xsurf[3],1);
Free_surfaces.c:        sphere_expansion_output(E,1,E->Xsurf[3],
Free_surfaces.c:                                E->sphere.sphc[0],E->sphere.sphs[0],
Free_surfaces.c:                                E->monitor.solution_cycles,"init_surf");
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)    {
Free_surfaces.c:            E->slice_ve.surf[2][m][j] = E->Xsurf[3][m][j]*E->ve_data_cont.surf_scaling;
Free_surfaces.c:            E->slice_ve.botm[2][m][j] = 0.0 ;
Free_surfaces.c:        load_to_CM_grav( E, E->slice_ve.surf[2], E->slice_ve.botm[2], 1 );
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)    {
Free_surfaces.c:            E->slice_ve.load[0][m][j] = E->slice_ve.surf[2][m][j] ;
Free_surfaces.c:            E->slice_ve.load[2][m][j] = E->slice_ve.botm[2][m][j] ;
Free_surfaces.c:    else if (E->ve_data_cont.Heaviside==2)  {   /* ice-model */
Free_surfaces.c:        get_iceModel(E,E->slice_ve.iceload[0]);  
Free_surfaces.c:        if (E->ve_data_cont.SLE) get_static_oceanload(E);
Free_surfaces.c:    if (E->ve_data_cont.Heaviside==1)  
Free_surfaces.c:        E->ve_data_cont.change_of_load = 0; // no more load changes in this case
Free_surfaces.c:    if (E->ve_data_cont.SELFG)  {// for conversion of potential -> geoid 
Free_surfaces.c:        con1 = E->ve_data_cont.Rsg; // surface
Free_surfaces.c:        con =  E->ve_data_cont.Rsg  // CMB
Free_surfaces.c:               * (E->data.density_below-E->data.density) / E->data.density;
Free_surfaces.c:    if (E->parallel.me_loc[3]==E->parallel.nprocz-1)          // surface
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)    {
Free_surfaces.c:            E->slice_ve.load[1][m][j] = -(  E->slice_ve.load[0][m][j] 
Free_surfaces.c:                                       + E->slice_ve.dynamic_oceanload[m][j] )
Free_surfaces.c:                                     + con1*E->potential[0][m][j];
Free_surfaces.c:            /* E->slice_ve.load[1][m][j] = -E->slice_ve.load[1][m][j] 
Free_surfaces.c:                                     + con1*E->potential[m][is];*/
Free_surfaces.c:    if (E->parallel.me_loc[3]==0)                              // CMB
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)    {
Free_surfaces.c:            E->slice_ve.load[3][m][j] = - ( E->slice_ve.load[2][m][j] 
Free_surfaces.c:                                         - con*E->potential[1][m][j] ) ; 
Free_surfaces.c:            /* E->slice_ve.load[3][m][j] = - ( E->slice_ve.load[3][m][j] 
Free_surfaces.c:                                        - con*E->potential[m][ib]) ; */
Free_surfaces.c:        sphere_expansion_output(E,1,E->slice_ve.load[1],
Free_surfaces.c:                                E->sphere.sphc[0],E->sphere.sphs[0],
Free_surfaces.c:                                E->monitor.solution_cycles,"surfaceload");
Free_surfaces.c: * If E->control.polar_wander is true, it further changes the potential arrays
Free_surfaces.c: *     X_surf/cmb must be nondimensional stresses (such as E->iceload).
Free_surfaces.c:    ri = E->sphere.ri;
Free_surfaces.c:    ro = E->sphere.ro;
Free_surfaces.c:    density_cmb = (E->data.density_below-E->data.density)/E->data.density;
Free_surfaces.c:        for (ll=1;ll<=E->output.llmax;ll++)    {
Free_surfaces.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:   for (j=1;j<=E->lmesh.nsf;j++) {
Free_surfaces.c:        E->Xsurf[1][m][j] = 0.0;
Free_surfaces.c:        E->Xsurf[2][m][j] = 0.0;
Free_surfaces.c:    if (E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)   {
Free_surfaces.c:            E->Xsurf[1][m][j] = X_surf[m][j]/E->ve_data_cont.surf_scaling;
Free_surfaces.c:        sphere_expansion_VE(E,1,E->Xsurf[1],
Free_surfaces.c:                         E->sphere.sphc[0],E->sphere.sphs[0],E->output.llmax);
Free_surfaces.c:        for (ll=0;ll<=E->output.llmax;ll++)
Free_surfaces.c:            p = E->sphere.hindex[ll][mm];
Free_surfaces.c:            E->sphere.sphc[0][p] *= density_surf;
Free_surfaces.c:            E->sphere.sphs[0][p] *= density_surf;
Free_surfaces.c:    if (E->parallel.me_loc[3]==0)  {
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)   {
Free_surfaces.c:            E->Xsurf[2][m][j] = X_cmb[m][j]/E->ve_data_cont.botm_scaling;
Free_surfaces.c:        sphere_expansion_VE(E,0,E->Xsurf[2],
Free_surfaces.c:                          E->sphere.sphc[1],E->sphere.sphs[1],E->output.llmax);
Free_surfaces.c:        for (ll=0;ll<=E->output.llmax;ll++)
Free_surfaces.c:            p = E->sphere.hindex[ll][mm];
Free_surfaces.c:            E->sphere.sphc[1][p] *= density_cmb;
Free_surfaces.c:            E->sphere.sphs[1][p] *= density_cmb;
Free_surfaces.c:    if (E->parallel.nprocz>1)  // if >1 cap in z-direction (probably not)
Free_surfaces.c:        exchange_sphcs(E,E->sphere.sphc[0],E->sphere.sphs[0],
Free_surfaces.c:                         E->sphere.sphc[1],E->sphere.sphs[1]);
Free_surfaces.c:    if (E->parallel.me_loc[3]==0)  {
Free_surfaces.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:      for (j=1;j<=E->lmesh.nsf;j++) {
Free_surfaces.c:        for (ll=1;ll<=E->output.llmax;ll++)  
Free_surfaces.c:            p = E->sphere.hindex[ll][mm]; 
Free_surfaces.c:            potential_cmb[m][j] += ( E->Tbl_cs[m][mm][j]*
Free_surfaces.c:              (brll1[ll]*E->sphere.sphc[0][p] + brll2[ll]*E->sphere.sphc[1][p])
Free_surfaces.c:               + E->Tbl_sn[m][mm][j]*
Free_surfaces.c:              (brll1[ll]*E->sphere.sphs[0][p] + brll2[ll]*E->sphere.sphs[1][p]))
Free_surfaces.c:                *E->Tbl_lm[m][p][j];
Free_surfaces.c:    if (E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Free_surfaces.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:      for (j=1;j<=E->lmesh.nsf;j++) {
Free_surfaces.c:        for (ll=1;ll<=E->output.llmax;ll++)   
Free_surfaces.c:            p = E->sphere.hindex[ll][mm]; 
Free_surfaces.c:            potential_surf[m][j] += ( E->Tbl_cs[m][mm][j]*
Free_surfaces.c:             (srll1[ll]*E->sphere.sphc[0][p] + srll2[ll]*E->sphere.sphc[1][p])
Free_surfaces.c:                    + E->Tbl_sn[m][mm][j]*
Free_surfaces.c:             (srll1[ll]*E->sphere.sphs[0][p] + srll2[ll]*E->sphere.sphs[1][p]) )
Free_surfaces.c:                *E->Tbl_lm[m][p][j];
Free_surfaces.c:    if (E->ve_data_cont.polar_wander && icon==1)  
Free_surfaces.c://        polar_wander_effects( E, E->Xsurf[1], E->Xsurf[2], 
Free_surfaces.c:    ri = E->sphere.ri;
Free_surfaces.c:    ro = E->sphere.ro;
Free_surfaces.c:    density_cmb = (E->data.density_below-E->data.density)/E->data.density;
Free_surfaces.c:    if (E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)   {
Free_surfaces.c:            E->Xsurf[1][m][j] = X_surf[m][j]/E->ve_data_cont.surf_scaling;
Free_surfaces.c:        sphere_expansion_VE(E,1,E->Xsurf[1],
Free_surfaces.c:                             E->sphere.sphc[0],E->sphere.sphs[0],llmax);
Free_surfaces.c:            p = E->sphere.hindex[ll][mm];
Free_surfaces.c:            E->sphere.sphc[0][p] *= density_surf;
Free_surfaces.c:            E->sphere.sphs[0][p] *= density_surf;
Free_surfaces.c:    if (E->parallel.me_loc[3]==0)  {
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)   {
Free_surfaces.c:            E->Xsurf[2][m][j] = X_cmb[m][j]/E->ve_data_cont.botm_scaling;
Free_surfaces.c:        sphere_expansion_VE(E,0,E->Xsurf[2],
Free_surfaces.c:                             E->sphere.sphc[1],E->sphere.sphs[1],llmax);
Free_surfaces.c:            p = E->sphere.hindex[ll][mm];
Free_surfaces.c:            E->sphere.sphc[1][p] *= density_cmb;
Free_surfaces.c:            E->sphere.sphs[1][p] *= density_cmb;
Free_surfaces.c:    if (E->parallel.nprocz>1)  // if >1 cap in z-direction (probably not)
Free_surfaces.c:        exchange_sphcs(E,E->sphere.sphc[0],E->sphere.sphs[0],
Free_surfaces.c:                         E->sphere.sphc[1],E->sphere.sphs[1]);
Free_surfaces.c:    p = E->sphere.hindex[ll][mm]; 
Free_surfaces.c:    E->ve_data_cont.CM_pot[0]= srll1[ll]*E->sphere.sphc[0][p]+srll2[ll]*E->sphere.sphc[1][p];
Free_surfaces.c:    p = E->sphere.hindex[ll][mm]; 
Free_surfaces.c:    E->ve_data_cont.CM_pot[1]= srll1[ll]*E->sphere.sphc[0][p]+srll2[ll]*E->sphere.sphc[1][p];
Free_surfaces.c:    E->ve_data_cont.CM_pot[2]= srll1[ll]*E->sphere.sphs[0][p]+srll2[ll]*E->sphere.sphs[1][p];
Free_surfaces.c:    p = E->sphere.hindex[ll][mm]; 
Free_surfaces.c:    E->ve_data_cont.PW_pot[0]= srll1[ll]*E->sphere.sphc[0][p]+srll2[ll]*E->sphere.sphc[1][p];
Free_surfaces.c:    E->ve_data_cont.PW_pot[1]= srll1[ll]*E->sphere.sphs[0][p]+srll2[ll]*E->sphere.sphs[1][p];
Free_surfaces.c: * Sets E->potential[0/1], the nondim grav'l potential at the surface/cmb.
Free_surfaces.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:    TG[m] = (double *)malloc((E->lmesh.nsf+1)*sizeof(double));
Free_surfaces.c:            // We are performing self-grav iteration. So initialize E->potential
Free_surfaces.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:            for (j=1;j<=E->lmesh.nsf;j++)   {
Free_surfaces.c:                E->potential[1][m][j] = E->init_potential[1][m][j];
Free_surfaces.c:                E->potential[0][m][j] = E->init_potential[0][m][j];
Free_surfaces.c:        // calculate E->incr_potential[0/1] from E->slice.surf/botm[2]:
Free_surfaces.c:        calculate_potential( E, E->slice_ve.surf[2], E->slice_ve.botm[2], 
Free_surfaces.c:                             E->incr_potential[0], E->incr_potential[1], 1);
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)   {
Free_surfaces.c:            E->potential[1][m][j] =  E->init_potential[1][m][j] 
Free_surfaces.c:                                   + E->incr_potential[1][m][j];  // cmb
Free_surfaces.c:            E->potential[0][m][j] =  E->init_potential[0][m][j] 
Free_surfaces.c:                                   + E->incr_potential[0][m][j];  // surface
Free_surfaces.c:for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:    for (j=1;j<=E->lmesh.nsf;j++)  { 
Free_surfaces.c:         TG[m][j] = fabs(E->potential[0][m][j]);
Free_surfaces.c:if (E->parallel.me==0) fprintf(stderr,"in get_potential %g count %d\n",temp1,count);
Free_surfaces.c:  const int onedp=onedvpoints[E->mesh.nsd];
Free_surfaces.c: if (E->parallel.me_loc[3]==E->parallel.nprocz-1 || E->parallel.me_loc[3]==0)  {
Free_surfaces.c: for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)     
Free_surfaces.c: for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Free_surfaces.c:   if (E->parallel.me_loc[3]==E->parallel.nprocz-1)  
Free_surfaces.c:     for (e=1;e<=E->lmesh.SNEL[lev];e++)    {
Free_surfaces.c:       el = e*E->lmesh.ELZ[lev];
Free_surfaces.c:           E->B_R[lev][m][nn[k]][(e-1)*onedp+i] =
Free_surfaces.c:                     E->M.vpt[GMVINDEX(k,i)]
Free_surfaces.c:   if (E->parallel.me_loc[3]==0)  
Free_surfaces.c:     for (e=1;e<=E->lmesh.SNEL[lev];e++)     {
Free_surfaces.c:       el = (e-1)*E->lmesh.ELZ[lev]+1;
Free_surfaces.c:           E->B_R[lev][m][nn[k]][(e-1)*onedp+i] =
Free_surfaces.c:                     E->M.vpt[GMVINDEX(k,i)]
Free_surfaces.c:    const int onedp=onedvpoints[E->mesh.nsd];
Free_surfaces.c:    if (E->parallel.me_loc[3]==E->parallel.nprocz-1)  {
Free_surfaces.c:        for (e=1;e<=E->lmesh.SNEL[lev];e++)   {
Free_surfaces.c:            el=e*E->lmesh.ELZ[lev];
Free_surfaces.c:                nn[k] = E->ID[lev][m][E->IEN[lev][m][el].node[k+onedp]].doff[3];
Free_surfaces.c:                force[k] = E->ve_data_cont.surf_scaling*u[m][nn[k]];
Free_surfaces.c:                    force_at_gs[i] += force[k] * E->M.vpt[GMVINDEX(k,i)];
Free_surfaces.c:                Au[m][nn[k]] += E->B_R[lev][m][k+onedp][(e-1)*onedp+i] * force_at_gs[i];
Free_surfaces.c:    if (E->parallel.me_loc[3]==0)  {
Free_surfaces.c:        for (e=1;e<=E->lmesh.SNEL[lev];e++)   {
Free_surfaces.c:            el=(e-1)*E->lmesh.ELZ[lev]+1;
Free_surfaces.c:                nn[k] = E->ID[lev][m][E->IEN[lev][m][el].node[k]].doff[3];
Free_surfaces.c:                force[k] = E->ve_data_cont.botm_scaling*u[m][nn[k]];
Free_surfaces.c:                    force_at_gs[i] += force[k] * E->M.vpt[GMVINDEX(k,i)];
Free_surfaces.c:                Au[m][nn[k]] += E->B_R[lev][m][k][(e-1)*onedp+i] * force_at_gs[i];
Free_surfaces.c: * About the flag E->control.change_of_load:
Free_surfaces.c:    if (E->ve_data_cont.change_of_load==0) {  // no more ice or static ocean load
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:        for (i=1;i<=E->lmesh.nsf;i++)   {
Free_surfaces.c:            E->incr_potential[2][m][i] = 0.0 ;
Free_surfaces.c:            E->incr_potential[3][m][i] = 0.0 ;
Free_surfaces.c:    if (E->ve_data_cont.Heaviside==2) {  // only for ice-model type loading
Free_surfaces.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Free_surfaces.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Free_surfaces.c:            for (i=1;i<=E->lmesh.nsf;i++)
Free_surfaces.c:                E->slice_ve.surf[2][m][i] =  E->slice_ve.iceload[0][m][i]
Free_surfaces.c:                                        + E->slice_ve.static_oceanload[m][i];
Free_surfaces.c:        if (E->parallel.me_loc[3]==0)
Free_surfaces.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Free_surfaces.c:            for (i=1;i<=E->lmesh.nsf;i++)
Free_surfaces.c:                E->slice_ve.botm[2][m][i] = 0.0;
Free_surfaces.c:        load_to_CM_grav( E, E->slice_ve.surf[2], E->slice_ve.botm[2], 1 );
Free_surfaces.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Free_surfaces.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Free_surfaces.c:            for (i=1;i<=E->lmesh.nsf;i++)
Free_surfaces.c:                E->slice_ve.load[0][m][i] +=  E->slice_ve.surf[2][m][i];
Free_surfaces.c:        if (E->parallel.me_loc[3]==0)
Free_surfaces.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Free_surfaces.c:            for (i=1;i<=E->lmesh.nsf;i++)
Free_surfaces.c:                E->slice_ve.load[2][m][i] += E->slice_ve.botm[2][m][i];
Free_surfaces.c:    if (E->ve_data_cont.SELFG)   {
Free_surfaces.c:        if (E->ve_data_cont.change_of_load==1 || E->ve_data_cont.SLE)
Free_surfaces.c:            calculate_potential( E, E->slice_ve.surf[2], E->slice_ve.botm[2], 
Free_surfaces.c:                                 E->incr_potential[2], E->incr_potential[3], 1);
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:        for (i=1;i<=E->lmesh.nsf;i++)   {
Free_surfaces.c:            E->init_potential[0][m][i] += E->incr_potential[2][m][i];
Free_surfaces.c:            E->init_potential[1][m][i] += E->incr_potential[3][m][i];
Free_surfaces.c: * About the flag E->control.change_of_load:
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Free_surfaces.c:            E->slice_ve.ice_height_prev[m] = (double *)
Free_surfaces.c:                              malloc((E->lmesh.nsf+2)*sizeof(double));
Free_surfaces.c:            E->slice_ve.ice_height_curr[m] = (double *)
Free_surfaces.c:                              malloc((E->lmesh.nsf+2)*sizeof(double));
Free_surfaces.c:            for (n=1;n<=E->lmesh.nsf;n++)  {  
Free_surfaces.c:                E->slice_ve.ice_height_prev[m][n] = 0.0;
Free_surfaces.c:                E->slice_ve.ice_height_curr[m][n] = 0.0;
Free_surfaces.c:   if (E->ve_data_cont.DIRECT == 0 && been_here!=0) 
Free_surfaces.c:    ifile = E->ve_data_cont.stage + 1;
Free_surfaces.c:    E->ve_data_cont.change_of_load = 1;
Free_surfaces.c:            E->ve_data_cont.ice_file, E->sphere.elx, E->sphere.ely, ifile-1);
Free_surfaces.c:        read_reg_grids(E,outfile,E->slice_ve.ice_height_prev);
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)  {
Free_surfaces.c:           E->slice_ve.ice_height_prev[m][j] = E->slice_ve.ice_height_prev[m][j]/E->sphere.dradius; // non-dimensionalized by the Earth's radius
Free_surfaces.c:           E->slice_ve.ice_height_prev[m][j] = 0.0; // reset to be ice free
Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)  
Free_surfaces.c:            E->slice_ve.ice_height_prev[m][j] = E->slice_ve.ice_height_curr[m][j];   
Free_surfaces.c:        step_prev = E->ve_data_cont.stages_step[E->ve_data_cont.stage-1];
Free_surfaces.c:                E->ve_data_cont.ice_file, E->sphere.elx, E->sphere.ely, ifile);
Free_surfaces.c:    read_reg_grids(E,outfile,E->slice_ve.ice_height_curr);
Free_surfaces.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:    for (j=1;j<=E->lmesh.nsf;j++)  {
Free_surfaces.c:        E->slice_ve.ice_height_curr[m][j] = E->slice_ve.ice_height_curr[m][j]/E->sphere.dradius; // non-dimensionalized by the Earth's radius
Free_surfaces.c:    temp1 = E->ve_data_cont.ice_stress_scale/(E->ve_data_cont.stages_step[E->ve_data_cont.stage] - step_prev);
Free_surfaces.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:    for (j=1;j<=E->lmesh.nsf;j++) 
Free_surfaces.c:        iceload[m][j] = ( E->slice_ve.ice_height_curr[m][j]
Free_surfaces.c:                         -E->slice_ve.ice_height_prev[m][j])*temp1;
Free_surfaces.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:    for (n=1;n<=E->lmesh.nsf;n++)    
Free_surfaces.c:        E->Xsurf[3][m][n] = iceload[m][n];
Free_surfaces.c:    remove_average(E,E->Xsurf[3],1);
Free_surfaces.c:    sphere_expansion_output( E, 1, E->Xsurf[3], 
Free_surfaces.c:                             E->sphere.sphc[0], E->sphere.sphs[0],
Free_surfaces.c:                             E->monitor.solution_cycles,outfile );
Free_surfaces.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Free_surfaces.c:    for (n=1;n<=E->lmesh.nsf;n++)
Free_surfaces.c:        iceload[m][n] = E->Xsurf[3][m][n];
Free_surfaces.c: if (E->sphere.nox==181) {
Free_surfaces.c: else if (E->sphere.nox==361) {
Free_surfaces.c:   for (j=1;j<=E->sphere.caps_per_proc;j++)
Free_surfaces.c:   for (node=1;node<=E->lmesh.nno;node++)   {
Free_surfaces.c:     theta=E->sx[j][1][node];
Free_surfaces.c:     phi  =E->sx[j][2][node];
Free_surfaces.c:     if (node%E->lmesh.noz==0)  {
Free_surfaces.c:   del_degree=180.0/(E->sphere.nox-1); /* increments given in input file */
Free_surfaces.c:   numtheta=E->sphere.nox-1;       /* number of theta increments */
Free_surfaces.c:   for (j=1;j<=E->sphere.caps_per_proc;j++)
Free_surfaces.c:   for (node=1;node<=E->lmesh.nno;node++)   {
Free_surfaces.c:     theta=E->sx[j][1][node];
Free_surfaces.c:     phi  =E->sx[j][2][node];
Free_surfaces.c:     if (node%E->lmesh.noz==0)  {
Free_surfaces.c:   for (j=1;j<=E->sphere.caps_per_proc;j++)
Free_surfaces.c:   for (node=1;node<=E->lmesh.nno;node++)   {
Free_surfaces.c:     theta=E->sx[j][1][node];
Free_surfaces.c:     phi  =E->sx[j][2][node];
Free_surfaces.c:     if (node%E->lmesh.noz==0)  {
Full_boundary_conditions.c:  for(lv=E->mesh.gridmax;lv>=E->mesh.gridmin;lv--)
Full_boundary_conditions.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)     {
Full_boundary_conditions.c:      noz = E->mesh.NOZ[lv];
Full_boundary_conditions.c:      if(E->mesh.topvbc != 1) {	/* free stress top, note: free-slip BC is removed */
Full_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,1,0.0,VBX,0,lv,j);
Full_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,VBZ,0,lv,j);
Full_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,2,0.0,VBY,0,lv,j);
Full_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,1,E->control.VBXtopval,SBX,1,lv,j);
Full_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,3,E->control.VBZtopval,SBZ,1,lv,j);
Full_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,2,E->control.VBYtopval,SBY,1,lv,j);
Full_boundary_conditions.c:      if(E->mesh.botvbc != 1) {	/* free stress bottom */
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,0.0,VBX,0,lv,j);
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,VBZ,0,lv,j);
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,0.0,VBY,0,lv,j);
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,E->control.VBXbotval,SBX,1,lv,j);
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,E->control.VBZbotval,SBZ,1,lv,j);
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,E->control.VBYbotval,SBY,1,lv,j);
Full_boundary_conditions.c:      if(E->mesh.topvbc == 1) {	/* velocity/no slip BC */
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,E->control.VBXtopval,VBX,1,lv,j);
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,VBZ,1,lv,j);
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,E->control.VBYtopval,VBY,1,lv,j);
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,0.0,SBX,0,lv,j);
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,SBZ,0,lv,j);
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,0.0,SBY,0,lv,j);
Full_boundary_conditions.c:        if(E->control.vbcs_file){ /* this should either only be called
Full_boundary_conditions.c:	  if((lv == E->mesh.gridmin) && (j == E->sphere.caps_per_proc))
Full_boundary_conditions.c:      if(E->mesh.botvbc == 1) {	/* velocity bottom BC */
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,E->control.VBXbotval,VBX,1,lv,j);
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,VBZ,1,lv,j);
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,E->control.VBYbotval,VBY,1,lv,j);
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,0.0,SBX,0,lv,j);
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,SBZ,0,lv,j);
Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,0.0,SBY,0,lv,j);
Full_boundary_conditions.c:      if(E->control.side_sbcs)
Full_boundary_conditions.c:/* if(E->control.verbose) { */
Full_boundary_conditions.c:/*  for (j=1;j<=E->sphere.caps_per_proc;j++) */
Full_boundary_conditions.c:/*    for (node=1;node<=E->lmesh.nno;node++) */
Full_boundary_conditions.c:/*       fprintf(E->fp_out,"m=%d VB== %d %g %g %g flag %u %u %u\n",j,node,E->sphere.cap[j].VB[1][node],E->sphere.cap[j].VB[2][node],E->sphere.cap[j].VB[3][node],E->node[j][node]&VBX,E->node[j][node]&VBY,E->node[j][node]&VBZ); */
Full_boundary_conditions.c:/*  fflush(E->fp_out); */
Full_boundary_conditions.c:  lev = E->mesh.levmax;
Full_boundary_conditions.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)    {
Full_boundary_conditions.c:    noz = E->mesh.noz;
Full_boundary_conditions.c:    if(E->mesh.toptbc == 1)    {
Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,TBZ,1,lev,j);
Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,FBZ,0,lev,j);
Full_boundary_conditions.c:      if(E->control.tbcs_file)
Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,TBZ,0,lev,j);
Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,FBZ,1,lev,j);
Full_boundary_conditions.c:    if(E->mesh.bottbc == 1)    {
Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,TBZ,1,lev,j);
Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,FBZ,0,lev,j);
Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,TBZ,0,lev,j);
Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,FBZ,1,lev,j);
Full_boundary_conditions.c:    if(E->control.lith_age_time==1)  {
Full_boundary_conditions.c:  E->temperatures_conform_bcs = temperatures_conform_bcs;
Full_boundary_conditions.c:  if(dirn > E->mesh.nsd)
Full_boundary_conditions.c:      rowl = E->lmesh.NOZ[level];
Full_boundary_conditions.c:  if ( ( (ROW==1) && (E->parallel.me_loc[3]==0) ) ||
Full_boundary_conditions.c:       ( (ROW==E->mesh.NOZ[level]) && (E->parallel.me_loc[3]==E->parallel.nprocz-1) ) ) {
Full_boundary_conditions.c:      for(j=1;j<=E->lmesh.NOY[level];j++)
Full_boundary_conditions.c:    	for(i=1;i<=E->lmesh.NOX[level];i++)     {
Full_boundary_conditions.c:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+(j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Full_boundary_conditions.c:    	  E->NODE[level][m][node] = E->NODE[level][m][node] & (~ mask);
Full_boundary_conditions.c:      for(j=1;j<=E->lmesh.NOY[level];j++)
Full_boundary_conditions.c:        for(i=1;i<=E->lmesh.NOX[level];i++)       {
Full_boundary_conditions.c:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+(j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Full_boundary_conditions.c:    	  E->NODE[level][m][node] = E->NODE[level][m][node] | (mask);
Full_boundary_conditions.c:    	  if(level==E->mesh.levmax)   /* NB */
Full_boundary_conditions.c:  fprintf(E->fp,"Periodic boundary conditions\n");
Full_boundary_conditions.c: fprintf(E->fp,"Periodic temperature boundary conditions\n");
Full_geometry_cartesian.c:  E->mesh.nsd = 2;
Full_geometry_cartesian.c:  E->mesh.dof = 2;
Full_geometry_cartesian.c:  E->mesh.nsd = 2;
Full_geometry_cartesian.c:  E->mesh.dof = 3;
Full_geometry_cartesian.c:  E->mesh.nsd = 3;
Full_geometry_cartesian.c:  E->mesh.dof = 3;
Full_geometry_cartesian.c:  E->mesh.nsd = 3;
Full_geometry_cartesian.c:  E->mesh.dof = 3;
Full_geometry_cartesian.c:  E->sphere.caps = 12;
Full_geometry_cartesian.c:  E->sphere.max_connections = 6;
Full_obsolete.c:  E->parallel.me = 0;
Full_obsolete.c:  E->parallel.nproc = 1;
Full_obsolete.c:  E->parallel.me_loc[1] = 0;
Full_obsolete.c:  E->parallel.me_loc[2] = 0;
Full_obsolete.c:  E->parallel.me_loc[3] = 0;
Full_obsolete.c:  MPI_Comm_rank(E->parallel.world, &(E->parallel.me) );
Full_obsolete.c:  MPI_Comm_size(E->parallel.world, &(E->parallel.nproc) );
Full_obsolete.c: const int dims = E->mesh.nsd;
Full_obsolete.c: if (E->parallel.nprocz==1)  {
Full_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"scatter_to_nlayer should not be called\n");
Full_obsolete.c:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Full_obsolete.c:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Full_obsolete.c:   SD = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Full_obsolete.c:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Full_obsolete.c:   for (j=0;j<E->parallel.nprocz;j++) {
Full_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_obsolete.c:    if (E->parallel.me==rootid)
Full_obsolete.c:      for (d=0;d<E->parallel.nprocz;d++)  {
Full_obsolete.c:        for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Full_obsolete.c:          k1 = k + d*E->lmesh.ELZ[lev];
Full_obsolete.c:          for (j=1;j<=E->lmesh.NOY[lev];j++)
Full_obsolete.c:            for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Full_obsolete.c:              node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Full_obsolete.c:              node1= k1+ (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Full_obsolete.c:           MPI_Send(SD,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],rootid,E->parallel.world);
Full_obsolete.c:           for (i=0;i<E->lmesh.NEQ[lev];i++)
Full_obsolete.c:        MPI_Recv(AUo[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,rootid,E->parallel.world,&status);
Full_obsolete.c: const int dims = E->mesh.nsd;
Full_obsolete.c: if (E->parallel.nprocz==1)  {
Full_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Full_obsolete.c:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Full_obsolete.c:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Full_obsolete.c:   RV = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Full_obsolete.c:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Full_obsolete.c:   for (j=0;j<E->parallel.nprocz;j++) {
Full_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_obsolete.c:    if (E->parallel.me!=rootid)
Full_obsolete.c:       MPI_Send(AUi[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,E->parallel.me,E->parallel.world);
Full_obsolete.c:       for (d=0;d<E->parallel.nprocz;d++) {
Full_obsolete.c:	   MPI_Recv(RV,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],processors[d],E->parallel.world,&status);
Full_obsolete.c:           for (node=0;node<E->lmesh.NEQ[lev];node++)
Full_obsolete.c:         for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Full_obsolete.c:           k1 = k + d*E->lmesh.ELZ[lev];
Full_obsolete.c:           for (j=1;j<=E->lmesh.NOY[lev];j++)
Full_obsolete.c:             for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Full_obsolete.c:               node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Full_obsolete.c:               node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Full_obsolete.c: if (E->parallel.nprocz==1)  {
Full_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Full_obsolete.c:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Full_obsolete.c:   NNO = NOZ*E->lmesh.NOX[lev]*E->lmesh.NOY[lev];
Full_obsolete.c:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Full_obsolete.c:   RV = (float *)malloc((E->lmesh.NNO[lev]+2)*sizeof(float));
Full_obsolete.c:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Full_obsolete.c:   for (j=0;j<E->parallel.nprocz;j++) {
Full_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_obsolete.c:    if (E->parallel.me!=rootid) {
Full_obsolete.c:       MPI_Send(AUi[m],E->lmesh.NNO[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Full_obsolete.c:       for (d=0;d<E->parallel.nprocz;d++) {
Full_obsolete.c:           MPI_Recv(RV,E->lmesh.NNO[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Full_obsolete.c:	   for (node=1;node<=E->lmesh.NNO[lev];node++)
Full_obsolete.c:         for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Full_obsolete.c:           k1 = k + d*E->lmesh.ELZ[lev];
Full_obsolete.c:           for (j=1;j<=E->lmesh.NOY[lev];j++)
Full_obsolete.c:             for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Full_obsolete.c:               node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Full_obsolete.c:               node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Full_obsolete.c: if (E->parallel.nprocz==1)  {
Full_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Full_obsolete.c:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz;
Full_obsolete.c:   NNO = NOZ*E->lmesh.ELX[lev]*E->lmesh.ELY[lev];
Full_obsolete.c:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Full_obsolete.c:   RV = (float *)malloc((E->lmesh.NEL[lev]+2)*sizeof(float));
Full_obsolete.c:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Full_obsolete.c:   for (j=0;j<E->parallel.nprocz;j++) {
Full_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_obsolete.c:    if (E->parallel.me!=rootid) {
Full_obsolete.c:       MPI_Send(AUi[m],E->lmesh.NEL[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Full_obsolete.c:       for (d=0;d<E->parallel.nprocz;d++) {
Full_obsolete.c:           MPI_Recv(RV,E->lmesh.NEL[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Full_obsolete.c:	   for (e=1;e<=E->lmesh.NEL[lev];e++)
Full_obsolete.c:         for (k=1;k<=E->lmesh.ELZ[lev];k++)   {
Full_obsolete.c:           k1 = k + d*E->lmesh.ELZ[lev];
Full_obsolete.c:           for (j=1;j<=E->lmesh.ELY[lev];j++)
Full_obsolete.c:             for (i=1;i<=E->lmesh.ELX[lev];i++)   {
Full_obsolete.c:               e = k + (i-1)*E->lmesh.ELZ[lev] + (j-1)*E->lmesh.ELZ[lev]*E->lmesh.ELX[lev];
Full_obsolete.c:               e1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.ELX[lev];
Full_obsolete.c: if (E->parallel.nprocxy==1)   return;
Full_obsolete.c: nsl = E->sphere.nsf+1;
Full_obsolete.c: me = E->parallel.me;
Full_obsolete.c:   for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Full_obsolete.c:     RG[i] = ( float *)malloc((E->sphere.nsf+1)*sizeof(float));
Full_obsolete.c: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Full_obsolete.c:   to_everyone = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Full_obsolete.c:     MPI_Isend(TG,nsl,MPI_FLOAT,to_everyone,mst,E->parallel.world,&request[idb-1]);
Full_obsolete.c: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Full_obsolete.c:   from_proc = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Full_obsolete.c:      MPI_Irecv(RG[idb],nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&request[idb-1]);
Full_obsolete.c: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Full_obsolete.c:   for (j=1;j<=E->sphere.nsf; j++)  {
Full_obsolete.c: if (E->parallel.nprocz==1)   return;
Full_obsolete.c: jumpp = E->sphere.hindice;
Full_obsolete.c: nsl = E->sphere.hindice*2;
Full_obsolete.c: me = E->parallel.me;
Full_obsolete.c: if (E->parallel.me_loc[3]==dest_proc)
Full_obsolete.c: for (i=0;i<E->sphere.hindice;i++)   {
Full_obsolete.c: if (E->parallel.me_loc[3]!=dest_proc)    {  /* send TG */
Full_obsolete.c:     to_proc = E->parallel.me_sph*E->parallel.nprocz+E->parallel.nprocz-1;
Full_obsolete.c:     MPI_Send(TG,nsl,MPI_FLOAT,to_proc,mst,E->parallel.world);
Full_obsolete.c: if (E->parallel.me_loc[3]==dest_proc)  {
Full_obsolete.c:   for (i=1;i<E->parallel.nprocz;i++) {
Full_obsolete.c:      MPI_Recv(RG,nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&status1);
Full_obsolete.c:      for (j=0;j<E->sphere.hindice;j++)   {
Full_obsolete.c: if (E->parallel.me_loc[3]==dest_proc)
Full_obsolete.c: if (E->parallel.nprocxy==1)   return;
Full_obsolete.c: nsl = E->sphere.hindice*2;
Full_obsolete.c: me = E->parallel.me;
Full_obsolete.c: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Full_obsolete.c: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Full_obsolete.c:   to_everyone = E->parallel.nprocz*(i-1) + loc_proc;
Full_obsolete.c:     MPI_Isend(TG,nsl,MPI_FLOAT,to_everyone,mst,E->parallel.world,&request[idb-1]);
Full_obsolete.c: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Full_obsolete.c:   from_proc = E->parallel.nprocz*(i-1) + loc_proc;
Full_obsolete.c:      MPI_Irecv(RG[idb],nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&request[idb-1]);
Full_obsolete.c: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Full_obsolete.c: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Full_obsolete.c:  i = cases[E->sphere.caps_per_proc];
Full_obsolete.c:  E->parallel.nproc_sph[1] = incases3[i].xy[0];
Full_obsolete.c:  E->parallel.nproc_sph[2] = incases3[i].xy[1];
Full_obsolete.c:  E->sphere.lelx = E->sphere.elx/E->parallel.nproc_sph[1];
Full_obsolete.c:  E->sphere.lely = E->sphere.ely/E->parallel.nproc_sph[2];
Full_obsolete.c:  E->sphere.lsnel = E->sphere.lely*E->sphere.lelx;
Full_obsolete.c:  E->sphere.lnox = E->sphere.lelx + 1;
Full_obsolete.c:  E->sphere.lnoy = E->sphere.lely + 1;
Full_obsolete.c:  E->sphere.lnsf = E->sphere.lnox*E->sphere.lnoy;
Full_obsolete.c:  for (i=0;i<=E->parallel.nprocz-1;i++)
Full_obsolete.c:    if (E->parallel.me_loc[3] == i)    {
Full_obsolete.c:      E->parallel.me_sph = (E->parallel.me-i)/E->parallel.nprocz;
Full_obsolete.c:      E->parallel.me_loc_sph[1] = E->parallel.me_sph%E->parallel.nproc_sph[1];
Full_obsolete.c:      E->parallel.me_loc_sph[2] = E->parallel.me_sph/E->parallel.nproc_sph[1];
Full_obsolete.c:  E->sphere.lexs = E->sphere.lelx * E->parallel.me_loc_sph[1];
Full_obsolete.c:  E->sphere.leys = E->sphere.lely * E->parallel.me_loc_sph[2];
Full_obsolete.c:    record_h = E->control.record_every;
Full_obsolete.c:    if ( (ii == 0) || ((ii % record_h) == 0) || E->control.DIRECTII)    {
Full_obsolete.c:    if ( ((ii == 0) || ((ii % E->control.record_every) == 0))
Full_obsolete.c:	 || E->control.DIRECTII)     {
Full_obsolete.c:  int lev = E->mesh.levmax;
Full_obsolete.c:  const int nno = E->lmesh.nno;
Full_obsolete.c:  const int nsd = E->mesh.nsd;
Full_obsolete.c:/*       ii = E->lmesh.nsf; */
Full_obsolete.c:/*       m = (E->parallel.me_loc[3]==0)?ii:0; */
Full_obsolete.c:      /* size2 = (E->lmesh.nel+1)*sizeof(float); */
Full_obsolete.c:  sprintf(output_file,"%s.coord.%d",E->control.data_file,E->parallel.me);
Full_obsolete.c:     fprintf(E->fp,"(Output.c #1) Cannot open %s\n",output_file);
Full_obsolete.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Full_obsolete.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Full_obsolete.c:    for(i=1;i<=E->lmesh.nno;i++)
Full_obsolete.c:      fprintf(fp1,"%.3e %.3e %.3e\n",E->sx[j][1][i],E->sx[j][2][i],E->sx[j][3][i]);
Full_obsolete.c:  sprintf(output_file,"%s.visc.%d.%d",E->control.data_file,E->parallel.me,file_number);
Full_obsolete.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Full_obsolete.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Full_obsolete.c:    for(i=1;i<=E->lmesh.nno;i++)
Full_obsolete.c:      fprintf(fp1,"%.3e\n",E->VI[lev][j][i]);
Full_obsolete.c:  sprintf(output_file,"%s.velo.%d.%d",E->control.data_file,E->parallel.me,file_number);
Full_obsolete.c:  fprintf(fp1,"%d %d %.5e\n",file_number,E->lmesh.nno,E->monitor.elapsed_time);
Full_obsolete.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Full_obsolete.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Full_obsolete.c:     for(i=1;i<=E->lmesh.nno;i++)
Full_obsolete.c:       fprintf(fp1,"%.6e %.6e %.6e %.6e\n",E->sphere.cap[j].V[1][i],E->sphere.cap[j].V[2][i],E->sphere.cap[j].V[3][i],E->T[j][i]);
Full_obsolete.c:     /* for(i=1;i<=E->lmesh.nno;i++)
Full_obsolete.c:	fprintf(fp1,"%.6e\n",E->T[j][i]); */
Full_obsolete.c:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)      {
Full_obsolete.c:    sprintf(output_file,"%s.surf.%d.%d",E->control.data_file,E->parallel.me,file_number);
Full_obsolete.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Full_obsolete.c:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Full_obsolete.c:      for(i=1;i<=E->lmesh.nsf;i++)   {
Full_obsolete.c:	s = i*E->lmesh.noz;
Full_obsolete.c:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpg[j][i],E->slice.shflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Full_obsolete.c:  if (E->parallel.me_loc[3]==0)      {
Full_obsolete.c:    sprintf(output_file,"%s.botm.%d.%d",E->control.data_file,E->parallel.me,file_number);
Full_obsolete.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Full_obsolete.c:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Full_obsolete.c:      for(i=1;i<=E->lmesh.nsf;i++)  {
Full_obsolete.c:	s = (i-1)*E->lmesh.noz + 1;
Full_obsolete.c:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpgb[j][i],E->slice.bhflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Full_obsolete.c:/*   if (E->parallel.me<E->parallel.nprocz)  { */
Full_obsolete.c:/*     sprintf(output_file,"%s.ave_r.%d.%d",E->control.data_file,E->parallel.me,file_number); */
Full_obsolete.c:/*     for(j=1;j<=E->lmesh.noz;j++)  { */
Full_obsolete.c:/*         fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->sx[1][3][j],E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j]); */
Full_obsolete.c:  size2= (E->lmesh.nno+1)*sizeof(float);
Full_obsolete.c:  sprintf(output_file,"%s.%05d.SZZ",E->control.data_file,file_number);
Full_obsolete.c:  if (E->parallel.me==proc_loc)  {
Full_obsolete.c:     sprintf(output_file,"%s.%s_intp",E->control.data_file,filen);
Full_obsolete.c:     for (i=E->sphere.nox;i>=1;i--)
Full_obsolete.c:     for (j=1;j<=E->sphere.noy;j++)  {
Full_obsolete.c:        node = i + (j-1)*E->sphere.nox;
Full_obsolete.c:        t = 90-E->sphere.sx[1][node]*rad;
Full_obsolete.c:        f = E->sphere.sx[2][node]*rad;
Full_obsolete.c:     fprintf(E->fp,"lmaxx=%.4e lminx=%.4e for %s\n",maxx,minx,filen);
Full_obsolete.c:     sprintf(output_file,"%s.%s_sharm",E->control.data_file,filen);
Full_obsolete.c:     for (ll=0;ll<=E->output.llmax;ll++)
Full_obsolete.c:        i = E->sphere.hindex[ll][mm];
Full_obsolete.c:	    E->trace.Have_C=(double *)malloc((E->lmesh.noz+2)*sizeof(double));
Full_obsolete.c:	    E->trace.Havel_tracers=(double *)malloc((E->lmesh.elz+2)*sizeof(double));
Full_obsolete.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_obsolete.c:	    reltrac[j]=(double *) malloc((E->lmesh.nel+1)*sizeof(double));
Full_obsolete.c:	    for (kk=1;kk<=E->lmesh.nel;kk++)
Full_obsolete.c:		    reltrac[j][kk]=(1.0*E->composition.ieltrac[j][kk]);
Full_obsolete.c:    return_elementwise_horiz_ave(E,reltrac,E->trace.Havel_tracers);
Full_obsolete.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_obsolete.c:    if (E->parallel.me<E->parallel.nprocz)
Full_obsolete.c:	    sprintf(output_file,"%s.ave_tracers.%d.%d",E->control.data_file,E->parallel.me,E->monitor.solution_cycles);
Full_obsolete.c:	    for(kk=1;kk<=E->lmesh.elz;kk++)
Full_obsolete.c:		    halfpoint=0.5*(E->sx[1][3][kk+1]+E->sx[1][3][kk]);
Full_obsolete.c:		    fprintf(fp2,"%.4e %.4e\n",halfpoint,E->trace.Havel_tracers[kk]);
Full_obsolete.c:    if (E->composition.chemical_buoyancy==1)
Full_obsolete.c:	    return_horiz_ave(E,E->composition.comp_node,E->trace.Have_C);
Full_obsolete.c:	    if (E->parallel.me<E->parallel.nprocz)
Full_obsolete.c:		    sprintf(output_file,"%s.ave_c.%d.%d",E->control.data_file,E->parallel.me,E->monitor.solution_cycles);
Full_obsolete.c:		    for(kk=1;kk<=E->lmesh.noz;kk++)
Full_obsolete.c:			    fprintf(fp2,"%.4e %.4e\n",E->sx[1][3][kk],E->trace.Have_C[kk]);
Full_obsolete.c:    fprintf(E->trace.fpt,"ERROR(icheck_regular_neighbors)-this subroutine is no longer used !\n");
Full_obsolete.c:    fflush(E->trace.fpt);
Full_obsolete.c:                    if ( (new_ntheta>0)&&(new_ntheta<=E->trace.numtheta[j])&&(new_nphi>0)&&(new_nphi<=E->trace.numphi[j]) )
Full_obsolete.c:                            iregel=new_ntheta+(new_nphi-1)*E->trace.numtheta[j];
Full_obsolete.c:                            if ((iregel>0) && (iregel<=E->trace.numregel[j]))
Full_obsolete.c:    fprintf(E->trace.fpt,"ERROR(iquick element)-this routine is no longer used!\n");
Full_obsolete.c:    fflush(E->trace.fpt);
Full_obsolete.c:      fprintf(E->trace.fpt,"AA: ichoice: %d\n",ichoice);
Full_obsolete.c:      fflush(E->trace.fpt);
Full_obsolete.c:      iregnode[3]=iregel+nphi+E->trace.numtheta[j]+1;
Full_obsolete.c:      iregnode[4]=iregel+nphi+E->trace.numtheta[j];
Full_obsolete.c:    itemp2=itemp1+E->trace.numtheta[j];
Full_obsolete.c:            if ((iregnode[kk]<1) || (iregnode[kk]>E->trace.numregnodes[j]) )
Full_obsolete.c:                    fprintf(E->trace.fpt,"ERROR(iquick)-weird regnode %d\n",iregnode[kk]);
Full_obsolete.c:                    fflush(E->trace.fpt);
Full_obsolete.c:            if (E->trace.regnodetoel[j][iregnode[kk]]<=0) goto next_corner;
Full_obsolete.c:                    if (E->trace.regnodetoel[j][iregnode[kk]]==E->trace.regnodetoel[j][iregnode[pp]]) goto next_corner;
Full_obsolete.c:            imap[ichoice]=E->trace.regnodetoel[j][iregnode[kk]];
Full_obsolete.c:    E->trace.istat_ichoice[j][ichoice]++;
Full_parallel_related.c:  me = E->parallel.me;
Full_parallel_related.c:  if ( E->parallel.nprocx != E->parallel.nprocy ) {
Full_parallel_related.c:    if (E->parallel.me==0) fprintf(stderr,"!!!! nprocx must equal to nprocy \n");
Full_parallel_related.c:  surf_proc_per_cap = E->parallel.nprocx * E->parallel.nprocy;
Full_parallel_related.c:  proc_per_cap = surf_proc_per_cap * E->parallel.nprocz;
Full_parallel_related.c:  total_proc = E->sphere.caps * proc_per_cap;
Full_parallel_related.c:  E->parallel.total_surf_proc = E->sphere.caps * surf_proc_per_cap;
Full_parallel_related.c:  if ( total_proc != E->parallel.nproc ) {
Full_parallel_related.c:    if (E->parallel.me==0) fprintf(stderr,"!!!! # of requested CPU is incorrect \n");
Full_parallel_related.c:  E->sphere.caps_per_proc = max(1,E->sphere.caps*E->parallel.nprocz/E->parallel.nproc);
Full_parallel_related.c:  if (E->sphere.caps_per_proc > 1) {
Full_parallel_related.c:    if (E->parallel.me==0) fprintf(stderr,"!!!! # caps per proc > 1 is not supported.\n \n");
Full_parallel_related.c:  E->parallel.me_loc[3] = (me - cap_id_surf*proc_per_cap) % E->parallel.nprocz;
Full_parallel_related.c:  E->parallel.me_loc[1] = ((me - cap_id_surf*proc_per_cap - E->parallel.me_loc[3])/E->parallel.nprocz) % E->parallel.nprocx;
Full_parallel_related.c:  E->parallel.me_loc[2] = ((((me - cap_id_surf*proc_per_cap - E->parallel.me_loc[3])/E->parallel.nprocz) - E->parallel.me_loc[1])/E->parallel.nprocx) % E->parallel.nprocy;
Full_parallel_related.c:the second oordinate as fi, which goes E-W. Here we use R-L as the first
Full_parallel_related.c:[xyz] is x=E->parallel.me_loc[1],y=E->parallel.me_loc[2],z=E->parallel.me_loc[3]
Full_parallel_related.c:  i = cases[E->sphere.caps_per_proc]; /* 1 for more than 12 processors */
Full_parallel_related.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Full_parallel_related.c:    temp = pid_surf*E->sphere.caps_per_proc + j-1; /* cap number (out of 12) */
Full_parallel_related.c:    E->sphere.capid[j] = incases1[i].links[temp]; /* id (1~12) of the current cap */
Full_parallel_related.c:     E->sphere.max_connections = 8;
Full_parallel_related.c:  E->parallel.loc2proc_map = (int ****) malloc(E->sphere.caps*sizeof(int ***));
Full_parallel_related.c:  for (m=0;m<E->sphere.caps;m++)  {
Full_parallel_related.c:    E->parallel.loc2proc_map[m] = (int ***) malloc(E->parallel.nprocx*sizeof(int **));
Full_parallel_related.c:    for (i=0;i<E->parallel.nprocx;i++) {
Full_parallel_related.c:      E->parallel.loc2proc_map[m][i] = (int **) malloc(E->parallel.nprocy*sizeof(int *));
Full_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++)
Full_parallel_related.c:	E->parallel.loc2proc_map[m][i][j] = (int *) malloc(E->parallel.nprocz*sizeof(int));
Full_parallel_related.c:  for (m=0;m<E->sphere.caps;m++)
Full_parallel_related.c:    for (i=0;i<E->parallel.nprocx;i++)
Full_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++)
Full_parallel_related.c:	for (k=0;k<E->parallel.nprocz;k++) {
Full_parallel_related.c:	  if (E->sphere.caps_per_proc>1) {
Full_parallel_related.c:	    temp = cases[E->sphere.caps_per_proc];
Full_parallel_related.c:	    E->parallel.loc2proc_map[m][i][j][k] = incases2[temp].links[m-1];
Full_parallel_related.c:	    E->parallel.loc2proc_map[m][i][j][k] = m*proc_per_cap
Full_parallel_related.c:	      + j*E->parallel.nprocx*E->parallel.nprocz
Full_parallel_related.c:	      + i*E->parallel.nprocz + k;
Full_parallel_related.c:  if (E->control.verbose) {
Full_parallel_related.c:    fprintf(E->fp_out,"me=%d loc1=%d loc2=%d loc3=%d\n",me,E->parallel.me_loc[1],E->parallel.me_loc[2],E->parallel.me_loc[3]);
Full_parallel_related.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Full_parallel_related.c:      fprintf(E->fp_out,"capid[%d]=%d \n",j,E->sphere.capid[j]);
Full_parallel_related.c:    for (m=0;m<E->sphere.caps;m++)
Full_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++)
Full_parallel_related.c:	for (i=0;i<E->parallel.nprocx;i++)
Full_parallel_related.c:	  for (k=0;k<E->parallel.nprocz;k++)
Full_parallel_related.c:	    fprintf(E->fp_out,"loc2proc_map[cap=%d][x=%d][y=%d][z=%d] = %d\n",
Full_parallel_related.c:		    m,i,j,k,E->parallel.loc2proc_map[m][i][j][k]);
Full_parallel_related.c:    fflush(E->fp_out);
Full_parallel_related.c:  E->exchange_node_d = exchange_node_d;
Full_parallel_related.c:  E->exchange_node_f = exchange_node_f;
Full_parallel_related.c:  processors = (int *) malloc((E->parallel.total_surf_proc+1)*sizeof(int));
Full_parallel_related.c:  k = E->parallel.me_loc[3];
Full_parallel_related.c:  for (m=0;m<E->sphere.caps;m++)
Full_parallel_related.c:    for (i=0;i<E->parallel.nprocx;i++)
Full_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++) {
Full_parallel_related.c:	processors[n] = E->parallel.loc2proc_map[m][i][j][k];
Full_parallel_related.c:  MPI_Comm_group(E->parallel.world, &world_g);
Full_parallel_related.c:  MPI_Group_incl(world_g, E->parallel.total_surf_proc, processors, &horizon_g);
Full_parallel_related.c:  MPI_Comm_create(E->parallel.world, horizon_g, &(E->parallel.horizontal_comm));
Full_parallel_related.c:  if (E->control.verbose) {
Full_parallel_related.c:    fprintf(E->fp_out,"horizontal group of me=%d loc3=%d\n",E->parallel.me,E->parallel.me_loc[3]);
Full_parallel_related.c:    for (j=0;j<E->parallel.total_surf_proc;j++) {
Full_parallel_related.c:      fprintf(E->fp_out,"%d proc=%d\n",j,processors[j]);
Full_parallel_related.c:    fflush(E->fp_out);
Full_parallel_related.c:  processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Full_parallel_related.c:  m = E->sphere.capid[1] - 1;  /* assume 1 cap per proc. */
Full_parallel_related.c:  i = E->parallel.me_loc[1];
Full_parallel_related.c:  j = E->parallel.me_loc[2];
Full_parallel_related.c:  for (k=0;k<E->parallel.nprocz;k++) {
Full_parallel_related.c:      processors[k] = E->parallel.loc2proc_map[m][i][j][k];
Full_parallel_related.c:  MPI_Comm_group(E->parallel.world, &world_g);
Full_parallel_related.c:  MPI_Group_incl(world_g, E->parallel.nprocz, processors, &vertical_g);
Full_parallel_related.c:  MPI_Comm_create(E->parallel.world, vertical_g, &(E->parallel.vertical_comm));
Full_parallel_related.c:  if (E->control.verbose) {
Full_parallel_related.c:    fprintf(E->fp_out,"vertical group of me=%d loc1=%d loc2=%d\n",E->parallel.me,E->parallel.me_loc[1],E->parallel.me_loc[2]);
Full_parallel_related.c:    for (j=0;j<E->parallel.nprocz;j++) {
Full_parallel_related.c:      fprintf(E->fp_out,"%d proc=%d\n",j,processors[j]);
Full_parallel_related.c:    fflush(E->fp_out);
Full_parallel_related.c:  me = E->parallel.me;
Full_parallel_related.c:  E->lmesh.elx = E->mesh.elx/E->parallel.nprocx;
Full_parallel_related.c:  E->lmesh.elz = E->mesh.elz/E->parallel.nprocz;
Full_parallel_related.c:  E->lmesh.ely = E->mesh.ely/E->parallel.nprocy;
Full_parallel_related.c:  E->lmesh.nox = E->lmesh.elx + 1;
Full_parallel_related.c:  E->lmesh.noz = E->lmesh.elz + 1;
Full_parallel_related.c:  E->lmesh.noy = E->lmesh.ely + 1;
Full_parallel_related.c:  E->lmesh.exs = E->parallel.me_loc[1]*E->lmesh.elx;
Full_parallel_related.c:  E->lmesh.eys = E->parallel.me_loc[2]*E->lmesh.ely;
Full_parallel_related.c:  E->lmesh.ezs = E->parallel.me_loc[3]*E->lmesh.elz;
Full_parallel_related.c:  E->lmesh.nxs = E->parallel.me_loc[1]*E->lmesh.elx+1;
Full_parallel_related.c:  E->lmesh.nys = E->parallel.me_loc[2]*E->lmesh.ely+1;
Full_parallel_related.c:  E->lmesh.nzs = E->parallel.me_loc[3]*E->lmesh.elz+1;
Full_parallel_related.c:  E->lmesh.nno = E->lmesh.noz*E->lmesh.nox*E->lmesh.noy;
Full_parallel_related.c:  E->lmesh.nel = E->lmesh.ely*E->lmesh.elx*E->lmesh.elz;
Full_parallel_related.c:  E->lmesh.npno = E->lmesh.nel;
Full_parallel_related.c:  E->lmesh.nsf = E->lmesh.nno/E->lmesh.noz;
Full_parallel_related.c:  E->lmesh.snel = E->lmesh.elx*E->lmesh.ely;
Full_parallel_related.c:  for(i=E->mesh.levmax;i>=E->mesh.levmin;i--)   {
Full_parallel_related.c:     if (E->control.NMULTIGRID)  {
Full_parallel_related.c:        nox = E->lmesh.elx/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Full_parallel_related.c:        noy = E->lmesh.ely/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Full_parallel_related.c:        noz = E->lmesh.elz/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Full_parallel_related.c:        E->parallel.redundant[i]=0;
Full_parallel_related.c:        { noz = E->lmesh.noz;
Full_parallel_related.c:          noy = E->lmesh.noy;
Full_parallel_related.c:          nox = E->lmesh.nox;
Full_parallel_related.c:     E->lmesh.ELX[i] = nox-1;
Full_parallel_related.c:     E->lmesh.ELY[i] = noy-1;
Full_parallel_related.c:     E->lmesh.ELZ[i] = noz-1;
Full_parallel_related.c:     E->lmesh.NOZ[i] = noz;
Full_parallel_related.c:     E->lmesh.NOY[i] = noy;
Full_parallel_related.c:     E->lmesh.NOX[i] = nox;
Full_parallel_related.c:     E->lmesh.NNO[i] = nox * noz * noy;
Full_parallel_related.c:     E->lmesh.NNOV[i] = E->lmesh.NNO[i];
Full_parallel_related.c:     E->lmesh.SNEL[i] = E->lmesh.ELX[i]*E->lmesh.ELY[i];
Full_parallel_related.c:     E->lmesh.NEL[i] = (nox-1) * (noz-1) * (noy-1);
Full_parallel_related.c:     E->lmesh.NPNO[i] = E->lmesh.NEL[i] ;
Full_parallel_related.c:     E->lmesh.NEQ[i] = E->mesh.nsd * E->lmesh.NNOV[i] ;
Full_parallel_related.c:     E->lmesh.EXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i];
Full_parallel_related.c:     E->lmesh.EYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i];
Full_parallel_related.c:     E->lmesh.EZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i];
Full_parallel_related.c:     E->lmesh.NXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i]+1;
Full_parallel_related.c:     E->lmesh.NYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i]+1;
Full_parallel_related.c:     E->lmesh.NZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i]+1;
Full_parallel_related.c:fprintf(stderr,"b %d %d %d %d %d %d %d\n",E->parallel.me,E->parallel.me_loc[1],E->parallel.me_loc[2],E->parallel.me_loc[3],E->lmesh.nzs,E->lmesh.nys,E->lmesh.noy);
Full_parallel_related.c:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)   {
Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:      nel = E->lmesh.NEL[lev];
Full_parallel_related.c:      elx = E->lmesh.ELX[lev];
Full_parallel_related.c:      elz = E->lmesh.ELZ[lev];
Full_parallel_related.c:      ely = E->lmesh.ELY[lev];
Full_parallel_related.c:      nox = E->lmesh.NOX[lev];
Full_parallel_related.c:      noy = E->lmesh.NOY[lev];
Full_parallel_related.c:      noz = E->lmesh.NOZ[lev];
Full_parallel_related.c:      nno = E->lmesh.NNO[lev];
Full_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] =  node;
Full_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Full_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Full_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] =  node;
Full_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Full_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Full_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Full_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Full_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Full_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Full_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Full_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Full_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Full_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Full_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Full_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Full_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Full_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Full_parallel_related.c:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[2];lnode++) {
Full_parallel_related.c:          node = E->parallel.NODE[lev][m][lnode].bound[2];
Full_parallel_related.c:          E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Full_parallel_related.c:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[3];lnode++) {
Full_parallel_related.c:          node = E->parallel.NODE[lev][m][lnode].bound[3];
Full_parallel_related.c:          E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Full_parallel_related.c:      if (E->sphere.capid[m] == 1 &&
Full_parallel_related.c:          E->parallel.me_loc[1] == 0 &&
Full_parallel_related.c:          E->parallel.me_loc[2] == 0)
Full_parallel_related.c:              E->NODE[lev][m][node] = E->NODE[lev][m][node] & ~SKIP;
Full_parallel_related.c:      if (E->sphere.capid[m] == E->sphere.caps &&
Full_parallel_related.c:          E->parallel.me_loc[1] == E->parallel.nprocx-1 &&
Full_parallel_related.c:          E->parallel.me_loc[2] == E->parallel.nprocy-1)
Full_parallel_related.c:              E->NODE[lev][m][node] = E->NODE[lev][m][node] & ~SKIP;
Full_parallel_related.c:      if (E->parallel.me_loc[3]!=E->parallel.nprocz-1 )
Full_parallel_related.c:          for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[6];lnode++) {
Full_parallel_related.c:              node = E->parallel.NODE[lev][m][lnode].bound[6];
Full_parallel_related.c:              E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Full_parallel_related.c:if (E->control.verbose) {
Full_parallel_related.c: fprintf(E->fp_out,"output_shared_nodes %d \n",E->parallel.me);
Full_parallel_related.c: for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Full_parallel_related.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)      {
Full_parallel_related.c:    fprintf(E->fp_out,"lev=%d  me=%d capid=%d m=%d \n",lev,E->parallel.me,E->sphere.capid[m],m);
Full_parallel_related.c:      for (i=1;i<=E->parallel.NUM_NNO[lev][m].bound[ii];i++)
Full_parallel_related.c:        fprintf(E->fp_out,"ii=%d   %d %d \n",ii,i,E->parallel.NODE[lev][m][i].bound[ii]);
Full_parallel_related.c:    for (node=1;node<=E->lmesh.NNO[lev];node++)
Full_parallel_related.c:      if((E->NODE[lev][m][node] & SKIP)) {
Full_parallel_related.c:        fprintf(E->fp_out,"skip %d %d \n",lnode,node);
Full_parallel_related.c: fflush(E->fp_out);
Full_parallel_related.c:  const int dims=E->mesh.nsd;
Full_parallel_related.c:  me = E->parallel.me;
Full_parallel_related.c:  nprocx = E->parallel.nprocx;
Full_parallel_related.c:  nprocy = E->parallel.nprocy;
Full_parallel_related.c:  nprocz = E->parallel.nprocz;
Full_parallel_related.c:  tscaps = E->parallel.total_surf_proc;
Full_parallel_related.c:  lx = E->parallel.me_loc[1];
Full_parallel_related.c:  ly = E->parallel.me_loc[2];
Full_parallel_related.c:  lz = E->parallel.me_loc[3];
Full_parallel_related.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Full_parallel_related.c:    nox = E->lmesh.NOX[lev];
Full_parallel_related.c:    noz = E->lmesh.NOZ[lev];
Full_parallel_related.c:    noy = E->lmesh.NOY[lev];
Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:      cap = E->sphere.capid[m] - 1;  /* which cap I am in (0~11) */
Full_parallel_related.c:	target = E->parallel.loc2proc_map[cap][lx-1][ly][lz];
Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][nprocx-1][ly][lz];
Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][ly][0][lz];
Full_parallel_related.c:      E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:	target = E->parallel.loc2proc_map[cap][lx+1][ly][lz];
Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][0][ly][lz];
Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][ly][nprocy-1][lz];
Full_parallel_related.c:      E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:	target = E->parallel.loc2proc_map[cap][lx][ly-1][lz];
Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][lx][nprocy-1][lz];
Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][0][lx][lz];
Full_parallel_related.c:      E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:	target = E->parallel.loc2proc_map[cap][lx][ly+1][lz];
Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][lx][0][lz];
Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][nprocx-1][lx][lz];
Full_parallel_related.c:      E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:	    target = E->parallel.loc2proc_map[temp][lx][ly][lz];
Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[1] - nprocz;
Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[3] - nprocxz;
Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[1] - nprocxz;
Full_parallel_related.c:	  E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:	    target = E->parallel.loc2proc_map[temp][lx][ly][lz];
Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[2] + nprocz;
Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[4] + nprocxz;
Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[2] + nprocxz;
Full_parallel_related.c:	  E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[4] - nprocxz;
Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[1] + nprocz;
Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[1] + nprocxz;
Full_parallel_related.c:	  E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[2] - nprocz;
Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[3] + nprocxz;
Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[2] - nprocxz;
Full_parallel_related.c:	  E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Full_parallel_related.c:      E->parallel.TNUM_PASS[lev][m] = npass;
Full_parallel_related.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Full_parallel_related.c:      E->parallel.NUM_PASSz[lev].bound[ii] = 1;
Full_parallel_related.c:	E->parallel.NUM_PASSz[lev].bound[ii] = 0;
Full_parallel_related.c:	E->parallel.NUM_PASSz[lev].bound[ii] = 0;
Full_parallel_related.c:      for (p=1;p<=E->parallel.NUM_PASSz[lev].bound[ii];p++)  {
Full_parallel_related.c:	kkkp = kkk + E->sphere.max_connections;
Full_parallel_related.c:	E->parallel.NUM_NODEz[lev].pass[kkk] = 0;
Full_parallel_related.c:	E->parallel.NUM_NEQz[lev].pass[kkk] = 0;
Full_parallel_related.c:	for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:	  cap = E->sphere.capid[m] - 1;  /* which cap I am in (0~11) */
Full_parallel_related.c:	  E->parallel.PROCESSORz[lev].pass[kkk] =
Full_parallel_related.c:	    E->parallel.loc2proc_map[cap][lx][ly][lz+((ii==5)?-1:1)];
Full_parallel_related.c:	  for (k=1;k<=E->parallel.NUM_NNO[lev][m].bound[ii];k++)   {
Full_parallel_related.c:	    node = E->parallel.NODE[lev][m][k].bound[ii];
Full_parallel_related.c:	    E->parallel.EXCHANGE_NODE[lev][m][++kk].pass[kkkp] = node;
Full_parallel_related.c:	      E->parallel.EXCHANGE_ID[lev][m][++jj].pass[kkkp] =
Full_parallel_related.c:		E->ID[lev][m][node].doff[doff];
Full_parallel_related.c:	  E->parallel.NUM_NODE[lev][m].pass[kkkp] = kk;
Full_parallel_related.c:	  E->parallel.NUM_NEQ[lev][m].pass[kkkp] = jj;
Full_parallel_related.c:	  E->parallel.NUM_NODEz[lev].pass[kkk] += kk;
Full_parallel_related.c:	  E->parallel.NUM_NEQz[lev].pass[kkk] += jj;
Full_parallel_related.c:    E->parallel.TNUM_PASSz[lev] = kkk;
Full_parallel_related.c:  if(E->control.verbose) {
Full_parallel_related.c:    for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Full_parallel_related.c:      fprintf(E->fp_out,"output_communication route surface for lev=%d \n",lev);
Full_parallel_related.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Full_parallel_related.c:	fprintf(E->fp_out,"  me= %d cap=%d pass  %d \n",E->parallel.me,E->sphere.capid[m],E->parallel.TNUM_PASS[lev][m]);
Full_parallel_related.c:	for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:	  fprintf(E->fp_out,"proc %d and pass  %d to proc %d with %d eqn and %d node\n",E->parallel.me,k,E->parallel.PROCESSOR[lev][m].pass[k],E->parallel.NUM_NEQ[lev][m].pass[k],E->parallel.NUM_NODE[lev][m].pass[k]);
Full_parallel_related.c:	  fprintf(E->fp_out,"Eqn:\n");  
Full_parallel_related.c:	  for (ii=1;ii<=E->parallel.NUM_NEQ[lev][m].pass[k];ii++)  
Full_parallel_related.c:	    fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_ID[lev][m][ii].pass[k]);  
Full_parallel_related.c:	  fprintf(E->fp_out,"Node:\n");  
Full_parallel_related.c:	  for (ii=1;ii<=E->parallel.NUM_NODE[lev][m].pass[k];ii++)  
Full_parallel_related.c:	    fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_NODE[lev][m][ii].pass[k]);  
Full_parallel_related.c:      fprintf(E->fp_out,"output_communication route vertical \n");
Full_parallel_related.c:      fprintf(E->fp_out," me= %d pass  %d \n",E->parallel.me,E->parallel.TNUM_PASSz[lev]);
Full_parallel_related.c:      for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)   {
Full_parallel_related.c:	kkkp = k + E->sphere.max_connections;
Full_parallel_related.c:	fprintf(E->fp_out,"proc %d and pass  %d to proc %d\n",E->parallel.me,k,E->parallel.PROCESSORz[lev].pass[k]);
Full_parallel_related.c:	for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Full_parallel_related.c:	  fprintf(E->fp_out,"cap=%d eqn=%d node=%d\n",E->sphere.capid[m],E->parallel.NUM_NEQ[lev][m].pass[kkkp],E->parallel.NUM_NODE[lev][m].pass[kkkp]);
Full_parallel_related.c:	  for (ii=1;ii<=E->parallel.NUM_NEQ[lev][m].pass[kkkp];ii++) 
Full_parallel_related.c:	    fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_ID[lev][m][ii].pass[kkkp]); 
Full_parallel_related.c:	  for (ii=1;ii<=E->parallel.NUM_NODE[lev][m].pass[kkkp];ii++) 
Full_parallel_related.c:	    fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_NODE[lev][m][ii].pass[kkkp]); 
Full_parallel_related.c:    fflush(E->fp_out);
Full_parallel_related.c:  const int dims=E->mesh.nsd;
Full_parallel_related.c:  me = E->parallel.me;
Full_parallel_related.c:  nprocz = E->parallel.nprocz;
Full_parallel_related.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Full_parallel_related.c:    nox = E->lmesh.NOX[lev];
Full_parallel_related.c:    noz = E->lmesh.NOZ[lev];
Full_parallel_related.c:    noy = E->lmesh.NOY[lev];
Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:      j = E->sphere.capid[m];
Full_parallel_related.c:      for (kkk=1;kkk<=E->parallel.TNUM_PASS[lev][m];kkk++) {
Full_parallel_related.c:          E->parallel.NUM_sNODE[lev][m].pass[kkk] =
Full_parallel_related.c:                           E->parallel.NUM_NNO[lev][m].bound[ii]/noz;
Full_parallel_related.c:          for (k=1;k<=E->parallel.NUM_sNODE[lev][m].pass[kkk];k++)   {
Full_parallel_related.c:            node = (E->parallel.NODE[lev][m][lnode].bound[ii]-1)/noz + 1;
Full_parallel_related.c:            E->parallel.EXCHANGE_sNODE[lev][m][k].pass[kkk] = node;
Full_parallel_related.c:          E->parallel.NUM_sNODE[lev][m].pass[kkk]=1;
Full_parallel_related.c:          for (k=1;k<=E->parallel.NUM_sNODE[lev][m].pass[kkk];k++)   {
Full_parallel_related.c:            node = E->parallel.EXCHANGE_NODE[lev][m][k].pass[kkk]/noz + 1;
Full_parallel_related.c:            E->parallel.EXCHANGE_sNODE[lev][m][k].pass[kkk] = node;
Full_parallel_related.c:  if(E->control.verbose) {
Full_parallel_related.c:    for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Full_parallel_related.c:      fprintf(E->fp_out,"output_communication route surface for lev=%d \n",lev);
Full_parallel_related.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Full_parallel_related.c:	fprintf(E->fp_out,"  me= %d cap=%d pass  %d \n",E->parallel.me,E->sphere.capid[m],E->parallel.TNUM_PASS[lev][m]);
Full_parallel_related.c:	for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++) {
Full_parallel_related.c:	  fprintf(E->fp_out,"proc %d and pass  %d to proc %d with %d node\n",E->parallel.me,k,E->parallel.PROCESSOR[lev][m].pass[k],E->parallel.NUM_sNODE[lev][m].pass[k]);
Full_parallel_related.c:	  fprintf(E->fp_out,"Node:\n");
Full_parallel_related.c:	  for (ii=1;ii<=E->parallel.NUM_sNODE[lev][m].pass[k];ii++)
Full_parallel_related.c:	    fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_sNODE[lev][m][ii].pass[k]);
Full_parallel_related.c:    fflush(E->fp_out);
Full_parallel_related.c:  const int dims=E->mesh.nsd;
Full_parallel_related.c:  E->parallel.NUM_NODE[lev][m].pass[npass] = E->parallel.NUM_NNO[lev][m].bound[bd];
Full_parallel_related.c:  for (kk=1;kk<=E->parallel.NUM_NODE[lev][m].pass[npass];kk++)   {
Full_parallel_related.c:    node = E->parallel.NODE[lev][m][kk].bound[bd];
Full_parallel_related.c:    E->parallel.EXCHANGE_NODE[lev][m][kk].pass[npass] = node;
Full_parallel_related.c:      E->parallel.EXCHANGE_ID[lev][m][++jj].pass[npass] = E->ID[lev][m][node].doff[doff];
Full_parallel_related.c:  E->parallel.NUM_NEQ[lev][m].pass[npass] = jj;
Full_parallel_related.c:  const int dims=E->mesh.nsd;
Full_parallel_related.c:  E->parallel.NUM_NODE[lev][m].pass[npass] = num_node;
Full_parallel_related.c:  for (kk=1;kk<=E->parallel.NUM_NODE[lev][m].pass[npass];kk++)   {
Full_parallel_related.c:    E->parallel.EXCHANGE_NODE[lev][m][kk].pass[npass] = node;
Full_parallel_related.c:      E->parallel.EXCHANGE_ID[lev][m][++jj].pass[npass] = E->ID[lev][m][node].doff[doff];
Full_parallel_related.c:  E->parallel.NUM_NEQ[lev][m].pass[npass] = jj;
Full_parallel_related.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:     for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Full_parallel_related.c:       sizeofk = (1+E->parallel.NUM_NEQ[lev][m].pass[k])*sizeof(double);
Full_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Full_parallel_related.c:     sizeofk = (1+E->parallel.NUM_NEQ[lev][m].pass[k])*sizeof(double);
Full_parallel_related.c: for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:   kk = (1+E->parallel.NUM_NEQz[lev].pass[k])*sizeof(double);
Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)     {
Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[k];j++) {
Full_parallel_related.c:        S[k][j-1] = U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[k] ];
Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k] != E->parallel.me &&
Full_parallel_related.c:	  E->parallel.PROCESSOR[lev][m].pass[k] != -1) {
Full_parallel_related.c:          MPI_Isend(S[k], E->parallel.NUM_NEQ[lev][m].pass[k], MPI_DOUBLE,
Full_parallel_related.c:		    E->parallel.PROCESSOR[lev][m].pass[k], 1,
Full_parallel_related.c:		    E->parallel.world, &request[idb-1]);
Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k] != E->parallel.me &&
Full_parallel_related.c:	  E->parallel.PROCESSOR[lev][m].pass[k] != -1) {
Full_parallel_related.c:	 MPI_Irecv(R[k],E->parallel.NUM_NEQ[lev][m].pass[k], MPI_DOUBLE,
Full_parallel_related.c:		   E->parallel.PROCESSOR[lev][m].pass[k], 1,
Full_parallel_related.c:		   E->parallel.world, &request[idb-1]);
Full_parallel_related.c:	for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[k];j++)
Full_parallel_related.c:           U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[k] ] += S[k][j-1];
Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k] != E->parallel.me &&
Full_parallel_related.c:	  E->parallel.PROCESSOR[lev][m].pass[k] != -1) {
Full_parallel_related.c:	for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[k];j++)
Full_parallel_related.c:	  U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[k] ] += R[k][j-1];
Full_parallel_related.c:  for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:    kk = k + E->sphere.max_connections;
Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[kk];j++)
Full_parallel_related.c:        SV[jj++] = U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[kk] ];
Full_parallel_related.c:    MPI_Sendrecv(SV, E->parallel.NUM_NEQz[lev].pass[k], MPI_DOUBLE,
Full_parallel_related.c:		 E->parallel.PROCESSORz[lev].pass[k], 1,
Full_parallel_related.c:                 RV, E->parallel.NUM_NEQz[lev].pass[k], MPI_DOUBLE,
Full_parallel_related.c:		 E->parallel.PROCESSORz[lev].pass[k], 1,
Full_parallel_related.c:		 E->parallel.world, &status1);
Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[kk];j++)
Full_parallel_related.c:        U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[kk] ] += RV[jj++];
Full_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Full_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Full_parallel_related.c:     sizeofk = (1+E->parallel.NUM_NODE[lev][m].pass[k])*sizeof(double);
Full_parallel_related.c: for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:   sizeofk = (1+E->parallel.NUM_NODEz[lev].pass[k])*sizeof(double);
Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)     {
Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Full_parallel_related.c:        S[kk][j-1] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ];
Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me) {
Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:        MPI_Isend(S[kk],E->parallel.NUM_NODE[lev][m].pass[k],MPI_DOUBLE,
Full_parallel_related.c:             E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)  {
Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:         MPI_Irecv(R[kk],E->parallel.NUM_NODE[lev][m].pass[k],MPI_DOUBLE,
Full_parallel_related.c:         E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Full_parallel_related.c:         for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Full_parallel_related.c:           U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += S[kk][j-1];
Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)
Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:        for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Full_parallel_related.c:           U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += R[kk][j-1];
Full_parallel_related.c:  for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:    kk = k + E->sphere.max_connections;
Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[kk];j++)
Full_parallel_related.c:        SV[jj++] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[kk] ];
Full_parallel_related.c:    MPI_Sendrecv(SV,E->parallel.NUM_NODEz[lev].pass[k],MPI_DOUBLE,
Full_parallel_related.c:             E->parallel.PROCESSORz[lev].pass[k],1,
Full_parallel_related.c:                 RV,E->parallel.NUM_NODEz[lev].pass[k],MPI_DOUBLE,
Full_parallel_related.c:             E->parallel.PROCESSORz[lev].pass[k],1,E->parallel.world,&status1);
Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[kk];j++)
Full_parallel_related.c:        U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[kk] ] += RV[jj++];
Full_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Full_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Full_parallel_related.c:     sizeofk = (1+E->parallel.NUM_NODE[lev][m].pass[k])*sizeof(float);
Full_parallel_related.c: for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:   sizeofk = (1+E->parallel.NUM_NODEz[lev].pass[k])*sizeof(float);
Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)     {
Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Full_parallel_related.c:        S[kk][j-1] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ];
Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me) {
Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:        MPI_Isend(S[kk],E->parallel.NUM_NODE[lev][m].pass[k],MPI_FLOAT,
Full_parallel_related.c:             E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)  {
Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:         MPI_Irecv(R[kk],E->parallel.NUM_NODE[lev][m].pass[k],MPI_FLOAT,
Full_parallel_related.c:         E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Full_parallel_related.c:         for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Full_parallel_related.c:           U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += S[kk][j-1];
Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)
Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:        for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Full_parallel_related.c:           U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += R[kk][j-1];
Full_parallel_related.c:  for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Full_parallel_related.c:    kk = k + E->sphere.max_connections;
Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[kk];j++)
Full_parallel_related.c:        SV[jj++] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[kk] ];
Full_parallel_related.c:    MPI_Sendrecv(SV,E->parallel.NUM_NODEz[lev].pass[k],MPI_FLOAT,
Full_parallel_related.c:             E->parallel.PROCESSORz[lev].pass[k],1,
Full_parallel_related.c:                 RV,E->parallel.NUM_NODEz[lev].pass[k],MPI_FLOAT,
Full_parallel_related.c:             E->parallel.PROCESSORz[lev].pass[k],1,E->parallel.world,&status1);
Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[kk];j++)
Full_parallel_related.c:        U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[kk] ] += RV[jj++];
Full_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Full_parallel_related.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:     for (k=1;k<=E->parallel.TNUM_PASS[E->mesh.levmax][m];k++)  {
Full_parallel_related.c:       sizeofk = (1+2*E->parallel.NUM_sNODE[E->mesh.levmax][m].pass[k])*sizeof(float);
Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)     {
Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_sNODE[lev][m].pass[k];j++)  {
Full_parallel_related.c:        S[kk][j-1] = U1[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ];
Full_parallel_related.c:        S[kk][j-1+E->parallel.NUM_sNODE[lev][m].pass[k]]
Full_parallel_related.c:                   = U2[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ];
Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me) {
Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:         MPI_Isend(S[kk],2*E->parallel.NUM_sNODE[lev][m].pass[k],MPI_FLOAT,
Full_parallel_related.c:             E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)  {
Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:         MPI_Irecv(R[kk],2*E->parallel.NUM_sNODE[lev][m].pass[k],MPI_FLOAT,
Full_parallel_related.c:           E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Full_parallel_related.c:         for (j=1;j<=E->parallel.NUM_sNODE[lev][m].pass[k];j++)     {
Full_parallel_related.c:           U1[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] += S[kk][j-1];
Full_parallel_related.c:           U2[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] +=
Full_parallel_related.c:                               S[kk][j-1+E->parallel.NUM_sNODE[lev][m].pass[k]];
Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)
Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Full_parallel_related.c:        for (j=1;j<=E->parallel.NUM_sNODE[lev][m].pass[k];j++)    {
Full_parallel_related.c:           U1[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] += R[kk][j-1];
Full_parallel_related.c:           U2[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] +=
Full_parallel_related.c:                              R[kk][j-1+E->parallel.NUM_sNODE[lev][m].pass[k]];
Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[E->mesh.levmax][m];k++)  {
Full_parallel_related.c:   idb = 2*E->sphere.hindice;
Full_parallel_related.c:  if (E->parallel.me_loc[3] == 0)  {
Full_parallel_related.c:    for (p=0;p<E->sphere.hindice;p++)  {
Full_parallel_related.c:      SV[p+E->sphere.hindice] = sphs1[p];
Full_parallel_related.c:    target_proc= E->parallel.me + E->parallel.nprocz-1;
Full_parallel_related.c:  else if (E->parallel.me_loc[3] == E->parallel.nprocz-1)  {
Full_parallel_related.c:    for (p=0;p<E->sphere.hindice;p++)  {
Full_parallel_related.c:      SV[p+E->sphere.hindice] = sphs0[p];
Full_parallel_related.c:    target_proc = E->parallel.me - E->parallel.nprocz+1;
Full_parallel_related.c:  if (E->parallel.me_loc[3] == 0)  {
Full_parallel_related.c:    for (p=0;p<E->sphere.hindice;p++)  {
Full_parallel_related.c:      sphs0[p] = RV[p+E->sphere.hindice];
Full_parallel_related.c:  else if (E->parallel.me_loc[3] == E->parallel.nprocz-1)  {
Full_parallel_related.c:    for (p=0;p<E->sphere.hindice;p++)  {
Full_parallel_related.c:      sphs1[p] = RV[p+E->sphere.hindice];
Full_read_input_from_files.c:    const int dims=E->mesh.nsd;
Full_read_input_from_files.c:    nox=E->mesh.nox;
Full_read_input_from_files.c:    noy=E->mesh.noy;
Full_read_input_from_files.c:    noz=E->mesh.noz;
Full_read_input_from_files.c:    nox1=E->lmesh.nox;
Full_read_input_from_files.c:    noz1=E->lmesh.noz;
Full_read_input_from_files.c:    noy1=E->lmesh.noy;
Full_read_input_from_files.c:    elx=E->lmesh.elx;
Full_read_input_from_files.c:    elz=E->lmesh.elz;
Full_read_input_from_files.c:    ely=E->lmesh.ely;
Full_read_input_from_files.c:    emax=E->mesh.elx*E->mesh.elz*E->mesh.ely;
Full_read_input_from_files.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Full_read_input_from_files.c:      cap = E->sphere.capid[m] - 1;  /* capid: 1-12 */
Full_read_input_from_files.c:	if(!E->control.ggrd.vtop_control){
Full_read_input_from_files.c:	sprintf(output_file1,"%s%0.0f.%d",E->control.velocity_boundary_file,newage1,cap);
Full_read_input_from_files.c:	sprintf(output_file2,"%s%0.0f.%d",E->control.velocity_boundary_file,newage2,cap);
Full_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #4) Cannot open %s\n",output_file1);
Full_read_input_from_files.c:	    fprintf(E->fp,"(Problem_related #5) Cannot open %s\n",output_file2);
Full_read_input_from_files.c:	if((E->parallel.me==0) && (output==1))   {
Full_read_input_from_files.c:	  fprintf(E->fp,"Velocity: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Full_read_input_from_files.c:	  fprintf(E->fp,"Velocity: File1 = %s\n",output_file1);
Full_read_input_from_files.c:	    fprintf(E->fp,"Velocity: File2 = %s\n",output_file2);
Full_read_input_from_files.c:	    fprintf(E->fp,"Velocity: File2 = No file inputted (negative age)\n");
Full_read_input_from_files.c:	if(!E->control.ggrd.age_control){
Full_read_input_from_files.c:	sprintf(output_file1,"%s%0.0f.%d",E->control.lith_age_file,newage1,cap);
Full_read_input_from_files.c:	sprintf(output_file2,"%s%0.0f.%d",E->control.lith_age_file,newage2,cap);
Full_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #6) Cannot open %s\n",output_file1);
Full_read_input_from_files.c:	    fprintf(E->fp,"(Problem_related #7) Cannot open %s\n",output_file2);
Full_read_input_from_files.c:	if((E->parallel.me==0) && (output==1))   {
Full_read_input_from_files.c:	  fprintf(E->fp,"Age: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Full_read_input_from_files.c:	  fprintf(E->fp,"Age: File1 = %s\n",output_file1);
Full_read_input_from_files.c:	    fprintf(E->fp,"Age: File2 = %s\n",output_file2);
Full_read_input_from_files.c:	    fprintf(E->fp,"Age: File2 = No file inputted (negative age)\n");
Full_read_input_from_files.c:	if(!E->control.ggrd.mat_control){
Full_read_input_from_files.c:	sprintf(output_file1,"%s%0.0f.%d",E->control.mat_file,newage1,cap);
Full_read_input_from_files.c:	sprintf(output_file2,"%s%0.0f.%d",E->control.mat_file,newage2,cap);
Full_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #8) Cannot open %s\n",output_file1);
Full_read_input_from_files.c:	    fprintf(E->fp,"(Problem_related #9) Cannot open %s\n",output_file2);
Full_read_input_from_files.c:	if((E->parallel.me==0) && (output==1))   {
Full_read_input_from_files.c:	  fprintf(E->fp,"Mat: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Full_read_input_from_files.c:	  fprintf(E->fp,"Mat: File1 = %s\n",output_file1);
Full_read_input_from_files.c:	    fprintf(E->fp,"Mat: File2 = %s\n",output_file2);
Full_read_input_from_files.c:	    fprintf(E->fp,"Mat: File2 = No file inputted (negative age)\n");
Full_read_input_from_files.c:	sprintf(output_file1,"%s%0.0f.%d",E->control.temperature_boundary_file,newage1,cap);
Full_read_input_from_files.c:	sprintf(output_file2,"%s%0.0f.%d",E->control.temperature_boundary_file,newage2,cap);
Full_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #10) Cannot open %s\n",output_file1);
Full_read_input_from_files.c:	    fprintf(E->fp,"(Problem_related #11) Cannot open %s\n",output_file2);
Full_read_input_from_files.c:	if((E->parallel.me==0) && (output==1))   {
Full_read_input_from_files.c:	  fprintf(E->fp,"Surface Temperature: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Full_read_input_from_files.c:	  fprintf(E->fp,"Surface Temperature: File1 = %s\n",output_file1);
Full_read_input_from_files.c:	    fprintf(E->fp,"Surface Temperature: File2 = %s\n",output_file2);
Full_read_input_from_files.c:	    fprintf(E->fp,"Velocity: File2 = No file inputted (negative age)\n");
Full_read_input_from_files.c:	if(E->control.ggrd.vtop_control){
Full_read_input_from_files.c:	  VB1[1][i] *= E->data.timedir;
Full_read_input_from_files.c:	  VB1[2][i] *= E->data.timedir;
Full_read_input_from_files.c:	    VB2[1][i] *= E->data.timedir;
Full_read_input_from_files.c:	    VB2[2][i] *= E->data.timedir;
Full_read_input_from_files.c:	  /* if( E->parallel.me ==0)
Full_read_input_from_files.c:	if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Full_read_input_from_files.c:	      nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Full_read_input_from_files.c:		E->sphere.cap[m].VB[1][nodel] = (VB1[1][nodeg] + (VB2[1][nodeg]-VB1[1][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Full_read_input_from_files.c:		E->sphere.cap[m].VB[2][nodel] = (VB1[2][nodeg] + (VB2[2][nodeg]-VB1[2][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Full_read_input_from_files.c:		E->sphere.cap[m].VB[3][nodel] = 0.0;
Full_read_input_from_files.c:		E->sphere.cap[m].VB[1][nodel] = VB1[1][nodeg] * E->data.scalev;
Full_read_input_from_files.c:		E->sphere.cap[m].VB[2][nodel] = VB1[2][nodeg] * E->data.scalev;
Full_read_input_from_files.c:		E->sphere.cap[m].VB[3][nodel] = 0.0;
Full_read_input_from_files.c:	}   /* end of E->parallel.me_loc[3]==E->parallel.nproczl-1   */
Full_read_input_from_files.c:	if(E->control.ggrd.age_control){
Full_read_input_from_files.c:              E->age_t[node] = (inputage1 + (inputage2-inputage1)/(newage2-newage1)*(age-newage1))/E->data.scalet;
Full_read_input_from_files.c:              E->age_t[node] = inputage1;
Full_read_input_from_files.c:	if(E->control.ggrd.mat_control){ /* use netcdf grids */
Full_read_input_from_files.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Full_read_input_from_files.c:            nodea = E->ien[m][el].node[2];
Full_read_input_from_files.c:              E->mat[m][el] = llayer;
Full_read_input_from_files.c:          for (m=1;m<=E->sphere.caps_per_proc;m++) {
Full_read_input_from_files.c:                  el = j + (i-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Full_read_input_from_files.c:                  elg = E->lmesh.ezs+j + (E->lmesh.exs+i-1)*E->mesh.elz + (E->lmesh.eys+k-1)*E->mesh.elz*E->mesh.elx;
Full_read_input_from_files.c:                  E->VIP[m][el] = VIP1[elg]+(VIP2[elg]-VIP1[elg])/(newage2-newage1)*(age-newage1);
Full_read_input_from_files.c:                  /* E->mat[m][el] = LL1[elg]; */ /*get material numbers from radius internally */
Full_read_input_from_files.c:	if(E->control.ggrd.ray_control)
Full_read_input_from_files.c:	if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Full_read_input_from_files.c:	      nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Full_read_input_from_files.c:		E->sphere.cap[m].TB[1][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Full_read_input_from_files.c:		E->sphere.cap[m].TB[2][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Full_read_input_from_files.c:		E->sphere.cap[m].TB[3][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Full_read_input_from_files.c:		E->sphere.cap[m].TB[1][nodel] = TB1[nodeg];
Full_read_input_from_files.c:		E->sphere.cap[m].TB[2][nodel] = TB1[nodeg];
Full_read_input_from_files.c:		E->sphere.cap[m].TB[3][nodel] = TB1[nodeg];
Full_read_input_from_files.c:	}   /* end of E->parallel.me_loc[3]==E->parallel.nproczl-1   */
Full_read_input_from_files.c:    fflush(E->fp);
Full_solver.c:    E->solver.velocity_boundary_conditions = full_velocity_boundary_conditions;
Full_solver.c:    E->solver.temperature_boundary_conditions = full_temperature_boundary_conditions;
Full_solver.c:    E->solver.set_2dc_defaults = full_set_2dc_defaults;
Full_solver.c:    E->solver.set_2pt5dc_defaults = full_set_2pt5dc_defaults;
Full_solver.c:    E->solver.set_3dc_defaults = full_set_3dc_defaults;
Full_solver.c:    E->solver.set_3dsphere_defaults = full_set_3dsphere_defaults;
Full_solver.c:    E->solver.lith_age_read_files = full_lith_age_read_files;
Full_solver.c:    E->solver.parallel_processor_setup = full_parallel_processor_setup;
Full_solver.c:    E->solver.parallel_domain_decomp0 = full_parallel_domain_decomp0;
Full_solver.c:    E->solver.parallel_domain_boundary_nodes = full_parallel_domain_boundary_nodes;
Full_solver.c:    E->solver.parallel_communication_routs_v = full_parallel_communication_routs_v;
Full_solver.c:    E->solver.parallel_communication_routs_s = full_parallel_communication_routs_s;
Full_solver.c:    E->solver.exchange_id_d = full_exchange_id_d;
Full_solver.c:    E->solver.read_input_files_for_timesteps = full_read_input_files_for_timesteps;
Full_solver.c:    E->solver.node_locations = full_node_locations;
Full_solver.c:    E->solver.construct_boundary = full_construct_boundary;
Full_sphere_related.c:  temp = max(E->mesh.noy, E->mesh.nox);
Full_sphere_related.c:  temp = E->mesh.noy * E->mesh.nox;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[1] = 0.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[2] = M_PI/4.0+offset;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[3] = M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[4] = M_PI/4.0+offset;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[1] = 0.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[2] = (i-1)*M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[3] = (i-1)*M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[4] = i*M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[1] = M_PI/4.0+offset;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[2] = M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[3] = 3*M_PI/4.0-offset;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[4] = M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[1] = i*M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[2] = i*M_PI/2.0 - M_PI/4.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[3] = i*M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[4] = i*M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:    E->sphere.cap[j].theta[1] = M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[j].theta[2] = 3*M_PI/4.0-offset;
Full_sphere_related.c:    E->sphere.cap[j].theta[3] = M_PI;
Full_sphere_related.c:    E->sphere.cap[j].theta[4] = 3*M_PI/4.0-offset;
Full_sphere_related.c:    E->sphere.cap[j].fi[1] = (i-1)*M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:    E->sphere.cap[j].fi[2] = (i-1)*M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[j].fi[3] = 0.0;
Full_sphere_related.c:    E->sphere.cap[j].fi[4] = i*M_PI/2.0;
Full_sphere_related.c:    x[i] = E->data.ra * sin(E->sphere.cap[icap].theta[i])*cos(E->sphere.cap[icap].fi[i]);
Full_sphere_related.c:    y[i] = E->data.ra * sin(E->sphere.cap[icap].theta[i])*sin(E->sphere.cap[icap].fi[i]);
Full_sphere_related.c:    z[i] = E->data.rc * cos(E->sphere.cap[icap].theta[i]);
Full_sphere_related.c:    x[i] = sin(E->sphere.cap[icap].theta[i])*cos(E->sphere.cap[icap].fi[i]);
Full_sphere_related.c:    y[i] = sin(E->sphere.cap[icap].theta[i])*sin(E->sphere.cap[icap].fi[i]);
Full_sphere_related.c:    z[i] = cos(E->sphere.cap[icap].theta[i]);
Full_sphere_related.c:  lev = E->mesh.levmax;
Full_sphere_related.c:     elx = E->lmesh.ELX[lev]*E->parallel.nprocx;
Full_sphere_related.c:     ely = E->lmesh.ELY[lev]*E->parallel.nprocy;
Full_sphere_related.c:     lelx = E->lmesh.ELX[lev];
Full_sphere_related.c:     lely = E->lmesh.ELY[lev];
Full_sphere_related.c:     for (j=0, i=E->lmesh.nxs; j<lnox; j++, i++) {
Full_sphere_related.c:     for (j=0, i=E->lmesh.nxs; j<lnox; j++, i++) {
Full_sphere_related.c:     for (k=0, i=E->lmesh.nys; k<lnoy; k++, i++) {
Full_sphere_related.c:     for (k=0, i=E->lmesh.nys; k<lnoy; k++, i++) {
Full_sphere_related.c:                 fprintf(stderr, "Error(Full_coord_of_cap): cannot find intersection point! rank=%d, nx=%d, ny=%d\n", E->parallel.me, j, k);
Full_sphere_related.c:     if(E->parallel.me_loc[2] == 0) {
Full_sphere_related.c:     if(E->parallel.me_loc[2] == E->parallel.nprocy-1) {
Full_sphere_related.c:     if(E->parallel.me_loc[1] == 0) {
Full_sphere_related.c:     if(E->parallel.me_loc[1] == E->parallel.nprocx-1) {
Full_sphere_related.c:     efac2 = E->data.ellipticity*(2.0 - E->data.ellipticity)/
Full_sphere_related.c:       ((1.- E->data.ellipticity)*(1.-E->data.ellipticity));
Full_sphere_related.c:     for (lev=E->mesh.levmax, step=1; lev>=E->mesh.levmin; lev--, step*=2) {
Full_sphere_related.c:       lvnox = E->lmesh.NOX[lev];
Full_sphere_related.c:       lvnoy = E->lmesh.NOY[lev];
Full_sphere_related.c:       lvnoz = E->lmesh.NOZ[lev];
Full_sphere_related.c:	   rfac = E->data.ra*1./sqrt(1.0+efac2*cost*cost);
Full_sphere_related.c:	     E->SX[lev][m][1][node] = theta;
Full_sphere_related.c:	     E->SX[lev][m][2][node] = fi;
Full_sphere_related.c:	     E->SX[lev][m][3][node] = rfac * E->sphere.R[lev][i];
Full_sphere_related.c:	     E->X[lev][m][1][node] = E->data.ra * E->sphere.R[lev][i]*sint*cosf;
Full_sphere_related.c:	     E->X[lev][m][2][node] = E->data.ra * E->sphere.R[lev][i]*sint*sinf;
Full_sphere_related.c:	     E->X[lev][m][3][node] = E->data.rc * E->sphere.R[lev][i]*cost;
Full_sphere_related.c:     for (lev=E->mesh.levmax, step=1; lev>=E->mesh.levmin; lev--, step*=2) {
Full_sphere_related.c:       lvnox = E->lmesh.NOX[lev];
Full_sphere_related.c:       lvnoy = E->lmesh.NOY[lev];
Full_sphere_related.c:       lvnoz = E->lmesh.NOZ[lev];
Full_sphere_related.c:	     E->SX[lev][m][1][node] = theta;
Full_sphere_related.c:	     E->SX[lev][m][2][node] = fi;
Full_sphere_related.c:	     E->SX[lev][m][3][node] = E->sphere.R[lev][i];
Full_sphere_related.c:	     E->X[lev][m][1][node]  = E->sphere.R[lev][i]*sint*cosf;
Full_sphere_related.c:	     E->X[lev][m][2][node]  = E->sphere.R[lev][i]*sint*sinf;
Full_sphere_related.c:	     E->X[lev][m][3][node]  = E->sphere.R[lev][i]*cost;
Full_sphere_related.c:  temp = max(E->lmesh.NOY[E->mesh.levmax],E->lmesh.NOX[E->mesh.levmax]);
Full_sphere_related.c:  temp = E->lmesh.NOY[E->mesh.levmax]*E->lmesh.NOX[E->mesh.levmax];
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[1] = 0.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[2] = M_PI/4.0+offset;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[3] = M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[4] = M_PI/4.0+offset;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[1] = 0.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[2] = (i-1)*M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[3] = (i-1)*M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[4] = i*M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[1] = M_PI/4.0+offset;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[2] = M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[3] = 3*M_PI/4.0-offset;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[4] = M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[1] = i*M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[2] = i*M_PI/2.0 - M_PI/4.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[3] = i*M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[4] = i*M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:    E->sphere.cap[j].theta[1] = M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[j].theta[2] = 3*M_PI/4.0-offset;
Full_sphere_related.c:    E->sphere.cap[j].theta[3] = M_PI;
Full_sphere_related.c:    E->sphere.cap[j].theta[4] = 3*M_PI/4.0-offset;
Full_sphere_related.c:    E->sphere.cap[j].fi[1] = (i-1)*M_PI/2.0 + M_PI/4.0;
Full_sphere_related.c:    E->sphere.cap[j].fi[2] = (i-1)*M_PI/2.0;
Full_sphere_related.c:    E->sphere.cap[j].fi[3] = 0.0;
Full_sphere_related.c:    E->sphere.cap[j].fi[4] = i*M_PI/2.0;
Full_sphere_related.c:     x[i] = sin(E->sphere.cap[icap].theta[i])*cos(E->sphere.cap[icap].fi[i]);
Full_sphere_related.c:     y[i] = sin(E->sphere.cap[icap].theta[i])*sin(E->sphere.cap[icap].fi[i]);
Full_sphere_related.c:     z[i] = cos(E->sphere.cap[icap].theta[i]);
Full_sphere_related.c:/*     fprintf(E->fp_out,"m=%d %d x=%g y=%g z=%g t=%g f=%g\n",icap,i,x[i],y[i],z[i],E->sphere.cap[icap].theta[i],E->sphere.cap[icap].fi[i]);        */
Full_sphere_related.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Full_sphere_related.c:     elx = E->lmesh.ELX[lev];
Full_sphere_related.c:     ely = E->lmesh.ELY[lev];
Full_sphere_related.c:     nox = E->lmesh.NOX[lev];
Full_sphere_related.c:     noy = E->lmesh.NOY[lev];
Full_sphere_related.c:     noz = E->lmesh.NOZ[lev];
Full_sphere_related.c:/*       fprintf(E->fp_out,"m=%d %d x=%g y=%g z=%g t=%g f=%g\n",icap,j,xx[1],yy[1],zz[1],theta1[j],fi1[j]);
Full_sphere_related.c:       fprintf(E->fp_out,"m=%d %d x=%g y=%g z=%g t=%g f=%g\n",icap,j,xx[2],yy[2],zz[2],theta2[j],fi2[j]);             */
Full_sphere_related.c:                E->SX[lev][m][1][node] = SX[0][nodes];
Full_sphere_related.c:                E->SX[lev][m][2][node] = SX[1][nodes];
Full_sphere_related.c:                E->SX[lev][m][3][node] = E->sphere.R[lev][i];
Full_sphere_related.c:                E->X[lev][m][1][node] = 
Full_sphere_related.c:                            E->sphere.R[lev][i]*sin(SX[0][nodes])*cos(SX[1][nodes]);
Full_sphere_related.c:                E->X[lev][m][2][node] = 
Full_sphere_related.c:                            E->sphere.R[lev][i]*sin(SX[0][nodes])*sin(SX[1][nodes]);
Full_sphere_related.c:                E->X[lev][m][3][node] = 
Full_sphere_related.c:                            E->sphere.R[lev][i]*cos(SX[0][nodes]);
Full_sphere_related.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Full_sphere_related.c:    for (i=1;i<=E->lmesh.NNO[lev];i++)  {
Full_sphere_related.c:/*      t[0] = E->X[lev][m][1][i]*E->sphere.dircos[1][1]+ 
Full_sphere_related.c:             E->X[lev][m][2][i]*E->sphere.dircos[1][2]+ 
Full_sphere_related.c:             E->X[lev][m][3][i]*E->sphere.dircos[1][3]; 
Full_sphere_related.c:      t[1] = E->X[lev][m][1][i]*E->sphere.dircos[2][1]+ 
Full_sphere_related.c:             E->X[lev][m][2][i]*E->sphere.dircos[2][2]+ 
Full_sphere_related.c:             E->X[lev][m][3][i]*E->sphere.dircos[2][3]; 
Full_sphere_related.c:      t[2] = E->X[lev][m][1][i]*E->sphere.dircos[3][1]+ 
Full_sphere_related.c:             E->X[lev][m][2][i]*E->sphere.dircos[3][2]+ 
Full_sphere_related.c:             E->X[lev][m][3][i]*E->sphere.dircos[3][3]; 
Full_sphere_related.c:      E->X[lev][m][1][i] = t[0];
Full_sphere_related.c:      E->X[lev][m][2][i] = t[1];
Full_sphere_related.c:      E->X[lev][m][3][i] = t[2];
Full_sphere_related.c:      E->SX[lev][m][1][i] = acos(t[2]/E->SX[lev][m][3][i]);
Full_sphere_related.c:      E->SX[lev][m][2][i] = myatan(t[1],t[0]);
Full_tracer_advection.c:    int m = E->parallel.me;
Full_tracer_advection.c:    E->trace.deltheta[0]=1.0;
Full_tracer_advection.c:    E->trace.delphi[0]=1.0;
Full_tracer_advection.c:    input_double("regular_grid_deltheta",&(E->trace.deltheta[0]),"1.0",m);
Full_tracer_advection.c:    input_double("regular_grid_delphi",&(E->trace.delphi[0]),"1.0",m);
Full_tracer_advection.c:    E->trace.ianalytical_tracer_test=0;
Full_tracer_advection.c:    /* input_int("analytical_tracer_test",&(E->trace.ianalytical_tracer_test),
Full_tracer_advection.c:    if (E->sphere.caps_per_proc>1) {
Full_tracer_advection.c:    sprintf(output_file,"%s.tracer_log.%d",E->control.data_file,E->parallel.me);
Full_tracer_advection.c:    E->trace.fpt=fopen(output_file,"w");
Full_tracer_advection.c:    E->trace.istat_isend=0;
Full_tracer_advection.c:    E->trace.istat_iempty=0;
Full_tracer_advection.c:    E->trace.istat_elements_checked=0;
Full_tracer_advection.c:    E->trace.istat1=0;
Full_tracer_advection.c:    E->trace.box_cushion=0.00001;
Full_tracer_advection.c:    E->trace.number_of_basic_quantities=12;
Full_tracer_advection.c:    E->trace.number_of_extra_quantities = 0;
Full_tracer_advection.c:    if (E->trace.nflavors > 0)
Full_tracer_advection.c:        E->trace.number_of_extra_quantities += 1;
Full_tracer_advection.c:    E->trace.number_of_tracer_quantities =
Full_tracer_advection.c:        E->trace.number_of_basic_quantities +
Full_tracer_advection.c:        E->trace.number_of_extra_quantities;
Full_tracer_advection.c:    if (E->trace.number_of_basic_quantities>99) {
Full_tracer_advection.c:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of basic in tracer_defs.h\n");
Full_tracer_advection.c:        fflush(E->trace.fpt);
Full_tracer_advection.c:    if (E->trace.number_of_extra_quantities>99) {
Full_tracer_advection.c:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of extraq in tracer_defs.h\n");
Full_tracer_advection.c:        fflush(E->trace.fpt);
Full_tracer_advection.c:    if (E->trace.number_of_tracer_quantities>99) {
Full_tracer_advection.c:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of rlater in tracer_defs.h\n");
Full_tracer_advection.c:        fflush(E->trace.fpt);
Full_tracer_advection.c:    if (E->trace.ianalytical_tracer_test==1) {
Full_tracer_advection.c:    if (E->composition.on)
Full_tracer_advection.c:    fprintf(E->trace.fpt, "Tracer intiailization takes %f seconds.\n",
Full_tracer_advection.c:    /* This code works only if E->sphere.caps_per_proc==1 */
Full_tracer_advection.c:    int lev=E->mesh.levmax;
Full_tracer_advection.c:    int num_ngb = E->parallel.TNUM_PASS[lev][j];
Full_tracer_advection.c:    if(E->control.verbose)
Full_tracer_advection.c:      fprintf(E->trace.fpt, "Entering lost_souls()\n");
Full_tracer_advection.c:    E->trace.istat_isend=E->trace.ilater[j];
Full_tracer_advection.c:    for (kk=1; kk<=E->trace.istat_isend; kk++) {
Full_tracer_advection.c:        fprintf(E->trace.fpt, "tracer#=%d xx=(%g,%g,%g)\n", kk,
Full_tracer_advection.c:                E->trace.rlater[j][0][kk],
Full_tracer_advection.c:                E->trace.rlater[j][1][kk],
Full_tracer_advection.c:                E->trace.rlater[j][2][kk]);
Full_tracer_advection.c:    fflush(E->trace.fpt);
Full_tracer_advection.c:    isize[j]=E->trace.ilater[j]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Error(lost souls)-no memory (u389)\n");
Full_tracer_advection.c:            fflush(E->trace.fpt);
Full_tracer_advection.c:    ithiscap=E->sphere.capid[j];
Full_tracer_advection.c:        ithatcap=E->parallel.PROCESSOR[lev][j].pass[kk];
Full_tracer_advection.c:        fprintf(E->trace.fpt,"cap: %d me %d TNUM: %d rank: %d\n",
Full_tracer_advection.c:                ithiscap,E->parallel.me,kk,ithatcap);
Full_tracer_advection.c:    fflush(E->trace.fpt);
Full_tracer_advection.c:    if (E->parallel.nprocz>1) {
Full_tracer_advection.c:        idestination_proc=E->parallel.PROCESSOR[lev][j].pass[kk];
Full_tracer_advection.c:                  11,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:                  11,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:	  isource_proc=E->parallel.me;
Full_tracer_advection.c:	  isource_proc=E->parallel.PROCESSOR[lev][j].pass[kk];
Full_tracer_advection.c:	fprintf(E->trace.fpt,"%d send %d to proc %d\n",
Full_tracer_advection.c:		E->parallel.me,isend[j][kk],isource_proc);
Full_tracer_advection.c:	fprintf(E->trace.fpt,"%d recv %d from proc %d\n",
Full_tracer_advection.c:		E->parallel.me,ireceive[j][kk],isource_proc);
Full_tracer_advection.c:        isize[j]=ireceive[j][ithatcap]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Error(lost souls)-no memory (c721)\n");
Full_tracer_advection.c:            fflush(E->trace.fpt);
Full_tracer_advection.c:    if (E->parallel.nprocz>1) {
Full_tracer_advection.c:        isize[j]=isend[j][ithatcap]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:        idestination_proc=E->parallel.PROCESSOR[lev][j].pass[kk];
Full_tracer_advection.c:        isize[j]=isend[j][kk]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:                  11,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:        isize[j]=ireceive[j][kk]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:                  11,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:    isize[j]=isum[j]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:        fprintf(E->trace.fpt,"Error(lost souls)-no memory (g323)\n");
Full_tracer_advection.c:        fflush(E->trace.fpt);
Full_tracer_advection.c:            ipos=pp*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:            for (mm=0;mm<E->trace.number_of_tracer_quantities;mm++) {
Full_tracer_advection.c:    if (E->parallel.nprocz>1) {
Full_tracer_advection.c:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Full_tracer_advection.c:            isize[j]=itracers_subject_to_vertical_transport[j]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:                fprintf(E->trace.fpt,"Error(lost souls)-no memory (c721)\n");
Full_tracer_advection.c:                fflush(E->trace.fpt);
Full_tracer_advection.c:        for (ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Full_tracer_advection.c:            ithat_processor=E->parallel.PROCESSORz[lev].pass[ivertical_neighbor];
Full_tracer_advection.c:                ireceive_position=it*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:                    isend_position=isend_z[j][ivertical_neighbor]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:                    ilast_receiver_position=(irec[j]-1)*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:                    for (mm=0;mm<=(E->trace.number_of_tracer_quantities-1);mm++) {
Full_tracer_advection.c:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Full_tracer_advection.c:            idestination_proc = E->parallel.PROCESSORz[lev].pass[kk];
Full_tracer_advection.c:                      14,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:                      14,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Full_tracer_advection.c:            fprintf(E->trace.fpt, "PROC: %d IVN: %d (P: %d) "
Full_tracer_advection.c:                    E->parallel.me,kk,E->parallel.PROCESSORz[lev].pass[kk],
Full_tracer_advection.c:        fflush(E->trace.fpt);
Full_tracer_advection.c:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Full_tracer_advection.c:            isize[j]=ireceive_z[j][kk]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:                fprintf(E->trace.fpt,"Error(lost souls)-no memory (t590)\n");
Full_tracer_advection.c:                fflush(E->trace.fpt);
Full_tracer_advection.c:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Full_tracer_advection.c:            idestination_proc = E->parallel.PROCESSORz[lev].pass[kk];
Full_tracer_advection.c:            isize_send=isend_z[j][kk]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:                      15,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:            isize_receive=ireceive_z[j][kk]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:                      15,E->parallel.world,&request[idb++]);
Full_tracer_advection.c:        for (ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Full_tracer_advection.c:        isize[j]=isum[j]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:                fprintf(E->trace.fpt,"Error(lost souls)-no memory (i981)\n");
Full_tracer_advection.c:                fprintf(E->trace.fpt,"isize: %d\n",isize[j]);
Full_tracer_advection.c:                fflush(E->trace.fpt);
Full_tracer_advection.c:        for (ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Full_tracer_advection.c:                irec_position=irec[j]*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:                ireceive_position=kk*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:                for (mm=0;mm<E->trace.number_of_tracer_quantities;mm++) {
Full_tracer_advection.c:        for (ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Full_tracer_advection.c:        E->trace.ntracers[j]++;
Full_tracer_advection.c:        if (E->trace.ntracers[j]>(E->trace.max_ntracers[j]-5)) expand_tracer_arrays(E,j);
Full_tracer_advection.c:        ireceive_position=kk*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:        for (mm=0;mm<E->trace.number_of_basic_quantities;mm++) {
Full_tracer_advection.c:            E->trace.basicq[j][mm][E->trace.ntracers[j]]=REC[j][ipos];
Full_tracer_advection.c:        for (mm=0;mm<E->trace.number_of_extra_quantities;mm++) {
Full_tracer_advection.c:            ipos=ireceive_position+E->trace.number_of_basic_quantities+mm;
Full_tracer_advection.c:            E->trace.extraq[j][mm][E->trace.ntracers[j]]=REC[j][ipos];
Full_tracer_advection.c:        theta=E->trace.basicq[j][0][E->trace.ntracers[j]];
Full_tracer_advection.c:        phi=E->trace.basicq[j][1][E->trace.ntracers[j]];
Full_tracer_advection.c:        rad=E->trace.basicq[j][2][E->trace.ntracers[j]];
Full_tracer_advection.c:        x=E->trace.basicq[j][3][E->trace.ntracers[j]];
Full_tracer_advection.c:        y=E->trace.basicq[j][4][E->trace.ntracers[j]];
Full_tracer_advection.c:        z=E->trace.basicq[j][5][E->trace.ntracers[j]];
Full_tracer_advection.c:        iel=(E->trace.iget_element)(E,j,-99,x,y,z,theta,phi,rad);
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Error(lost souls) - element not here?\n");
Full_tracer_advection.c:            fprintf(E->trace.fpt,"x,y,z-theta,phi,rad: %f %f %f - %f %f %f\n",x,y,z,theta,phi,rad);
Full_tracer_advection.c:            fflush(E->trace.fpt);
Full_tracer_advection.c:        E->trace.ielement[j][E->trace.ntracers[j]]=iel;
Full_tracer_advection.c:    if(E->control.verbose){
Full_tracer_advection.c:      fprintf(E->trace.fpt,"Freeing memory in lost_souls()\n");
Full_tracer_advection.c:      fflush(E->trace.fpt);
Full_tracer_advection.c:    if(E->control.verbose){
Full_tracer_advection.c:      fprintf(E->trace.fpt,"Leaving lost_souls()\n");
Full_tracer_advection.c:      fflush(E->trace.fpt);
Full_tracer_advection.c:    E->trace.lost_souls_time += CPU_time0() - begin_time;
Full_tracer_advection.c:    int lev = E->mesh.levmax;
Full_tracer_advection.c:    numtracers=E->trace.ilater[j];
Full_tracer_advection.c:        rad=E->trace.rlater[j][2][kk];
Full_tracer_advection.c:        x=E->trace.rlater[j][3][kk];
Full_tracer_advection.c:        y=E->trace.rlater[j][4][kk];
Full_tracer_advection.c:        z=E->trace.rlater[j][5][kk];
Full_tracer_advection.c:        if (E->parallel.nprocz>1) {
Full_tracer_advection.c:        for (pp=1;pp<=E->parallel.TNUM_PASS[lev][j];pp++) {
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Error(lost souls)-should not be here\n");
Full_tracer_advection.c:            fprintf(E->trace.fpt,"x: %f y: %f z: %f rad: %f\n",x,y,z,rad);
Full_tracer_advection.c:            if (icheck==1) fprintf(E->trace.fpt," icheck here!\n");
Full_tracer_advection.c:            else fprintf(E->trace.fpt,"icheck not here!\n");
Full_tracer_advection.c:            fflush(E->trace.fpt);
Full_tracer_advection.c:        isend_position=(isend[j][ithatcap]-1)*E->trace.number_of_tracer_quantities;
Full_tracer_advection.c:        for (pp=0;pp<=(E->trace.number_of_tracer_quantities-1);pp++) {
Full_tracer_advection.c:            send[j][ithatcap][ipos]=E->trace.rlater[j][pp][kk];
Full_tracer_advection.c:    int maxlevel=E->mesh.levmax;
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ERROR(gnomonic_interpolation)-inum>3!\n");
Full_tracer_advection.c:                    fflush(E->trace.fpt);
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ERROR(gnomonic_interpolation)-inum>1\n");
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"shape %f %f %f\n",shape2d[1],shape2d[2],shape2d[3]);
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"u %f v %f element: %d \n",u,v, nelem);
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"Element uv boundaries: \n");
Full_tracer_advection.c:                        i = (E->ien[j][nelem].node[kk] - 1) / E->lmesh.noz + 1;
Full_tracer_advection.c:                        fprintf(E->trace.fpt,"%d: U: %f V:%f\n",kk,E->gnomonic[i].u,E->gnomonic[i].v);
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"theta: %f phi: %f rad: %f\n",theta,phi,rad);
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"Element theta-phi boundaries: \n");
Full_tracer_advection.c:                        fprintf(E->trace.fpt,"%d: Theta: %f Phi:%f\n",kk,E->sx[j][1][E->ien[j][nelem].node[kk]],E->sx[j][2][E->ien[j][nelem].node[kk]]);
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ICHECK?: %d\n",ival);
Full_tracer_advection.c:                    ival=(E->trace.iget_element)(E,j,-99,x,y,z,theta,phi,rad);
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"New Element?: %d\n",ival);
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"New Element (neighs)?: %d\n",ival);
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ICHECK?: %d\n",ival);
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"NO LUCK\n");
Full_tracer_advection.c:                    fflush(E->trace.fpt);
Full_tracer_advection.c:    fprintf(E->trace.fpt, "shp: %e %e %e %e %e %e\n",
Full_tracer_advection.c:    int n = (nelem - 1) / E->lmesh.elz + 1;
Full_tracer_advection.c:    a0=E->trace.shape_coefs[j][iwedge][1][n];
Full_tracer_advection.c:    a1=E->trace.shape_coefs[j][iwedge][2][n];
Full_tracer_advection.c:    a2=E->trace.shape_coefs[j][iwedge][3][n];
Full_tracer_advection.c:    a0=E->trace.shape_coefs[j][iwedge][4][n];
Full_tracer_advection.c:    a1=E->trace.shape_coefs[j][iwedge][5][n];
Full_tracer_advection.c:    a2=E->trace.shape_coefs[j][iwedge][6][n];
Full_tracer_advection.c:    a0=E->trace.shape_coefs[j][iwedge][7][n];
Full_tracer_advection.c:    a1=E->trace.shape_coefs[j][iwedge][8][n];
Full_tracer_advection.c:    a2=E->trace.shape_coefs[j][iwedge][9][n];
Full_tracer_advection.c:    fprintf(E->trace.fpt, "el=%d els=%d iwedge=%d shape=(%e %e %e)\n",
Full_tracer_advection.c:    node1=E->ien[j][nelem].node[1];
Full_tracer_advection.c:    node5=E->ien[j][nelem].node[5];
Full_tracer_advection.c:    rad1=E->sx[j][3][node1];
Full_tracer_advection.c:    rad5=E->sx[j][3][node5];
Full_tracer_advection.c:            fprintf(E->trace.fpt,"ERROR(get_radial_shape)\n");
Full_tracer_advection.c:            fprintf(E->trace.fpt,"shaperad[1]: %f \n",shaperad[1]);
Full_tracer_advection.c:            fprintf(E->trace.fpt,"shaperad[2]: %f \n",shaperad[2]);
Full_tracer_advection.c:            fflush(E->trace.fpt);
Full_tracer_advection.c:    phi_f = E->gnomonic_reference_phi;
Full_tracer_advection.c:    cos_theta_f = E->gnomonic[0].u;
Full_tracer_advection.c:    sin_theta_f = E->gnomonic[0].v;
Full_tracer_advection.c:    fprintf(E->trace.fpt, "(%e %e) -> (%e %e)\n",
Full_tracer_advection.c:    elz=E->lmesh.elz;
Full_tracer_advection.c:    nelsurf=E->lmesh.elx*E->lmesh.ely;
Full_tracer_advection.c:    expansion=2.0*0.5*(M_PI/4.0)/(1.0*E->lmesh.elx);
Full_tracer_advection.c:    if (E->parallel.me==0) fprintf(stderr,"Generating Regular Grid\n");
Full_tracer_advection.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:            for (kk=1;kk<=E->lmesh.nno;kk=kk+E->lmesh.noz)
Full_tracer_advection.c:                    theta=E->sx[j][1][kk];
Full_tracer_advection.c:                    phi=E->sx[j][2][kk];
Full_tracer_advection.c:            deltheta=E->trace.deltheta[0]*M_PI/180.0;
Full_tracer_advection.c:            delphi=E->trace.delphi[0]*M_PI/180.0;
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"Error(make_regular_grid): numtheta: %d numphi: %d\n",numtheta,numphi);
Full_tracer_advection.c:                    fflush(E->trace.fpt);
Full_tracer_advection.c:            E->trace.deltheta[j]=deltheta;
Full_tracer_advection.c:            E->trace.delphi[j]=delphi;
Full_tracer_advection.c:            E->trace.numtheta[j]=numtheta;
Full_tracer_advection.c:            E->trace.numphi[j]=numphi;
Full_tracer_advection.c:            E->trace.thetamax[j]=thetamax;
Full_tracer_advection.c:            E->trace.thetamin[j]=thetamin;
Full_tracer_advection.c:            E->trace.phimax[j]=phimax;
Full_tracer_advection.c:            E->trace.phimin[j]=phimin;
Full_tracer_advection.c:            E->trace.numregel[j]=numregel;
Full_tracer_advection.c:            E->trace.numregnodes[j]=numregnodes;
Full_tracer_advection.c:            if ( ((1.0*numregel)/(1.0*E->lmesh.elx*E->lmesh.ely)) < 0.5 )
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"\n ! WARNING: regular/real ratio low: %f ! \n",
Full_tracer_advection.c:                            ((1.0*numregel)/(1.0*E->lmesh.nel)) );
Full_tracer_advection.c:                    fprintf(E->trace.fpt," Should reduce size of regular mesh\n");
Full_tracer_advection.c:                            ((1.0*numregel)/(1.0*E->lmesh.nel)) );
Full_tracer_advection.c:                    fflush(E->trace.fpt);
Full_tracer_advection.c:                    if (E->trace.itracer_warnings) exit(10);
Full_tracer_advection.c:            fprintf(E->trace.fpt,"\nRegular grid:\n");
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Theta min: %f max: %f \n",thetamin,thetamax);
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Phi min: %f max: %f \n",phimin,phimax);
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Adjusted deltheta: %f delphi: %f\n",deltheta,delphi);
Full_tracer_advection.c:            fprintf(E->trace.fpt,"(numtheta: %d  numphi: %d)\n",numtheta,numphi);
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Number of regular elements: %d  (nodes: %d)\n",numregel,numregnodes);
Full_tracer_advection.c:            fprintf(E->trace.fpt,"regular/real ratio: %f\n",((1.0*numregel)/(1.0*E->lmesh.elx*E->lmesh.ely)));
Full_tracer_advection.c:            fflush(E->trace.fpt);
Full_tracer_advection.c:            if ((E->trace.regnodetoel[j]=(int *)malloc((numregnodes+1)*sizeof(int)))==NULL)
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ERROR(make regular) -no memory - uh3ud\n");
Full_tracer_advection.c:                    fflush(E->trace.fpt);
Full_tracer_advection.c:                    E->trace.regnodetoel[j][kk]=-99;
Full_tracer_advection.c:            if (E->parallel.me==0) fprintf(stderr,"Beginning Mapping\n");
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Full_tracer_advection.c:                    fflush(E->trace.fpt);
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Full_tracer_advection.c:                    fflush(E->trace.fpt);
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Full_tracer_advection.c:                    fflush(E->trace.fpt);
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Full_tracer_advection.c:                    fflush(E->trace.fpt);
Full_tracer_advection.c:            for (mm=elz;mm<=E->lmesh.nel;mm=mm+elz)
Full_tracer_advection.c:                            node=E->ien[j][mm].node[pp];
Full_tracer_advection.c:                            theta=E->sx[j][1][node];
Full_tracer_advection.c:                            phi=E->sx[j][2][node];
Full_tracer_advection.c:            rad=E->sphere.ro;
Full_tracer_advection.c:                    E->trace.regnodetoel[j][kk]=-99;
Full_tracer_advection.c:                      for (mm=elz;mm<=E->lmesh.nel;mm=mm+elz)
Full_tracer_advection.c:                      E->trace.regnodetoel[j][kk]=mm;
Full_tracer_advection.c:                            E->trace.regnodetoel[j][kk]=ilast_el;
Full_tracer_advection.c:                            E->trace.regnodetoel[j][kk]=ival;
Full_tracer_advection.c:                    for (mm=elz;mm<=E->lmesh.nel;mm=mm+elz)
Full_tracer_advection.c:                                            E->trace.regnodetoel[j][kk]=mm;
Full_tracer_advection.c:                    if (E->trace.regnodetoel[j][kk]>0) imap++;
Full_tracer_advection.c:            fprintf(E->trace.fpt,"percentage mapped: %f\n", (1.0*imap)/(1.0*numregnodes)*100.0);
Full_tracer_advection.c:            fflush(E->trace.fpt);
Full_tracer_advection.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:                    if (E->trace.regnodetoel[j][kk]!=-99)
Full_tracer_advection.c:                            if ( (E->trace.regnodetoel[j][kk]<1)||(E->trace.regnodetoel[j][kk]>E->lmesh.nel) )
Full_tracer_advection.c:                                    fprintf(stderr,"Error(make_regular_grid)-invalid element: %d\n",E->trace.regnodetoel[j][kk]);
Full_tracer_advection.c:                                    fprintf(E->trace.fpt,"Error(make_regular_grid)-invalid element: %d\n",E->trace.regnodetoel[j][kk]);
Full_tracer_advection.c:                                    fflush(E->trace.fpt);
Full_tracer_advection.c:    if (E->parallel.me==0) fprintf(stderr,"Beginning Regtoel submapping \n");
Full_tracer_advection.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:            numregel= E->trace.numregel[j];
Full_tracer_advection.c:                    if ((E->trace.regtoel[j][pp]=(int *)malloc((numregel+1)*sizeof(int)))==NULL)
Full_tracer_advection.c:                            fprintf(E->trace.fpt,"ERROR(make regular)-no memory 98d (%d %d %d)\n",pp,numregel,j);
Full_tracer_advection.c:                            fflush(E->trace.fpt);
Full_tracer_advection.c:            numtheta=E->trace.numtheta[j];
Full_tracer_advection.c:            numphi=E->trace.numphi[j];
Full_tracer_advection.c:                            for (pp=0;pp<=4;pp++) E->trace.regtoel[j][pp][iregel]=-33;
Full_tracer_advection.c:                                    fprintf(E->trace.fpt,"ERROR(make_regular_grid)-weird iregel: %d (max: %d)\n",iregel,numregel);
Full_tracer_advection.c:                                    fflush(E->trace.fpt);
Full_tracer_advection.c:                            iregnode[3]=iregel+nphi+E->trace.numtheta[j]+1;
Full_tracer_advection.c:                            iregnode[4]=iregel+nphi+E->trace.numtheta[j];
Full_tracer_advection.c:                                            fprintf(E->trace.fpt,"ERROR(make regular)-bad regnode %d\n",iregnode[kk]);
Full_tracer_advection.c:                                            fflush(E->trace.fpt);
Full_tracer_advection.c:                                    if (E->trace.regnodetoel[j][iregnode[kk]]>E->lmesh.nel)
Full_tracer_advection.c:                                            fprintf(E->trace.fpt,"AABB HERE %d %d %d %d\n",iregel,iregnode[kk],kk,E->trace.regnodetoel[j][iregnode[kk]]);
Full_tracer_advection.c:                                            fflush(E->trace.fpt);
Full_tracer_advection.c:                                    if (E->trace.regnodetoel[j][iregnode[kk]]<=0) goto next_corner;
Full_tracer_advection.c:                                            if (E->trace.regnodetoel[j][iregnode[kk]]==E->trace.regnodetoel[j][iregnode[pp]]) goto next_corner;
Full_tracer_advection.c:                                    itemp[ichoice]=E->trace.regnodetoel[j][iregnode[kk]];
Full_tracer_advection.c:                                            fprintf(E->trace.fpt,"ERROR(make regular) - weird ichoice %d \n",ichoice);
Full_tracer_advection.c:                                            fflush(E->trace.fpt);
Full_tracer_advection.c:                                    if ((itemp[ichoice]<0) || (itemp[ichoice]>E->lmesh.nel) )
Full_tracer_advection.c:                                            fprintf(E->trace.fpt,"ERROR(make regular) - weird element choice %d %d\n",itemp[ichoice],ichoice);
Full_tracer_advection.c:                                            fflush(E->trace.fpt);
Full_tracer_advection.c:                                    fprintf(E->trace.fpt,"ERROR(make_regular)-wierd ichoice %d\n",ichoice);
Full_tracer_advection.c:                                    fflush(E->trace.fpt);
Full_tracer_advection.c:                                    E->trace.regtoel[j][0][iregel]=-1;
Full_tracer_advection.c:                                      fprintf(E->trace.fpt,"HH1: (%p) iregel: %d ichoice: %d value: %d %d\n",&E->trace.regtoel[j][1][iregel],iregel,ichoice,E->trace.regtoel[j][0][iregel],E->trace.regtoel[j][1][iregel]);
Full_tracer_advection.c:                                    E->trace.regtoel[j][0][iregel]=0;
Full_tracer_advection.c:                                    E->trace.regtoel[j][1][iregel]=itemp[1];
Full_tracer_advection.c:                                      fprintf(E->trace.fpt,"HH2: (%p) iregel: %d ichoice: %d value: %d %d\n",&E->trace.regtoel[j][1][iregel],iregel,ichoice,E->trace.regtoel[j][0][iregel],E->trace.regtoel[j][1][iregel]);
Full_tracer_advection.c:                                    if (itemp[1]<1 || itemp[1]>E->lmesh.nel)
Full_tracer_advection.c:                                            fprintf(E->trace.fpt,"ERROR(make_regular)-huh? wierd itemp\n");
Full_tracer_advection.c:                                            fflush(E->trace.fpt);
Full_tracer_advection.c:                                    E->trace.regtoel[j][0][iregel]=ichoice;
Full_tracer_advection.c:                                            E->trace.regtoel[j][pp][iregel]=itemp[pp];
Full_tracer_advection.c:                                              fprintf(E->trace.fpt,"HH:(%p)  iregel: %d ichoice: %d pp: %d value: %d %d\n",&E->trace.regtoel[j][pp][iregel],iregel,ichoice,pp,itemp[pp],E->trace.regtoel[j][pp][iregel]);
Full_tracer_advection.c:                                            if (itemp[pp]<1 || itemp[pp]>E->lmesh.nel)
Full_tracer_advection.c:                                                    fprintf(E->trace.fpt,"ERROR(make_regular)-huh? wierd itemp 2 \n");
Full_tracer_advection.c:                                                    fflush(E->trace.fpt);
Full_tracer_advection.c:                                    fprintf(E->trace.fpt,"ERROR(make_regular)- should not be here! %d\n",ichoice);
Full_tracer_advection.c:                                    fflush(E->trace.fpt);
Full_tracer_advection.c:            free (E->trace.regnodetoel[j]);
Full_tracer_advection.c:            for (kk=1;kk<=E->trace.numregel[j];kk++)
Full_tracer_advection.c:                    if ((E->trace.regtoel[j][0][kk]<-1)||(E->trace.regtoel[j][0][kk]>4))
Full_tracer_advection.c:                            fprintf(E->trace.fpt,"ERROR(make regular) regtoel ichoice0? %d %d \n",kk,E->trace.regtoel[j][pp][kk]);
Full_tracer_advection.c:                            fflush(E->trace.fpt);
Full_tracer_advection.c:                            if (((E->trace.regtoel[j][pp][kk]<1)&&(E->trace.regtoel[j][pp][kk]!=-33))||(E->trace.regtoel[j][pp][kk]>E->lmesh.nel))
Full_tracer_advection.c:                                    fprintf(E->trace.fpt,"ERROR(make regular) (%p) regtoel? %d %d(%d) %d\n",&E->trace.regtoel[j][pp][kk],kk,pp,E->trace.regtoel[j][0][kk],E->trace.regtoel[j][pp][kk]);
Full_tracer_advection.c:                                    fflush(E->trace.fpt);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"Mapping completed (%f seconds)\n",CPU_time0()-start_time);
Full_tracer_advection.c:    fflush(E->trace.fpt);
Full_tracer_advection.c:    if (E->parallel.me==0) fprintf(stderr,"Mapping completed (%f seconds)\n",CPU_time0()-start_time);
Full_tracer_advection.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:            fprintf(E->trace.fpt,"\n\nInformation regarding number of real elements per regular elements\n");
Full_tracer_advection.c:            fprintf(E->trace.fpt," (stats done on regular elements that were used)\n");
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Ichoice is number of real elements touched by a regular element\n");
Full_tracer_advection.c:            fprintf(E->trace.fpt,"  (ichoice=0 is optimal)\n");
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Ichoice=0: %f percent\n",(100.0*istat_ichoice[j][0])/(1.0*isum));
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Ichoice=1: %f percent\n",(100.0*istat_ichoice[j][1])/(1.0*isum));
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Ichoice=2: %f percent\n",(100.0*istat_ichoice[j][2])/(1.0*isum));
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Ichoice=3: %f percent\n",(100.0*istat_ichoice[j][3])/(1.0*isum));
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Ichoice=4: %f percent\n",(100.0*istat_ichoice[j][4])/(1.0*isum));
Full_tracer_advection.c:    fprintf(E->trace.fpt,"\nTracing Activated! (proc: %d)\n",E->parallel.me);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"   Allen K. McNamara 12-2003\n\n");
Full_tracer_advection.c:    if (E->trace.ic_method==0)
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Generating New Tracer Array\n");
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Tracers per element: %d\n",E->trace.itperel);
Full_tracer_advection.c:    if (E->trace.ic_method==1)
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Reading tracer file %s\n",E->trace.tracer_file);
Full_tracer_advection.c:    if (E->trace.ic_method==2)
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Reading individual tracer files\n");
Full_tracer_advection.c:    fprintf(E->trace.fpt,"Number of tracer flavors: %d\n", E->trace.nflavors);
Full_tracer_advection.c:    if (E->trace.nflavors && E->trace.ic_method==0) {
Full_tracer_advection.c:        fprintf(E->trace.fpt,"Initialized tracer flavors by: %d\n", E->trace.ic_method_for_flavors);
Full_tracer_advection.c:        if (E->trace.ic_method_for_flavors == 0) {
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Layered tracer flavors\n");
Full_tracer_advection.c:            for (i=0; i<E->trace.nflavors-1; i++)
Full_tracer_advection.c:                fprintf(E->trace.fpt,"Interface Height: %d %f\n",i,E->trace.z_interface[i]);
Full_tracer_advection.c:	else if((E->trace.ic_method_for_flavors == 1)||(E->trace.ic_method_for_flavors == 99)) {
Full_tracer_advection.c:            fprintf(E->trace.fpt,"netcdf grd assigned tracer flavors\n");
Full_tracer_advection.c:	    if( E->trace.ggrd_layers > 0)
Full_tracer_advection.c:	      fprintf(E->trace.fpt,"file: %s top %i layers\n",E->trace.ggrd_file,
Full_tracer_advection.c:		      E->trace.ggrd_layers);
Full_tracer_advection.c:	      fprintf(E->trace.fpt,"file: %s only layer %i\n",E->trace.ggrd_file,
Full_tracer_advection.c:		      -E->trace.ggrd_layers);
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Sorry-This IC methods for Flavors are Unavailable %d\n",E->trace.ic_method_for_flavors);
Full_tracer_advection.c:            fflush(E->trace.fpt);
Full_tracer_advection.c:    for (i=0; i<E->trace.nflavors-2; i++) {
Full_tracer_advection.c:        if (E->trace.z_interface[i] < E->trace.z_interface[i+1]) {
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Sorry - The %d-th z_interface is smaller than the next one.\n", i);
Full_tracer_advection.c:            fflush(E->trace.fpt);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"Regular Grid-> deltheta: %f delphi: %f\n",
Full_tracer_advection.c:            E->trace.deltheta[0],E->trace.delphi[0]);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"Box Cushion: %f\n",E->trace.box_cushion);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"Number of Basic Quantities: %d\n",
Full_tracer_advection.c:            E->trace.number_of_basic_quantities);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"Number of Extra Quantities: %d\n",
Full_tracer_advection.c:            E->trace.number_of_extra_quantities);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"Total Number of Tracer Quantities: %d\n",
Full_tracer_advection.c:            E->trace.number_of_tracer_quantities);
Full_tracer_advection.c:    if (E->trace.ianalytical_tracer_test==1)
Full_tracer_advection.c:            fprintf(E->trace.fpt,"\n\n ! Analytical Test Being Performed ! \n");
Full_tracer_advection.c:            fprintf(E->trace.fpt,"(some of the above parameters may not be used or applied\n");
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Velocity functions given in main code\n");
Full_tracer_advection.c:            fflush(E->trace.fpt);
Full_tracer_advection.c:    if (E->trace.itracer_warnings==0)
Full_tracer_advection.c:            fprintf(E->trace.fpt,"\n WARNING EXITS ARE TURNED OFF! TURN THEM ON!\n");
Full_tracer_advection.c:            fflush(E->trace.fpt);
Full_tracer_advection.c:    elx=E->lmesh.elx;
Full_tracer_advection.c:    ely=E->lmesh.ely;
Full_tracer_advection.c:    elz=E->lmesh.elz;
Full_tracer_advection.c:            if ((neighbor[kk]>=1)&&(neighbor[kk]<=E->lmesh.nel))
Full_tracer_advection.c:    int elz=E->lmesh.elz;
Full_tracer_advection.c:    int numel=E->lmesh.nel;
Full_tracer_advection.c:    ibottom_node=E->ien[1][nel].node[1];
Full_tracer_advection.c:    itop_node=E->ien[1][nel].node[5];
Full_tracer_advection.c:    bottom_rad=E->sx[1][3][ibottom_node];
Full_tracer_advection.c:    top_rad=E->sx[1][3][itop_node];
Full_tracer_advection.c:    int lev = E->mesh.levmax;
Full_tracer_advection.c:    E->trace.istat_elements_checked++;
Full_tracer_advection.c:            node=E->ien[j][nel].node[kk+4];
Full_tracer_advection.c:            rnode[kk][1]=E->x[j][1][node];
Full_tracer_advection.c:            rnode[kk][2]=E->x[j][2][node];
Full_tracer_advection.c:            rnode[kk][3]=E->x[j][3][node];
Full_tracer_advection.c:            rnode[kk][4]=E->sx[j][1][node];
Full_tracer_advection.c:            rnode[kk][5]=E->sx[j][2][node];
Full_tracer_advection.c:            rnode[kk][6]=E->SinCos[lev][j][2][node]; /* cos(theta) */
Full_tracer_advection.c:            rnode[kk][7]=E->SinCos[lev][j][0][node]; /* sin(theta) */
Full_tracer_advection.c:            rnode[kk][8]=E->SinCos[lev][j][3][node]; /* cos(phi) */
Full_tracer_advection.c:            rnode[kk][9]=E->SinCos[lev][j][1][node]; /* sin(phi) */
Full_tracer_advection.c:            rnode[kk][1]=E->trace.xcap[icap][kk];
Full_tracer_advection.c:            rnode[kk][2]=E->trace.ycap[icap][kk];
Full_tracer_advection.c:            rnode[kk][3]=E->trace.zcap[icap][kk];
Full_tracer_advection.c:            rnode[kk][4]=E->trace.theta_cap[icap][kk];
Full_tracer_advection.c:            rnode[kk][5]=E->trace.phi_cap[icap][kk];
Full_tracer_advection.c:            rnode[kk][6]=E->trace.cos_theta[icap][kk];
Full_tracer_advection.c:            rnode[kk][7]=E->trace.sin_theta[icap][kk];
Full_tracer_advection.c:            rnode[kk][8]=E->trace.cos_phi[icap][kk];
Full_tracer_advection.c:            rnode[kk][9]=E->trace.sin_phi[icap][kk];
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Error(icheck_bounds)-too many tries\n");
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Rads: %f %f %f %f\n",rad1,rad2,rad3,rad4);
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Test Point: %f %f %f  \n",test_point[1],test_point[2],test_point[3]);
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Nodal points: 1: %f %f %f\n",rnode1[1],rnode1[2],rnode1[3]);
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Nodal points: 2: %f %f %f\n",rnode2[1],rnode2[2],rnode2[3]);
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Nodal points: 3: %f %f %f\n",rnode3[1],rnode3[2],rnode3[3]);
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Nodal points: 4: %f %f %f\n",rnode4[1],rnode4[2],rnode4[3]);
Full_tracer_advection.c:            fflush(E->trace.fpt);
Full_tracer_advection.c:      fprintf(stderr,"%d: icheck: %d\n",E->parallel.me,icheck);
Full_tracer_advection.c:      fprintf(stderr,"%d: rads: %f %f %f %f\n",E->parallel.me,rad1,rad2,rad3,rad4);
Full_tracer_advection.c:    max_radius = E->sphere.ro - E->trace.box_cushion;
Full_tracer_advection.c:    min_radius = E->sphere.ri + E->trace.box_cushion;
Full_tracer_advection.c:    elx=E->lmesh.elx;
Full_tracer_advection.c:    ely=E->lmesh.ely;
Full_tracer_advection.c:    elz=E->lmesh.elz;
Full_tracer_advection.c:    if (E->parallel.nprocz>1)
Full_tracer_advection.c:    if (E->trace.regtoel[j][0][iregel]==0)
Full_tracer_advection.c:            iel=E->trace.regtoel[j][1][iregel];
Full_tracer_advection.c:    if (E->trace.regtoel[j][0][iregel]>0)
Full_tracer_advection.c:            ichoice=E->trace.regtoel[j][0][iregel];
Full_tracer_advection.c:                    nelem=E->trace.regtoel[j][kk][iregel];
Full_tracer_advection.c:                            ineighbor=E->trace.regtoel[j][kk][iregel];
Full_tracer_advection.c:    E->trace.istat1++;
Full_tracer_advection.c:      fprintf(E->trace.fpt,"WARNING(full_iget_element)-doing a full search!\n");
Full_tracer_advection.c:      fprintf(E->trace.fpt,"  Most often means tracers have moved more than 1 element away\n");
Full_tracer_advection.c:      fprintf(E->trace.fpt,"  or regular element resolution is way too low.\n");
Full_tracer_advection.c:      fprintf(E->trace.fpt,"  COLUMN: %d \n",iel);
Full_tracer_advection.c:      fprintf(E->trace.fpt,"  PREVIOUS ELEMENT: %d \n",iprevious_element);
Full_tracer_advection.c:      fprintf(E->trace.fpt,"  x,y,z,theta,phi,rad: %f %f %f   %f %f %f\n",x,y,z,theta,phi,rad);
Full_tracer_advection.c:      fflush(E->trace.fpt);
Full_tracer_advection.c:      if (E->trace.itracer_warnings) exit(10);
Full_tracer_advection.c:    if (E->trace.istat1%100==0)
Full_tracer_advection.c:            fprintf(E->trace.fpt,"Checked all elements %d times already this turn\n",E->trace.istat1);
Full_tracer_advection.c:            fflush(E->trace.fpt);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"Error(full_iget_element) - element not found\n");
Full_tracer_advection.c:    fprintf(E->trace.fpt,"x,y,z,theta,phi,iregel %.15e %.15e %.15e %.15e %.15e %d\n",
Full_tracer_advection.c:    fflush(E->trace.fpt);
Full_tracer_advection.c:    int elz=E->lmesh.elz;
Full_tracer_advection.c:            node=E->ien[j][iradial_element].node[8];
Full_tracer_advection.c:            top_rad=E->sx[j][3][node];
Full_tracer_advection.c:    fprintf(E->trace.fpt,"Error(iget_radial_element)-out of range %f %d %d %d\n",rad,j,iel,ibottom_element);
Full_tracer_advection.c:    fflush(E->trace.fpt);
Full_tracer_advection.c:    if (theta<E->trace.thetamin[j]) return -99;
Full_tracer_advection.c:    if (theta>E->trace.thetamax[j]) return -99;
Full_tracer_advection.c:    rdum=theta-E->trace.thetamin[j];
Full_tracer_advection.c:    idum=rdum/E->trace.deltheta[j];
Full_tracer_advection.c:    rdum=phi-E->trace.phimin[j];
Full_tracer_advection.c:    idum=rdum/E->trace.delphi[j];
Full_tracer_advection.c:    iregel=*ntheta+(*nphi-1)*E->trace.numtheta[j];
Full_tracer_advection.c:    if (iregel>E->trace.numregel[j]) return -99;
Full_tracer_advection.c:/* E->gnomonic[node].u = u                                      */
Full_tracer_advection.c:/* E->gnomonic[node].v = v                                      */
Full_tracer_advection.c:    const int lev = E->mesh.levmax;
Full_tracer_advection.c:    if ((E->gnomonic = malloc((E->lmesh.nsf+1)*sizeof(struct CITCOM_GNOMONIC)))
Full_tracer_advection.c:    sint = E->SinCos[lev][j][0];
Full_tracer_advection.c:    sinf = E->SinCos[lev][j][1];
Full_tracer_advection.c:    cost = E->SinCos[lev][j][2];
Full_tracer_advection.c:    cosf = E->SinCos[lev][j][3];
Full_tracer_advection.c:    refnode = 1 + E->lmesh.noz * ((E->lmesh.noy / 2) * E->lmesh.nox
Full_tracer_advection.c:                                  + E->lmesh.nox / 2);
Full_tracer_advection.c:    phi_f = E->gnomonic_reference_phi = E->sx[j][2][refnode];
Full_tracer_advection.c:    theta_f = E->sx[j][1][refnode];
Full_tracer_advection.c:    for (i=1; i<=E->lmesh.nsf; i++) {
Full_tracer_advection.c:        fprintf(E->trace.fpt, "i=%d (%e %e %e %e)\n",
Full_tracer_advection.c:    fprintf(E->trace.fpt, "%d %d %d ref=(%e %e)\n",
Full_tracer_advection.c:            E->lmesh.noz, E->lmesh.nsf, refnode, theta_f, phi_f);
Full_tracer_advection.c:    E->gnomonic[0].u = cost[refnode];
Full_tracer_advection.c:    E->gnomonic[0].v = sint[refnode];
Full_tracer_advection.c:    for (i=1, n=1; i<=E->lmesh.nsf; i++, n+=E->lmesh.noz) {
Full_tracer_advection.c:        dphi = E->sx[j][2][n] - phi_f;
Full_tracer_advection.c:        E->gnomonic[i].u = u;
Full_tracer_advection.c:        E->gnomonic[i].v = v;
Full_tracer_advection.c:        fprintf(E->trace.fpt, "n=%d ns=%d cosc=%e (%e %e) -> (%e %e)\n",
Full_tracer_advection.c:                n, i, cosc, E->sx[j][1][n], E->sx[j][2][n], u, v);
Full_tracer_advection.c:            if ((E->trace.shape_coefs[j][iwedge][kk] =
Full_tracer_advection.c:                 (double *)malloc((E->lmesh.snel+1)*sizeof(double))) == NULL) {
Full_tracer_advection.c:                fprintf(E->trace.fpt,"ERROR(find shape coefs)-not enough memory(a)\n");
Full_tracer_advection.c:                fflush(E->trace.fpt);
Full_tracer_advection.c:    for (i=1, nelem=1; i<=E->lmesh.snel; i++, nelem+=E->lmesh.elz) {
Full_tracer_advection.c:            snode = (E->ien[j][nelem].node[kk]-1) / E->lmesh.noz + 1;
Full_tracer_advection.c:            u[kk] = E->gnomonic[snode].u;
Full_tracer_advection.c:            v[kk] = E->gnomonic[snode].v;
Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][1][i] = a0;
Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][2][i] = a1;
Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][3][i] = a2;
Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][4][i] = a0;
Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][5][i] = a1;
Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][6][i] = a2;
Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][7][i] = a0;
Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][8][i] = a1;
Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][9][i] = a2;
Full_tracer_advection.c:            fprintf(E->trace.fpt, "el=%d els=%d iwedge=%d shape=(%e %e %e, %e %e %e, %e %e %e)\n",
Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][1][i],
Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][2][i],
Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][3][i],
Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][4][i],
Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][5][i],
Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][6][i],
Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][7][i],
Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][8][i],
Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][9][i]);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"Starting Analytical Test\n");
Full_tracer_advection.c:    if (E->parallel.me==0) fprintf(stderr,"Starting Analytical Test\n");
Full_tracer_advection.c:    fflush(E->trace.fpt);
Full_tracer_advection.c:    E->trace.box_cushion=0.0000;
Full_tracer_advection.c:    E->advection.timestep=dt;
Full_tracer_advection.c:    fprintf(E->trace.fpt,"steps: %d  dt: %f\n",nsteps,dt);
Full_tracer_advection.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:            for (kk=1;kk<=E->lmesh.nno;kk++)
Full_tracer_advection.c:                    theta=E->sx[j][1][kk];
Full_tracer_advection.c:                    phi=E->sx[j][2][kk];
Full_tracer_advection.c:                    rad=E->sx[j][3][kk];
Full_tracer_advection.c:                    E->sphere.cap[j].V[1][kk]=vel_s[1];
Full_tracer_advection.c:                    E->sphere.cap[j].V[2][kk]=vel_s[2];
Full_tracer_advection.c:                    E->sphere.cap[j].V[3][kk]=vel_s[3];
Full_tracer_advection.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:            if (E->trace.ntracers[j]>10)
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"Warning(analytical)-too many tracers to print!\n");
Full_tracer_advection.c:                    fflush(E->trace.fpt);
Full_tracer_advection.c:                    if (E->trace.itracer_warnings) exit(10);
Full_tracer_advection.c:    E->monitor.solution_cycles=0;
Full_tracer_advection.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:            for (pp=1;pp<=E->trace.ntracers[j];pp++)
Full_tracer_advection.c:                    theta=E->trace.basicq[j][0][pp];
Full_tracer_advection.c:                    phi=E->trace.basicq[j][1][pp];
Full_tracer_advection.c:                    rad=E->trace.basicq[j][2][pp];
Full_tracer_advection.c:                    fprintf(E->trace.fpt,"(%d) time: %f theta: %f phi: %f rad: %f\n",E->monitor.solution_cycles,time,theta,phi,rad);
Full_tracer_advection.c:                    if (pp==1) fprintf(stderr,"(%d) time: %f theta: %f phi: %f rad: %f\n",E->monitor.solution_cycles,time,theta,phi,rad);
Full_tracer_advection.c:            E->monitor.solution_cycles=kk;
Full_tracer_advection.c:            for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:                    for (pp=1;pp<=E->trace.ntracers[j];pp++)
Full_tracer_advection.c:                            theta=E->trace.basicq[j][0][pp];
Full_tracer_advection.c:                            phi=E->trace.basicq[j][1][pp];
Full_tracer_advection.c:                            rad=E->trace.basicq[j][2][pp];
Full_tracer_advection.c:                            fprintf(E->trace.fpt,"(%d) time: %f theta: %f phi: %f rad: %f\n",E->monitor.solution_cycles,time,theta,phi,rad);
Full_tracer_advection.c:                            if (pp==1) fprintf(stderr,"(%d) time: %f theta: %f phi: %f rad: %f\n",E->monitor.solution_cycles,time,theta,phi,rad);
Full_tracer_advection.c:    fflush(E->trace.fpt);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"\n\nComparison to Runge-Kutte\n");
Full_tracer_advection.c:    if (E->parallel.me==0) fprintf(stderr,"Comparison to Runge-Kutte\n");
Full_tracer_advection.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_tracer_advection.c:            my_number=E->trace.ntracers[j];
Full_tracer_advection.c:    MPI_Allreduce(&my_number,&number,1,MPI_INT,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"Number of tracers: %d\n", number);
Full_tracer_advection.c:    if (E->parallel.me==0) fprintf(stderr,"Number of tracers: %d\n", number);
Full_tracer_advection.c:            fprintf(E->trace.fpt,"(Note: RK comparison only appropriate for one tracing particle (%d here) \n",number);
Full_tracer_advection.c:            if (E->parallel.me==0) fprintf(stderr,"(Note: RK comparison only appropriate for one tracing particle (%d here) \n",number);
Full_tracer_advection.c:            fflush(E->trace.fpt);
Full_tracer_advection.c:    MPI_Allreduce(&my_theta0,&theta0,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:    MPI_Allreduce(&my_phi0,&phi0,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:    MPI_Allreduce(&my_rad0,&rad0,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:    MPI_Allreduce(&my_thetaf,&thetaf,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:    MPI_Allreduce(&my_phif,&phif,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:    MPI_Allreduce(&my_radf,&radf,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"Citcom calculation: steps: %d  dt: %f\n",nsteps,dt);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"  (nodes per cap: %d x %d x %d)\n",E->lmesh.nox,E->lmesh.noy,(E->lmesh.noz-1)*E->parallel.nprocz+1);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"                    starting position: theta: %f phi: %f rad: %f\n", theta0,phi0,rad0);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"                    final position: theta: %f phi: %f rad: %f\n", thetaf,phif,radf);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"                    (final time: %f) \n",time );
Full_tracer_advection.c:    fprintf(E->trace.fpt,"\n\nRunge-Kutte calculation: steps: %d  dt: %g\n",nrunge_steps,runge_dt);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"                    starting position: theta: %f phi: %f rad: %f\n", theta0,phi0,rad0);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"                    final position: theta: %f phi: %f rad: %f\n",xf_s[1],xf_s[2],xf_s[3]);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"                    path length: %f \n",runge_path_length );
Full_tracer_advection.c:    fprintf(E->trace.fpt,"                    (final time: %f) \n",runge_time );
Full_tracer_advection.c:    fprintf(E->trace.fpt,"\n\n Difference between Citcom and RK: %e  (diff per path length: %e)\n\n",difference,difperpath);
Full_tracer_advection.c:    if (E->parallel.me==0)
Full_tracer_advection.c:            fprintf(stderr,"  (nodes per cap: %d x %d x %d)\n",E->lmesh.nox,E->lmesh.noy,(E->lmesh.noz-1)*E->parallel.nprocz+1);
Full_tracer_advection.c:    fflush(E->trace.fpt);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"HERE (Before Sync): %d\n",i);
Full_tracer_advection.c:    fflush(E->trace.fpt);
Full_tracer_advection.c:    fprintf(E->trace.fpt,"HERE (After Sync): %d\n",i);
Full_tracer_advection.c:    fflush(E->trace.fpt);
Full_version_dependent.c:    for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Full_version_dependent.c:        for (i=1;i<=E->lmesh.NNO[lev];i++) {
Full_version_dependent.c:            t[0] = E->X[lev][m][1][i]*dircos[1][1]+
Full_version_dependent.c:                E->X[lev][m][2][i]*dircos[1][2]+
Full_version_dependent.c:                E->X[lev][m][3][i]*dircos[1][3];
Full_version_dependent.c:            t[1] = E->X[lev][m][1][i]*dircos[2][1]+
Full_version_dependent.c:                E->X[lev][m][2][i]*dircos[2][2]+
Full_version_dependent.c:                E->X[lev][m][3][i]*dircos[2][3];
Full_version_dependent.c:            t[2] = E->X[lev][m][1][i]*dircos[3][1]+
Full_version_dependent.c:                E->X[lev][m][2][i]*dircos[3][2]+
Full_version_dependent.c:                E->X[lev][m][3][i]*dircos[3][3];
Full_version_dependent.c:            E->X[lev][m][1][i] = t[0];
Full_version_dependent.c:            E->X[lev][m][2][i] = t[1];
Full_version_dependent.c:            E->X[lev][m][3][i] = t[2];
Full_version_dependent.c:            E->SX[lev][m][1][i] = acos(t[2]/E->SX[lev][m][3][i]);
Full_version_dependent.c:            E->SX[lev][m][2][i] = myatan(t[1],t[0]);
Full_version_dependent.c:  rr = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Full_version_dependent.c:  RR = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Full_version_dependent.c:  switch(E->control.coor){
Full_version_dependent.c:    dr = (E->sphere.ro-E->sphere.ri)/(E->mesh.noz-1);
Full_version_dependent.c:    for (k=1;k <= E->mesh.noz;k++)  {
Full_version_dependent.c:      rr[k] = E->sphere.ri + (k-1)*dr;
Full_version_dependent.c:    sprintf(output_file,"%s",E->control.coor_file);
Full_version_dependent.c:      fprintf(E->fp,"(Nodal_mesh.c #1) Cannot open %s\n",output_file);
Full_version_dependent.c:    for (k=1;k<=E->mesh.noz;k++)  {
Full_version_dependent.c:  for (i=1;i<=E->lmesh.noz;i++)  {
Full_version_dependent.c:    k = E->lmesh.nzs+i-1;
Full_version_dependent.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Full_version_dependent.c:    if (E->control.NMULTIGRID)
Full_version_dependent.c:        step = (int) pow(2.0,(double)(E->mesh.levmax-lev));
Full_version_dependent.c:      for (i=1;i<=E->lmesh.NOZ[lev];i++)
Full_version_dependent.c:         E->sphere.R[lev][i] = RR[(i-1)*step+1];
Full_version_dependent.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Full_version_dependent.c:     ii = E->sphere.capid[j];
Full_version_dependent.c:  if (E->control.verbose) {
Full_version_dependent.c:      for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)   {
Full_version_dependent.c:          fprintf(E->fp_out,"output_coordinates before rotation %d \n",lev);
Full_version_dependent.c:          for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_version_dependent.c:              for (i=1;i<=E->lmesh.NNO[lev];i++)
Full_version_dependent.c:                  if(i%E->lmesh.NOZ[lev]==1)
Full_version_dependent.c:                      fprintf(E->fp_out,"%d %d %g %g %g\n",j,i,E->SX[lev][j][1][i],E->SX[lev][j][2][i],E->SX[lev][j][3][i]);
Full_version_dependent.c:      fflush(E->fp_out);
Full_version_dependent.c:  ro = -0.5*(M_PI/4.0)/E->mesh.elx;
Full_version_dependent.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Full_version_dependent.c:     ii = E->sphere.capid[j];
Full_version_dependent.c:  if (E->control.verbose) {
Full_version_dependent.c:      for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)   {
Full_version_dependent.c:          fprintf(E->fp_out,"output_coordinates after rotation %d \n",lev);
Full_version_dependent.c:          for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_version_dependent.c:              for (i=1;i<=E->lmesh.NNO[lev];i++)
Full_version_dependent.c:                  if(i%E->lmesh.NOZ[lev]==1)
Full_version_dependent.c:                      fprintf(E->fp_out,"%d %d %g %g %g\n",j,i,E->SX[lev][j][1][i],E->SX[lev][j][2][i],E->SX[lev][j][3][i]);
Full_version_dependent.c:      fflush(E->fp_out);
Full_version_dependent.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Full_version_dependent.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_version_dependent.c:      for (i=1;i<=E->lmesh.NNO[lev];i++)  {
Full_version_dependent.c:	tg = theta_g(E->SX[lev][j][1][i],E);
Full_version_dependent.c:	E->SinCos[lev][j][0][i] = sin(tg); /*  */
Full_version_dependent.c:	E->SinCos[lev][j][1][i] = sin(E->SX[lev][j][2][i]);
Full_version_dependent.c:	E->SinCos[lev][j][2][i] = cos(tg);
Full_version_dependent.c:	E->SinCos[lev][j][3][i] = cos(E->SX[lev][j][2][i]);
Full_version_dependent.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Full_version_dependent.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Full_version_dependent.c:      for (i=1;i<=E->lmesh.NNO[lev];i++)  {
Full_version_dependent.c:	E->SinCos[lev][j][0][i] = sin(E->SX[lev][j][1][i]); /* sin(theta) */
Full_version_dependent.c:	E->SinCos[lev][j][1][i] = sin(E->SX[lev][j][2][i]); /* sin(phi) */
Full_version_dependent.c:	E->SinCos[lev][j][2][i] = cos(E->SX[lev][j][1][i]); /* cos(theta) */
Full_version_dependent.c:	E->SinCos[lev][j][3][i] = cos(E->SX[lev][j][2][i]); /* cos(phi) */
Full_version_dependent.c:  const int dims=E->mesh.nsd;
Full_version_dependent.c:  int max_size = 2*E->lmesh.elx*E->lmesh.ely + 1;
Full_version_dependent.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Full_version_dependent.c:    E->boundary.element[m] = (int *)malloc(max_size*sizeof(int));
Full_version_dependent.c:      E->boundary.normal[m][d] = (int *)malloc(max_size*sizeof(int));
Full_version_dependent.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Full_version_dependent.c:    for(k=1; k<=E->lmesh.ely; k++)
Full_version_dependent.c:      for(j=1; j<=E->lmesh.elx; j++) {
Full_version_dependent.c:	if(E->parallel.me_loc[3] == 0) {
Full_version_dependent.c:	  el = i + (j-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Full_version_dependent.c:	  E->boundary.element[m][count] = el;
Full_version_dependent.c:	  E->boundary.normal[m][dims][count] = -1;
Full_version_dependent.c:	      E->boundary.normal[m][d][count] = 0;
Full_version_dependent.c:	if(E->parallel.me_loc[3] == E->parallel.nprocz - 1) {
Full_version_dependent.c:	  i = E->lmesh.elz;
Full_version_dependent.c:	  el = i + (j-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Full_version_dependent.c:	  E->boundary.element[m][count] = el;
Full_version_dependent.c:	  E->boundary.normal[m][dims][count] = 1;
Full_version_dependent.c:	    E->boundary.normal[m][d][count] = 0;
Full_version_dependent.c:    E->boundary.nel = count - 1;
General_matrix_functions.c:  neq  = E->lmesh.NEQ[high_lev];
General_matrix_functions.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:  r0=residual=sqrt(global_vdot(E,F,F,high_lev)/E->mesh.neq);
General_matrix_functions.c:  if (!E->control.NMULTIGRID) {
General_matrix_functions.c:    cycles = E->control.v_steps_low;
General_matrix_functions.c:    if(E->parallel.me==0){	/* output */
General_matrix_functions.c:	fprintf(E->fp,"resi = %.6e for iter %d acc %.6e\n",residual,counts,acc);
General_matrix_functions.c:      if(E->parallel.me==0){	/* output  */
General_matrix_functions.c:	fprintf(E->fp,"resi = %.6e for iter %d acc %.6e\n",residual,counts,acc);
General_matrix_functions.c:    }  while (!valid && counts < E->control.max_mg_cycles);
General_matrix_functions.c:  if(E->control.print_convergence&&E->parallel.me==0)   {
General_matrix_functions.c:    fprintf(E->fp,"%s residual (%03d) = %.3e from %.3e to %.3e in %5.2f secs \n",
General_matrix_functions.c:    fflush(E->fp);
General_matrix_functions.c:  E->monitor.momentum_residual = residual;
General_matrix_functions.c:  E->control.total_iteration_cycles += count;
General_matrix_functions.c:  E->control.total_v_solver_calls += 1;
General_matrix_functions.c:    const int levmin = E->mesh.levmin;
General_matrix_functions.c:    const int levmax = E->mesh.levmax;
General_matrix_functions.c:    for(i=E->mesh.levmin;i<=E->mesh.levmax;i++)
General_matrix_functions.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)    {
General_matrix_functions.c:	del_vel[i][m]=(double *)malloc((E->lmesh.NEQ[i]+1)*sizeof(double));
General_matrix_functions.c:	AU[i][m] = (double *)malloc((E->lmesh.NEQ[i]+1)*sizeof(double));
General_matrix_functions.c:	vel[i][m]=(double *)malloc((E->lmesh.NEQ[i]+1)*sizeof(double));
General_matrix_functions.c:	res[i][m]=(double *)malloc((E->lmesh.NEQ[i])*sizeof(double));
General_matrix_functions.c:	if (i<E->mesh.levmax)
General_matrix_functions.c:	  fl[i][m]=(double *)malloc((E->lmesh.NEQ[i])*sizeof(double));
General_matrix_functions.c:    Vnmax = E->control.mg_cycle;
General_matrix_functions.c:    cycles = E->control.v_steps_low;
General_matrix_functions.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:          for(j=0;j<E->lmesh.NEQ[lev];j++)
General_matrix_functions.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:          for(j=0;j<E->lmesh.NEQ[lev];j++)
General_matrix_functions.c:          cycles=((dlev==levmax)?E->control.v_steps_high:E->control.down_heavy);
General_matrix_functions.c:          for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:             for(i=0;i<E->lmesh.NEQ[dlev];i++)  {
General_matrix_functions.c:       cycles = E->control.v_steps_low;
General_matrix_functions.c:            cycles=((ulev==levmax)?E->control.v_steps_high:E->control.up_heavy);
General_matrix_functions.c:            for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:              for(i=0;i<E->lmesh.NEQ[ulev];i++)   {
General_matrix_functions.c:              for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:                for(i=0;i<E->lmesh.NEQ[ulev];i++)   {
General_matrix_functions.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:     for(j=0;j<E->lmesh.NEQ[levmax];j++)   {
General_matrix_functions.c:     residual = sqrt(global_vdot(E,F,F,hl)/E->mesh.NEQ[hl]);
General_matrix_functions.c:      for(i=E->mesh.levmin;i<=E->mesh.levmax;i++)
General_matrix_functions.c:        for(m=1;m<=E->sphere.caps_per_proc;m++) {
General_matrix_functions.c:	  if (i<E->mesh.levmax)
General_matrix_functions.c:    const int mem_lev=E->mesh.levmax;
General_matrix_functions.c:    const int high_neq = E->lmesh.NEQ[level];
General_matrix_functions.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
General_matrix_functions.c:      r0[m] = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
General_matrix_functions.c:      r1[m] = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
General_matrix_functions.c:      r2[m] = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
General_matrix_functions.c:      z0[m] = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
General_matrix_functions.c:      z1[m] = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
General_matrix_functions.c:      p1[m] = (double *)malloc((1+E->lmesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:      p2[m] = (double *)malloc((1+E->lmesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:      Ap[m] = (double *)malloc((1+E->lmesh.NEQ[mem_lev])*sizeof(double));
General_matrix_functions.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:         z1[m][i] = E->BI[level][m][i] * r1[m][i];
General_matrix_functions.c:          for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:            for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)    {
General_matrix_functions.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
General_matrix_functions.c:    const int dims=E->mesh.nsd;
General_matrix_functions.c:    const int n=loc_mat_size[E->mesh.nsd];
General_matrix_functions.c:    const int neq=E->lmesh.NEQ[level];
General_matrix_functions.c:    const int nel=E->lmesh.NEL[level];
General_matrix_functions.c:    const int nno=E->lmesh.NNO[level];
General_matrix_functions.c:    for (m=1;m<=E->sphere.caps_per_proc;m++) {
General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:     for (m=1;m<=E->sphere.caps_per_proc;m++) {
General_matrix_functions.c:	    elt_k = E->elt_k[level][m][e].k;
General_matrix_functions.c:		node=E->IEN[level][m][e].node[i];
General_matrix_functions.c:		if(E->NODE[level][m][node] & VBX)
General_matrix_functions.c:		if(E->NODE[level][m][node] & VBY)
General_matrix_functions.c:		if(E->NODE[level][m][node] & VBZ)
General_matrix_functions.c:		node=E->IEN[level][m][e].node[i];
General_matrix_functions.c:		eqn1=E->ID[level][m][node].doff[1];
General_matrix_functions.c:		eqn2=E->ID[level][m][node].doff[2];
General_matrix_functions.c:                eqn3=E->ID[level][m][node].doff[3];
General_matrix_functions.c:		    node1=E->IEN[level][m][e].node[j];
General_matrix_functions.c:	            eqn11=E->ID[level][m][node1].doff[1];
General_matrix_functions.c:		    eqn12=E->ID[level][m][node1].doff[2];
General_matrix_functions.c:		    eqn13=E->ID[level][m][node1].doff[3];
General_matrix_functions.c:		node=E->IEN[level][m][e].node[i];
General_matrix_functions.c:		eqn1=E->ID[level][m][node].doff[1];
General_matrix_functions.c:		eqn2=E->ID[level][m][node].doff[2];
General_matrix_functions.c:		eqn3=E->ID[level][m][node].doff[3];
General_matrix_functions.c:		d0[m][eqn1] += (dd[m][eqn1] = w[(i-1)*dims]*(F[m][eqn1]-Ad[m][eqn1])*E->BI[level][m][eqn1]);
General_matrix_functions.c:		d0[m][eqn2] += (dd[m][eqn2] = w[(i-1)*dims+1]*(F[m][eqn2]-Ad[m][eqn2])*E->BI[level][m][eqn2]);
General_matrix_functions.c:		d0[m][eqn3] += (dd[m][eqn3] = w[(i-1)*dims+2]*(F[m][eqn3]-Ad[m][eqn3])*E->BI[level][m][eqn3]);
General_matrix_functions.c:		   node1=E->IEN[level][m][e].node[j];
General_matrix_functions.c:		   eqn11=E->ID[level][m][node1].doff[1];
General_matrix_functions.c:		   eqn12=E->ID[level][m][node1].doff[2];
General_matrix_functions.c:		   eqn13=E->ID[level][m][node1].doff[3];
General_matrix_functions.c:        (E->solver.exchange_id_d)(E, Ad, level);
General_matrix_functions.c:        (E->solver.exchange_id_d)(E, d0, level);
General_matrix_functions.c:    for (m=1;m<=E->sphere.caps_per_proc;m++) {
General_matrix_functions.c:    const int dims=E->mesh.nsd;
General_matrix_functions.c:    const int n=loc_mat_size[E->mesh.nsd];
General_matrix_functions.c:    const int neq=E->lmesh.NEQ[level];
General_matrix_functions.c:    const int num_nodes=E->lmesh.NNO[level];
General_matrix_functions.c:    const int nox=E->lmesh.NOX[level];
General_matrix_functions.c:    const int noz=E->lmesh.NOY[level];
General_matrix_functions.c:    const int noy=E->lmesh.NOZ[level];
General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c: 	for(j=0;j<=E->lmesh.NEQ[level];j++)
General_matrix_functions.c:          E->temp[m][j] = zeroo;
General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c: 	for(i=1;i<=E->lmesh.NNO[level];i++)
General_matrix_functions.c:          if(E->NODE[level][m][i] & OFFSIDE)   {
General_matrix_functions.c:	    eqn1=E->ID[level][m][i].doff[1];
General_matrix_functions.c:	    eqn2=E->ID[level][m][i].doff[2];
General_matrix_functions.c:	    eqn3=E->ID[level][m][i].doff[3];
General_matrix_functions.c:	    E->temp[m][eqn1] = (F[m][eqn1] - Ad[m][eqn1])*E->BI[level][m][eqn1];
General_matrix_functions.c:	    E->temp[m][eqn2] = (F[m][eqn2] - Ad[m][eqn2])*E->BI[level][m][eqn2];
General_matrix_functions.c:	    E->temp[m][eqn3] = (F[m][eqn3] - Ad[m][eqn3])*E->BI[level][m][eqn3];
General_matrix_functions.c:	    E->temp1[m][eqn1] = Ad[m][eqn1];
General_matrix_functions.c:	    E->temp1[m][eqn2] = Ad[m][eqn2];
General_matrix_functions.c:	    E->temp1[m][eqn3] = Ad[m][eqn3];
General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c: 	for(i=1;i<=E->lmesh.NNO[level];i++)     {
General_matrix_functions.c:	    eqn1=E->ID[level][m][i].doff[1];
General_matrix_functions.c:	    eqn2=E->ID[level][m][i].doff[2];
General_matrix_functions.c:	    eqn3=E->ID[level][m][i].doff[3];
General_matrix_functions.c:            C=E->Node_map[level][m]+(i-1)*max_eqn;
General_matrix_functions.c:	    B1=E->Eqn_k1[level][m]+(i-1)*max_eqn;
General_matrix_functions.c:	    B2=E->Eqn_k2[level][m]+(i-1)*max_eqn;
General_matrix_functions.c: 	    B3=E->Eqn_k3[level][m]+(i-1)*max_eqn;
General_matrix_functions.c:                 UU = E->temp[m][C[j]];
General_matrix_functions.c:            if (!(E->NODE[level][m][i]&OFFSIDE))   {
General_matrix_functions.c:               E->temp[m][eqn1] = (F[m][eqn1] - Ad[m][eqn1])*E->BI[level][m][eqn1];
General_matrix_functions.c:               E->temp[m][eqn2] = (F[m][eqn2] - Ad[m][eqn2])*E->BI[level][m][eqn2];
General_matrix_functions.c:               E->temp[m][eqn3] = (F[m][eqn3] - Ad[m][eqn3])*E->BI[level][m][eqn3];
General_matrix_functions.c:		    Ad[m][C[j]]  += B1[j]*E->temp[m][eqn1]
General_matrix_functions.c:                                 +  B2[j]*E->temp[m][eqn2]
General_matrix_functions.c:                                 +  B3[j]*E->temp[m][eqn3];
General_matrix_functions.c:	    d0[m][eqn1] += E->temp[m][eqn1];
General_matrix_functions.c:	    d0[m][eqn2] += E->temp[m][eqn2];
General_matrix_functions.c:	    d0[m][eqn3] += E->temp[m][eqn3];
General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c: 	for(i=1;i<=E->lmesh.NNO[level];i++)
General_matrix_functions.c:          if(E->NODE[level][m][i] & OFFSIDE)   {
General_matrix_functions.c:	    eqn1=E->ID[level][m][i].doff[1];
General_matrix_functions.c:	    eqn2=E->ID[level][m][i].doff[2];
General_matrix_functions.c:	    eqn3=E->ID[level][m][i].doff[3];
General_matrix_functions.c:	    Ad[m][eqn1] -= E->temp1[m][eqn1];
General_matrix_functions.c:	    Ad[m][eqn2] -= E->temp1[m][eqn2];
General_matrix_functions.c:	    Ad[m][eqn3] -= E->temp1[m][eqn3];
General_matrix_functions.c:      (E->solver.exchange_id_d)(E, Ad, level);
General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
General_matrix_functions.c: 	for(i=1;i<=E->lmesh.NNO[level];i++)
General_matrix_functions.c:          if(E->NODE[level][m][i] & OFFSIDE)   {
General_matrix_functions.c:	    eqn1=E->ID[level][m][i].doff[1];
General_matrix_functions.c:	    eqn2=E->ID[level][m][i].doff[2];
General_matrix_functions.c:	    eqn3=E->ID[level][m][i].doff[3];
General_matrix_functions.c:	    Ad[m][eqn1] += E->temp1[m][eqn1];
General_matrix_functions.c:	    Ad[m][eqn2] += E->temp1[m][eqn2];
General_matrix_functions.c:	    Ad[m][eqn3] += E->temp1[m][eqn3];
General_matrix_functions.c:/*     for (m=1;m<=E->sphere.caps_per_proc;m++)
Ggrd_handling.c:  if (E->parallel.nprocxy == 12){
Ggrd_handling.c:  only_one_layer = ((E->trace.ggrd_layers > 0)?(0):(1));
Ggrd_handling.c:  if(E->parallel.me > 0){	
Ggrd_handling.c:    mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 
Ggrd_handling.c:		      0, E->parallel.world, &mpi_stat);
Ggrd_handling.c:  if(ggrd_grdtrack_init_general(FALSE,E->trace.ggrd_file,
Ggrd_handling.c:  if(E->parallel.me <  E->parallel.nproc-1){
Ggrd_handling.c:		      MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Ggrd_handling.c:  for (j=1;j<=E->sphere.caps_per_proc;j++) {
Ggrd_handling.c:    number_of_tracers = E->trace.ntracers[j];
Ggrd_handling.c:      rad = E->trace.basicq[j][2][kk]; /* tracer radius */
Ggrd_handling.c:      if((only_one_layer && (this_layer == -E->trace.ggrd_layers)) ||
Ggrd_handling.c:	 ((!only_one_layer)&&(this_layer <= E->trace.ggrd_layers))){
Ggrd_handling.c:	phi =   E->trace.basicq[j][1][kk];
Ggrd_handling.c:	theta = E->trace.basicq[j][0][kk];
Ggrd_handling.c:	E->trace.extraq[j][0][kk]= indbl;
Ggrd_handling.c:	E->trace.extraq[j][0][kk] = 0.0;
Ggrd_handling.c:  if(E->parallel.me == 0)
Ggrd_handling.c:  noy=E->lmesh.noy;
Ggrd_handling.c:  nox=E->lmesh.nox;
Ggrd_handling.c:  noz=E->lmesh.noz;
Ggrd_handling.c:  if(E->parallel.me == 0)
Ggrd_handling.c:  if(E->parallel.me > 0){
Ggrd_handling.c:    mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1),
Ggrd_handling.c:		      0, E->parallel.world, &mpi_stat);
Ggrd_handling.c:  if(E->control.ggrd.temp.scale_with_prem){/* initialize PREM */
Ggrd_handling.c:    if(prem_read_model(E->control.ggrd.temp.prem.model_filename,
Ggrd_handling.c:		       &E->control.ggrd.temp.prem, (E->parallel.me == 0)))
Ggrd_handling.c:  E->control.ggrd.temp.d[0].init = FALSE;
Ggrd_handling.c:  if(ggrd_grdtrack_init_general(TRUE,E->control.ggrd.temp.gfile,
Ggrd_handling.c:				E->control.ggrd.temp.dfile,gmt_string,
Ggrd_handling.c:				E->control.ggrd.temp.d,(E->parallel.me == 0),
Ggrd_handling.c:  if(E->parallel.me <  E->parallel.nproc-1){
Ggrd_handling.c:    mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Ggrd_handling.c:	    E->parallel.me);
Ggrd_handling.c:  if(E->mesh.bottbc == 1){
Ggrd_handling.c:    tbot =  E->control.TBCbotval;
Ggrd_handling.c:  tmean = (tbot + E->control.TBCtopval)/2.0 +  E->control.ggrd.temp.offset;
Ggrd_handling.c:  for(m=1;m <= E->sphere.caps_per_proc;m++)
Ggrd_handling.c:	  if(!ggrd_grdtrack_interpolate_rtp((double)E->sx[m][3][node],(double)E->sx[m][1][node],
Ggrd_handling.c:					    (double)E->sx[m][2][node],
Ggrd_handling.c:					    E->control.ggrd.temp.d,&tadd,
Ggrd_handling.c:	    fprintf(stderr,"%g %g %g\n",E->sx[m][2][node]*57.29577951308232087,
Ggrd_handling.c:		    90-E->sx[m][1][node]*57.29577951308232087,(1-E->sx[m][3][node])*6371);
Ggrd_handling.c:	  if(E->control.ggrd.temp.scale_with_prem){
Ggrd_handling.c:	    prem_get_rho(&rho_prem,(double)E->sx[m][3][node],&E->control.ggrd.temp.prem);
Ggrd_handling.c:	    E->T[m][node] = tmean + tadd * E->control.ggrd.temp.scale *
Ggrd_handling.c:	      rho_prem / E->data.density;
Ggrd_handling.c:	    E->T[m][node] = tmean + tadd * E->control.ggrd.temp.scale;
Ggrd_handling.c:	  if(E->control.ggrd.temp.limit_trange){
Ggrd_handling.c:	    E->T[m][node] = min(max(E->T[m][node], 0.0),1.0);
Ggrd_handling.c:	  //fprintf(stderr,"z: %11g T: %11g\n",E->sx[m][3][node],E->T[m][node]);
Ggrd_handling.c:	  if(E->control.ggrd.temp.override_tbc){
Ggrd_handling.c:	    if((k == 1) && (E->mesh.bottbc == 1)){ /* bottom TBC */
Ggrd_handling.c:	      E->sphere.cap[m].TB[1][node] =  E->T[m][node];
Ggrd_handling.c:	      E->sphere.cap[m].TB[2][node] =  E->T[m][node];
Ggrd_handling.c:	      E->sphere.cap[m].TB[3][node] =  E->T[m][node];
Ggrd_handling.c:	      //fprintf(stderr,"z: %11g TBB: %11g\n",E->sx[m][3][node],E->T[m][node]);
Ggrd_handling.c:	    if((k == noz) && (E->mesh.toptbc == 1)){ /* top TBC */
Ggrd_handling.c:	      E->sphere.cap[m].TB[1][node] =  E->T[m][node];
Ggrd_handling.c:	      E->sphere.cap[m].TB[2][node] =  E->T[m][node];
Ggrd_handling.c:	      E->sphere.cap[m].TB[3][node] =  E->T[m][node];
Ggrd_handling.c:	      //fprintf(stderr,"z: %11g TBT: %11g\n",E->sx[m][3][node],E->T[m][node]);
Ggrd_handling.c:  ggrd_grdtrack_free_gstruc(E->control.ggrd.temp.d);
Ggrd_handling.c:layer <=  E->control.ggrd.mat_control
Ggrd_handling.c:  const int dims=E->mesh.nsd;
Ggrd_handling.c:  nox=E->mesh.nox;noy=E->mesh.noy;noz=E->mesh.noz;
Ggrd_handling.c:  nox1=E->lmesh.nox;noz1=E->lmesh.noz;noy1=E->lmesh.noy;
Ggrd_handling.c:  elx=E->lmesh.elx;elz=E->lmesh.elz;ely=E->lmesh.ely;
Ggrd_handling.c:  if(!E->control.ggrd.time_hist.init){
Ggrd_handling.c:    ggrd_init_thist_from_file(&E->control.ggrd.time_hist,
Ggrd_handling.c:			      E->control.ggrd.time_hist.file,TRUE,(E->parallel.me == 0));
Ggrd_handling.c:    E->control.ggrd.time_hist.init = 1;
Ggrd_handling.c:  timedep = (E->control.ggrd.time_hist.nvtimes > 1)?(1):(0);
Ggrd_handling.c:  if(!E->control.ggrd.mat_control_init){
Ggrd_handling.c:    if(E->parallel.me==0)
Ggrd_handling.c:	      E->data.radius_km*E->viscosity.zbase_layer[E->control.ggrd.mat_control-1]);
Ggrd_handling.c:    if(E->parallel.me > 0)	/* wait for previous processor */
Ggrd_handling.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1),
Ggrd_handling.c:			0, E->parallel.world, &mpi_stat);
Ggrd_handling.c:    E->control.ggrd.mat = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Ggrd_handling.c:    for(i=0;i < E->control.ggrd.time_hist.nvtimes;i++){
Ggrd_handling.c:	sprintf(tfilename,"%s",E->control.ggrd.mat_file);
Ggrd_handling.c:	sprintf(tfilename,"%s/%i/weak.grd",E->control.ggrd.mat_file,i+1);
Ggrd_handling.c:				    gmt_string,(E->control.ggrd.mat+i),(E->parallel.me == 0),FALSE))
Ggrd_handling.c:    if(E->parallel.me <  E->parallel.nproc-1){ /* tell the next proc to go ahead */
Ggrd_handling.c:			MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Ggrd_handling.c:  if(timedep || (!E->control.ggrd.mat_control_init)){
Ggrd_handling.c:    if(E->parallel.me == 0)
Ggrd_handling.c:      ggrd_interpol_time(age,&E->control.ggrd.time_hist,&i1,&i2,&f1,&f2,
Ggrd_handling.c:			 E->control.ggrd.time_hist.vstage_transition);
Ggrd_handling.c:    for (m=1;m <= E->sphere.caps_per_proc;m++) {
Ggrd_handling.c:	if(E->mat[m][j] <= E->control.ggrd.mat_control ){
Ggrd_handling.c:		ind = E->ien[m][el].node[inode];
Ggrd_handling.c:		xloc[1] += E->x[m][1][ind];xloc[2] += E->x[m][2][ind];xloc[3] += E->x[m][3][ind];
Ggrd_handling.c:	      if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.mat+i1),&indbl,
Ggrd_handling.c:						 (E->control.ggrd.mat+i2),&indbl2,
Ggrd_handling.c:	      E->VIP[m][el] = vip;
Ggrd_handling.c:	      E->VIP[m][el] = 1.0;
Ggrd_handling.c:  if((!timedep) && (!E->control.ggrd.mat_control_init)){			/* forget the grid */
Ggrd_handling.c:    ggrd_grdtrack_free_gstruc(E->control.ggrd.mat);
Ggrd_handling.c:  E->control.ggrd.mat_control_init = 1;
Ggrd_handling.c:layer <= E->control.ggrd.ray_control
Ggrd_handling.c:  const int dims=E->mesh.nsd;
Ggrd_handling.c:  nox=E->mesh.nox;noy=E->mesh.noy;noz=E->mesh.noz;
Ggrd_handling.c:  nox1=E->lmesh.nox;noz1=E->lmesh.noz;noy1=E->lmesh.noy;
Ggrd_handling.c:  elx=E->lmesh.elx;elz=E->lmesh.elz;ely=E->lmesh.ely;
Ggrd_handling.c:  lev=E->mesh.levmax;
Ggrd_handling.c:  if(!E->control.ggrd.time_hist.init){
Ggrd_handling.c:    ggrd_init_thist_from_file(&E->control.ggrd.time_hist,
Ggrd_handling.c:			      E->control.ggrd.time_hist.file,TRUE,(E->parallel.me == 0));
Ggrd_handling.c:    E->control.ggrd.time_hist.init = 1;
Ggrd_handling.c:  timedep = (E->control.ggrd.time_hist.nvtimes > 1)?(1):(0);
Ggrd_handling.c:  if(!E->control.ggrd.ray_control_init){
Ggrd_handling.c:    if(E->parallel.me==0)
Ggrd_handling.c:      fprintf(stderr,"ggrd_read_ray_from_file: initializing from %s\n",E->control.ggrd.ray_file);
Ggrd_handling.c:    if(E->parallel.me > 0)	/* wait for previous processor */
Ggrd_handling.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1),
Ggrd_handling.c:			0, E->parallel.world, &mpi_stat);
Ggrd_handling.c:    E->control.ggrd.ray = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Ggrd_handling.c:    for(i=0;i < E->control.ggrd.time_hist.nvtimes;i++){
Ggrd_handling.c:	sprintf(tfilename,"%s",E->control.ggrd.ray_file);
Ggrd_handling.c:	sprintf(tfilename,"%s/%i/rayleigh.grd",E->control.ggrd.ray_file,i+1);
Ggrd_handling.c:				    gmt_string,(E->control.ggrd.ray+i),(E->parallel.me == 0),FALSE))
Ggrd_handling.c:    if(E->parallel.me <  E->parallel.nproc-1){ /* tell the next proc to go ahead */
Ggrd_handling.c:			MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Ggrd_handling.c:    E->control.surface_rayleigh = (float *)malloc(sizeof(float)*(E->lmesh.nsf+2));
Ggrd_handling.c:    if(!E->control.surface_rayleigh)
Ggrd_handling.c:  if(timedep || (!E->control.ggrd.ray_control_init)){
Ggrd_handling.c:      ggrd_interpol_time(age,&E->control.ggrd.time_hist,&i1,&i2,&f1,&f2,
Ggrd_handling.c:			 E->control.ggrd.time_hist.vstage_transition);
Ggrd_handling.c:    if(E->parallel.me == 0)
Ggrd_handling.c:    for (m=1;m <= E->sphere.caps_per_proc;m++) {
Ggrd_handling.c:      for (j=1;j <= E->lmesh.nsf;j++)  {
Ggrd_handling.c:	node = j * E->lmesh.noz ;
Ggrd_handling.c:	rout[1] = (double)E->sx[m][1][node];
Ggrd_handling.c:	rout[2] = (double)E->sx[m][2][node];
Ggrd_handling.c:	if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.ray+i1),&indbl,
Ggrd_handling.c:	//fprintf(stderr,"%i %i %g %g %g\n",j,E->lmesh.nsf,rout[1],rout[2],indbl);
Ggrd_handling.c:					   (E->control.ggrd.ray+i2),&indbl2,
Ggrd_handling.c:	E->control.surface_rayleigh[j] = vip;
Ggrd_handling.c:  if((!timedep) && (!E->control.ggrd.ray_control_init)){			/* forget the grid */
Ggrd_handling.c:    ggrd_grdtrack_free_gstruc(E->control.ggrd.ray);
Ggrd_handling.c:  E->control.ggrd.ray_control_init = 1;
Ggrd_handling.c:  const int dims=E->mesh.nsd;
Ggrd_handling.c:  use_codes = (E->control.ggrd_vtop_omega[0] > 1e-7)?(1):(0);
Ggrd_handling.c:  if(E->mesh.topvbc != 1)
Ggrd_handling.c:  noxg = E->lmesh.nox;nozg=E->lmesh.noz;noyg=E->lmesh.noy;
Ggrd_handling.c:  vscale = E->data.scalev * E->data.timedir;
Ggrd_handling.c:    vscale *=  E->data.radius_km*1e3/1e6*1e2*M_PI/180.;		/* for deg/Myr -> cm/yr conversion */
Ggrd_handling.c:  if (E->parallel.me_loc[3] == E->parallel.nprocz-1) { 
Ggrd_handling.c:    if(!E->control.ggrd.time_hist.init){/* init times, if available*/
Ggrd_handling.c:      ggrd_init_thist_from_file(&E->control.ggrd.time_hist,E->control.ggrd.time_hist.file,
Ggrd_handling.c:				TRUE,(E->parallel.me == 0));
Ggrd_handling.c:      E->control.ggrd.time_hist.init = 1;
Ggrd_handling.c:    timedep = (E->control.ggrd.time_hist.nvtimes > 1)?(1):(0);
Ggrd_handling.c:    if(!E->control.ggrd.vtop_control_init){
Ggrd_handling.c:      if(E->parallel.me==0)
Ggrd_handling.c:      E->control.ggrd.svt = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Ggrd_handling.c:      E->control.ggrd.svp = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Ggrd_handling.c:      E->control.ggrd.svt->bandlim = E->control.ggrd.svp->bandlim = 1e6;
Ggrd_handling.c:      for(i=0;i < E->control.ggrd.time_hist.nvtimes;i++){
Ggrd_handling.c:	    sprintf(tfilename1,"%s/code.grd",E->control.ggrd.vtop_dir);
Ggrd_handling.c:	    sprintf(tfilename1,"%s/vt.grd",E->control.ggrd.vtop_dir);
Ggrd_handling.c:	    sprintf(tfilename2,"%s/vp.grd",E->control.ggrd.vtop_dir);
Ggrd_handling.c:	    sprintf(tfilename1,"%s/%i/code.grd",E->control.ggrd.vtop_dir,i+1);
Ggrd_handling.c:	    sprintf(tfilename1,"%s/%i/vt.grd",E->control.ggrd.vtop_dir,i+1);
Ggrd_handling.c:	    sprintf(tfilename2,"%s/%i/vp.grd",E->control.ggrd.vtop_dir,i+1);
Ggrd_handling.c:					gmt_string,(E->control.ggrd.svt+i),(E->parallel.me == 0),FALSE))
Ggrd_handling.c:					gmt_string,(E->control.ggrd.svt+i),(E->parallel.me == 0),FALSE))
Ggrd_handling.c:					gmt_string,(E->control.ggrd.svp+i),(E->parallel.me == 0),FALSE))
Ggrd_handling.c:	snprintf(tfilename1,1000,"%s/codes.%d.gz", E->control.data_dir,E->parallel.me);
Ggrd_handling.c:      if(E->parallel.me == 0)
Ggrd_handling.c:		  E->control.ggrd_vtop_omega[1],
Ggrd_handling.c:		  E->control.ggrd_vtop_omega[2],
Ggrd_handling.c:		  E->control.ggrd_vtop_omega[3],
Ggrd_handling.c:		  (int)E->control.ggrd_vtop_omega[0]);
Ggrd_handling.c:		  E->control.ggrd.time_hist.nvtimes,E->control.ggrd.svp->fmaxlim[0]);
Ggrd_handling.c:    theta_max = (90-E->control.ggrd.svp[0].south)*M_PI/180-1e-5;
Ggrd_handling.c:    theta_min = (90-E->control.ggrd.svp[0].north)*M_PI/180+1e-5;
Ggrd_handling.c:    if((E->parallel.me ==0) && (is_global)){
Ggrd_handling.c:	      E->control.ggrd.svp[0].south,E->control.ggrd.svp[0].north);
Ggrd_handling.c:    if((E->control.ggrd.time_hist.nvtimes > 1)|| (!E->control.ggrd.vtop_control_init)){
Ggrd_handling.c:	  i1 = E->control.ggrd.time_hist.nvtimes - 1;
Ggrd_handling.c:	  if(E->parallel.me == 0)
Ggrd_handling.c:	  ggrd_interpol_time(age,&E->control.ggrd.time_hist,&i1,&i2,&f1,&f2,
Ggrd_handling.c:			     E->control.ggrd.time_hist.vstage_transition);
Ggrd_handling.c:	  if(E->parallel.me == 0)
Ggrd_handling.c:	if(E->parallel.me == 0)
Ggrd_handling.c:      if(E->parallel.me==0){
Ggrd_handling.c:      if(E->control.ggrd_allow_mixed_vbcs){
Ggrd_handling.c:	if(E->parallel.me == 0)
Ggrd_handling.c:	cutoff = E->control.ggrd.svp->fmaxlim[0] + 1e-5;	  
Ggrd_handling.c:	for(level=E->mesh.gridmax;level>=E->mesh.gridmin;level--){/* multigrid levels */
Ggrd_handling.c:	  noxl = E->lmesh.NOX[level];
Ggrd_handling.c:	  noyl = E->lmesh.NOY[level];
Ggrd_handling.c:	  nozl = E->lmesh.NOZ[level];
Ggrd_handling.c:	  for (m=1;m <= E->sphere.caps_per_proc;m++) {
Ggrd_handling.c:		rout[1] = E->SX[level][m][1][nodel]; /* theta,phi */
Ggrd_handling.c:		rout[2] = E->SX[level][m][2][nodel];
Ggrd_handling.c:		if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svp+i1),
Ggrd_handling.c:		  if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svp+i2),vin2,
Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] & (~VBX);
Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] | SBX;
Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] & (~VBY);
Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] | SBY;
Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] | VBX;
Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] & (~SBX);
Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] | VBY;
Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] & (~SBY);
Ggrd_handling.c:      for (m=1;m <= E->sphere.caps_per_proc;m++) {
Ggrd_handling.c:	  cutoff = E->control.ggrd.svp->fmaxlim[0] * vscale + 1e-5;
Ggrd_handling.c:	    gzprintf(fp1,"%3d %7d\n",m,E->lmesh.nsf);
Ggrd_handling.c:	    rout[1] = E->sx[m][1][nodel]; /* theta,phi coordinates */
Ggrd_handling.c:	    rout[2] = E->sx[m][2][nodel];
Ggrd_handling.c:	    if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svt+i1),
Ggrd_handling.c:	      if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svp+i1),
Ggrd_handling.c:	      if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svt+i2),vin2,
Ggrd_handling.c:		if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svp+i2),(vin2+1),
Ggrd_handling.c:	      if((int)E->control.ggrd_vtop_omega[0] == code){
Ggrd_handling.c:		vx[1]=E->control.ggrd_vtop_omega[2]*E->x[m][3][nodel] - E->control.ggrd_vtop_omega[3]*E->x[m][2][nodel]; 
Ggrd_handling.c:		vx[2]=E->control.ggrd_vtop_omega[3]*E->x[m][1][nodel] - E->control.ggrd_vtop_omega[1]*E->x[m][3][nodel]; 
Ggrd_handling.c:		vx[3]=E->control.ggrd_vtop_omega[1]*E->x[m][2][nodel] - E->control.ggrd_vtop_omega[2]*E->x[m][1][nodel]; 
Ggrd_handling.c:	      E->sphere.cap[m].VB[1][nodel] = 0;	/* theta */
Ggrd_handling.c:	      E->sphere.cap[m].VB[2][nodel] = 0;	/* phi */
Ggrd_handling.c:	      E->sphere.cap[m].VB[1][nodel] = v[1];	/* theta */
Ggrd_handling.c:	      E->sphere.cap[m].VB[2][nodel] = v[2];	/* phi */
Ggrd_handling.c:	    E->sphere.cap[m].VB[3][nodel] = 0.0; /* r */
Ggrd_handling.c:      if((!timedep)&&(!E->control.ggrd.vtop_control_init)){			/* forget the grids */
Ggrd_handling.c:	ggrd_grdtrack_free_gstruc(E->control.ggrd.svt);
Ggrd_handling.c:	ggrd_grdtrack_free_gstruc(E->control.ggrd.svp);
Ggrd_handling.c:  E->control.ggrd.vtop_control_init = 1;
Ggrd_handling.c:  if(E->parallel.me == 0)fprintf(stderr,"vtop from grd done: %i\n",lc++);
Ggrd_handling.c:  if(!E->control.ggrd.ray_control_init)
Ggrd_handling.c:  if(E->parallel.me == 0)
Ggrd_handling.c:	    E->control.ggrd.ray_control);
Ggrd_handling.c:  for(m=1;m <= E->sphere.caps_per_proc;m++){
Ggrd_handling.c:    for(snode=1;snode <= E->lmesh.nsf;snode++){ /* loop through surface nodes */
Ggrd_handling.c:      if(fabs(E->control.surface_rayleigh[snode]-1.0)>1e-6){
Ggrd_handling.c:	for(i=1;i <= E->lmesh.noz;i++){ /* go through depth layers */
Ggrd_handling.c:	  node = (snode-1)*E->lmesh.noz + i; /* global node number */
Ggrd_handling.c:	  if(layers(E,m,node) <= E->control.ggrd.ray_control){ 
Ggrd_handling.c:	    xloc=1.0 + ((1 - E->sx[m][3][node]) - 
Ggrd_handling.c:			E->viscosity.zbase_layer[E->control.ggrd.ray_control-1])/
Ggrd_handling.c:	      E->viscosity.zbase_layer[E->control.ggrd.ray_control-1];
Ggrd_handling.c:	    bnew = buoy[m][node] * E->control.surface_rayleigh[snode]; /* modified rayleigh */
Ggrd_handling.c:	    /* 	    	    (1 - E->sx[m][3][node])*E->data.radius_km,E->control.ggrd.ray_control, */
Ggrd_handling.c:	    /* 	    	    E->viscosity.zbase_layer[E->control.ggrd.ray_control-1]*E->data.radius_km, */
Ggrd_handling.c:	    /* 	    	    fac,E->control.surface_rayleigh[snode],(fac * bnew + (1-fac)*buoy[m][node]),buoy[m][node]); */
Global_operations.c:    const int dims = E->mesh.nsd;
Global_operations.c:    noy = E->lmesh.noy;
Global_operations.c:    noz = E->lmesh.noz;
Global_operations.c:    nox = E->lmesh.nox;
Global_operations.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:    H = (double *)malloc( (E->lmesh.noz+1)*sizeof(double));
Global_operations.c:  const int dims = E->mesh.nsd;
Global_operations.c:  sizeofH = (2*E->lmesh.noz+2)*sizeof(double);
Global_operations.c:  noz = E->lmesh.noz;
Global_operations.c:  noy = E->lmesh.noy;
Global_operations.c:  elz = E->lmesh.elz;
Global_operations.c:  elx = E->lmesh.elx;
Global_operations.c:  ely = E->lmesh.ely;
Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:          lnode[1] = E->ien[m][el].node[1];
Global_operations.c:          lnode[2] = E->ien[m][el].node[2];
Global_operations.c:          lnode[3] = E->ien[m][el].node[3];
Global_operations.c:          lnode[4] = E->ien[m][el].node[4];
Global_operations.c:          for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Global_operations.c:            for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:              temp[i] += X[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Global_operations.c:            lnode[1] = E->ien[m][el].node[5];
Global_operations.c:            lnode[2] = E->ien[m][el].node[6];
Global_operations.c:            lnode[3] = E->ien[m][el].node[7];
Global_operations.c:            lnode[4] = E->ien[m][el].node[8];
Global_operations.c:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Global_operations.c:              for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:                temp[i+1] += X[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Global_operations.c:  MPI_Allreduce(temp,Have,noz2+1,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c: /* if (E->parallel.me==0)
Global_operations.c:      fprintf(stderr,"area %d %d %g\n",E->parallel.me,i,Have[i+noz]);
Global_operations.c:  const int dims = E->mesh.nsd;
Global_operations.c:  sizeofH = (2*E->lmesh.noz+2)*sizeof(float);
Global_operations.c:  noz = E->lmesh.noz;
Global_operations.c:  noy = E->lmesh.noy;
Global_operations.c:  elz = E->lmesh.elz;
Global_operations.c:  elx = E->lmesh.elx;
Global_operations.c:  ely = E->lmesh.ely;
Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:          lnode[1] = E->ien[m][el].node[1];
Global_operations.c:          lnode[2] = E->ien[m][el].node[2];
Global_operations.c:          lnode[3] = E->ien[m][el].node[3];
Global_operations.c:          lnode[4] = E->ien[m][el].node[4];
Global_operations.c:          for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Global_operations.c:            for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:              temp[i] += X[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Global_operations.c:            lnode[1] = E->ien[m][el].node[5];
Global_operations.c:            lnode[2] = E->ien[m][el].node[6];
Global_operations.c:            lnode[3] = E->ien[m][el].node[7];
Global_operations.c:            lnode[4] = E->ien[m][el].node[8];
Global_operations.c:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Global_operations.c:              for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:                temp[i+1] += X[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Global_operations.c:  MPI_Allreduce(temp,Have,noz2+1,MPI_FLOAT,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c: /* if (E->parallel.me==0)
Global_operations.c:      fprintf(stderr,"area %d %d %g\n",E->parallel.me,i,Have[i+noz]);
Global_operations.c:  sizeofH = (2*E->lmesh.elz+2)*sizeof(double);
Global_operations.c:  noz = E->lmesh.noz;
Global_operations.c:  noy = E->lmesh.noy;
Global_operations.c:  elz = E->lmesh.elz;
Global_operations.c:  elx = E->lmesh.elx;
Global_operations.c:  ely = E->lmesh.ely;
Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:          temp[i] += X[m][el]*E->ECO[E->mesh.levmax][m][el].area;
Global_operations.c:          temp[i+elz] += E->ECO[E->mesh.levmax][m][el].area;
Global_operations.c:  MPI_Allreduce(temp,Have,elz2+1,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c:    const int vpts = vpoints[E->mesh.nsd];
Global_operations.c:    const int ends = enodes[E->mesh.nsd];
Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:       for (el=1;el<=E->lmesh.nel;el++)  {
Global_operations.c:		n = E->ien[m][el].node[i];
Global_operations.c:		volume1 += E->N.vpt[GNVINDEX(i,j)] * E->gDA[m][el].vpt[j];
Global_operations.c:		integral1 += Z[m][n] * E->N.vpt[GNVINDEX(i,j)] * E->gDA[m][el].vpt[j];
Global_operations.c:    MPI_Allreduce(&volume1  ,&volume  ,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Global_operations.c:    MPI_Allreduce(&integral1,&integral,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Global_operations.c:    const int vpts = vpoints[E->mesh.nsd];
Global_operations.c:    const int ends = enodes[E->mesh.nsd];
Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:       for (el=1;el<=E->lmesh.nel;el++)  {
Global_operations.c:                n = E->ien[m][el].node[i];
Global_operations.c:                volume1 += E->N.vpt[GNVINDEX(i,j)] * E->gDA[m][el].vpt[j];
Global_operations.c:                integral1 += Z[m][n] * E->N.vpt[GNVINDEX(i,j)] * E->gDA[m][el].vpt[j];
Global_operations.c:    MPI_Allreduce(&volume1  ,&volume  ,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:    MPI_Allreduce(&integral1,&integral,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c: MPI_Allreduce(&Tmax,&ttmax,1,MPI_FLOAT,MPI_MAX,E->parallel.horizontal_comm);
Global_operations.c: temp = (double *) malloc((E->sphere.hindice*2+3)*sizeof(double));
Global_operations.c: sphcs = (double *) malloc((E->sphere.hindice*2+3)*sizeof(double));
Global_operations.c: jumpp = E->sphere.hindice;
Global_operations.c: total = E->sphere.hindice*2+3;
Global_operations.c: for (j=0;j<E->sphere.hindice;j++)   {
Global_operations.c: sphcs[total-1] = sphs[E->sphere.hindice];
Global_operations.c: MPI_Allreduce(sphcs,temp,total,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c: for (j=0;j<E->sphere.hindice;j++)   {
Global_operations.c: sphs[E->sphere.hindice]=temp[total-1];
Global_operations.c: temp = (float *) malloc((E->sphere.hindice*2+3)*sizeof(float));
Global_operations.c: sphcs = (float *) malloc((E->sphere.hindice*2+3)*sizeof(float));
Global_operations.c: jumpp = E->sphere.hindice;
Global_operations.c: total = E->sphere.hindice*2+3;
Global_operations.c: for (j=0;j<E->sphere.hindice;j++)   {
Global_operations.c: sphcs[total-1] = sphs[E->sphere.hindice];
Global_operations.c: MPI_Allreduce(sphcs,temp,total,MPI_FLOAT,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c: for (j=0;j<E->sphere.hindice;j++)   {
Global_operations.c: sphs[E->sphere.hindice]=temp[total-1];
Global_operations.c:  neq=E->lmesh.NEQ[lev];
Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:    neq=E->lmesh.NEQ[lev];
Global_operations.c:    for (i=1;i<=E->parallel.Skip_neq[lev][m];i++)
Global_operations.c:       temp1 += A[m][E->parallel.Skip_id[lev][m][i]]*B[m][E->parallel.Skip_id[lev][m][i]];
Global_operations.c:  MPI_Allreduce(&temp, &prod,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:    neq=E->lmesh.NEQ[lev];
Global_operations.c:    for (i=1;i<=E->parallel.Skip_neq[lev][m];i++)
Global_operations.c:      if ((E->parallel.Skip_id[lev][m][i]+1)%3==0)
Global_operations.c:        temp1 += A[m][E->parallel.Skip_id[lev][m][i]]*A[m][E->parallel.Skip_id[lev][m][i]];
Global_operations.c:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:  const int ends=enodes[E->mesh.nsd];
Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:    nel=E->lmesh.nel;
Global_operations.c:      if (E->viscosity.sdepv_expt[E->mat[m][e]-1]>1.01)  {   // for non-Newt 
Global_operations.c:          node = E->ien[m][e].node[a];
Global_operations.c:          for (j=1;j<=E->mesh.nsd;j++) {
Global_operations.c:            i = E->id[m][node].doff[j];
Global_operations.c:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:    neq=E->lmesh.NEQ[lev];
Global_operations.c:    for (i=1;i<=E->parallel.Skip_neq[lev][m];i++)
Global_operations.c:       temp1 += A[m][E->parallel.Skip_id[lev][m][i]]*B[m][E->parallel.Skip_id[lev][m][i]];
Global_operations.c:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:  npno=E->lmesh.NPNO[lev];
Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:    npno=E->lmesh.NPNO[lev];
Global_operations.c:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Global_operations.c:        for (i=1; i<=E->lmesh.nno; i++) {
Global_operations.c:            eqn1 = E->id[m][i].doff[1];
Global_operations.c:            eqn2 = E->id[m][i].doff[2];
Global_operations.c:            eqn3 = E->id[m][i].doff[3];
Global_operations.c:                     V[m][eqn3] * V[m][eqn3]) * E->NMass[m][i];
Global_operations.c:    MPI_Allreduce(&temp, &prod, 1, MPI_DOUBLE, MPI_SUM, E->parallel.world);
Global_operations.c:    return (prod/E->mesh.volume);
Global_operations.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Global_operations.c:        for (i=1; i<=E->lmesh.npno; i++) {
Global_operations.c:            temp += P[m][i] * P[m][i] * E->eco[m][i].area;
Global_operations.c:    MPI_Allreduce(&temp, &prod, 1, MPI_DOUBLE, MPI_SUM, E->parallel.world);
Global_operations.c:    return (prod/E->mesh.volume);
Global_operations.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Global_operations.c:        for (i=1; i<=E->lmesh.npno; i++) {
Global_operations.c:            temp += A[m][i] * A[m][i] / E->eco[m][i].area;
Global_operations.c:    MPI_Allreduce(&temp, &prod, 1, MPI_DOUBLE, MPI_SUM, E->parallel.world);
Global_operations.c:    return (prod/E->mesh.volume);
Global_operations.c:  nno=E->lmesh.NNO[lev];
Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:    nno=E->lmesh.NNO[lev];
Global_operations.c:    if (!(E->NODE[lev][m][i] & SKIP))
Global_operations.c:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:    nno=E->lmesh.NNO[lev];
Global_operations.c:      if (!(E->NODE[lev][m][i] & SKIP))
Global_operations.c:  MPI_Allreduce(&temp, &prod,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Global_operations.c:  MPI_Allreduce(&a, &temp,1,MPI_FLOAT,MPI_MIN,E->parallel.world);
Global_operations.c:  MPI_Allreduce(&a, &temp,1,MPI_DOUBLE,MPI_MAX,E->parallel.world);
Global_operations.c:  MPI_Allreduce(&a, &temp,1,MPI_FLOAT,MPI_MAX,E->parallel.world);
Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:    for(i=1;i<=E->lmesh.nno;i++)
Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:    for(i=1;i<=E->lmesh.nno;i++)
Global_operations.c: const int dims = E->mesh.nsd;
Global_operations.c: const int nel=E->lmesh.nel;
Global_operations.c:for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:   /*if (E->mat[m][e]==1)*/
Global_operations.c:	 node = E->IEN[lev][m][e].node[a];
Global_operations.c:         dtemp += dU[m][ E->ID[lev][m][node].doff[i] ]*
Global_operations.c:                  dU[m][ E->ID[lev][m][node].doff[i] ];
Global_operations.c:         temp += U[m][ E->ID[lev][m][node].doff[i] ]*
Global_operations.c:                 U[m][ E->ID[lev][m][node].doff[i] ];
Global_operations.c:  MPI_Allreduce(&dtemp, &temp2,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:  MPI_Allreduce(&temp, &temp1,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:    if (E->parallel.nprocz > 1)  {
Global_operations.c:	total = E->sphere.hindice*2;
Global_operations.c:	jumpp = E->sphere.hindice;
Global_operations.c:	for (j=0;j<E->sphere.hindice;j++)   {
Global_operations.c:		      E->parallel.vertical_comm);
Global_operations.c:	for (j=0;j<E->sphere.hindice;j++)   {
Global_operations.c:    if(E->parallel.nprocz == 1) return;
Global_operations.c:    jumpp = E->sphere.hindice;
Global_operations.c:    total = E->sphere.hindice*2;
Global_operations.c:    if (E->parallel.me_loc[3] == root) {
Global_operations.c:        for (j=0; j<E->sphere.hindice; j++)   {
Global_operations.c:    MPI_Bcast(temp, total, MPI_DOUBLE, root, E->parallel.vertical_comm);
Global_operations.c:    if (E->parallel.me_loc[3] != root) {
Global_operations.c:        for (j=0; j<E->sphere.hindice; j++)   {
Global_operations.c:    const int lev = E->mesh.levmax;
Global_operations.c:    const int nno = E->lmesh.nno;
Global_operations.c:    if(E->control.remove_angular_momentum) {
Global_operations.c:        for (i=1;i<=E->lmesh.elz;i++)
Global_operations.c:                0.5*(E->refstate.rho[i] + E->refstate.rho[i+1])*
Global_operations.c:                (pow(E->sx[1][3][i+1],5.0) - pow(E->sx[1][3][i],5.0));
Global_operations.c:                      MPI_SUM, E->parallel.vertical_comm);
Global_operations.c:            (pow(E->sphere.ro,5.0) - pow(E->sphere.ri,5.0));
Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++) {
Global_operations.c:      for (e=1;e<=E->lmesh.nel;e++) {
Global_operations.c:	t = theta_g(E->eco[m][e].centre[1],E);
Global_operations.c:	t = E->eco[m][e].centre[1];
Global_operations.c:	f = E->eco[m][e].centre[2];
Global_operations.c:	r = E->eco[m][e].centre[3];
Global_operations.c:	    vx[j] += VV[1][i]*E->N.ppt[GNPINDEX(i,j)]; 
Global_operations.c:	    vy[j] += VV[2][i]*E->N.ppt[GNPINDEX(i,j)]; 
Global_operations.c:        if(E->control.remove_angular_momentum) {
Global_operations.c:            int nz = (e-1) % E->lmesh.elz + 1;
Global_operations.c:            rho = 0.5 * (E->refstate.rho[nz] + E->refstate.rho[nz+1]);
Global_operations.c:	exyz[1] += (wx*cos_t*cos_f - wy*sin_f) * E->eco[m][e].area * rho;
Global_operations.c:	exyz[2] += (wx*cos_t*sin_f + wy*cos_f) * E->eco[m][e].area * rho;
Global_operations.c:	exyz[3] -= (wx*sin_t                 ) * E->eco[m][e].area * rho;
Global_operations.c:    MPI_Allreduce(exyz,fxyz,4,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:    if (E->parallel.me==0) {
Global_operations.c:        if(E->control.remove_angular_momentum) {
Global_operations.c:            fprintf(E->fp,"Angular momentum: rot=%e tr=%e fr=%e\n",rot,tr*180/M_PI,fr*180/M_PI);
Global_operations.c:            fprintf(E->fp,"Rigid rotation: rot=%e tr=%e fr=%e\n",rot,tr*180/M_PI,fr*180/M_PI);
Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:	vx[0] = fxyz[2]* E->x[m][3][node] - fxyz[3]*E->x[m][2][node];
Global_operations.c:	vx[1] = fxyz[3]* E->x[m][1][node] - fxyz[1]*E->x[m][3][node];
Global_operations.c:	vx[2] = fxyz[1]* E->x[m][2][node] - fxyz[2]*E->x[m][1][node];
Global_operations.c:	E->sphere.cap[m].V[1][node] -= v_theta;
Global_operations.c:	E->sphere.cap[m].V[2][node] -= v_phi;
Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Global_operations.c:	frd = fr - E->sx[m][2][node];
Global_operations.c:	v_theta = E->sx[m][3][node] * sin_t * sin(frd);
Global_operations.c:	v_phi =   E->sx[m][3][node] * 
Global_operations.c:	  (  E->SinCos[lev][m][0][node] * cos_t - E->SinCos[lev][m][2][node]  * sin_t * cos(frd) );
Global_operations.c:	E->sphere.cap[m].V[1][node] -= v_theta;
Global_operations.c:	E->sphere.cap[m].V[2][node] -= v_phi;
Global_operations.c://        E->U[m][E->id[m][node].doff[1]] = E->sphere.cap[m].V[1][node];
Global_operations.c://        E->U[m][E->id[m][node].doff[2]] = E->sphere.cap[m].V[2][node];
Global_operations.c:    if (E->parallel.me_loc[3] != E->parallel.nprocz-1)  return;
Global_operations.c:    if (E->parallel.me == 0)  time = CPU_time0();
Global_operations.c:    sphc = E->sphere.sphc[0] ;
Global_operations.c:    sphs = E->sphere.sphs[0] ;
Global_operations.c:    for (i=0;i<E->sphere.hindice;i++) sphc[i] = sphs[i] = 0.0 ;
Global_operations.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Global_operations.c:    for (es=1;es<=E->lmesh.snel;es++) {
Global_operations.c:        el = (E->lmesh.elz*es) ;
Global_operations.c:        for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Global_operations.c:            for(k1=1;k1<=onedvpoints[E->mesh.nsd];k1++)   
Global_operations.c:                temp0[k] +=  X3[j][E->sien[j][es].node[k1]] 
Global_operations.c:                           * E->M.vpt[GMVINDEX(k1,k)];
Global_operations.c:        area += E->gDA1[j][es].vpt[5];
Global_operations.c:        for(k=1;k<=onedvpoints[E->mesh.nsd];k++)
Global_operations.c:            temp0[k] = temp0[k]*E->gDA1[j][es].vpt[k];
Global_operations.c:            p = E->sphere.hindex[ll][mm];
Global_operations.c:            for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Global_operations.c:                sphc[p]+= temp0[k] *E->Sph_Harm_Tblcs[j][mm][es].cs[k]
Global_operations.c:                                   *E->Sph_Harm_Tbllm[j][p][es].lm[k];
Global_operations.c:                sphs[p]+= temp0[k] *E->Sph_Harm_Tblcs[j][mm][es].sn[k]
Global_operations.c:                                   *E->Sph_Harm_Tbllm[j][p][es].lm[k];
Global_operations.c:    sphs[E->sphere.hindice] = area;
Global_operations.c:    area = 4.0*M_PI/sphs[E->sphere.hindice];
Global_operations.c:    for (i=0;i<E->sphere.hindice;i++)    {
Global_operations.c:    // (but it takes ll from 1 to E->sphere.output_llmax)
Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:    for (j=1;j<=E->lmesh.nsf;j++) {
Global_operations.c:            p = E->sphere.hindex[ll][mm]; 
Global_operations.c:            X3[m][j] += E->Tbl_lm[m][p][j] *
Global_operations.c:                        ( E->Tbl_cs[m][mm][j]* sphc[p] 
Global_operations.c:                        + E->Tbl_sn[m][mm][j]* sphs[p] ) ;
Global_operations.c:    if (verbose && E->parallel.me==0)
Global_operations.c:        fp = (i==0)? stderr : E->fp ;
Global_operations.c:    const int dims = E->mesh.nsd;
Global_operations.c:    const int lev = E->mesh.levmax;
Global_operations.c:    nox = E->lmesh.nox;
Global_operations.c:    noy = E->lmesh.noy;
Global_operations.c:    elx = E->lmesh.elx;
Global_operations.c:    ely = E->lmesh.ely;
Global_operations.c:    elz = E->lmesh.elz;
Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:            lnode[d] = E->sien[m][el].node[d];
Global_operations.c:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)
Global_operations.c:            for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:                temp[1] += X3[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)] 
Global_operations.c:                          * E->gDA0[m][el].vpt[nint];
Global_operations.c:            temp[2] += E->gDA0[m][el].vpt[5];
Global_operations.c:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)
Global_operations.c:            for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:                temp[1] += X3[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)] 
Global_operations.c:                          * E->gDA1[m][el].vpt[nint];
Global_operations.c:            temp[2] += E->gDA1[m][el].vpt[5];
Global_operations.c:  MPI_Allreduce(temp,Have,3,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c: * E->data.CM_incr will be affected depending on the value of add_incr_CM:
Global_operations.c: *    0 => E->data.CM_incr is not changed
Global_operations.c: *    1 => the computed CM is put into E->data.CM_incr 
Global_operations.c: *    2 => the computed CM is added to E->data.CM_incr 
Global_operations.c:    const int dims = E->mesh.nsd;
Global_operations.c:    const int lev = E->mesh.levmax;
Global_operations.c:        earth_mass =  4.0*M_PI / 3.0 * pow(E->sphere.dradius,3) 
Global_operations.c:                     *(   pow(E->sphere.ri,3) * E->data.density_below
Global_operations.c:                        + pow(E->sphere.ro,3) * E->data.density      
Global_operations.c:                        - pow(E->sphere.ri,3) * E->data.density   );
Global_operations.c:        c_surf  = 1.0/ E->ve_data_cont.surf_scaling ; // nondim stress -> nondim height
Global_operations.c:        c_surf *= E->sphere.dradius ;    // -> dim'ful height 
Global_operations.c:        c_surf *= E->data.density ;      // -> dim'ful mass/area
Global_operations.c:        c_surf *= ( E->sphere.dradius*E->sphere.dradius ) / earth_mass; 
Global_operations.c:        c_surf *= E->sphere.ro ;
Global_operations.c:            c_cmb   = 1.0/ E->ve_data_cont.botm_scaling ;
Global_operations.c:            c_cmb  *= E->sphere.dradius ;    // -> dim'ful height 
Global_operations.c:            c_cmb  *= (E->data.density_below - E->data.density) ;
Global_operations.c:            c_cmb   = E->ve_data_cont.shear_mod ;   // rho.g.h
Global_operations.c:            c_cmb  *= 1.0/E->data.grav_acc ;
Global_operations.c:        c_cmb  *= ( E->sphere.dradius*E->sphere.dradius ) / earth_mass; 
Global_operations.c:        c_cmb  *= E->sphere.ri ;
Global_operations.c:        E->ve_data_cont.CM[0] = 0.0 ;
Global_operations.c:        E->ve_data_cont.CM[1] = 0.0 ;
Global_operations.c:        E->ve_data_cont.CM[2] = 0.0 ;
Global_operations.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Global_operations.c:    for (k=1; k<=E->lmesh.ely; k++)
Global_operations.c:    for (j=1; j<=E->lmesh.elx; j++) {
Global_operations.c:        el = j + (k-1)*E->lmesh.elx;
Global_operations.c:        for(d=1;d<=onedvpoints[E->mesh.nsd];d++) {
Global_operations.c:            lnode[d] = E->sien[m][el].node[d];
Global_operations.c:        for(d =1; d <=onedvpoints[E->mesh.nsd]; d++) 
Global_operations.c:        for(d1=1; d1<=onedvpoints[E->mesh.nsd]; d1++) {
Global_operations.c:            i = lnode[d1]*E->lmesh.noz;
Global_operations.c:            tempx[d] += E->X[E->mesh.levmax][m][1][i]*E->M.vpt[GMVINDEX(d1,d)];
Global_operations.c:            tempy[d] += E->X[E->mesh.levmax][m][2][i]*E->M.vpt[GMVINDEX(d1,d)];
Global_operations.c:            tempz[d] += E->X[E->mesh.levmax][m][3][i]*E->M.vpt[GMVINDEX(d1,d)];
Global_operations.c:            temps[d] += X_surf[m][lnode[d1]]*E->M.vpt[GMVINDEX(d1,d)];
Global_operations.c:            tempb[d] += X_cmb[m][lnode[d1]]*E->M.vpt[GMVINDEX(d1,d)];
Global_operations.c:        if (E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Global_operations.c:          for(d =1; d <=onedvpoints[E->mesh.nsd]; d++)   { 
Global_operations.c:                      * E->gDA1[m][el].vpt[d];
Global_operations.c:        if (E->parallel.me_loc[3] == 0) {
Global_operations.c:          for(d =1; d <=onedvpoints[E->mesh.nsd]; d++)   { 
Global_operations.c:                      * E->gDA0[m][el].vpt[d];
Global_operations.c:       fprintf(E->fp_out,"CMtemp %g %g %g %d\n",temp[0],temp[1],temp[2],E->parallel.me);
Global_operations.c:       fprintf(E->fp_out,"CMtemp %g %g %g %d\n",temp0[0],temp0[1],temp0[2],E->parallel.me);
Global_operations.c:        MPI_Allreduce(temp,cm,3,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:       fprintf(E->fp_out,"CMtemp %g %g %g %d\n",temp[0],temp[1],temp[2],E->parallel.me);
Global_operations.c:       fprintf(E->fp_out,"CM %g %g %g %d %d %d\n",cm[0],cm[1],cm[2],E->parallel.me,E->monitor.solution_cycles,add_incr_CM);
Global_operations.c:       fflush(E->fp_out);
Global_operations.c:        for (i=0;i<3;i++) E->ve_data_cont.CM_incr[i] = cm[i] ;
Global_operations.c:        for (i=0;i<3;i++) E->ve_data_cont.CM_incr[i] += cm[i] ;
Global_operations.c:    load_height_surf = r0 * E->ve_data_cont.surf_scaling  ;
Global_operations.c:    load_height_cmb  = r0 * E->ve_data_cont.botm_scaling  ;
Global_operations.c:    if (E->parallel.me_loc[3]==E->parallel.nprocz-1) {
Global_operations.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:      for (j=1;j<=E->lmesh.nsf;j++)    {
Global_operations.c:        i = j*E->lmesh.noz;
Global_operations.c:        t1 = E->SX[E->mesh.levmax][m][1][i];
Global_operations.c:        f1 = E->SX[E->mesh.levmax][m][2][i];
Global_operations.c:    if (E->parallel.me_loc[3]==0) {
Global_operations.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:      for (j=1;j<=E->lmesh.nsf;j++)    {
Global_operations.c:        i = j*E->lmesh.noz;
Global_operations.c:        t1 = E->SX[E->mesh.levmax][m][1][i];
Global_operations.c:        f1 = E->SX[E->mesh.levmax][m][2][i];
Global_operations.c:    const int dims = E->mesh.nsd;
Global_operations.c:    const int lev = E->mesh.levmax;
Global_operations.c:        earth_mass =  4.0*M_PI / 3.0 * pow(E->sphere.dradius,3) 
Global_operations.c:                     *(   pow(E->sphere.ri,3) * E->data.density_below
Global_operations.c:                        + pow(E->sphere.ro,3) * E->data.density      
Global_operations.c:                        - pow(E->sphere.ri,3) * E->data.density   );
Global_operations.c:        earth_mass = earth_mass/(E->data.density*pow(E->sphere.dradius,3));
Global_operations.c:        E->ve_data_cont.CM[0] = 0.0 ;
Global_operations.c:        E->ve_data_cont.CM[1] = 0.0 ;
Global_operations.c:        E->ve_data_cont.CM[2] = 0.0 ;
Global_operations.c:    cm[0] = -E->ve_data_cont.CM_pot[1]*sqrt(12.0*M_PI)/earth_mass;
Global_operations.c:    cm[1] = -E->ve_data_cont.CM_pot[2]*sqrt(12.0*M_PI)/earth_mass;
Global_operations.c:    cm[2] =  E->ve_data_cont.CM_pot[0]*sqrt(12.0*M_PI)/earth_mass;
Global_operations.c:       fprintf(E->fp_out,"CM %g %g %g %d %d %d\n",cm[0],cm[1],cm[2],E->parallel.me,E->monitor.solution_cycles,add_incr_CM);
Global_operations.c:       fflush(E->fp_out);
Global_operations.c:        for (i=0;i<3;i++) E->ve_data_cont.CM_incr[i] = cm[i] ;
Global_operations.c:        for (i=0;i<3;i++) E->ve_data_cont.CM_incr[i] += cm[i] ;
Global_operations.c:    load_height_surf = r0 * E->ve_data_cont.surf_scaling  ;
Global_operations.c:    load_height_cmb  = r0 * E->ve_data_cont.botm_scaling  ;
Global_operations.c:    if (E->parallel.me_loc[3]==E->parallel.nprocz-1) {
Global_operations.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:      for (j=1;j<=E->lmesh.nsf;j++)    {
Global_operations.c:        i = j*E->lmesh.noz;
Global_operations.c:        t1 = E->SX[E->mesh.levmax][m][1][i];
Global_operations.c:        f1 = E->SX[E->mesh.levmax][m][2][i];
Global_operations.c:    if (E->parallel.me_loc[3]==0) {
Global_operations.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:      for (j=1;j<=E->lmesh.nsf;j++)    {
Global_operations.c:        i = j*E->lmesh.noz;
Global_operations.c:        t1 = E->SX[E->mesh.levmax][m][1][i];
Global_operations.c:        f1 = E->SX[E->mesh.levmax][m][2][i];
Global_operations.c: * doesn't change the surface arrays or E->data.CM*.
Global_operations.c:    const int dims = E->mesh.nsd;
Global_operations.c:    const int lev = E->mesh.levmax;
Global_operations.c:        earth_mass =  4.0*M_PI / 3.0 * pow(E->sphere.dradius,3) 
Global_operations.c:                     *(   pow(E->sphere.ri,3) * E->data.density_below
Global_operations.c:                        + pow(E->sphere.ro,3) * E->data.density      
Global_operations.c:                        - pow(E->sphere.ri,3) * E->data.density   );
Global_operations.c:        c_surf  = 1.0/ E->ve_data_cont.surf_scaling ; // nondim stress -> nondim height
Global_operations.c:        c_surf *= E->sphere.dradius ;    // -> dim'ful height 
Global_operations.c:        c_surf *= E->data.density ;      // -> dim'ful mass/area
Global_operations.c:        c_surf *= ( E->sphere.dradius*E->sphere.dradius ) / earth_mass; 
Global_operations.c:        c_surf *= E->sphere.ro ;
Global_operations.c:        c_cmb   = E->ve_data_cont.shear_mod ;   // rho.g.h
Global_operations.c:        c_cmb  *= 1.0/E->data.grav_acc ;
Global_operations.c:        c_cmb  *= ( E->sphere.dradius*E->sphere.dradius ) / earth_mass; 
Global_operations.c:        c_cmb  *= E->sphere.ri ;
Global_operations.c:        E->ve_data_cont.CM[0] = 0.0 ;
Global_operations.c:        E->ve_data_cont.CM[1] = 0.0 ;
Global_operations.c:        E->ve_data_cont.CM[2] = 0.0 ;
Global_operations.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Global_operations.c:    for (k=1; k<=E->lmesh.ely; k++)
Global_operations.c:    for (j=1; j<=E->lmesh.elx; j++) {
Global_operations.c:        el = j + (k-1)*E->lmesh.elx;
Global_operations.c:        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:            lnode[d] = E->sien[m][el].node[d];
Global_operations.c:        for(d =1; d <=onedvpoints[E->mesh.nsd]; d++) 
Global_operations.c:        for(d1=1; d1<=onedvpoints[E->mesh.nsd]; d1++) {
Global_operations.c:            i = lnode[d1]*E->lmesh.noz;
Global_operations.c:            t1 = E->SX[E->mesh.levmax][m][1][i];
Global_operations.c:            f1 = E->SX[E->mesh.levmax][m][2][i];
Global_operations.c:                      * E->gDA1[m][el].vpt[d] * E->M.vpt[GMVINDEX(d1,d)] ;
Global_operations.c:                      * E->gDA0[m][el].vpt[d] * E->M.vpt[GMVINDEX(d1,d)] ;
Global_operations.c:   MPI_Allreduce(temp,cm,3,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c:    for (i=0;i<3;i++) E->ve_data_cont.CM_incr[i] = cm[i] ;
Global_operations.c:    if (E->parallel.me==0)
Global_operations.c:        fp = (i==0)? stderr : E->fp ;
Global_operations.c:                    E->monitor.solution_cycles,
Global_operations.c:                    E->monitor.solution_cycles,
Global_operations.c:                    E->ve_data_cont.CM[0], E->ve_data_cont.CM[1], E->ve_data_cont.CM[2] );
Global_operations.c: * mass location (stored in E->data.CM_incr).  This keeps the field X in a
Global_operations.c:    xy_mag = sqrt(  E->ve_data_cont.CM_incr[0]*E->ve_data_cont.CM_incr[0] 
Global_operations.c:                  + E->ve_data_cont.CM_incr[1]*E->ve_data_cont.CM_incr[1] );
Global_operations.c:    r0 = sqrt( E->ve_data_cont.CM_incr[2]*E->ve_data_cont.CM_incr[2] + xy_mag*xy_mag );
Global_operations.c:        t0 = acos( E->ve_data_cont.CM_incr[2]/r0 );
Global_operations.c:        f0 = acos( E->ve_data_cont.CM_incr[0]/xy_mag );
Global_operations.c:        if ( E->ve_data_cont.CM_incr[1]<0 ) f0 = 2.0*M_PI - f0 ;
Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:    for (j=1;j<=E->lmesh.nsf;j++)    {
Global_operations.c:       i = j*E->lmesh.noz;
Global_operations.c:       t1 = E->SX[E->mesh.levmax][m][1][i];
Global_operations.c:       f1 = E->SX[E->mesh.levmax][m][2][i];
Global_operations.c:    xy_mag = sqrt(  E->ve_data_cont.CM_incr[0]*E->ve_data_cont.CM_incr[0] 
Global_operations.c:                  + E->ve_data_cont.CM_incr[1]*E->ve_data_cont.CM_incr[1] );
Global_operations.c:    r0 = sqrt( E->ve_data_cont.CM_incr[2]*E->ve_data_cont.CM_incr[2] + xy_mag*xy_mag );
Global_operations.c:        t0 = acos( E->ve_data_cont.CM_incr[2]/r0 );
Global_operations.c:        f0 = acos( E->ve_data_cont.CM_incr[0]/xy_mag );
Global_operations.c:        if ( E->ve_data_cont.CM_incr[1]<0 ) f0 = 2.0*M_PI - f0 ;
Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:    for (j=1;j<=E->lmesh.nsf;j++)    
Global_operations.c:    for (k=1;k<=E->lmesh.noz;k++)    {
Global_operations.c:       i = k+(j-1)*E->lmesh.noz;
Global_operations.c:       t1 = E->SX[E->mesh.levmax][m][1][i];
Global_operations.c:       f1 = E->SX[E->mesh.levmax][m][2][i];
Global_operations.c:       u1 = E->sphere.cap[m].V[1][i] - r0 * rel_cos ;
Global_operations.c:       u2 = E->sphere.cap[m].V[2][i] - r0 * rel_cos ;
Global_operations.c:       u3 = E->sphere.cap[m].V[3][i] - r0 * rel_cos ;
Global_operations.c:    if ( k==E->lmesh.noz && E->parallel.me_loc[3]==E->parallel.nprocz-1) {
Global_operations.c:       E->sphere.cap[m].total_VS[1][j] += E->sphere.cap[m].V[1][i];
Global_operations.c:       E->sphere.cap[m].total_VS[2][j] += E->sphere.cap[m].V[2][i];
Global_operations.c:       E->sphere.cap[m].total_VS[3][j] += E->sphere.cap[m].V[3][i];  
Global_operations.c:    if ( k==E->lmesh.noz && E->parallel.me_loc[3]==E->parallel.nprocz-1) {
Global_operations.c:       E->sphere.cap[m].total_VS[1][j] += u1;
Global_operations.c:       E->sphere.cap[m].total_VS[2][j] += u2;
Global_operations.c:       E->sphere.cap[m].total_VS[3][j] += u3;
Global_operations.c:/*       if ( k==E->lmesh.noz && E->parallel.me_loc[3]==E->parallel.nprocz-1) {
Global_operations.c:          v1 = E->sphere.cap[m].V[1][i];
Global_operations.c:          v2 = E->sphere.cap[m].V[2][i];
Global_operations.c:          v3 = E->sphere.cap[m].V[3][i];
Global_operations.c:          E->sphere.cap[m].total_VC[1][j] += sin(t1)*cos(f1)*v3 + cos(t1)*cos(f1)*v1 - sin(f1)*v2;
Global_operations.c:          E->sphere.cap[m].total_VC[2][j] += sin(t1)*sin(f1)*v3 + cos(t1)*sin(f1)*v1 + cos(f1)*v2;
Global_operations.c:          E->sphere.cap[m].total_VC[3][j] += cos(t1)*v3         - sin(t1)*v1;
Global_operations.c:          v1 = E->sphere.cap[m].total_VC[1][j];
Global_operations.c:          v2 = E->sphere.cap[m].total_VC[2][j];
Global_operations.c:          v3 = E->sphere.cap[m].total_VC[3][j];
Global_operations.c:          E->sphere.cap[m].total_VS[3][j] = sin(t1)*cos(f1)*v1 + sin(t1)*sin(f1)*v2 + cos(t1)*v3;
Global_operations.c:          E->sphere.cap[m].total_VS[1][j] = cos(t1)*cos(f1)*v1 + cos(t1)*sin(f1)*v2 - sin(t1)*v3;
Global_operations.c:          E->sphere.cap[m].total_VS[2][j] = -sin(f1)*v1         + cos(f1)*v2;  
Global_operations.c:       E->sphere.cap[m].V[1][i] = u1;
Global_operations.c:       E->sphere.cap[m].V[2][i] = u2; 
Global_operations.c:       E->sphere.cap[m].V[3][i] = u3;
Global_operations.c:       if ( k==E->lmesh.noz && E->parallel.me_loc[3]==E->parallel.nprocz-1) {
Global_operations.c:       if ( k==1 && E->parallel.me_loc[3]==0)  {
Global_operations.c:    const int dims = E->mesh.nsd;
Global_operations.c:    const int lev = E->mesh.levmax;
Global_operations.c:    nox = E->lmesh.nox;
Global_operations.c:    noy = E->lmesh.noy;
Global_operations.c:    elx = E->lmesh.elx;
Global_operations.c:    ely = E->lmesh.ely;
Global_operations.c:    elz = E->lmesh.elz;
Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:                for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:                    lnode[d] = E->sien[m][el].node[d];
Global_operations.c:                    for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)
Global_operations.c:                        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:                            temp[1] += X3[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)] 
Global_operations.c:                                * E->gDA0[m][el].vpt[nint];
Global_operations.c:                    temp[2] += E->gDA0[m][el].vpt[5];
Global_operations.c:                    for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)
Global_operations.c:                        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:                            temp[1] += X3[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)] 
Global_operations.c:                                * E->gDA1[m][el].vpt[nint];
Global_operations.c:                    temp[2] += E->gDA1[m][el].vpt[5];
Global_operations.c:   MPI_Allreduce(temp,Have,3,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Global_operations.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:        // To dimensionalize a nondim'l potential (such as E->potential or
Global_operations.c:        // E->incr_potential), multiply by 4.pi.G.rho.R^2 (where rho is the
Global_operations.c:        scale_pot = 1.0/( 4.0*M_PI * E->data.grav_const * E->data.density );
Global_operations.c:        c_cmb = c_surf * E->sphere.ri*E->sphere.ri/(E->sphere.ro*E->sphere.ro);
Global_operations.c:        E->ve_data_cont.PW_incr[0] = 0.0;
Global_operations.c:        E->ve_data_cont.PW_incr[1] = 0.0;
Global_operations.c:       for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Global_operations.c:          oldpotl_surf[m] =(double*)malloc((E->lmesh.nsf+2)*sizeof(double));
Global_operations.c:          oldpotl_cmb[m] = (double*)malloc((E->lmesh.nsf+2)*sizeof(double));
Global_operations.c:          for (n=1;n<=E->lmesh.nsf;n++)  { 
Global_operations.c:    M0 = E->viscosity.beta*M[0] + (1.0-E->viscosity.beta)*E->ve_data_cont.PW_incr[0]; 
Global_operations.c:    M1 = E->viscosity.beta*M[1] + (1.0-E->viscosity.beta)*E->ve_data_cont.PW_incr[1]; 
Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:    for (n=1;n<=E->lmesh.nsf;n++)   {
Global_operations.c:        t = E->SX[E->mesh.levmax][m][1][n*E->lmesh.NOZ[E->mesh.levmax]];
Global_operations.c:        f = E->SX[E->mesh.levmax][m][2][n*E->lmesh.NOZ[E->mesh.levmax]];
Global_operations.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Global_operations.c:        if (E->parallel.me_loc[3]==0)   {
Global_operations.c:   MPI_Allreduce(potential,prod,3,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:   E->ve_data_cont.potential_vary_PW = sqrt(prod[1]/prod[0]);
Global_operations.c: if (E->parallel.me==0) fprintf(E->fp_out,"pw step=%d %g %g %g %g %g\n",E->monitor.solution_cycles,E->viscosity.beta,M[0],M[1],E->ve_data_cont.PW_incr[0],E->ve_data_cont.PW_incr[1]);
Global_operations.c:   E->ve_data_cont.PW_incr[0] = M[0];
Global_operations.c:   E->ve_data_cont.PW_incr[1] = M[1];
Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Global_operations.c:    for (n=1;n<=E->lmesh.nsf;n++)   {
Global_operations.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Global_operations.c:        if (E->parallel.me_loc[3]==0)   
Global_operations.c:        M_conv = (3.0*E->data.grav_const*E->data.density) /
Global_operations.c:          (omega*omega*E->ve_data_cont.kf)*5.0*sqrt(4.0*M_PI/15.0);
Global_operations.c:    M[0] = M_conv*E->ve_data_cont.PW_pot[0];
Global_operations.c:    M[1] = M_conv*E->ve_data_cont.PW_pot[1];
Global_operations.c:        //                    * E->control.CApert ); // non-hydrostatic effect
Global_operations.c:    	density_cmb = (E->data.density_below-E->data.density)/E->data.density;
Global_operations.c:        I_to_M_conv = ( 3.0 * E->data.grav_const * E->data.density) /
Global_operations.c:                      (omega*omega*E->ve_data_cont.kf);
Global_operations.c:        c_surf  = c_surf/E->ve_data_cont.surf_scaling*density_surf;    //turn load to surface mass density, sigma
Global_operations.c:        c_cmb   = -E->sphere.ri*E->sphere.ri/(E->sphere.ro*E->sphere.ro);  
Global_operations.c:        c_cmb  = c_cmb/E->ve_data_cont.botm_scaling*density_cmb;      //turn load to surface mass density, sigma
Global_operations.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Global_operations.c:    for (k=1; k<=E->lmesh.ely; k++)
Global_operations.c:    for (j=1; j<=E->lmesh.elx; j++) {
Global_operations.c:        el = j + (k-1)*E->lmesh.elx;
Global_operations.c:        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:            lnode[d] = E->sien[m][el].node[d];
Global_operations.c:        for(d =1; d <=onedvpoints[E->mesh.nsd]; d++) 
Global_operations.c:        for(d1=1; d1<=onedvpoints[E->mesh.nsd]; d1++) {
Global_operations.c:            i = lnode[d1]*E->lmesh.noz;
Global_operations.c:            t1 = E->SX[E->mesh.levmax][m][1][i];
Global_operations.c:            f1 = E->SX[E->mesh.levmax][m][2][i];
Global_operations.c:            if (E->parallel.me_loc[3]==E->parallel.nprocz-1) 
Global_operations.c:                      * E->gDA1[m][el].vpt[d] * E->M.vpt[GMVINDEX(d1,d)] ;
Global_operations.c:            if (E->parallel.me_loc[3]==0) 
Global_operations.c:                      * E->gDA0[m][el].vpt[d] * E->M.vpt[GMVINDEX(d1,d)] ;
Global_operations.c:    MPI_Allreduce(temp,I,3,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c:        //                    * E->control.CApert ); // non-hydrostatic effect
Global_operations.c:        I_to_M_conv = ( 3.0 * E->data.grav_const ) /
Global_operations.c:                      (omega*omega * pow(E->sphere.dradius,5) * E->ve_data_cont.kf);
Global_operations.c:        c_surf  = -E->sphere.dradius ;    // -> dim'ful height 
Global_operations.c:        c_surf *= E->data.density ;       // -> dim'ful mass/area
Global_operations.c:        c_surf *= (E->sphere.dradius*E->sphere.dradius) ; // nondim area
Global_operations.c:        c_surf *= (E->sphere.dradius*E->sphere.dradius) ; // dim'ful radius^2
Global_operations.c:        c_cmb   = -E->sphere.dradius ;  
Global_operations.c:        c_cmb  *= (E->data.density_below - E->data.density) ;
Global_operations.c:        c_cmb  *= ( E->sphere.dradius*E->sphere.dradius ) ;
Global_operations.c:        c_cmb  *= ( E->sphere.dradius*E->sphere.dradius ) * pow(E->sphere.ri,2);
Global_operations.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Global_operations.c:    for (k=1; k<=E->lmesh.ely; k++)
Global_operations.c:    for (j=1; j<=E->lmesh.elx; j++) {
Global_operations.c:        el = j + (k-1)*E->lmesh.elx;
Global_operations.c:        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Global_operations.c:            lnode[d] = E->sien[m][el].node[d];
Global_operations.c:        for(d =1; d <=onedvpoints[E->mesh.nsd]; d++) 
Global_operations.c:        for(d1=1; d1<=onedvpoints[E->mesh.nsd]; d1++) {
Global_operations.c:            i = lnode[d1]*E->lmesh.noz;
Global_operations.c:            t1 = E->SX[E->mesh.levmax][m][1][i];
Global_operations.c:            f1 = E->SX[E->mesh.levmax][m][2][i];
Global_operations.c:            if (E->parallel.me_loc[3]==E->parallel.nprocz-1) 
Global_operations.c:                      * E->gDA1[m][el].vpt[d] * E->M.vpt[GMVINDEX(d1,d)] ;
Global_operations.c:            if (E->parallel.me_loc[3]==0) 
Global_operations.c:                      * E->gDA0[m][el].vpt[d] * E->M.vpt[GMVINDEX(d1,d)] ;
Global_operations.c:    MPI_Allreduce(temp,I,3,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Global_operations.c: MPI_Allreduce(data,temp,total,MPI_FLOAT,MPI_SUM,E->parallel.horizontal_comm);
Initial_temperature.c:  int m = E->parallel.me;
Initial_temperature.c:  int noz = E->lmesh.noz;
Initial_temperature.c:  input_int("tic_method", &(E->convection.tic_method), "0,0,2", m);
Initial_temperature.c:    E->convection.tic_method = 4; /*  */
Initial_temperature.c:    E->control.ggrd.use_temp = 1;
Initial_temperature.c:     (E->control.mantle_temp).
Initial_temperature.c:      E->convection.number_of_perturbations = n;
Initial_temperature.c:      if (! input_float_vector("perturbmag", n, E->convection.perturb_mag, m) ) {
Initial_temperature.c:      if (! input_int_vector("perturbm", n, E->convection.perturb_mm, m) ) {
Initial_temperature.c:      if (! input_int_vector("perturbl", n, E->convection.perturb_ll, m) ) {
Initial_temperature.c:      if (! input_int_vector("perturblayer", n, E->convection.load_depth, m) ) {
Initial_temperature.c:      E->convection.number_of_perturbations = 1;
Initial_temperature.c:      E->convection.perturb_mag[0] = 1;
Initial_temperature.c:      E->convection.perturb_mm[0] = 2;
Initial_temperature.c:      E->convection.perturb_ll[0] = 2;
Initial_temperature.c:      E->convection.load_depth[0] = (noz+1)/2;
Initial_temperature.c:    input_float("half_space_age", &(E->convection.half_space_age), "40.0,1e-3,nomax", m);
Initial_temperature.c:    input_float("mantle_temp",&(E->control.mantle_temp),"1.0",m);
Initial_temperature.c:    switch(E->convection.tic_method){
Initial_temperature.c:      if( ! input_float_vector("blob_center", 3, E->convection.blob_center, m)) {
Initial_temperature.c:	assert( E->sphere.caps == 12 || E->sphere.caps == 1 );
Initial_temperature.c:	if(E->sphere.caps == 12) { /* Full version: just quit here */
Initial_temperature.c:	else if(E->sphere.caps == 1) { /* Regional version: put the blob at the center */
Initial_temperature.c:	  E->convection.blob_center[0] = 0.5*(E->control.theta_min+E->control.theta_max);
Initial_temperature.c:	  E->convection.blob_center[1] = 0.5*(E->control.fi_min+E->control.fi_max);
Initial_temperature.c:	  E->convection.blob_center[2] = 0.5*(E->sphere.ri+E->sphere.ro);
Initial_temperature.c:      input_float("blob_radius", &(E->convection.blob_radius), "0.063,0.0,1.0", m);
Initial_temperature.c:      input_float("blob_dT", &(E->convection.blob_dT), "0.18,nomin,nomax", m);
Initial_temperature.c:      input_boolean("blob_bc_persist",&(E->convection.blob_bc_persist),"off",m);
Initial_temperature.c:      input_boolean("ggrd_tinit_scale_with_prem",&(E->control.ggrd.temp.scale_with_prem),"off",E->parallel.me);
Initial_temperature.c:      input_boolean("ggrd_tinit_limit_trange",&(E->control.ggrd.temp.limit_trange),"on",E->parallel.me);
Initial_temperature.c:      input_double("ggrd_tinit_scale",&(E->control.ggrd.temp.scale),"1.0",E->parallel.me); /* scale */
Initial_temperature.c:      input_double("ggrd_tinit_offset",&(E->control.ggrd.temp.offset),"0.0",E->parallel.me); /* offset */
Initial_temperature.c:      input_string("ggrd_tinit_gfile",E->control.ggrd.temp.gfile,"",E->parallel.me); /* grids */
Initial_temperature.c:      input_string("ggrd_tinit_dfile",E->control.ggrd.temp.dfile,"",E->parallel.me); /* depth.dat layers of grids*/
Initial_temperature.c:      input_boolean("ggrd_tinit_override_tbc",&(E->control.ggrd.temp.override_tbc),"off",E->parallel.me);
Initial_temperature.c:      input_string("ggrd_tinit_prem_file",E->control.ggrd.temp.prem.model_filename,"hc/prem/prem.dat", E->parallel.me); /* PREM model filename */
Initial_temperature.c:  if (E->convection.tic_method == -1) {
Initial_temperature.c:      if(strcmp(E->output.format, "ascii-gz") == 0)
Initial_temperature.c:  else if (E->control.lith_age)
Initial_temperature.c:  if (E->control.verbose)
Initial_temperature.c:  fprintf(E->fp_out,"output_temperature\n");
Initial_temperature.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)        {
Initial_temperature.c:    fprintf(E->fp_out,"for cap %d\n",E->sphere.capid[m]);
Initial_temperature.c:    for (j=1;j<=E->lmesh.nno;j++)
Initial_temperature.c:      fprintf(E->fp_out,"X = %.6e Z = %.6e Y = %.6e T[%06d] = %.6e \n",E->sx[m][1][j],E->sx[m][2][j],E->sx[m][3][j],j,E->T[m][j]);
Initial_temperature.c:  fflush(E->fp_out);
Initial_temperature.c:  ii = E->monitor.solution_cycles_init;
Initial_temperature.c:  sprintf(output_file,"%s.velo.%d.%d",E->control.old_P_file,E->parallel.me,ii);
Initial_temperature.c:    fprintf(E->fp,"(Initial_temperature.c #1) Cannot open %s\n",output_file);
Initial_temperature.c:  if (E->parallel.me==0)
Initial_temperature.c:    fprintf(E->fp,"Reading %s for initial temperature\n",output_file);
Initial_temperature.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Initial_temperature.c:    for(i=1;i<=E->lmesh.nno;i++)  {
Initial_temperature.c:      E->T[m][i] = max(0.0,min(g,1.0));
Initial_temperature.c:    nox = E->lmesh.nox;
Initial_temperature.c:    noy = E->lmesh.noy;
Initial_temperature.c:    noz = E->lmesh.noz;
Initial_temperature.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:                    r1 = E->sx[m][3][node];
Initial_temperature.c:                    E->T[m][node] = E->control.TBCbotval - (E->control.TBCtopval + E->control.TBCbotval)*(r1 - E->sphere.ri)/(E->sphere.ro - E->sphere.ri);
Initial_temperature.c:    nox = E->lmesh.nox;
Initial_temperature.c:    noy = E->lmesh.noy;
Initial_temperature.c:    noz = E->lmesh.noz;
Initial_temperature.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:                    r1 = E->sx[m][3][node];
Initial_temperature.c:                    E->T[m][node] = (E->control.TBCtopval*E->sphere.ro
Initial_temperature.c:                                     - E->control.TBCbotval*E->sphere.ri)
Initial_temperature.c:                        / (E->sphere.ro - E->sphere.ri)
Initial_temperature.c:                        + (E->control.TBCbotval - E->control.TBCtopval)
Initial_temperature.c:                        * E->sphere.ro * E->sphere.ri / r1
Initial_temperature.c:                        / (E->sphere.ro - E->sphere.ri);
Initial_temperature.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:        for(i=1; i<=E->lmesh.nno; i++)
Initial_temperature.c:            E->T[m][i] = mantle_temp;
Initial_temperature.c:    nox = E->lmesh.nox;
Initial_temperature.c:    noy = E->lmesh.noy;
Initial_temperature.c:    noz = E->lmesh.noz;
Initial_temperature.c:    dT = (mantle_temp - E->control.TBCtopval);
Initial_temperature.c:    tmp = 0.5 / sqrt(age_in_myrs / E->data.scalet);
Initial_temperature.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:                    r1 = E->sx[m][3][node];
Initial_temperature.c:                    E->T[m][node] -= dT * erfc(tmp * (E->sphere.ro - r1));
Initial_temperature.c:    nox = E->lmesh.nox;
Initial_temperature.c:    noy = E->lmesh.noy;
Initial_temperature.c:    noz = E->lmesh.noz;
Initial_temperature.c:    dT = (E->control.TBCbotval - mantle_temp);
Initial_temperature.c:    tmp = 0.5 / sqrt(age_in_myrs / E->data.scalet);
Initial_temperature.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:                    r1 = E->sx[m][3][node];
Initial_temperature.c:                    E->T[m][node] += dT * erfc(tmp * (r1 - E->sphere.ri));
Initial_temperature.c:    nox = E->lmesh.nox;
Initial_temperature.c:    noy = E->lmesh.noy;
Initial_temperature.c:    noz = E->lmesh.noz;
Initial_temperature.c:    gnoz = E->mesh.noz;
Initial_temperature.c:    for (p=0; p<E->convection.number_of_perturbations; p++) {
Initial_temperature.c:        ll = E->convection.perturb_ll[p];
Initial_temperature.c:        mm = E->convection.perturb_mm[p];
Initial_temperature.c:        kk = E->convection.load_depth[p];
Initial_temperature.c:        con = E->convection.perturb_mag[p];
Initial_temperature.c:        k = kk - E->lmesh.nzs + 1; /* convert global nz to local nz */
Initial_temperature.c:        if (E->parallel.me_loc[1] == 0 && E->parallel.me_loc[2] == 0
Initial_temperature.c:            && E->sphere.capid[1] == 1 )
Initial_temperature.c:        if(E->sphere.caps == 1) {
Initial_temperature.c:            tlen = M_PI / (E->control.theta_max - E->control.theta_min);
Initial_temperature.c:            flen = M_PI / (E->control.fi_max - E->control.fi_min);
Initial_temperature.c:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:                        t1 = (E->sx[m][1][node] - E->control.theta_min) * tlen;
Initial_temperature.c:                        f1 = (E->sx[m][2][node] - E->control.fi_min) * flen;
Initial_temperature.c:                        E->T[m][node] += con * cos(ll*t1) * cos(mm*f1);
Initial_temperature.c:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:                        t1 = E->sx[m][1][node];
Initial_temperature.c:                        f1 = E->sx[m][2][node];
Initial_temperature.c:                        E->T[m][node] += con * modified_plgndr_a(ll,mm,t1) * cos(mm*f1);
Initial_temperature.c:    nox = E->lmesh.nox;
Initial_temperature.c:    noy = E->lmesh.noy;
Initial_temperature.c:    noz = E->lmesh.noz;
Initial_temperature.c:    gnoz = E->mesh.noz;
Initial_temperature.c:    rlen = M_PI / (E->sphere.ro - E->sphere.ri);
Initial_temperature.c:    for (p=0; p<E->convection.number_of_perturbations; p++) {
Initial_temperature.c:        ll = E->convection.perturb_ll[p];
Initial_temperature.c:        mm = E->convection.perturb_mm[p];
Initial_temperature.c:        con = E->convection.perturb_mag[p];
Initial_temperature.c:        if (E->parallel.me_loc[1] == 0 && E->parallel.me_loc[2] == 0
Initial_temperature.c:            && E->sphere.capid[1] == 1 )
Initial_temperature.c:        if(E->sphere.caps == 1) {
Initial_temperature.c:            tlen = M_PI / (E->control.theta_max - E->control.theta_min);
Initial_temperature.c:            flen = M_PI / (E->control.fi_max - E->control.fi_min);
Initial_temperature.c:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:                            t1 = (E->sx[m][1][node] - E->control.theta_min) * tlen;
Initial_temperature.c:                            f1 = (E->sx[m][2][node] - E->control.fi_min) * flen;
Initial_temperature.c:                            r1 = E->sx[m][3][node];
Initial_temperature.c:                            E->T[m][node] += con * cos(ll*t1) * cos(mm*f1)
Initial_temperature.c:                                * sin((r1-E->sphere.ri) * rlen);
Initial_temperature.c:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:                            t1 = E->sx[m][1][node];
Initial_temperature.c:                            f1 = E->sx[m][2][node];
Initial_temperature.c:                            r1 = E->sx[m][3][node];
Initial_temperature.c:                            E->T[m][node] += con * modified_plgndr_a(ll,mm,t1)
Initial_temperature.c:                                * sin((r1-E->sphere.ri) * rlen);
Initial_temperature.c:    noy = E->lmesh.noy;
Initial_temperature.c:    nox = E->lmesh.nox;
Initial_temperature.c:    noz = E->lmesh.noz;
Initial_temperature.c:    rout = E->sphere.ro;
Initial_temperature.c:    rin = E->sphere.ri;
Initial_temperature.c:    theta_center = E->convection.blob_center[0];
Initial_temperature.c:    fi_center    = E->convection.blob_center[1];
Initial_temperature.c:    r_center     = E->convection.blob_center[2];
Initial_temperature.c:    radius       = E->convection.blob_radius;
Initial_temperature.c:    amp          = E->convection.blob_dT;
Initial_temperature.c:    if(E->parallel.me == 0)
Initial_temperature.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Initial_temperature.c:		    dx[1] = E->x[m][1][node] - x_center[1];
Initial_temperature.c:		    dx[2] = E->x[m][2][node] - x_center[2];
Initial_temperature.c:		    dx[3] = E->x[m][3][node] - x_center[3];
Initial_temperature.c:		      E->T[m][node] += amp * exp(-1.0*distance/radius);
Initial_temperature.c:		      if(E->convection.blob_bc_persist){
Initial_temperature.c:			r1 = E->sx[m][3][node];
Initial_temperature.c:			  E->sphere.cap[m].TB[1][node]=E->T[m][node];
Initial_temperature.c:			  E->sphere.cap[m].TB[2][node]=E->T[m][node];
Initial_temperature.c:			  E->sphere.cap[m].TB[3][node]=E->T[m][node];
Initial_temperature.c:    switch (E->convection.tic_method){
Initial_temperature.c:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:        mantle_temperature = E->control.mantle_temp;
Initial_temperature.c:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:        if (E->sphere.caps == 1)
Initial_temperature.c:        mantle_temperature = E->control.mantle_temp;
Initial_temperature.c:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:        mantle_temperature = E->control.mantle_temp;
Initial_temperature.c:        add_bottom_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:        mantle_temperature = E->control.mantle_temp;
Initial_temperature.c:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:        add_bottom_tbl(E, E->convection.half_space_age, mantle_temperature);
Initial_temperature.c:        if((E->parallel.nprocz % 2) == 0) {
Initial_temperature.c:            if(E->parallel.me==0)
Initial_temperature.c:                        E->convection.tic_method);
Initial_temperature.c:            E->convection.number_of_perturbations = 1;
Initial_temperature.c:            mid = (E->mesh.noz+1) / 2;
Initial_temperature.c:            E->convection.load_depth[0] = mid;
Initial_temperature.c:            k = mid - E->lmesh.nzs + 1; /* convert to local nz */
Initial_temperature.c:            E->convection.perturb_mag[0] = 0;
Initial_temperature.c:            if ( (k > 1) && (k < E->lmesh.noz) ) {
Initial_temperature.c:                E->convection.perturb_mag[0] = 2 / (E->sx[1][3][k+1] - E->sx[1][3][k-1]);
Initial_temperature.c:                E->convection.tic_method);
Initial_temperature.c:        fprintf(stderr,"Invalid value: 'tic_method=%d'\n", E->convection.tic_method);
Instructions.c:  //chatty = ((E->parallel.me == 0)&&(E->control.verbose))?(1):(0);
Instructions.c:  chatty = E->parallel.me == 0;
Instructions.c:    E->monitor.cpu_time_at_last_cycle =
Instructions.c:        E->monitor.cpu_time_at_start = CPU_time0();
Instructions.c:    (E->problem_derived_values)(E);   /* call this before global_derived_  */
Instructions.c:    (E->solver.parallel_processor_setup)(E);   /* get # of proc in x,y,z */
Instructions.c:    (E->solver.parallel_domain_decomp0)(E);  /* get local nel, nno, elx, nox et al */
Instructions.c:    (E->problem_allocate_vars)(E);
Instructions.c:    (E->solver_allocate_vars)(E);
Instructions.c:    (E->solver.construct_boundary)(E);
Instructions.c:    (E->solver.parallel_domain_boundary_nodes)(E);
Instructions.c:    (E->solver.node_locations)(E);
Instructions.c:    if(E->output.write_q_files)
Instructions.c:      E->output.fpqt = E->output.fpqb = NULL;
Instructions.c:    if(E->control.lith_age)
Instructions.c:    (E->problem_boundary_conds)(E);
Instructions.c:    (E->solver.parallel_communication_routs_v)(E);
Instructions.c:    if(E->control.use_cbf_topo){
Instructions.c:      (E->solver.parallel_communication_routs_s)(E); 
Instructions.c:    if(E->control.inv_gruneisen != 0)
Instructions.c:    if(E->control.tracer) {
Instructions.c:	(E->problem_tracer_setup)(E);
Instructions.c:    if(E->control.ggrd.ray_control)
Instructions.c:    (E->next_buoyancy_field_init)(E);
Instructions.c:    if(E->control.mat_control)
Instructions.c:    if (E->control.tracer==1) {
Instructions.c:        if (E->composition.on)
Instructions.c:    (E->problem_initial_fields)(E);   /* temperature/chemistry/melting etc */
Instructions.c:  int m=E->parallel.me;
Instructions.c:  input_string("Problem",E->control.PROBLEM_TYPE,"convection",m);
Instructions.c:  if ( strcmp(E->control.PROBLEM_TYPE,"convection") == 0)
Instructions.c:  else if ( strcmp(E->control.PROBLEM_TYPE,"convection-chemical") == 0)
Instructions.c:    fprintf(E->fp,"Unable to determine problem type, assuming convection ... \n");
Instructions.c:  input_string("Geometry",E->control.GEOMETRY,"sphere",m);
Instructions.c:  if ( strcmp(E->control.GEOMETRY,"sphere") == 0)
Instructions.c:      (E->solver.set_3dsphere_defaults)(E);
Instructions.c:    fprintf(E->fp,"Unable to determine geometry, assuming sphere 3d ... \n");
Instructions.c:    (E->solver.set_3dsphere_defaults)(E);
Instructions.c:  input_string("Solver",E->control.SOLVER_TYPE,"cgrad",m);
Instructions.c:  if ( strcmp(E->control.SOLVER_TYPE,"cgrad") == 0)
Instructions.c:  else if ( strcmp(E->control.SOLVER_TYPE,"multigrid") == 0)
Instructions.c:    if (E->parallel.me==0) fprintf(stderr,"Unable to determine how to solve, specify Solver=VALID_OPTION \n");
Instructions.c:  input_string("datadir",E->control.data_dir,".",m);
Instructions.c:  input_string("datafile",E->control.data_prefix,"initialize",m);
Instructions.c:  input_string("datadir_old",E->control.data_dir_old,".",m);
Instructions.c:  input_string("datafile_old",E->control.data_prefix_old,"initialize",m);
Instructions.c:  input_string("te_datafile",E->ve_data_cont.te_file,"initialize",m);
Instructions.c:  input_string("platemargins_datafile",E->ve_data_cont.platemargins_file,"initialize",m);
Instructions.c:  input_string("ice_datafile",E->ve_data_cont.ice_file,"initialize",m);
Instructions.c:  input_string("ocean_datafile",E->ve_data_cont.ocean_file,"initialize",m);
Instructions.c:  E->ve_data_cont.variable_te=0;
Instructions.c:  input_int("variable_te",&(E->ve_data_cont.variable_te),"off",m);
Instructions.c:  E->ve_data_cont.Heaviside=0;
Instructions.c:  input_int("Heaviside",&(E->ve_data_cont.Heaviside),"0",m);
Instructions.c:  E->ve_data_cont.apply_potential=0;
Instructions.c:  input_int("apply_potential",&(E->ve_data_cont.apply_potential),"0",m);
Instructions.c:  E->ve_data_cont.plate_margins=0;
Instructions.c:  input_int("platemargins",&(E->ve_data_cont.plate_margins),"off",m);
Instructions.c:  input_int("update_K_steps",&(E->ve_data_cont.KERNEL),"0",m);
Instructions.c:  input_int("iteration",&(E->ve_data_cont.iteration),"0",m);
Instructions.c:  input_double("damping",&(E->ve_data_cont.damping),"1",m);
Instructions.c:  input_double("tole_compressibility",&(E->control.tole_comp),"1e-7",m);
Instructions.c:  input_int("self_gravitation",&(E->ve_data_cont.SELFG),"0",m);
Instructions.c:  input_int("apply_SLE",&(E->ve_data_cont.SLE),"0",m);
Instructions.c:  input_int("polar_wander",&(E->ve_data_cont.polar_wander),"0",m);
Instructions.c:  input_double("polar_wander_kf",&(E->ve_data_cont.kf),"1",m);
Instructions.c:  input_int("SLE_lmax",&(E->ve_data_cont.SLE_lmax),"0",m);
Instructions.c:  input_int("pure_visc",&(E->ve_data_cont.pure_visc),"0",m);
Instructions.c:  input_int("nproc_surf",&(E->parallel.nprocxy),"1",m);
Instructions.c:  input_int("nprocx",&(E->parallel.nprocx),"1",m);
Instructions.c:  input_int("nprocy",&(E->parallel.nprocy),"1",m);
Instructions.c:  input_int("nprocz",&(E->parallel.nprocz),"1",m);
Instructions.c:  if (E->control.CONJ_GRAD) {
Instructions.c:      input_int("nodex",&(E->mesh.nox),"essential",m);
Instructions.c:      input_int("nodez",&(E->mesh.noz),"essential",m);
Instructions.c:      input_int("nodey",&(E->mesh.noy),"essential",m);
Instructions.c:      E->mesh.mgunitx = (E->mesh.nox - 1) / E->parallel.nprocx;
Instructions.c:      E->mesh.mgunity = (E->mesh.noy - 1) / E->parallel.nprocy;
Instructions.c:      E->mesh.mgunitz = (E->mesh.noz - 1) / E->parallel.nprocz;
Instructions.c:      E->mesh.levels = 1;
Instructions.c:      input_int("mgunitx",&(E->mesh.mgunitx),"1",m);
Instructions.c:      input_int("mgunitz",&(E->mesh.mgunitz),"1",m);
Instructions.c:      input_int("mgunity",&(E->mesh.mgunity),"1",m);
Instructions.c:      input_int("levels",&(E->mesh.levels),"1",m);
Instructions.c:      levmax = E->mesh.levels - 1;
Instructions.c:      E->mesh.nox = E->mesh.mgunitx * (int) pow(2.0,levmax) * E->parallel.nprocx + 1;
Instructions.c:      E->mesh.noy = E->mesh.mgunity * (int) pow(2.0,levmax) * E->parallel.nprocy + 1;
Instructions.c:      E->mesh.noz = E->mesh.mgunitz * (int) pow(2.0,levmax) * E->parallel.nprocz + 1;
Instructions.c:  input_float("radius",&E->sphere.dradius,"6371e3.0",m);
Instructions.c:  E->data.radius_km = E->sphere.dradius / 1e3;
Instructions.c:  input_double("radius_outer",&(E->sphere.ro),"1",m);
Instructions.c:  input_double("radius_inner",&(E->sphere.ri),"0.55",m);
Instructions.c:  if(E->sphere.caps == 1) {
Instructions.c:      input_double("theta_min",&(E->control.theta_min),"essential",m);
Instructions.c:      input_double("theta_max",&(E->control.theta_max),"essential",m);
Instructions.c:      input_double("fi_min",&(E->control.fi_min),"essential",m);
Instructions.c:      input_double("fi_max",&(E->control.fi_max),"essential",m);
Instructions.c:  input_int("coor",&(E->control.coor),"0",m);
Instructions.c:  if(E->control.coor == 2){
Instructions.c:    E->control.coor_refine[0] = 0.10; /* bottom 10% */
Instructions.c:    E->control.coor_refine[1] = 0.15; /* get 15% of the nodes */
Instructions.c:    E->control.coor_refine[2] = 0.10; /* top 10% */
Instructions.c:    E->control.coor_refine[3] = 0.20; /* get 20% of the nodes */
Instructions.c:    input_float_vector("coor_refine",4,E->control.coor_refine,m);
Instructions.c:  }else if(E->control.coor == 3){
Instructions.c:    input_int("r_grid_layers", &(E->control.rlayers), "1",m);
Instructions.c:    if(E->control.rlayers > 20)
Instructions.c:    input_float_vector("rr", E->control.rlayers, (E->control.rrlayer),m);
Instructions.c:    input_int_vector("nr", E->control.rlayers, (E->control.nrlayer),m);
Instructions.c:  input_string("coor_file",E->control.coor_file,"",m);
Instructions.c:  input_boolean("node_assemble",&(E->control.NASSEMBLE),"off",m);
Instructions.c:  input_boolean("verbose",&(E->control.verbose),"off",m);
Instructions.c:  input_boolean("see_convergence",&(E->control.print_convergence),"off",m);
Instructions.c:  input_boolean("stokes_flow_only",&(E->control.stokes),"off",m);
Instructions.c:  //input_boolean("remove_hor_buoy_avg",&(E->control.remove_hor_buoy_avg),"on",m);
Instructions.c:  input_boolean("restart",&(E->control.restart),"off",m);
Instructions.c:  input_int("post_p",&(E->control.post_p),"0",m);
Instructions.c:  input_int("solution_cycles_init",&(E->monitor.solution_cycles_init),"0",m);
Instructions.c:  input_int("num_mat_layer",&(E->viscosity.rheol_layers),"1",m);   // number of rheology layers
Instructions.c:  input_int("num_mat",&(E->viscosity.num_mat),"1",m);            // number of material groups. 
Instructions.c:  if(E->viscosity.num_mat > CITCOM_MAX_VISC_LAYER)
Instructions.c:  input_float("z_cmb",&(E->viscosity.zcmb),"0.45",m); /* 0.45063569 */
Instructions.c:  input_float("z_lmantle",&(E->viscosity.zlm),"0.45",m); /*0.10359441  */
Instructions.c:  input_float("z_410",&(E->viscosity.z410),"0.225",m); /* 0.06434, more like it */
Instructions.c:  input_float("z_lith",&(E->viscosity.zlith),"0.225",m); /* 0.0157, more like it */
Instructions.c:  E->viscosity.zbase_layer[0] = E->viscosity.zbase_layer[1] = -999;
Instructions.c:  E->viscosity.nbase_layer[0] = 1;
Instructions.c:  input_int_vector("n_mat_layer",E->viscosity.rheol_layers,(E->viscosity.nbase_layer),m);
Instructions.c:  input_float("start_age",&(E->control.start_age),"0.0",m);
Instructions.c:  input_int("reset_startage",&(E->control.reset_startage),"0",m);
Instructions.c:  input_int("zero_elapsed_time",&(E->control.zero_elapsed_time),"0",m);
Instructions.c:  input_int("output_ll_max",&(E->output.llmax),"1",m);
Instructions.c:  input_int("nlong",&(E->sphere.noy),"1",m);
Instructions.c:  input_int("nlati",&(E->sphere.nox),"1",m);
Instructions.c:  input_int("topvbc",&(E->mesh.topvbc),"0",m);
Instructions.c:  input_int("botvbc",&(E->mesh.botvbc),"0",m);
Instructions.c:  input_float("topvbxval",&(E->control.VBXtopval),"0.0",m);
Instructions.c:  input_float("botvbxval",&(E->control.VBXbotval),"0.0",m);
Instructions.c:  input_float("topvbyval",&(E->control.VBYtopval),"0.0",m);
Instructions.c:  input_float("botvbyval",&(E->control.VBYbotval),"0.0",m);
Instructions.c:  input_float("T_interior_max_for_exit",&(E->monitor.T_interior_max_for_exit),"1.5",m);
Instructions.c:  input_int("pseudo_free_surf",&(E->control.pseudo_free_surf),"0",m);
Instructions.c:  input_int("toptbc",&(E->mesh.toptbc),"1",m);
Instructions.c:  input_int("bottbc",&(E->mesh.bottbc),"1",m);
Instructions.c:  input_float("toptbcval",&(E->control.TBCtopval),"0.0",m);
Instructions.c:  input_float("bottbcval",&(E->control.TBCbotval),"1.0",m);
Instructions.c:  input_boolean("side_sbcs",&(E->control.side_sbcs),"off",m);
Instructions.c:  input_int("file_vbcs",&(E->control.vbcs_file),"0",m);
Instructions.c:  input_string("vel_bound_file",E->control.velocity_boundary_file,"",m);
Instructions.c:  input_int("file_tbcs",&(E->control.tbcs_file),"0",m);
Instructions.c:  input_string("temp_bound_file",E->control.temperature_boundary_file,"",m);
Instructions.c:  input_int("reference_state",&(E->refstate.choice),"1",m);
Instructions.c:  if(E->refstate.choice == 0) {
Instructions.c:      input_string("refstate_file",E->refstate.filename,"refstate.dat",m);
Instructions.c:  input_int("mineral_physics_model",&(E->control.mineral_physics_model),"1",m);
Instructions.c:  input_int("mat_control",&(E->control.mat_control),"0",m);
Instructions.c:  input_string("mat_file",E->control.mat_file,"",m);
Instructions.c:  input_boolean("precise_strain_rate",&(E->control.precise_strain_rate),"off",m);
Instructions.c:     read in time-constant prefactors from weak.grd netcdf file that apply to top two E->mat layers
Instructions.c:  ggrd_init_master(&E->control.ggrd);
Instructions.c:	       E->control.ggrd.time_hist.file,"",m); 
Instructions.c:  /* if > 0, will use top  E->control.ggrd.mat_control layers and assign a prefactor for the viscosity */
Instructions.c:  input_int("ggrd_mat_control",&(E->control.ggrd.mat_control),"0",m); 
Instructions.c:  input_string("ggrd_mat_file",E->control.ggrd.mat_file,"",m); /* file to read prefactors from */
Instructions.c:  if(E->control.ggrd.mat_control) /* this will override mat_control setting */
Instructions.c:    E->control.mat_control = 1;
Instructions.c:	    &(E->control.ggrd.ray_control),"0",m); 
Instructions.c:	       E->control.ggrd.ray_file,"",m); /* file to read prefactors from */
Instructions.c:  input_int("ggrd_vtop_control",&(E->control.ggrd.vtop_control),"0",m); 
Instructions.c:  input_string("ggrd_vtop_dir",E->control.ggrd.vtop_dir,"",m); /* file to read prefactors from */
Instructions.c:  E->control.ggrd_vtop_omega[0] = 0;
Instructions.c:  input_float_vector("ggrd_vtop_omega",4,E->control.ggrd_vtop_omega,m);
Instructions.c:  if(E->control.ggrd_vtop_omega[0] > 0)
Instructions.c:    E->control.ggrd.vtop_control = 1;
Instructions.c:  if(E->control.ggrd.vtop_control) /* this will override mat_control setting */
Instructions.c:    E->control.vbcs_file = 1;
Instructions.c:  input_boolean("allow_mixed_vbcs",&(E->control.ggrd_allow_mixed_vbcs),"off",m);
Instructions.c:  input_boolean("aug_lagr",&(E->control.augmented_Lagr),"off",m);
Instructions.c:  input_double("aug_number",&(E->control.augmented),"0.0",m);
Instructions.c:  input_boolean("remove_rigid_rotation",&(E->control.remove_rigid_rotation),"on",m);
Instructions.c:  input_boolean("remove_angular_momentum",&(E->control.remove_angular_momentum),"on",m);
Instructions.c:  input_boolean("self_gravitation",&(E->control.self_gravitation),"off",m);
Instructions.c:  input_boolean("use_cbf_topo",&(E->control.use_cbf_topo),"off",m); /* make default on later XXX TWB */
Instructions.c:  input_int("storage_spacing",&(E->control.record_every),"10",m);
Instructions.c:  input_int("checkpointFrequency",&(E->control.checkpoint_frequency),"100",m);
Instructions.c:  input_int("cpu_limits_in_seconds",&(E->control.record_all_until),"5",m);
Instructions.c:  input_int("write_q_files",&(E->output.write_q_files),"0",m);/* write additional
Instructions.c:  if(E->output.write_q_files){	/* make sure those get written at
Instructions.c:    E->output.write_q_files = min(E->output.write_q_files,E->control.record_every);
Instructions.c:  input_boolean("precond",&(E->control.precondition),"off",m);
Instructions.c:  input_int("mg_cycle",&(E->control.mg_cycle),"2,0,nomax",m);
Instructions.c:  input_int("down_heavy",&(E->control.down_heavy),"1,0,nomax",m);
Instructions.c:  input_int("up_heavy",&(E->control.up_heavy),"1,0,nomax",m);
Instructions.c:  input_double("accuracy",&(E->control.accuracy),"1.0e-4,0.0,1.0",m);
Instructions.c:  input_boolean("only_check_vel_convergence",&(E->control.only_check_vel_convergence),"off",m);
Instructions.c:  input_int("vhighstep",&(E->control.v_steps_high),"1,0,nomax",m);
Instructions.c:  input_int("vlowstep",&(E->control.v_steps_low),"250,0,nomax",m);
Instructions.c:  input_int("max_mg_cycles",&(E->control.max_mg_cycles),"100,0,nomax",m);
Instructions.c:  input_int("piterations",&(E->control.p_iterations),"100,0,nomax",m);
Instructions.c:  input_float("rayleigh",&(E->control.Atemp),"essential",m);
Instructions.c:  input_float("dissipation_number",&(E->control.disptn_number),"0.0",m);
Instructions.c:      E->control.inv_gruneisen = 1/tmp;
Instructions.c:      E->control.inv_gruneisen = 0;
Instructions.c:  if(E->control.inv_gruneisen != 0) {
Instructions.c:      input_string("uzawa",E->control.uzawa,"cg",m);
Instructions.c:      if(strcmp(E->control.uzawa, "cg") == 0) {
Instructions.c:          input_int("compress_iter_maxstep",&(E->control.compress_iter_maxstep),"100",m);
Instructions.c:      else if(strcmp(E->control.uzawa, "bicg") == 0) {
Instructions.c:  input_float("surfaceT",&(E->control.surface_temp),"0.1",m);
Instructions.c:  /*input_float("adiabaticT0",&(E->control.adiabaticT0),"0.4",m);*/
Instructions.c:  input_float("Q0",&(E->control.Q0),"0.0",m);
Instructions.c:  input_float("gravacc",&(E->data.grav_acc),"9.81",m);
Instructions.c:  input_float("thermexp",&(E->data.therm_exp),"3.0e-5",m);
Instructions.c:  input_float("cp",&(E->data.Cp),"1200.0",m);
Instructions.c:  input_float("thermdiff",&(E->data.therm_diff),"1.0e-6",m);
Instructions.c:  input_float("density",&(E->data.density),"3340.0",m);
Instructions.c:  input_float("density_above",&(E->data.density_above),"1030.0",m);
Instructions.c:  input_float("density_below",&(E->data.density_below),"6600.0",m);
Instructions.c:  input_double("shearmodulus",&(E->ve_data_cont.shear_mod),"1e11",m);
Instructions.c:  input_float("refvisc",&(E->data.ref_viscosity),"1.0e21",m);
Instructions.c:  E->control.sob_tolerance = 1.0;
Instructions.c:  input_float("additional_acc",&(E->control.sob_tolerance),"1.0",m);
Instructions.c:  E->ve_data_cont.tau = E->data.ref_viscosity/(E->ve_data_cont.shear_mod*365.25*24*3600);
Instructions.c:/*  if (E->ve_data_cont.Heaviside==1)  {   
Instructions.c:        input_int("stages",&(E->ve_data_cont.stages),"0",m);
Instructions.c:        input_int_vector("step",E->ve_data_cont.stages,(E->ve_data_cont.stages_step),m);
Instructions.c:        input_double_vector("timestep",E->ve_data_cont.stages,(E->ve_data_cont.stages_time),m);
Instructions.c:        input_int("maxstep",&(E->advection.max_timesteps),"1000",m);
Instructions.c:        input_int("maxtotstep",&(E->advection.max_total_timesteps),"1000000",m);
Instructions.c:  else if (E->ve_data_cont.Heaviside==2)  {   
Instructions.c:       input_string("load_stages_time_file",E->ve_data_cont.timestage_file,"initialize",m);
Instructions.c:       if ( (fp=fopen(E->ve_data_cont.timestage_file,"r"))==NULL) {
Instructions.c:          fprintf(stderr,"ERROR: cannot find file %s\n",E->ve_data_cont.timestage_file);
Instructions.c:       sscanf(input_s,"%d %d",&E->ve_data_cont.stages,&j);
Instructions.c:       for (i=0;i<=E->ve_data_cont.stages;i++)  {
Instructions.c:         E->ve_data_cont.stages_time[i]=temp1+temp0;
Instructions.c:         E->ve_data_cont.stages_step[i]=temp2;
Instructions.c://if (E->parallel.me==0) fprintf(stderr,"bbb %d %d %g %g %d\n",i,j,temp0,temp1,temp2);
Instructions.c:       for (i=0;i<E->ve_data_cont.stages;i++)  {
Instructions.c:          E->ve_data_cont.stages_time[i]=E->ve_data_cont.stages_time[i+1]-E->ve_data_cont.stages_time[i];
Instructions.c:          if(i>0) E->ve_data_cont.stages_step[i]+=temp2;
Instructions.c:          temp2 =E->ve_data_cont.stages_step[i];
Instructions.c://if (E->parallel.me==0) fprintf(stderr,"aaa %d %g %d\n",i,E->ve_data_cont.stages_time[i],E->ve_data_cont.stages_step[i]);
Instructions.c:       E->advection.max_timesteps = temp2;
Instructions.c:       E->advection.max_total_timesteps = temp2;
Instructions.c:  E->data.ellipticity = ell_tmp;
Instructions.c:  if(fabs(E->data.ellipticity) > 5e-7){
Instructions.c:    E->data.ra = pow((1.-E->data.ellipticity),-1./3.); /* non dim long axis */
Instructions.c:    E->data.rc = 1./(E->data.ra * E->data.ra); /* non dim short axis */
Instructions.c:    E->data.efac = (1.-E->data.ellipticity)*(1.-E->data.ellipticity);
Instructions.c:    if(E->parallel.me == 0){
Instructions.c:	      E->data.ellipticity,E->data.ra,E->data.rc);
Instructions.c:    E->data.use_ellipse = 1;
Instructions.c:    E->data.ra = E->data.rc = E->data.efac=1.0;
Instructions.c:    E->data.use_ellipse = 0;
Instructions.c:  input_double("rotation_m",&E->data.rotm,"0.0",m);
Instructions.c:  if(fabs(E->data.rotm) > 5e-7){
Instructions.c:    E->data.j2 = 2./3.*E->data.ellipticity*(1.-E->data.ellipticity/2.)-
Instructions.c:      E->data.rotm/3.*(1.-3./2.*E->data.rotm-2./7.*E->data.ellipticity);
Instructions.c:    E->data.ge = 1/(E->data.ra*E->data.ra)*(1+3./2.*E->data.j2-E->data.rotm);
Instructions.c:    if(E->parallel.me==0)
Instructions.c:	      E->data.rotm,E->data.j2,E->data.ge);
Instructions.c:    E->data.use_rotation_g = 1;
Instructions.c:    E->data.use_rotation_g = 0;
Instructions.c:  E->data.therm_cond = E->data.therm_diff * E->data.density * E->data.Cp;
Instructions.c:  E->data.ref_temperature = E->control.Atemp * E->data.therm_diff
Instructions.c:    * E->data.ref_viscosity
Instructions.c:    / (E->data.density * E->data.grav_acc * E->data.therm_exp)
Instructions.c:    / (E->data.radius_km * E->data.radius_km * E->data.radius_km * 1e9);
Instructions.c:  (E->problem_settings)(E);
Instructions.c:    if (E->control.CONJ_GRAD) {
Instructions.c:        if(E->mesh.levels != 1)
Instructions.c:        if(E->mesh.levels < 2)
Instructions.c:        if(E->mesh.levels > MAX_LEVELS)
Instructions.c:    if((E->parallel.me == 0) && (E->control.only_check_vel_convergence)) {
Instructions.c:    if(E->sphere.caps == 12 &&
Instructions.c:       (E->control.remove_angular_momentum || E->control.remove_rigid_rotation) &&
Instructions.c:       (E->mesh.topvbc || E->mesh.botvbc || E->control.side_sbcs)) {
Instructions.c:   E->mesh.levmax = E->mesh.levels-1;
Instructions.c:   E->mesh.gridmax = E->mesh.levmax;
Instructions.c:   E->mesh.elx = E->mesh.nox-1;
Instructions.c:   E->mesh.ely = E->mesh.noy-1;
Instructions.c:   E->mesh.elz = E->mesh.noz-1;
Instructions.c:   if(E->sphere.caps == 1) {
Instructions.c:       E->mesh.nno = E->sphere.caps * E->mesh.nox * E->mesh.noy * E->mesh.noz;
Instructions.c:       E->mesh.nno = E->sphere.caps * (E->mesh.nox-1) * (E->mesh.noy-1) * E->mesh.noz
Instructions.c:           + 2*E->mesh.noz;
Instructions.c:   E->mesh.nel = E->sphere.caps*E->mesh.elx*E->mesh.elz*E->mesh.ely;
Instructions.c:   E->mesh.nnov = E->mesh.nno;
Instructions.c:   E->mesh.neq = E->mesh.nnov*E->mesh.nsd;
Instructions.c:if (E->parallel.me==0) fprintf(E->fp,"neqneq %d %d\n",E->mesh.neq, E->mesh.nnov);
Instructions.c:   E->mesh.npno = E->mesh.nel;
Instructions.c:   E->mesh.nsf = E->mesh.nox*E->mesh.noy;
Instructions.c:   for(i=E->mesh.levmax;i>=E->mesh.levmin;i--) {
Instructions.c:      nox = E->mesh.mgunitx * (int) pow(2.0,(double)i)*E->parallel.nprocx + 1;
Instructions.c:      noy = E->mesh.mgunity * (int) pow(2.0,(double)i)*E->parallel.nprocy + 1;
Instructions.c:      noz = E->mesh.mgunitz * (int) pow(2.0,(double)i)*E->parallel.nprocz + 1;
Instructions.c:      E->mesh.ELX[i] = nox-1;
Instructions.c:      E->mesh.ELY[i] = noy-1;
Instructions.c:      E->mesh.ELZ[i] = noz-1;
Instructions.c:      if(E->sphere.caps == 1) {
Instructions.c:          E->mesh.NNO[i] = nox * noz * noy;
Instructions.c:          E->mesh.NNO[i] = E->sphere.caps * (nox-1) * (noy-1) * noz + 2 * noz;
Instructions.c:      E->mesh.NEL[i] = E->sphere.caps * (nox-1) * (noz-1) * (noy-1);
Instructions.c:      E->mesh.NPNO[i] = E->mesh.NEL[i] ;
Instructions.c:      E->mesh.NOX[i] = nox;
Instructions.c:      E->mesh.NOZ[i] = noz;
Instructions.c:      E->mesh.NOY[i] = noy;
Instructions.c:      E->mesh.NNOV[i] = E->mesh.NNO[i];
Instructions.c:      E->mesh.NEQ[i] = E->mesh.nsd * E->mesh.NNOV[i] ;
Instructions.c:  E->sphere.elx = E->sphere.nox-1;
Instructions.c:  E->sphere.ely = E->sphere.noy-1;
Instructions.c:  E->sphere.snel = E->sphere.elx*E->sphere.ely;
Instructions.c:  E->sphere.nsf = E->sphere.nox*E->sphere.noy;
Instructions.c:    E->data.scalet = (E->data.radius_km*1e3*E->data.radius_km*1e3/E->data.therm_diff)/(1.e6*365.25*24*3600);
Instructions.c:    E->data.scalev = (E->data.radius_km*1e3/E->data.therm_diff)/(100*365.25*24*3600);
Instructions.c:    E->data.timedir = E->control.Atemp / fabs(E->control.Atemp);
Instructions.c:    if(E->control.print_convergence && E->parallel.me==0) {
Instructions.c:                E->mesh.nox, E->mesh.noz, E->mesh.noy, E->mesh.nno, E->mesh.nel);
Instructions.c:	fprintf(E->fp,"Problem has %d x %d x %d nodes per cap, %d nodes and %d elements in total\n",
Instructions.c:                E->mesh.nox, E->mesh.noz, E->mesh.noy, E->mesh.nno, E->mesh.nel);
Instructions.c:    const int vpts = vpoints[E->mesh.nsd];
Instructions.c: for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Instructions.c:  npno = E->lmesh.npno;
Instructions.c:  nel  = E->lmesh.nel;
Instructions.c:  nno  = E->lmesh.nno;
Instructions.c:  nsf  = E->lmesh.nsf;
Instructions.c:  noz  = E->lmesh.noz;
Instructions.c:  nox  = E->lmesh.nox;
Instructions.c:  noy  = E->lmesh.noy;
Instructions.c:  elx  = E->lmesh.elx;
Instructions.c:  ely  = E->lmesh.ely;
Instructions.c:  snel = E->lmesh.elx*E->lmesh.ely;
Instructions.c:  E->P[j]        = (double *) malloc((npno+1)*sizeof(double));
Instructions.c:  E->T[j]        = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:  E->NP[j]       = (float *) malloc((nno+1)*sizeof(float));
Instructions.c:  E->buoyancy[j] = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:  E->gstress[j] = (float *) malloc((6*nno+1)*sizeof(float));
Instructions.c:  //E->stress[j]   = (float *) malloc((12*nsf+1)*sizeof(float));
Instructions.c:  for(i=1;i<=E->mesh.nsd;i++)
Instructions.c:      E->sphere.cap[j].TB[i] = (float *)  malloc((nno+1)*sizeof(float));
Instructions.c:   E->gDA0[j] = (struct Shape_function_dA *)malloc((snel+1)*sizeof(struct Shape_function_dA));
Instructions.c:   E->gDA1[j] = (struct Shape_function_dA *)malloc((snel+1)*sizeof(struct Shape_function_dA));
Instructions.c:  E->slice.tpg[j]      = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:  E->slice.tpgb[j]     = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:  E->slice.divg[j]     = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:  E->slice.vort[j]     = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:  E->slice.shflux[j]    = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:  E->slice.bhflux[j]    = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:  /*  if(E->mesh.topvbc==2 && E->control.pseudo_free_surf) */
Instructions.c:  E->slice.freesurf[j]    = (float *)malloc((nsf+2)*sizeof(float));
Instructions.c:  E->all_load[j]      = (double *)malloc((nno+2)*sizeof(double));
Instructions.c:  E->total_load[j]      = (double *)malloc((nno+2)*sizeof(double));
Instructions.c:  E->all_potential[j]      = (double *)malloc((nno+2)*sizeof(double));
Instructions.c:  E->all_load_potential[j]      = (double *)malloc((nno+2)*sizeof(double));
Instructions.c:  E->total_potential[j]      = (double *)malloc((nno+2)*sizeof(double));
Instructions.c:  E->potential[0][j]      = (double *)malloc((nsf+2)*sizeof(double));
Instructions.c:  E->potential[1][j]      = (double *)malloc((nsf+2)*sizeof(double));
Instructions.c:  E->init_potential[0][j]      = (double *)malloc((nsf+2)*sizeof(double));
Instructions.c:  E->init_potential[1][j]      = (double *)malloc((nsf+2)*sizeof(double));
Instructions.c:  E->incr_potential[0][j]      = (double *)malloc((nsf+2)*sizeof(double));
Instructions.c:  E->incr_potential[1][j]      = (double *)malloc((nsf+2)*sizeof(double));
Instructions.c:  E->incr_potential[2][j]      = (double *)malloc((nsf+2)*sizeof(double));
Instructions.c:  E->incr_potential[3][j]      = (double *)malloc((nsf+2)*sizeof(double));
Instructions.c:  E->slice_ve.elast_thick[j]=(double *)malloc((nsf+2)*sizeof(double));
Instructions.c:  E->slice_ve.plate_margins[j]=(double *)malloc((nsf+2)*sizeof(double));
Instructions.c:     E->all_load[j][i] = 0.0;
Instructions.c:     E->total_load[j][i] = 0.0;
Instructions.c:     E->total_potential[j][i] = 0.0;
Instructions.c:     E->all_potential[j][i] = 0.0;
Instructions.c:     E->all_load_potential[j][i] = 0.0;
Instructions.c:     E->init_total_potential[j][i] = 0.0;
Instructions.c:     E->slice_ve.load[i][j]      = (double *)malloc((nsf+2)*sizeof(double));
Instructions.c:       E->slice_ve.load[i][j][k] = 0.0;
Instructions.c:  for (i=1;i<=E->mesh.nsd;i++)   {
Instructions.c:     E->slice_ve.surf[i][j]      = (double *)malloc((nsf+2)*sizeof(double));
Instructions.c:     E->slice_ve.botm[i][j]      = (double *)malloc((nsf+2)*sizeof(double));
Instructions.c:     E->Xsurf[i][j]      = (double *)malloc((nsf+2)*sizeof(double));
Instructions.c:       E->slice_ve.surf[i][j][k] = 0.0;
Instructions.c:       E->slice_ve.botm[i][j][k] = 0.0;
Instructions.c:   E->slice_ve.dynamic_oceanload[j]=(double *)malloc((nsf+2)*sizeof(double));
Instructions.c:   E->slice_ve.static_oceanload[j]=(double *)malloc((nsf+2)*sizeof(double));
Instructions.c:   E->slice_ve.iceload[0][j]=(double *)malloc((nsf+2)*sizeof(double));
Instructions.c:       E->slice_ve.dynamic_oceanload[j][k] = 0.0;
Instructions.c:       E->slice_ve.static_oceanload[j][k] = 0.0;
Instructions.c:       E->slice_ve.iceload[0][j][k] = 0.0;
Instructions.c:  E->Maxwelltime[j] = (double *)malloc((nel+1)*sizeof(double));
Instructions.c:  E->Sxx[j] = (double *)malloc((nel*vpts+1)*sizeof(double));
Instructions.c:  E->Syy[j] = (double *)malloc((nel*vpts+1)*sizeof(double));
Instructions.c:  E->Szz[j] = (double *)malloc((nel*vpts+1)*sizeof(double));
Instructions.c:  E->Sxy[j] = (double *)malloc((nel*vpts+1)*sizeof(double));
Instructions.c:  E->Sxz[j] = (double *)malloc((nel*vpts+1)*sizeof(double));
Instructions.c:  E->Szy[j] = (double *)malloc((nel*vpts+1)*sizeof(double));
Instructions.c:    E->S2xx[j] = (double *)malloc((nel+1)*sizeof(double));
Instructions.c:    E->S2yy[j] = (double *)malloc((nel+1)*sizeof(double));
Instructions.c:    E->S2zz[j] = (double *)malloc((nel+1)*sizeof(double));
Instructions.c:    E->S2xy[j] = (double *)malloc((nel+1)*sizeof(double));
Instructions.c:    E->S2xz[j] = (double *)malloc((nel+1)*sizeof(double));
Instructions.c:    E->S2zy[j] = (double *)malloc((nel+1)*sizeof(double));
Instructions.c:    E->EVold[j] = (float *) malloc((nel+2)*sizeof(float));
Instructions.c:    E->EVolder[j] = (float *) malloc((nel+2)*sizeof(float));
Instructions.c:    E->S2inv[j] = (float *) malloc((nel+2)*sizeof(float));
Instructions.c:    E->E2inv[j] = (float *) malloc((nel+2)*sizeof(float));
Instructions.c:  E->mat[j] = (int *) malloc((nel+2)*sizeof(int));
Instructions.c:  E->VIP[j] = (float *) malloc((nel+2)*sizeof(float));
Instructions.c:  E->heating_adi[j]    = (double *) malloc((nel+1)*sizeof(double));
Instructions.c:  E->heating_visc[j]   = (double *) malloc((nel+1)*sizeof(double));
Instructions.c:  E->heating_latent[j] = (double *) malloc((nel+1)*sizeof(double));
Instructions.c:  E->TMass[j] = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:  E->NMass[j] = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:  E->sien[j]         = (struct SIEN *) malloc((nxyz+2)*sizeof(struct SIEN));
Instructions.c:  E->surf_element[j] = (int *) malloc((nxyz+2)*sizeof(int));
Instructions.c:  E->surf_node[j]    = (int *) malloc((nsf+2)*sizeof(int));
Instructions.c:  E->rho      = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:  E->Have.T         = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Instructions.c:  E->Have.V[1]      = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Instructions.c:  E->Have.V[2]      = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Instructions.c: for(i=E->mesh.levmin;i<=E->mesh.levmax;i++) {
Instructions.c:  E->sphere.R[i] = (double *)  malloc((E->lmesh.NOZ[i]+1)*sizeof(double));
Instructions.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Instructions.c:    nno  = E->lmesh.NNO[i];
Instructions.c:    npno = E->lmesh.NPNO[i];
Instructions.c:    nel  = E->lmesh.NEL[i];
Instructions.c:    nox = E->lmesh.NOX[i];
Instructions.c:    noz = E->lmesh.NOZ[i];
Instructions.c:    noy = E->lmesh.NOY[i];
Instructions.c:    elx = E->lmesh.ELX[i];
Instructions.c:    ely = E->lmesh.ELY[i];
Instructions.c:    snel=E->lmesh.SNEL[i];
Instructions.c:    for(d=1;d<=E->mesh.nsd;d++)   {
Instructions.c:      E->X[i][j][d]  = (double *)  malloc((nno+1)*sizeof(double));
Instructions.c:      E->SX[i][j][d]  = (double *)  malloc((nno+1)*sizeof(double));
Instructions.c:      E->SinCos[i][j][d]  = (double *)  malloc((nno+1)*sizeof(double));
Instructions.c:    E->IEN[i][j] = (struct IEN *)   malloc((nel+2)*sizeof(struct IEN));
Instructions.c:    E->EL[i][j]  = (struct SUBEL *) malloc((nel+2)*sizeof(struct SUBEL));
Instructions.c:    E->sphere.area1[i][j] = (double *) malloc((snel+1)*sizeof(double));
Instructions.c:      E->sphere.angle1[i][j][k] = (double *) malloc((snel+1)*sizeof(double));
Instructions.c:    E->GNX[i][j] = (struct Shape_function_dx *)malloc((nel+1)*sizeof(struct Shape_function_dx));
Instructions.c:    E->GDA[i][j] = (struct Shape_function_dA *)malloc((nel+1)*sizeof(struct Shape_function_dA));
Instructions.c:    E->MASS[i][j]     = (double *) malloc((nno+1)*sizeof(double));
Instructions.c:    E->ECO[i][j] = (struct COORD *) malloc((nno+2)*sizeof(struct COORD));
Instructions.c:    E->TWW[i][j] = (struct FNODE *)   malloc((nel+2)*sizeof(struct FNODE));
Instructions.c:    for(d=1;d<=E->mesh.nsd;d++)
Instructions.c:      for(l=1;l<=E->lmesh.NNO[i];l++)  {
Instructions.c:        E->SX[i][j][d][l] = 0.0;
Instructions.c:        E->X[i][j][d][l] = 0.0;
Instructions.c: for(i=0;i<=E->output.llmax;i++)
Instructions.c:  E->sphere.hindex[i] = (int *) malloc((E->output.llmax+3)
Instructions.c: for(i=E->mesh.gridmin;i<=E->mesh.gridmax;i++)
Instructions.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Instructions.c:    nno  = E->lmesh.NNO[i];
Instructions.c:    npno = E->lmesh.NPNO[i];
Instructions.c:    nel  = E->lmesh.NEL[i];
Instructions.c:    nox = E->lmesh.NOX[i];
Instructions.c:    noz = E->lmesh.NOZ[i];
Instructions.c:    noy = E->lmesh.NOY[i];
Instructions.c:    elx = E->lmesh.ELX[i];
Instructions.c:    ely = E->lmesh.ELY[i];
Instructions.c:    E->CC[i][j] =(struct CC *)  malloc((1)*sizeof(struct CC));
Instructions.c:    E->CCX[i][j]=(struct CCX *)  malloc((1)*sizeof(struct CCX));
Instructions.c:    E->ELEMENT[i][j] = (unsigned int *) malloc((nel+2)*sizeof(unsigned int));
Instructions.c:    E->elt_del[i][j] = (struct EG *) malloc((nel+1)*sizeof(struct EG));
Instructions.c:    if(E->control.inv_gruneisen != 0)
Instructions.c:        E->elt_c[i][j] = (struct EC *) malloc((nel+1)*sizeof(struct EC));
Instructions.c:    E->EVI[i][j] = (float *) malloc((nel+1)*vpoints[E->mesh.nsd]*sizeof(float));
Instructions.c:    E->erho[i][j]    = (float *) malloc((nel+1)*sizeof(float));
Instructions.c:    E->elambda[i][j] = (float *) malloc((nel+1)*sizeof(float));
Instructions.c:    E->esmu[i][j]    = (float *) malloc((nel+1)*sizeof(float));
Instructions.c:    E->egrav[i][j]    = (float *) malloc((nel+1)*sizeof(float));
Instructions.c:    E->BPI[i][j] = (double *) malloc((npno+1)*sizeof(double));
Instructions.c:    E->ID[i][j]  = (struct ID *)    malloc((nno+1)*sizeof(struct ID));
Instructions.c:    E->VI[i][j]  = (float *)        malloc((nno+1)*sizeof(float));
Instructions.c:    E->NODE[i][j] = (unsigned int *)malloc((nno+1)*sizeof(unsigned int));
Instructions.c:    E->parallel.EXCHANGE_sNODE[i][j] = (struct PASS *) malloc((nozl+2)*sizeof(struct PASS));
Instructions.c:    E->parallel.NODE[i][j]   = (struct BOUND *) malloc((nxyz+2)*sizeof(struct BOUND));
Instructions.c:    E->parallel.EXCHANGE_NODE[i][j]= (struct PASS *) malloc((nxyz+2)*sizeof(struct PASS));
Instructions.c:    E->parallel.EXCHANGE_ID[i][j] = (struct PASS *) malloc((nxyz*E->mesh.nsd+3)*sizeof(struct PASS));
Instructions.c:    for(l=1;l<=E->lmesh.NNO[i];l++)  {
Instructions.c:      E->NODE[i][j][l] = (INTX | INTY | INTZ);  /* and any others ... */
Instructions.c:      E->VI[i][j][l] = 1.0;
Instructions.c:      E->ELEMENT[i][j][l]=0;
Instructions.c: for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Instructions.c:  for(k=1;k<=E->mesh.nsd;k++)
Instructions.c:    for(i=1;i<=E->lmesh.nno;i++)
Instructions.c:      E->sphere.cap[j].TB[k][i] = 0.0;
Instructions.c:  for(i=1;i<=E->lmesh.nno;i++)  {
Instructions.c:     E->T[j][i] = 0.0;
Instructions.c:     E->buoyancy[j][i] = 0.0;
Instructions.c:  for(i=1;i<=E->lmesh.nel;i++)   {
Instructions.c:      E->mat[j][i]=1;
Instructions.c:      E->Maxwelltime[j][i]=1;
Instructions.c:      E->VIP[j][i]=1.0;
Instructions.c:      E->heating_adi[j][i] = 0;
Instructions.c:      E->heating_visc[j][i] = 0;
Instructions.c:      E->heating_latent[j][i] = 1.0;
Instructions.c:  for(i=1;i<=E->lmesh.npno;i++)
Instructions.c:      E->P[j][i] = 0.0;
Instructions.c:  if (strcmp(E->output.format, "hdf5") == 0)
Instructions.c:    E->monitor.incompressibility = 0;
Instructions.c:    E->monitor.fdotf = 0;
Instructions.c:    E->monitor.vdotv = 0;
Instructions.c:    E->monitor.pdotp = 0;
Instructions.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Instructions.c:    E->lmesh.nnov = E->lmesh.nno;
Instructions.c:    E->lmesh.neq = E->lmesh.nnov * E->mesh.nsd;
Instructions.c:    E->temp[j] = (double *) malloc((E->lmesh.neq+1)*sizeof(double));
Instructions.c:    E->temp1[j] = (double *) malloc(E->lmesh.neq*sizeof(double));
Instructions.c:    E->F[j] = (double *) malloc(E->lmesh.neq*sizeof(double));
Instructions.c:    E->U[j] = (double *) malloc((E->lmesh.neq+1)*sizeof(double));
Instructions.c:    E->u1[j] = (double *) malloc((E->lmesh.neq+1)*sizeof(double));
Instructions.c:    for(i=1;i<=E->mesh.nsd;i++) {
Instructions.c:      E->sphere.cap[j].V[i] = (double *) malloc((E->lmesh.nnov+1)*sizeof(double));
Instructions.c:      E->sphere.cap[j].total_VS[i] = (double *) malloc((E->lmesh.nnov+1)*sizeof(double));
Instructions.c:      E->sphere.cap[j].total_VC[i] = (double *) malloc((E->lmesh.nnov+1)*sizeof(double));
Instructions.c:      E->sphere.cap[j].VB[i] = (float *)malloc((E->lmesh.nnov+1)*sizeof(float));
Instructions.c:      E->sphere.cap[j].Vprev[i] = (float *) malloc((E->lmesh.nnov+1)*sizeof(float));
Instructions.c:    for(i=0;i<E->lmesh.neq;i++)
Instructions.c:      E->U[j][i] = E->temp[j][i] = E->temp1[j][i] = 0.0;
Instructions.c:    for(k=1;k<=E->mesh.nsd;k++)
Instructions.c:      for(i=1;i<=E->lmesh.nnov;i++)  {
Instructions.c:        E->sphere.cap[j].VB[k][i] = 0.0;
Instructions.c:    for(k=1;k<=E->mesh.nsd;k++)
Instructions.c:      for(i=1;i<=E->lmesh.nsf;i++)  {
Instructions.c:        E->sphere.cap[j].total_VS[k][i] = 0.0;
Instructions.c:        E->sphere.cap[j].total_VC[k][i] = 0.0;
Instructions.c:  for(l=E->mesh.gridmin;l<=E->mesh.gridmax;l++)
Instructions.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Instructions.c:      E->lmesh.NEQ[l] = E->lmesh.NNOV[l] * E->mesh.nsd;
Instructions.c:      for (i=1;i<=enodes[E->mesh.nsd];i++)  {
Instructions.c:         E->B_R[l][j][i] = (double *)malloc((E->lmesh.SNEL[l]*onedvpoints[E->mesh.nsd]+2)*sizeof(double));
Instructions.c:         for (n=1;n<=E->lmesh.SNEL[l]*onedvpoints[E->mesh.nsd]+1;n++)
Instructions.c:             E->B_R[l][j][i][n] = 0.0;
Instructions.c:      E->BI[l][j] = (double *) malloc((E->lmesh.NEQ[l])*sizeof(double));
Instructions.c:      k = (E->lmesh.NOX[l]*E->lmesh.NOZ[l]+E->lmesh.NOX[l]*E->lmesh.NOY[l]+
Instructions.c:          E->lmesh.NOY[l]*E->lmesh.NOZ[l])*6;
Instructions.c:      E->zero_resid[l][j] = (int *) malloc((k+2)*sizeof(int));
Instructions.c:      E->parallel.Skip_id[l][j] = (int *) malloc((k+2)*sizeof(int));
Instructions.c:      for(i=0;i<E->lmesh.NEQ[l];i++) {
Instructions.c:         E->BI[l][j][i]=0.0;
Instructions.c:  E->control.v_steps_low = 10;
Instructions.c:  E->control.v_steps_upper = 1;
Instructions.c:  E->control.accuracy = 1.0e-4;
Instructions.c:  E->control.verbose=0; /* debugging/profiles */
Instructions.c:    E->control.stokes=0;
Instructions.c:    E->control.restart=0;
Instructions.c:    E->control.CONVECTION = 0;
Instructions.c:    E->control.CART2D = 0;
Instructions.c:    E->control.CART3D = 0;
Instructions.c:    E->control.CART2pt5D = 0;
Instructions.c:    E->control.AXI = 0;
Instructions.c:    E->control.CONJ_GRAD = 0;
Instructions.c:    E->control.NMULTIGRID = 0;
Instructions.c:    E->control.augmented_Lagr = 0;
Instructions.c:    E->control.augmented = 0.0;
Instructions.c:    E->trace.fpt = NULL;
Instructions.c:    E->control.tracer = 0;
Instructions.c:    E->composition.on = 0;
Instructions.c:  E->parallel.nprocx=1; E->parallel.nprocz=1; E->parallel.nprocy=1;
Instructions.c:  E->mesh.levmax=0;
Instructions.c:  E->mesh.levmin=0;
Instructions.c:  E->mesh.gridmax=0;
Instructions.c:  E->mesh.gridmin=0;
Instructions.c:  E->mesh.noz = 1;    E->mesh.nzs = 1;  E->lmesh.noz = 1;    E->lmesh.nzs = 1;
Instructions.c:  E->mesh.noy = 1;    E->mesh.nys = 1;  E->lmesh.noy = 1;    E->lmesh.nys = 1;
Instructions.c:  E->mesh.nox = 1;    E->mesh.nxs = 1;  E->lmesh.nox = 1;    E->lmesh.nxs = 1;
Instructions.c:  E->sphere.ro = 1.0;
Instructions.c:  E->sphere.ri = 0.5;
Instructions.c:  E->control.precondition = 0;  /* for larger visc contrasts turn this back on  */
Instructions.c:  E->mesh.toptbc = 1; /* fixed t */
Instructions.c:  E->mesh.bottbc = 1;
Instructions.c:  E->mesh.topvbc = 0; /* stress */
Instructions.c:  E->mesh.botvbc = 0;
Instructions.c:  E->control.VBXtopval=0.0;
Instructions.c:  E->control.VBYtopval=0.0;
Instructions.c:  E->control.VBXbotval=0.0;
Instructions.c:  E->control.VBYbotval=0.0;
Instructions.c:  E->data.radius_km = 6370.0; /* Earth, whole mantle defaults */
Instructions.c:  E->data.grav_acc = 9.81;
Instructions.c:  E->data.therm_diff = 1.0e-6;
Instructions.c:  E->data.therm_exp = 3.e-5;
Instructions.c:  E->data.density = 3300.0;
Instructions.c:  E->data.ref_viscosity=1.e21;
Instructions.c:  E->data.density_above = 1000.0;    /* sea water */
Instructions.c:  E->data.density_below = 6600.0;    /* sea water */
Instructions.c:  E->data.Cp = 1200.0;
Instructions.c:  E->data.therm_cond = 3.168;
Instructions.c:  E->data.res_density = 3300.0;  /* density when X = ... */
Instructions.c:  E->data.res_density_X = 0.3;
Instructions.c:  E->data.melt_density = 2800.0;
Instructions.c:  E->data.permeability = 3.0e-10;
Instructions.c:  E->data.gas_const = 8.3;
Instructions.c:  E->data.surf_heat_flux = 4.4e-2;
Instructions.c:  E->data.grav_const = 6.6742e-11;
Instructions.c:  E->data.youngs_mod = 1.0e11;
Instructions.c:  E->data.Te = 0.0;
Instructions.c:  E->data.T_sol0 = 1373.0;      /* Dave's values 1991 (for the earth) */
Instructions.c:  E->data.Tsurf = 273.0;
Instructions.c:  E->data.dTsol_dz = 3.4e-3 ;
Instructions.c:  E->data.dTsol_dF = 440.0;
Instructions.c:  E->data.dT_dz = 0.48e-3;
Instructions.c:  E->data.delta_S = 250.0;
Instructions.c:  E->data.ref_temperature = 2 * 1350.0; /* fixed temperature ... delta T */
Instructions.c:    sprintf(E->control.data_prefix,"citcom.tmp.%d",getpid());
Instructions.c:    E->control.NASSEMBLE = 0;
Instructions.c:    E->monitor.elapsed_time=0.0;
Instructions.c:    E->control.record_all_until = 10000000;
Instructions.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Instructions.c:    for(i=1;i<=E->lmesh.nno;i++)    {
Instructions.c:      if ((E->node[j][i] & VBX) && (E->node[j][i] & SBX))
Instructions.c:      if ((E->node[j][i] & VBZ) && (E->node[j][i] & SBZ))
Instructions.c:      if ((E->node[j][i] & VBY) && (E->node[j][i] & SBY))
Instructions.c:      if ((E->node[j][i] & TBX) && (E->node[j][i] & FBX))
Instructions.c:      if ((E->node[j][i] & TBZ) && (E->node[j][i] & FBZ))
Instructions.c:      if ((E->node[j][i] & TBY) && (E->node[j][i] & FBY))
Instructions.c:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Instructions.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Instructions.c:      for(i=1;i<=E->lmesh.NNO[lev];i++)        {
Instructions.c:        if ((E->NODE[lev][j][i] & VBX) && (E->NODE[lev][j][i]  & SBX))
Instructions.c:        if ((E->NODE[lev][j][i] & VBZ) && (E->NODE[lev][j][i]  & SBZ))
Instructions.c:        if ((E->NODE[lev][j][i] & VBY) && (E->NODE[lev][j][i]  & SBY))
Instructions.c:  E->eco[j] = E->ECO[E->mesh.levmax][j];
Instructions.c:  E->ien[j] = E->IEN[E->mesh.levmax][j];
Instructions.c:  E->id[j] = E->ID[E->mesh.levmax][j];
Instructions.c:  E->Vi[j] = E->VI[E->mesh.levmax][j];
Instructions.c:  E->EVi[j] = E->EVI[E->mesh.levmax][j];
Instructions.c:  E->node[j] = E->NODE[E->mesh.levmax][j];
Instructions.c:  E->cc[j] = E->CC[E->mesh.levmax][j];
Instructions.c:  E->ccx[j] = E->CCX[E->mesh.levmax][j];
Instructions.c:  E->Mass[j] = E->MASS[E->mesh.levmax][j];
Instructions.c:  E->gDA[j] = E->GDA[E->mesh.levmax][j];
Instructions.c:  E->gNX[j] = E->GNX[E->mesh.levmax][j];
Instructions.c:  for (i=1;i<=E->mesh.nsd;i++)    {
Instructions.c:    E->x[j][i] = E->X[E->mesh.levmax][j][i];
Instructions.c:    E->sx[j][i] = E->SX[E->mesh.levmax][j][i];
Instructions.c:{ if(E->control.verbose && E->parallel.me==0)
Instructions.c:{ if(E->control.verbose && E->fp)
Instructions.c:    { fprintf(E->fp,"%s\n",string);
Instructions.c:      fflush(E->fp);
Instructions.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Instructions.c:    for(i=1;i<=E->lmesh.npno;i++)
Instructions.c:      E->P[m][i]=0.0;
Instructions.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Instructions.c:    for(i=1;i<=E->lmesh.nnov;i++)   {
Instructions.c:        E->sphere.cap[m].V[1][i]=0.0;
Instructions.c:        E->sphere.cap[m].V[2][i]=0.0;
Instructions.c:        E->sphere.cap[m].V[3][i]=0.0;
Instructions.c:  E->fp = NULL;
Instructions.c:  if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:    sprintf(logfile,"%s/log", E->control.data_dir);
Instructions.c:    sprintf(logfile,"%s.log", E->control.data_file);
Instructions.c:  if (E->control.restart || E->control.post_p)
Instructions.c:      E->fp = output_open(logfile, "a");
Instructions.c:      E->fp = output_open(logfile, "w");
Instructions.c:  sprintf(logfile,"%s.Love_numbers", E->control.data_file);
Instructions.c:  E->fp_LN = output_open(logfile, "w");
Instructions.c:  E->fptime = NULL;
Instructions.c:  if (E->parallel.me == 0) {
Instructions.c:  if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:    sprintf(timeoutput,"%s/time", E->control.data_dir);
Instructions.c:    sprintf(timeoutput,"%s.time", E->control.data_file);
Instructions.c:  if (E->control.restart || E->control.post_p)
Instructions.c:      E->fptime = output_open(timeoutput, "a");
Instructions.c:      E->fptime = output_open(timeoutput, "w");
Instructions.c:  E->fp_out = NULL;
Instructions.c:  if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:    sprintf(output_file,"%s/info.%d", E->control.data_dir, E->parallel.me);
Instructions.c:    sprintf(output_file,"%s.info.%d", E->control.data_file, E->parallel.me);
Instructions.c:  E->fp_out = output_open(output_file, "w");
Instructions.c:  if (E->control.verbose) {
Instructions.c:  if((E->parallel.me_loc[3] == E->parallel.nprocz-1) &&
Instructions.c:     (E->parallel.me==E->parallel.nprocz-1)){
Instructions.c:    if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:      sprintf(output_file,"%s/qt.dat", E->control.data_dir);
Instructions.c:      sprintf(output_file,"%s.qt.dat", E->control.data_file);
Instructions.c:    if(E->control.restart)
Instructions.c:      E->output.fpqt = output_open(output_file, "a"); /* append for restart */
Instructions.c:      E->output.fpqt = output_open(output_file, "w");
Instructions.c:    E->output.fpqt = NULL;
Instructions.c:  if (E->parallel.me_loc[3] == 0)    {
Instructions.c:    if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:      sprintf(output_file,"%s/qb.dat", E->control.data_dir);
Instructions.c:      sprintf(output_file,"%s.qb.dat", E->control.data_file);
Instructions.c:    if(E->control.restart)
Instructions.c:      E->output.fpqb = output_open(output_file, "a"); /* append */
Instructions.c:      E->output.fpqb = output_open(output_file, "w");
Instructions.c:    E->output.fpqb = NULL;
Instructions.c:    len = strlen(E->output.optional);
Instructions.c:    next = E->output.optional;
Instructions.c:    E->output.connectivity = 0;
Instructions.c:    E->output.stress = 0;
Instructions.c:    E->output.pressure = 0;
Instructions.c:    E->output.surf = 0;
Instructions.c:    E->output.botm = 0;
Instructions.c:    E->output.geoid = 0;
Instructions.c:    E->output.horiz_avg = 0;
Instructions.c:    E->output.seismic = 0;
Instructions.c:    E->output.coord_bin = 0;
Instructions.c:    E->output.tracer = 0;
Instructions.c:    E->output.comp_el = 0;
Instructions.c:    E->output.comp_nd = 0;
Instructions.c:    E->output.heating = 0;
Instructions.c:            E->output.connectivity = 1;
Instructions.c:            E->output.stress = 1;
Instructions.c:            E->output.pressure = 1;
Instructions.c:            E->output.surf = 1;
Instructions.c:            E->output.botm = 1;
Instructions.c:	    if (E->parallel.nprocxy != 12) {
Instructions.c:		E->output.geoid  = 1;
Instructions.c:            E->output.horiz_avg = 1;
Instructions.c:            E->output.seismic = E->output.coord_bin = 1;
Instructions.c:            if(E->parallel.me==0) {
Instructions.c:                fprintf(stderr, "Total temperature contrast = %f K\n", E->data.ref_temperature);
Instructions.c:                fprintf(E->fp, "Total temperature contrast = %f K\n", E->data.ref_temperature);
Instructions.c:            E->output.tracer = 1;
Instructions.c:            E->output.comp_el = 1;
Instructions.c:            E->output.comp_nd = 1;
Instructions.c:            E->output.heating = 1;
Instructions.c:            if(E->parallel.me == 0)
Instructions.c:/* check whether E->control.data_file contains a path seperator */
Instructions.c:  found = strchr(E->control.data_prefix, '/');
Instructions.c:      fprintf(stderr, "error in input parameter: datafile='%s' contains '/'\n", E->control.data_file);
Instructions.c:  if (E->control.restart || E->control.post_p ||
Instructions.c:      (E->convection.tic_method == -1) ||
Instructions.c:      (E->control.tracer && (E->trace.ic_method == 2))) {
Instructions.c:      found = strchr(E->control.data_prefix_old, '/');
Instructions.c:	  fprintf(stderr, "error in input parameter: datafile_old='%s' contains '/'\n", E->control.data_file);
Instructions.c:	sprintf(tmp, "%d", E->parallel.me);
Instructions.c:    expand_datadir(E, E->control.data_dir);
Instructions.c:    mkdatadir(E->control.data_dir);
Instructions.c:    snprintf(E->control.data_file, 200, "%s/%s", E->control.data_dir,
Instructions.c:	     E->control.data_prefix);
Instructions.c:    if (E->control.restart || E->control.post_p ||
Instructions.c:        (E->convection.tic_method == -1) ||
Instructions.c:        (E->control.tracer && (E->trace.ic_method == 2))) {
Instructions.c:	expand_datadir(E, E->control.data_dir_old);
Instructions.c:	snprintf(E->control.old_P_file, 200, "%s/%s", E->control.data_dir_old,
Instructions.c:		 E->control.data_prefix_old);
Instructions.c:    if (strcmp(E->output.format, "ascii") == 0) {
Instructions.c:        E->problem_output = output;
Instructions.c:    else if (strcmp(E->output.format, "hdf5") == 0)
Instructions.c:        E->problem_output = h5output;
Instructions.c:    else if (strcmp(E->output.format, "vtk") == 0)
Instructions.c:        E->problem_output = vtk_output;
Instructions.c:    else if (strcmp(E->output.format, "ascii-gz") == 0)
Instructions.c:        E->problem_output = gzdir_output;
Instructions.c:        if (E->parallel.me == 0) {
Instructions.c:            fprintf(E->fp, "wrong output_format, must be  'ascii', 'hdf5' 'ascii-gz', or 'vtk'\n");
Instructions.c:        if (E->parallel.me == 0) {
Instructions.c:            fprintf(E->fp, "wrong output_format, must be 'ascii', 'hdf5', or 'vtk' (USE_GZDIR undefined)\n");
Instructions.c:  if (E->fp)
Instructions.c:    fclose(E->fp);
Instructions.c:  if (E->fptime)
Instructions.c:    fclose(E->fptime);
Instructions.c:  if (E->fp_out)
Instructions.c:    fclose(E->fp_out);
Instructions.c:  if (E->trace.fpt)
Instructions.c:    fclose(E->trace.fpt);
Instructions.c:  if(E->output.fpqt)
Instructions.c:    fclose(E->output.fpqt);
Instructions.c:  if(E->output.fpqb)
Instructions.c:    fclose(E->output.fpqb);
Instructions.c:  if (E->fp_LN)
Instructions.c:    fclose(E->fp_LN);
Instructions.c:  if((E->output.gzdir.vtk_io != 0) &&
Instructions.c:     (strcmp(E->output.format, "ascii-gz") == 0)){
Instructions.c:    if((E->output.gzdir.vtk_io == 3)||(E->parallel.me == 0)){
Instructions.c:      if(E->parallel.me == 0){
Instructions.c:	if(E->output.gzdir.vtk_fp)
Instructions.c:	  fclose(E->output.gzdir.vtk_fp);
Lith_age.c:  int m = E->parallel.me;
Lith_age.c:  E->control.lith_age = 0;
Lith_age.c:  E->control.lith_age_time = 0;
Lith_age.c:  E->control.temperature_bound_adj = 0;
Lith_age.c:  input_int("lith_age",&(E->control.lith_age),"0",m);
Lith_age.c:  input_int("ggrd_age_control",&(E->control.ggrd.age_control),"0",m); /* if > 0, will use top  E->control.ggrd.mat_control layers and assign a prefactor for the viscosity */
Lith_age.c:  if(E->control.ggrd.age_control){
Lith_age.c:    E->control.lith_age = 1;	
Lith_age.c:  if (E->control.lith_age) {
Lith_age.c:    input_int("lith_age_time",&(E->control.lith_age_time),"0",m);
Lith_age.c:    input_string("lith_age_file",E->control.lith_age_file,"",m);
Lith_age.c:    input_float("lith_age_depth",&(E->control.lith_age_depth),"0.0471",m);
Lith_age.c:    input_int("temperature_bound_adj",&(E->control.temperature_bound_adj),"0",m);
Lith_age.c:    if (E->control.temperature_bound_adj) {
Lith_age.c:      input_float("depth_bound_adj",&(E->control.depth_bound_adj),"0.1570",m);
Lith_age.c:      input_float("width_bound_adj",&(E->control.width_bound_adj),"0.08727",m);
Lith_age.c:  gnox=E->mesh.nox;
Lith_age.c:  gnoy=E->mesh.noy;
Lith_age.c:  if (E->parallel.me == 0 ) fprintf(stderr,"INSIDE lith_age_init\n");
Lith_age.c:  E->age_t=(float*) malloc((gnox*gnoy+1)*sizeof(float));
Lith_age.c:  if(E->control.lith_age_time==1)   {
Lith_age.c:    E->control.lith_age_old_cycles = E->monitor.solution_cycles;
Lith_age.c:    (E->solver.lith_age_read_files)(E,output);
Lith_age.c:    sprintf(output_file,"%s",E->control.lith_age_file);
Lith_age.c:      fprintf(E->fp,"(Boundary_conditions #1) Can't open %s\n",output_file);
Lith_age.c:	if(fscanf(fp1,"%f",&(E->age_t[node])) != 1) {
Lith_age.c:	E->age_t[node]=E->age_t[node]*E->data.scalet;
Lith_age.c:  } /* end E->control.lith_age_time == false */
Lith_age.c:  noy=E->lmesh.noy;
Lith_age.c:  nox=E->lmesh.nox;
Lith_age.c:  noz=E->lmesh.noz;
Lith_age.c:  gnox=E->mesh.nox;
Lith_age.c:  gnoy=E->mesh.noy;
Lith_age.c:  gnoz=E->mesh.noz;
Lith_age.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Lith_age.c:	  nodeg=E->lmesh.nxs-1+j+(E->lmesh.nys+i-2)*gnox;
Lith_age.c:	  r1=E->sx[m][3][node];
Lith_age.c:	  E->T[m][node] = E->control.mantle_temp;
Lith_age.c:	  if( r1 >= E->sphere.ro-E->control.lith_age_depth )
Lith_age.c:	      temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Lith_age.c:	      E->T[m][node] = E->control.mantle_temp * erf(temp);
Lith_age.c:  noy = E->lmesh.noy;
Lith_age.c:  nox = E->lmesh.nox;
Lith_age.c:  noz = E->lmesh.noz;
Lith_age.c:  rout = E->sphere.ro;
Lith_age.c:  rin = E->sphere.ri;
Lith_age.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Lith_age.c:	  r1=E->sx[m][3][node];
Lith_age.c:	    E->sphere.cap[m].TB[1][node]=E->T[m][node];
Lith_age.c:	    E->sphere.cap[m].TB[2][node]=E->T[m][node];
Lith_age.c:	    E->sphere.cap[m].TB[3][node]=E->T[m][node];
Lith_age.c:  nno=E->lmesh.nno;
Lith_age.c:  if (E->control.temperature_bound_adj) {
Lith_age.c:    ttt2=E->control.theta_min + E->control.width_bound_adj;
Lith_age.c:    ttt3=E->control.theta_max - E->control.width_bound_adj;
Lith_age.c:    fff2=E->control.fi_min + E->control.width_bound_adj;
Lith_age.c:    fff3=E->control.fi_max - E->control.width_bound_adj;
Lith_age.c:    if(lv==E->mesh.gridmax)
Lith_age.c:      for(j=1;j<=E->sphere.caps_per_proc;j++)
Lith_age.c:	for(node=1;node<=E->lmesh.nno;node++)  {
Lith_age.c:	  if( ((E->sx[j][1][node]<=ttt2) && (E->sx[j][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) || ((E->sx[j][1][node]>=ttt3) && (E->sx[j][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) )
Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBX;
Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBX);
Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBY;
Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBY);
Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBZ;
Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBZ);
Lith_age.c:	  if( ((E->sx[j][2][node]<=fff2) && (E->sx[j][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) )
Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBX;
Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBX);
Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBY;
Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBY);
Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBZ;
Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBZ);
Lith_age.c:	  if( ((E->sx[j][2][node]>=fff3) && (E->sx[j][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) )
Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBX;
Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBX);
Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBY;
Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBY);
Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBZ;
Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBZ);
Lith_age.c:  } /* end E->control.temperature_bound_adj */
Lith_age.c:  if (E->control.lith_age_time) {
Lith_age.c:    if(lv==E->mesh.gridmax)
Lith_age.c:      for(j=1;j<=E->sphere.caps_per_proc;j++)
Lith_age.c:	for(node=1;node<=E->lmesh.nno;node++)  {
Lith_age.c:	  if(E->sx[j][3][node]>=E->sphere.ro-E->control.lith_age_depth)
Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBX;
Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBX);
Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBY;
Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBY);
Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBZ;
Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBZ);
Lith_age.c:  } /* end E->control.lith_age_time */
Lith_age.c:  gnox=E->mesh.nox;
Lith_age.c:  gnoy=E->mesh.noy;
Lith_age.c:  gnoz=E->mesh.noz;
Lith_age.c:  nox=E->lmesh.nox;
Lith_age.c:  noy=E->lmesh.noy;
Lith_age.c:  noz=E->lmesh.noz;
Lith_age.c:  if(E->control.lith_age_time==1)   {
Lith_age.c:    if (E->control.lith_age_old_cycles != E->monitor.solution_cycles) {
Lith_age.c:      E->control.lith_age_old_cycles = E->monitor.solution_cycles;
Lith_age.c:    if (E->parallel.me == 0) fprintf(stderr,"INSIDE lith_age_conform_tbc\n");
Lith_age.c:    (E->solver.lith_age_read_files)(E,output);
Lith_age.c:  if(E->monitor.solution_cycles>1 && E->control.temperature_bound_adj) {
Lith_age.c:    ttt2=E->control.theta_min + E->control.width_bound_adj;
Lith_age.c:    ttt3=E->control.theta_max - E->control.width_bound_adj;
Lith_age.c:    fff2=E->control.fi_min + E->control.width_bound_adj;
Lith_age.c:    fff3=E->control.fi_max - E->control.width_bound_adj;
Lith_age.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Lith_age.c:	    nodeg=E->lmesh.nxs-1+j+(E->lmesh.nys+i-2)*gnox;
Lith_age.c:	    t1=E->sx[m][1][node];
Lith_age.c:	    f1=E->sx[m][2][node];
Lith_age.c:	    r1=E->sx[m][3][node];
Lith_age.c:	    if(fabs(r1-E->sphere.ro)>=e_4 && fabs(r1-E->sphere.ri)>=e_4)  { /* if NOT right on the boundary */
Lith_age.c:	      if( ((E->sx[m][1][node]<=ttt2) && (E->sx[m][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) || ((E->sx[m][1][node]>=ttt3) && (E->sx[m][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) ) {
Lith_age.c:		temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Lith_age.c:		t0 = E->control.mantle_temp * erf(temp);
Lith_age.c:		E->sphere.cap[m].TB[1][node]=t0;
Lith_age.c:		E->sphere.cap[m].TB[2][node]=t0;
Lith_age.c:		E->sphere.cap[m].TB[3][node]=t0;
Lith_age.c:	      if( ((E->sx[m][2][node]<=fff2) || (E->sx[m][2][node]>=fff3)) && (E->sx[m][3][node]>=E->sphere.ro-E->control.depth_bound_adj) ) {
Lith_age.c:		temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Lith_age.c:		t0 = E->control.mantle_temp * erf(temp);
Lith_age.c:		E->sphere.cap[m].TB[1][node]=t0;
Lith_age.c:		E->sphere.cap[m].TB[2][node]=t0;
Lith_age.c:		E->sphere.cap[m].TB[3][node]=t0;
Lith_age.c:  if(E->monitor.solution_cycles>0 && E->control.lith_age_time)   {
Lith_age.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Lith_age.c:	    nodeg=E->lmesh.nxs-1+j+(E->lmesh.nys+i-2)*gnox;
Lith_age.c:	    t1=E->sx[m][1][node];
Lith_age.c:	    f1=E->sx[m][2][node];
Lith_age.c:	    r1=E->sx[m][3][node];
Lith_age.c:	    if(fabs(r1-E->sphere.ro)>=e_4 && fabs(r1-E->sphere.ri)>=e_4)  { /* if NOT right on the boundary */
Lith_age.c:	      if(  E->sx[m][3][node]>=E->sphere.ro-E->control.lith_age_depth ) {
Lith_age.c:                depth=E->sphere.ro - E->sx[m][3][node];
Lith_age.c:		temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Lith_age.c:		t0 = E->control.mantle_temp * erf(temp);
Lith_age.c:		E->sphere.cap[m].TB[1][node]=t0;
Lith_age.c:		E->sphere.cap[m].TB[2][node]=t0;
Lith_age.c:		E->sphere.cap[m].TB[3][node]=t0;
Lith_age.c:  nno=E->lmesh.nno;
Lith_age.c:  gnox=E->mesh.nox;
Lith_age.c:  gnoy=E->mesh.noy;
Lith_age.c:  gnoz=E->mesh.noz;
Lith_age.c:  nox=E->lmesh.nox;
Lith_age.c:  noy=E->lmesh.noy;
Lith_age.c:  noz=E->lmesh.noz;
Lith_age.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)
Lith_age.c:    for(node=1;node<=E->lmesh.nno;node++)  {
Lith_age.c:        type = (E->node[j][node] & (TBX | TBZ | TBY));
Lith_age.c:            assimilate_new_temp = E->sphere.cap[j].TB[1][node];
Lith_age.c:            assimilate_new_temp = E->sphere.cap[j].TB[3][node];
Lith_age.c:            assimilate_new_temp = E->sphere.cap[j].TB[2][node];
Lith_age.c:            assimilate_new_temp = 0.5 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[3][node]);
Lith_age.c:            assimilate_new_temp = 0.5 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[2][node]);
Lith_age.c:            assimilate_new_temp = 0.5 * (E->sphere.cap[j].TB[3][node] + E->sphere.cap[j].TB[2][node]);
Lith_age.c:            assimilate_new_temp = 0.3333333 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[2][node] + E->sphere.cap[j].TB[3][node]);
Lith_age.c:        depth = E->sphere.ro - E->sx[j][3][node];
Lith_age.c:            if(depth <= E->control.lith_age_depth) {
Lith_age.c:                daf = 0.5*depth/E->control.lith_age_depth;
Lith_age.c:                E->T[j][node] = daf*E->T[j][node] + (1.0-daf)*assimilate_new_temp;
Lith_age.c:                E->T[j][node] = assimilate_new_temp;
Material_properties.c:    int noz = E->lmesh.noz;
Material_properties.c:    int nno = E->lmesh.nno;
Material_properties.c:    int nel = E->lmesh.nel;
Material_properties.c:    E->refstate.rho = (double *) malloc((noz+1)*sizeof(double));
Material_properties.c:    E->refstate.gravity = (double *) malloc((noz+1)*sizeof(double));
Material_properties.c:    E->refstate.thermal_expansivity = (double *) malloc((noz+1)*sizeof(double));
Material_properties.c:    E->refstate.heat_capacity = (double *) malloc((noz+1)*sizeof(double));
Material_properties.c:    /*E->refstate.thermal_conductivity = (double *) malloc((noz+1)*sizeof(double));*/
Material_properties.c:    /*E->refstate.Tadi = (double *) malloc((noz+1)*sizeof(double));*/
Material_properties.c:for(i=0;i<E->viscosity.rheol_layers;i++)
Material_properties.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Material_properties.c:      E->viscosity.zbase_layer[i] = E->sphere.ro-E->sx[m][3][E->viscosity.nbase_layer[i] - E->lmesh.nzs +1];
Material_properties.c:    switch(E->refstate.choice) {
Material_properties.c:        if (E->parallel.me) {
Material_properties.c:            fprintf(E->fp, "Unknown option for reference state\n");
Material_properties.c:            fflush(E->fp);
Material_properties.c:    if(E->parallel.me == 0) {
Material_properties.c:    if(E->parallel.me < E->parallel.nprocz)
Material_properties.c:        for(i=1; i<=E->lmesh.noz; i++) {
Material_properties.c:                    i+E->lmesh.nzs-1, E->sx[1][3][i], 1-E->sx[1][3][i],
Material_properties.c:                    E->refstate.rho[i],layers_r(E,E->sx[1][3][i]));
Material_properties.c:    fp = fopen(E->refstate.filename, "r");
Material_properties.c:                E->refstate.filename);
Material_properties.c:    for(i=1; i<E->lmesh.nzs; i++) {
Material_properties.c:    for(i=1; i<=E->lmesh.noz; i++) {
Material_properties.c:                  &(E->refstate.rho[i]),
Material_properties.c:                  &(E->refstate.gravity[i]),
Material_properties.c:                  &(E->refstate.thermal_expansivity[i]),
Material_properties.c:                  &(E->refstate.heat_capacity[i]),
Material_properties.c:            fprintf(stderr,"Error while reading file '%s'\n", E->refstate.filename);
Material_properties.c:                E->refstate.rho[i],
Material_properties.c:                E->refstate.gravity[i],
Material_properties.c:                E->refstate.thermal_expansivity[i],
Material_properties.c:                E->refstate.heat_capacity[i]);
Material_properties.c:    beta = E->control.disptn_number * E->control.inv_gruneisen;
Material_properties.c:    for(i=1; i<=E->lmesh.noz; i++) {
Material_properties.c:	r = E->sx[1][3][i];
Material_properties.c:	E->refstate.rho[i] = exp(beta*z);
Material_properties.c:	E->refstate.gravity[i] = 1;
Material_properties.c:	E->refstate.thermal_expansivity[i] = 1;
Material_properties.c:	E->refstate.heat_capacity[i] = 1;
Material_properties.c:	/*E->refstate.thermal_conductivity[i] = 1;*/
Material_properties.c:	/*E->refstate.Tadi[i] = (E->control.adiabaticT0 + E->control.surface_temp) * exp(E->control.disptn_number * z) - E->control.surface_temp;*/
Maxwelltime:Advection_diffusion.c:    int m=E->parallel.me;
Maxwelltime:Advection_diffusion.c:    input_boolean("ADV",&(E->advection.ADVECTION),"on",m);
Maxwelltime:Advection_diffusion.c:    input_boolean("filter_temp",&(E->advection.filter_temperature),"off",m);
Maxwelltime:Advection_diffusion.c:    input_boolean("monitor_max_T",&(E->advection.monitor_max_T),"on",m);
Maxwelltime:Advection_diffusion.c:    input_int("minstep",&(E->advection.min_timesteps),"1",m);
Maxwelltime:Advection_diffusion.c://    input_int("maxstep",&(E->advection.max_timesteps),"1000",m);
Maxwelltime:Advection_diffusion.c://    input_int("maxtotstep",&(E->advection.max_total_timesteps),"1000000",m);
Maxwelltime:Advection_diffusion.c:    input_float("finetunedt",&(E->advection.fine_tune_dt),"0.9",m);
Maxwelltime:Advection_diffusion.c:    input_float("fixed_timestep",&(E->advection.fixed_timestep),"0.0",m);
Maxwelltime:Advection_diffusion.c:    input_float("adv_gamma",&(E->advection.gamma),"0.5",m);
Maxwelltime:Advection_diffusion.c:    input_int("adv_sub_iterations",&(E->advection.temp_iterations),"2,1,nomax",m);
Maxwelltime:Advection_diffusion.c:    input_float("inputdiffusivity",&(E->control.inputdiff),"1.0",m);
Maxwelltime:Advection_diffusion.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Advection_diffusion.c:    E->Tdot[m]= (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Maxwelltime:Advection_diffusion.c:    for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Advection_diffusion.c:      E->Tdot[m][i]=0.0;
Maxwelltime:Advection_diffusion.c:    const int dims=E->mesh.nsd;
Maxwelltime:Advection_diffusion.c:    const int dofs=E->mesh.dof;
Maxwelltime:Advection_diffusion.c:    const int nno=E->lmesh.nno;
Maxwelltime:Advection_diffusion.c:    const int lev=E->mesh.levmax;
Maxwelltime:Advection_diffusion.c:    nel=E->lmesh.nel;
Maxwelltime:Advection_diffusion.c:    if(E->advection.fixed_timestep != 0.0) {
Maxwelltime:Advection_diffusion.c:      E->advection.timestep = E->advection.fixed_timestep;
Maxwelltime:Advection_diffusion.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Advection_diffusion.c:	  uc1 += E->N.ppt[GNPINDEX(i,1)]*VV[1][i];
Maxwelltime:Advection_diffusion.c:	  uc2 += E->N.ppt[GNPINDEX(i,1)]*VV[2][i];
Maxwelltime:Advection_diffusion.c:	  uc3 += E->N.ppt[GNPINDEX(i,1)]*VV[3][i];
Maxwelltime:Advection_diffusion.c:	uc = fabs(uc1)/E->eco[m][el].size[1] + fabs(uc2)/E->eco[m][el].size[2] + fabs(uc3)/E->eco[m][el].size[3];
Maxwelltime:Advection_diffusion.c:    adv_timestep = E->advection.dt_reduced * adv_timestep;
Maxwelltime:Advection_diffusion.c:    adv_timestep = 1.0e-32 + min(E->advection.fine_tune_dt*adv_timestep,
Maxwelltime:Advection_diffusion.c:				 E->advection.diff_timestep);
Maxwelltime:Advection_diffusion.c:    E->advection.timestep = global_fmin(E,adv_timestep);
Maxwelltime:Advection_diffusion.c:/*     if (E->parallel.me==0) */
Maxwelltime:Advection_diffusion.c:/*       fprintf(stderr, "adv_timestep=%g diff_timestep=%g\n",adv_timestep,E->advection.diff_timestep); */
Maxwelltime:Advection_diffusion.c:  E->advection.timesteps++;
Maxwelltime:Advection_diffusion.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Advection_diffusion.c:    DTdot[m]= (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Maxwelltime:Advection_diffusion.c:  if(E->advection.monitor_max_T) {
Maxwelltime:Advection_diffusion.c:     for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Advection_diffusion.c:         T1[m]= (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Maxwelltime:Advection_diffusion.c:         Tdot1[m]= (double *)malloc((E->lmesh.nno+1)*sizeof(double));
Maxwelltime:Advection_diffusion.c:     for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Advection_diffusion.c:         for (i=1;i<=E->lmesh.nno;i++)   {
Maxwelltime:Advection_diffusion.c:             T1[m][i] = E->T[m][i];
Maxwelltime:Advection_diffusion.c:             Tdot1[m][i] = E->Tdot[m][i];
Maxwelltime:Advection_diffusion.c:     T_interior1 = Tmaxd(E,E->T);
Maxwelltime:Advection_diffusion.c:  E->advection.dt_reduced = 1.0;
Maxwelltime:Advection_diffusion.c:  E->advection.last_sub_iterations = 1;
Maxwelltime:Advection_diffusion.c:    E->advection.timestep *= E->advection.dt_reduced;
Maxwelltime:Advection_diffusion.c:    if (E->advection.ADVECTION) {
Maxwelltime:Advection_diffusion.c:      predictor(E,E->T,E->Tdot);
Maxwelltime:Advection_diffusion.c:      for(psc_pass=0;psc_pass<E->advection.temp_iterations;psc_pass++)   {
Maxwelltime:Advection_diffusion.c:        if(E->control.disptn_number != 0)
Maxwelltime:Advection_diffusion.c:	pg_solver(E,E->T,E->Tdot,DTdot,&(E->convection.heat_sources),E->control.inputdiff,1,E->node);
Maxwelltime:Advection_diffusion.c:	corrector(E,E->T,E->Tdot,DTdot);
Maxwelltime:Advection_diffusion.c:      if(E->advection.monitor_max_T) {
Maxwelltime:Advection_diffusion.c:          E->monitor.T_interior = Tmaxd(E,E->T);
Maxwelltime:Advection_diffusion.c:          if (E->monitor.T_interior/T_interior1 > E->monitor.T_maxvaried) {
Maxwelltime:Advection_diffusion.c:              if(E->parallel.me==0) {
Maxwelltime:Advection_diffusion.c:                          T_interior1, E->monitor.T_interior);
Maxwelltime:Advection_diffusion.c:                  fprintf(E->fp, "max T varied from %e to %e\n",
Maxwelltime:Advection_diffusion.c:                          T_interior1, E->monitor.T_interior);
Maxwelltime:Advection_diffusion.c:              for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Advection_diffusion.c:                  for (i=1;i<=E->lmesh.nno;i++)   {
Maxwelltime:Advection_diffusion.c:                      E->T[m][i] = T1[m][i];
Maxwelltime:Advection_diffusion.c:                      E->Tdot[m][i] = Tdot1[m][i];
Maxwelltime:Advection_diffusion.c:              E->advection.dt_reduced *= 0.5;
Maxwelltime:Advection_diffusion.c:              E->advection.last_sub_iterations ++;
Maxwelltime:Advection_diffusion.c:  }  while ( iredo==1 && E->advection.last_sub_iterations <= 5);
Maxwelltime:Advection_diffusion.c:  if(E->advection.filter_temperature)
Maxwelltime:Advection_diffusion.c:  E->advection.total_timesteps++;
Maxwelltime:Advection_diffusion.c:  E->monitor.elapsed_time += E->advection.timestep;
Maxwelltime:Advection_diffusion.c:  if (E->advection.last_sub_iterations==5)
Maxwelltime:Advection_diffusion.c:    E->control.keep_going = 0;
Maxwelltime:Advection_diffusion.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Advection_diffusion.c:  if(E->advection.monitor_max_T) {
Maxwelltime:Advection_diffusion.c:      for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Advection_diffusion.c:  if(E->control.lith_age) {
Maxwelltime:Advection_diffusion.c:      if(E->parallel.me==0) fprintf(stderr,"PG_timestep_solve\n");
Maxwelltime:Advection_diffusion.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Advection_diffusion.c:    for(el=1;el<=E->lmesh.nel;el++)  {
Maxwelltime:Advection_diffusion.c:      for(d=1;d<=E->mesh.nsd;d++)    {
Maxwelltime:Advection_diffusion.c:	ts = E->eco[m][el].size[d] * E->eco[m][el].size[d];
Maxwelltime:Advection_diffusion.c:  E->advection.diff_timestep = 0.5 * diff_timestep;
Maxwelltime:Advection_diffusion.c:  multiplier = (1.0-E->advection.gamma) * E->advection.timestep;
Maxwelltime:Advection_diffusion.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Advection_diffusion.c:    for(node=1;node<=E->lmesh.nno;node++)  {
Maxwelltime:Advection_diffusion.c:  multiplier = E->advection.gamma * E->advection.timestep;
Maxwelltime:Advection_diffusion.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Advection_diffusion.c:    for(node=1;node<=E->lmesh.nno;node++) {
Maxwelltime:Advection_diffusion.c:    const int dims=E->mesh.nsd;
Maxwelltime:Advection_diffusion.c:    const int dofs=E->mesh.dof;
Maxwelltime:Advection_diffusion.c:    const int lev=E->mesh.levmax;
Maxwelltime:Advection_diffusion.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Advection_diffusion.c:      for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Advection_diffusion.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Advection_diffusion.c:       for(el=1;el<=E->lmesh.nel;el++)    {
Maxwelltime:Advection_diffusion.c:          pg_shape_fn(E, el, &PG, &(E->gNX[m][el]), VV,
Maxwelltime:Advection_diffusion.c:          element_residual(E, el, &PG, &(E->gNX[m][el]), &(E->gDA[m][el]),
Maxwelltime:Advection_diffusion.c:                           Q0, Eres, rtf, diff, E->sphere.cap[m].TB,
Maxwelltime:Advection_diffusion.c:	    a1 = E->ien[m][el].node[a];
Maxwelltime:Advection_diffusion.c:    (E->exchange_node_d)(E,DTdot,lev);
Maxwelltime:Advection_diffusion.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Advection_diffusion.c:      for(i=1;i<=E->lmesh.nno;i++) {
Maxwelltime:Advection_diffusion.c:        if(!(E->node[m][i] & (TBX | TBY | TBZ))){
Maxwelltime:Advection_diffusion.c:	  DTdot[m][i] *= E->TMass[m][i];         /* lumped mass matrix */
Maxwelltime:Advection_diffusion.c:    ienm=E->ien[m][el].node;
Maxwelltime:Advection_diffusion.c:      uc1 +=  E->N.ppt[GNPINDEX(i,1)]*VV[1][i];
Maxwelltime:Advection_diffusion.c:      uc2 +=  E->N.ppt[GNPINDEX(i,1)]*VV[2][i];
Maxwelltime:Advection_diffusion.c:      uc3 +=  E->N.ppt[GNPINDEX(i,1)]*VV[3][i];
Maxwelltime:Advection_diffusion.c:    uxse = fabs(uc1*E->eco[m][el].size[1]);
Maxwelltime:Advection_diffusion.c:    ueta = fabs(uc2*E->eco[m][el].size[2]);
Maxwelltime:Advection_diffusion.c:    ufai = fabs(uc3*E->eco[m][el].size[3]);
Maxwelltime:Advection_diffusion.c:		u1 += VV[1][j] * E->N.vpt[GNVINDEX(j,i)];
Maxwelltime:Advection_diffusion.c:		u2 += VV[2][j] * E->N.vpt[GNVINDEX(j,i)];
Maxwelltime:Advection_diffusion.c:	   	u3 += VV[3][j] * E->N.vpt[GNVINDEX(j,i)];
Maxwelltime:Advection_diffusion.c:	    PG->vpt[GNVINDEX(j,i)] = E->N.vpt[GNVINDEX(j,i)] + adiff * prod1;
Maxwelltime:Advection_diffusion.c:    const int dims=E->mesh.nsd;
Maxwelltime:Advection_diffusion.c:    const int dofs=E->mesh.dof;
Maxwelltime:Advection_diffusion.c:    const int nno=E->lmesh.nno;
Maxwelltime:Advection_diffusion.c:    const int lev=E->mesh.levmax;
Maxwelltime:Advection_diffusion.c:      node = E->ien[m][el].node[j];
Maxwelltime:Advection_diffusion.c:      if(E->node[m][node] & (TBX | TBY | TBZ))
Maxwelltime:Advection_diffusion.c:          dT[i] += DT * E->N.vpt[GNVINDEX(j,i)];
Maxwelltime:Advection_diffusion.c:          sfn = E->N.vpt[GNVINDEX(j,i)];
Maxwelltime:Advection_diffusion.c:	  Q += Q0->Q[i] * exp(-Q0->lambda[i] * (E->monitor.elapsed_time+Q0->t_offset));
Maxwelltime:Advection_diffusion.c:    Q = E->control.Q0;
Maxwelltime:Advection_diffusion.c:    if(E->control.tracer_enriched){
Maxwelltime:Advection_diffusion.c:      Q *= (1.0 - E->composition.comp_el[m][0][el]);
Maxwelltime:Advection_diffusion.c:      Q += E->composition.comp_el[m][0][el] * E->control.Q0ER;
Maxwelltime:Advection_diffusion.c:    nz = ((el-1) % E->lmesh.elz) + 1;
Maxwelltime:Advection_diffusion.c:    rho = 0.5 * (E->refstate.rho[nz] + E->refstate.rho[nz+1]);
Maxwelltime:Advection_diffusion.c:    cp = 0.5 * (E->refstate.heat_capacity[nz] + E->refstate.heat_capacity[nz+1]);
Maxwelltime:Advection_diffusion.c:    if(E->control.disptn_number == 0)
Maxwelltime:Advection_diffusion.c:        /* E->heating_latent is actually the inverse of latent heating */
Maxwelltime:Advection_diffusion.c:        heating = (rho * Q - E->heating_adi[m][el] + E->heating_visc[m][el])
Maxwelltime:Advection_diffusion.c:            * E->heating_latent[m][el];
Maxwelltime:Advection_diffusion.c:              + diff * dOmega->vpt[i] * E->heating_latent[m][el]
Maxwelltime:Advection_diffusion.c:      if (FLAGS[m][E->ien[m][el].node[1]] & FBZ) {   // only check for the 1st node
Maxwelltime:Advection_diffusion.c:      else if (FLAGS[m][E->ien[m][el].node[5]] & FBZ) {   // only check for the 5th node
Maxwelltime:Advection_diffusion.c:              dT[j] += E->M.vpt[GMVINDEX(k,j)]*BC[3][E->ien[m][el].node[k+aid*onedvpts]];
Maxwelltime:Advection_diffusion.c:		E->M.vpt[GMVINDEX(a,j)] * g_1d[j].weight[dims-1] *
Maxwelltime:Advection_diffusion.c:    lev=E->mesh.levmax;
Maxwelltime:Advection_diffusion.c:    rhocp = (double *)malloc((E->lmesh.noz+1)*sizeof(double));
Maxwelltime:Advection_diffusion.c:    for(i=1;i<=E->lmesh.noz;i++)
Maxwelltime:Advection_diffusion.c:        rhocp[i] = E->refstate.rho[i] * E->refstate.heat_capacity[i];
Maxwelltime:Advection_diffusion.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Advection_diffusion.c:        for(i=1;i<=E->lmesh.nno;i++)  {
Maxwelltime:Advection_diffusion.c:            nz = ((i-1) % E->lmesh.noz) + 1;
Maxwelltime:Advection_diffusion.c:            if(!(E->NODE[lev][m][i] & SKIP))
Maxwelltime:Advection_diffusion.c:                Tsum0 += E->T[m][i]*rhocp[nz];
Maxwelltime:Advection_diffusion.c:            if(E->T[m][i]<Tmin)  Tmin=E->T[m][i];
Maxwelltime:Advection_diffusion.c:            if(E->T[m][i]<Tmin0) E->T[m][i]=Tmin0;
Maxwelltime:Advection_diffusion.c:            if(E->T[m][i]>Tmax) Tmax=E->T[m][i];
Maxwelltime:Advection_diffusion.c:            if(E->T[m][i]>Tmax0) E->T[m][i]=Tmax0;
Maxwelltime:Advection_diffusion.c:    MPI_Allreduce(&Tmin,&Tmin1,1,MPI_DOUBLE,MPI_MIN,E->parallel.world);
Maxwelltime:Advection_diffusion.c:    MPI_Allreduce(&Tmax,&Tmax1,1,MPI_DOUBLE,MPI_MAX,E->parallel.world);
Maxwelltime:Advection_diffusion.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Advection_diffusion.c:        for(i=1;i<=E->lmesh.nno;i++)  {
Maxwelltime:Advection_diffusion.c:            nz = ((i-1) % E->lmesh.noz) + 1;
Maxwelltime:Advection_diffusion.c:            if(E->T[m][i]<=fabs(2*Tmin0-Tmin1))   E->T[m][i]=Tmin0;
Maxwelltime:Advection_diffusion.c:            if(E->T[m][i]>=(2*Tmax0-Tmax1))   E->T[m][i]=Tmax0;
Maxwelltime:Advection_diffusion.c:            if (!(E->NODE[lev][m][i] & SKIP))  {
Maxwelltime:Advection_diffusion.c:                Tsum1 += E->T[m][i]*rhocp[nz];
Maxwelltime:Advection_diffusion.c:                if(E->T[m][i]!=Tmin0 && E->T[m][i]!=Tmax0) {
Maxwelltime:Advection_diffusion.c:    MPI_Allreduce(&TDIST,&TDIST1,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Advection_diffusion.c:    MPI_Allreduce(&sum_rhocp,&total_sum_rhocp,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Advection_diffusion.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Advection_diffusion.c:        for(i=1;i<=E->lmesh.nno;i++)   {
Maxwelltime:Advection_diffusion.c:            if(E->T[m][i]!=Tmin0 && E->T[m][i]!=Tmax0)
Maxwelltime:Advection_diffusion.c:                E->T[m][i] +=TDIST;
Maxwelltime:Advection_diffusion.c:    strain_sqr = (float*) malloc((E->lmesh.nel+1)*sizeof(float));
Maxwelltime:Advection_diffusion.c:    temp = E->control.disptn_number / E->control.Atemp / vpts;
Maxwelltime:Advection_diffusion.c:    for(e=1; e<=E->lmesh.nel; e++) {
Maxwelltime:Advection_diffusion.c:            visc += E->EVi[m][(e-1)*vpts + i];
Maxwelltime:Advection_diffusion.c:    temp2 = E->control.disptn_number / ends;
Maxwelltime:Advection_diffusion.c:    for(e=1; e<=E->lmesh.nel; e++) {
Maxwelltime:Advection_diffusion.c:        ez = (e - 1) % E->lmesh.elz + 1;
Maxwelltime:Advection_diffusion.c:            * (E->refstate.thermal_expansivity[ez] +
Maxwelltime:Advection_diffusion.c:               E->refstate.thermal_expansivity[ez + 1])
Maxwelltime:Advection_diffusion.c:            * (E->refstate.rho[ez] + E->refstate.rho[ez + 1])
Maxwelltime:Advection_diffusion.c:            * (E->refstate.gravity[ez] + E->refstate.gravity[ez + 1]);
Maxwelltime:Advection_diffusion.c:            j = E->ien[m][e].node[i];
Maxwelltime:Advection_diffusion.c:            temp1 += E->sphere.cap[m].V[3][j]
Maxwelltime:Advection_diffusion.c:                * (E->T[m][j] + E->control.surface_temp);
Maxwelltime:Advection_diffusion.c:    temp0 = 2.0 * inv_width * clapeyron * E->control.disptn_number * Ra / E->control.Atemp / ends;
Maxwelltime:Advection_diffusion.c:    for(e=1; e<=E->lmesh.nel; e++) {
Maxwelltime:Advection_diffusion.c:        ez = (e - 1) % E->lmesh.elz + 1;
Maxwelltime:Advection_diffusion.c:            * (E->refstate.thermal_expansivity[ez] +
Maxwelltime:Advection_diffusion.c:               E->refstate.thermal_expansivity[ez + 1])
Maxwelltime:Advection_diffusion.c:            * (E->refstate.rho[ez] + E->refstate.rho[ez + 1])
Maxwelltime:Advection_diffusion.c:            * (E->refstate.gravity[ez] + E->refstate.gravity[ez + 1]);
Maxwelltime:Advection_diffusion.c:            j = E->ien[m][e].node[i];
Maxwelltime:Advection_diffusion.c:                * (E->T[m][j] + E->control.surface_temp);
Maxwelltime:Advection_diffusion.c:            temp2 += temp * E->sphere.cap[m].V[3][j];
Maxwelltime:Advection_diffusion.c:    for(e=1; e<=E->lmesh.nel; e++)
Maxwelltime:Advection_diffusion.c:    if(E->control.Ra_410 != 0.0) {
Maxwelltime:Advection_diffusion.c:                       E->Fas410, E->control.Ra_410,
Maxwelltime:Advection_diffusion.c:                       E->control.clapeyron410, E->viscosity.z410,
Maxwelltime:Advection_diffusion.c:                       E->control.transT410, E->control.inv_width410);
Maxwelltime:Advection_diffusion.c:    if(E->control.Ra_670 != 0.0) {
Maxwelltime:Advection_diffusion.c:                       E->Fas670, E->control.Ra_670,
Maxwelltime:Advection_diffusion.c:                       E->control.clapeyron670, E->viscosity.zlm,
Maxwelltime:Advection_diffusion.c:                       E->control.transT670, E->control.inv_width670);
Maxwelltime:Advection_diffusion.c:    if(E->control.Ra_cmb != 0.0) {
Maxwelltime:Advection_diffusion.c:                       E->Fascmb, E->control.Ra_cmb,
Maxwelltime:Advection_diffusion.c:                       E->control.clapeyroncmb, E->viscosity.zcmb,
Maxwelltime:Advection_diffusion.c:                       E->control.transTcmb, E->control.inv_widthcmb);
Maxwelltime:Advection_diffusion.c:    if(E->control.Ra_410 != 0 || E->control.Ra_670 != 0.0 ||
Maxwelltime:Advection_diffusion.c:       E->control.Ra_cmb != 0) {
Maxwelltime:Advection_diffusion.c:        for(e=1; e<=E->lmesh.nel; e++)
Maxwelltime:Advection_diffusion.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Advection_diffusion.c:        for(e=1; e<=E->lmesh.nel; e++)
Maxwelltime:Advection_diffusion.c:            sum += heating[m][e] * E->eco[m][e].area;
Maxwelltime:Advection_diffusion.c:                  MPI_DOUBLE, MPI_SUM, E->parallel.world);
Maxwelltime:Advection_diffusion.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Advection_diffusion.c:            process_visc_heating(E, m, E->heating_visc[m]);
Maxwelltime:Advection_diffusion.c:        process_adi_heating(E, m, E->heating_adi[m]);
Maxwelltime:Advection_diffusion.c:        process_latent_heating(E, m, E->heating_latent[m], E->heating_adi[m]);
Maxwelltime:Advection_diffusion.c:    if(psc_pass == (E->advection.temp_iterations-1)) {
Maxwelltime:Advection_diffusion.c:        total_visc_heating = total_heating(E, E->heating_visc);
Maxwelltime:Advection_diffusion.c:        total_adi_heating = total_heating(E, E->heating_adi);
Maxwelltime:Advection_diffusion.c:        if(E->parallel.me == 0) {
Maxwelltime:Advection_diffusion.c:            fprintf(E->fp, "Step: %d, Total_heating(visc, adi): %g %g\n",
Maxwelltime:Advection_diffusion.c:                    E->monitor.solution_cycles,
Maxwelltime:Advection_diffusion.c:                    E->monitor.solution_cycles,
Maxwelltime:BC_util.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:BC_util.c:    if (E->num_zero_resid[level][m])
Maxwelltime:BC_util.c:      for(i=1;i<=E->num_zero_resid[level][m];i++)
Maxwelltime:BC_util.c:         Res[m][E->zero_resid[level][m][i]] = 0.0;
Maxwelltime:BC_util.c:  if(E->control.lith_age) {
Maxwelltime:BC_util.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:BC_util.c:    for(node=1;node<=E->lmesh.nno;node++)  {
Maxwelltime:BC_util.c:        type = (E->node[j][node] & (TBX | TBZ | TBY));
Maxwelltime:BC_util.c:            E->T[j][node] = E->sphere.cap[j].TB[1][node];
Maxwelltime:BC_util.c:            E->T[j][node] = E->sphere.cap[j].TB[3][node];
Maxwelltime:BC_util.c:            E->T[j][node] = E->sphere.cap[j].TB[2][node];
Maxwelltime:BC_util.c:            E->T[j][node] = 0.5 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[3][node]);
Maxwelltime:BC_util.c:            E->T[j][node] = 0.5 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[2][node]);
Maxwelltime:BC_util.c:            E->T[j][node] = 0.5 * (E->sphere.cap[j].TB[3][node] + E->sphere.cap[j].TB[2][node]);
Maxwelltime:BC_util.c:            E->T[j][node] = 0.3333333 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[2][node] + E->sphere.cap[j].TB[3][node]);
Maxwelltime:BC_util.c:    const int nno = E->lmesh.nno;
Maxwelltime:BC_util.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:BC_util.c:        if (E->node[m][node] & typex)
Maxwelltime:BC_util.c:	      U[m][E->id[m][node].doff[1]] = E->sphere.cap[m].VB[1][node];
Maxwelltime:BC_util.c: 	if (E->node[m][node] & typey)
Maxwelltime:BC_util.c:	      U[m][E->id[m][node].doff[2]] = E->sphere.cap[m].VB[2][node];
Maxwelltime:BC_util.c:	if (E->node[m][node] & typez)
Maxwelltime:BC_util.c:	      U[m][E->id[m][node].doff[3]] = E->sphere.cap[m].VB[3][node];
Maxwelltime:Checkpoints.c:    sprintf(output_file, "%s.chkpt.%d.%d", E->control.data_file,
Maxwelltime:Checkpoints.c:            E->parallel.me, E->monitor.solution_cycles);
Maxwelltime:Checkpoints.c:    if(E->control.tracer) {
Maxwelltime:Checkpoints.c:        if(E->composition.on)
Maxwelltime:Checkpoints.c:    snprintf(output_file, 254, "%s.chkpt.%d.%d", E->control.old_P_file,
Maxwelltime:Checkpoints.c:             E->parallel.me, E->monitor.solution_cycles_init);
Maxwelltime:Checkpoints.c:    if(E->parallel.me == 0)
Maxwelltime:Checkpoints.c:    /* init E->mat */
Maxwelltime:Checkpoints.c:    if(E->control.tracer) {
Maxwelltime:Checkpoints.c:      if(E->trace.ic_method_for_flavors == 99){
Maxwelltime:Checkpoints.c:	if(E->parallel.me == 0)
Maxwelltime:Checkpoints.c:        if(E->composition.on)
Maxwelltime:Checkpoints.c:    fwrite(&(E->lmesh.nox), sizeof(int), 1, fp);
Maxwelltime:Checkpoints.c:    fwrite(&(E->lmesh.noy), sizeof(int), 1, fp);
Maxwelltime:Checkpoints.c:    fwrite(&(E->lmesh.noz), sizeof(int), 1, fp);
Maxwelltime:Checkpoints.c:    fwrite(&(E->parallel.nprocx), sizeof(int), 1, fp);
Maxwelltime:Checkpoints.c:    fwrite(&(E->parallel.nprocy), sizeof(int), 1, fp);
Maxwelltime:Checkpoints.c:    fwrite(&(E->parallel.nprocz), sizeof(int), 1, fp);
Maxwelltime:Checkpoints.c:    fwrite(&(E->sphere.caps_per_proc), sizeof(int), 1, fp);
Maxwelltime:Checkpoints.c:    fwrite(&(E->monitor.solution_cycles), sizeof(int), 1, fp);
Maxwelltime:Checkpoints.c:    fwrite(&(E->monitor.elapsed_time), sizeof(float), 1, fp);
Maxwelltime:Checkpoints.c:    fwrite(&(E->advection.timestep), sizeof(float), 1, fp);
Maxwelltime:Checkpoints.c:    fwrite(&(E->control.start_age), sizeof(float), 1, fp);
Maxwelltime:Checkpoints.c:    if((tmp[0] != E->lmesh.nox) ||
Maxwelltime:Checkpoints.c:       (tmp[1] != E->lmesh.noy) ||
Maxwelltime:Checkpoints.c:       (tmp[2] != E->lmesh.noz) ||
Maxwelltime:Checkpoints.c:       (tmp[3] != E->parallel.nprocx) ||
Maxwelltime:Checkpoints.c:       (tmp[4] != E->parallel.nprocy) ||
Maxwelltime:Checkpoints.c:       (tmp[5] != E->parallel.nprocz) ||
Maxwelltime:Checkpoints.c:       (tmp[6] != E->sphere.caps_per_proc)) {
Maxwelltime:Checkpoints.c:                E->parallel.me);
Maxwelltime:Checkpoints.c:    tmp[0] = fread(&(E->monitor.solution_cycles), sizeof(int), 1, fp);
Maxwelltime:Checkpoints.c:    tmp[0]+= fread(&(E->monitor.elapsed_time), sizeof(float), 1, fp);
Maxwelltime:Checkpoints.c:    tmp[0]+= fread(&(E->advection.timestep), sizeof(float), 1, fp);
Maxwelltime:Checkpoints.c:    tmp[0]+= fread(&(E->control.start_age), sizeof(float), 1, fp);
Maxwelltime:Checkpoints.c:    E->advection.timesteps = E->monitor.solution_cycles;
Maxwelltime:Checkpoints.c:    fwrite(&(E->trace.number_of_basic_quantities), sizeof(int), 1, fp);
Maxwelltime:Checkpoints.c:    fwrite(&(E->trace.number_of_extra_quantities), sizeof(int), 1, fp);
Maxwelltime:Checkpoints.c:    fwrite(&(E->trace.nflavors), sizeof(int), 1, fp);
Maxwelltime:Checkpoints.c:    fwrite(&(E->trace.ilast_tracer_count), sizeof(int), 1, fp);
Maxwelltime:Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Checkpoints.c:        fwrite(&(E->trace.ntracers[m]), sizeof(int), 1, fp);
Maxwelltime:Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Checkpoints.c:            fwrite(E->trace.basicq[m][i], sizeof(double),
Maxwelltime:Checkpoints.c:                   E->trace.ntracers[m]+1, fp);
Maxwelltime:Checkpoints.c:        for(i=0; i<E->trace.number_of_extra_quantities; i++) {
Maxwelltime:Checkpoints.c:            fwrite(E->trace.extraq[m][i], sizeof(double),
Maxwelltime:Checkpoints.c:                   E->trace.ntracers[m]+1, fp);
Maxwelltime:Checkpoints.c:        fwrite(E->trace.ielement[m], sizeof(int),
Maxwelltime:Checkpoints.c:               E->trace.ntracers[m]+1, fp);
Maxwelltime:Checkpoints.c:    read_sentinel(fp, E->parallel.me);
Maxwelltime:Checkpoints.c:    if (itmp != E->trace.number_of_basic_quantities) {
Maxwelltime:Checkpoints.c:                E->parallel.me);
Maxwelltime:Checkpoints.c:    if (itmp != E->trace.number_of_extra_quantities) {
Maxwelltime:Checkpoints.c:                E->parallel.me);
Maxwelltime:Checkpoints.c:    if (itmp != E->trace.nflavors) {
Maxwelltime:Checkpoints.c:                E->parallel.me);
Maxwelltime:Checkpoints.c:    E->trace.ilast_tracer_count = itmp;
Maxwelltime:Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Checkpoints.c:        E->trace.ntracers[m] = itmp;
Maxwelltime:Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Checkpoints.c:            fread(E->trace.basicq[m][i], sizeof(double),
Maxwelltime:Checkpoints.c:                  E->trace.ntracers[m]+1, fp);
Maxwelltime:Checkpoints.c:        for(i=0; i<E->trace.number_of_extra_quantities; i++) {
Maxwelltime:Checkpoints.c:            fread(E->trace.extraq[m][i], sizeof(double),
Maxwelltime:Checkpoints.c:                  E->trace.ntracers[m]+1, fp);
Maxwelltime:Checkpoints.c:        fread(E->trace.ielement[m], sizeof(int),
Maxwelltime:Checkpoints.c:              E->trace.ntracers[m]+1, fp);
Maxwelltime:Checkpoints.c:    /* init E->trace.ntracer_flavor */
Maxwelltime:Checkpoints.c:    fwrite(&(E->composition.ncomp), sizeof(int), 1, fp);
Maxwelltime:Checkpoints.c:    fwrite(E->composition.bulk_composition, sizeof(double),
Maxwelltime:Checkpoints.c:           E->composition.ncomp, fp);
Maxwelltime:Checkpoints.c:    fwrite(E->composition.initial_bulk_composition, sizeof(double),
Maxwelltime:Checkpoints.c:           E->composition.ncomp, fp);
Maxwelltime:Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Checkpoints.c:        for(i=0; i<E->composition.ncomp; i++)
Maxwelltime:Checkpoints.c:            fwrite(E->composition.comp_el[m][i], sizeof(double),
Maxwelltime:Checkpoints.c:                   E->lmesh.nel+1, fp);
Maxwelltime:Checkpoints.c:    read_sentinel(fp, E->parallel.me);
Maxwelltime:Checkpoints.c:    if (itmp != E->composition.ncomp) {
Maxwelltime:Checkpoints.c:                E->parallel.me);
Maxwelltime:Checkpoints.c:    fread(E->composition.bulk_composition, sizeof(double),
Maxwelltime:Checkpoints.c:          E->composition.ncomp, fp);
Maxwelltime:Checkpoints.c:    fread(E->composition.initial_bulk_composition, sizeof(double),
Maxwelltime:Checkpoints.c:          E->composition.ncomp, fp);
Maxwelltime:Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Checkpoints.c:        for(i=0; i<E->composition.ncomp; i++)
Maxwelltime:Checkpoints.c:            fread(E->composition.comp_el[m][i], sizeof(double),
Maxwelltime:Checkpoints.c:                  E->lmesh.nel+1, fp);
Maxwelltime:Checkpoints.c:    /* init E->composition.comp_node */
Maxwelltime:Checkpoints.c:    E->trace.istat_iempty = 0;
Maxwelltime:Checkpoints.c:    for (i=0; i<E->composition.ncomp; i++) {
Maxwelltime:Checkpoints.c:        E->composition.error_fraction[i] = E->composition.bulk_composition[i]
Maxwelltime:Checkpoints.c:        / E->composition.initial_bulk_composition[i] - 1.0;
Maxwelltime:Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Checkpoints.c:        fwrite(E->T[m], sizeof(double), E->lmesh.nno+1, fp);
Maxwelltime:Checkpoints.c:        fwrite(E->Tdot[m], sizeof(double), E->lmesh.nno+1, fp);
Maxwelltime:Checkpoints.c:    read_sentinel(fp, E->parallel.me);
Maxwelltime:Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Checkpoints.c:      if(fread(E->T[m], sizeof(double), E->lmesh.nno+1, fp)!= E->lmesh.nno+1)
Maxwelltime:Checkpoints.c:      if(fread(E->Tdot[m], sizeof(double), E->lmesh.nno+1, fp)!=E->lmesh.nno+1)
Maxwelltime:Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Checkpoints.c:        fwrite(E->P[m], sizeof(double), E->lmesh.npno+1, fp);
Maxwelltime:Checkpoints.c:        fwrite(E->U[m], sizeof(double), E->lmesh.neq, fp);
Maxwelltime:Checkpoints.c:    int lev = E->mesh.levmax;
Maxwelltime:Checkpoints.c:    read_sentinel(fp, E->parallel.me);
Maxwelltime:Checkpoints.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Checkpoints.c:      if(fread(E->P[m], sizeof(double), E->lmesh.npno+1, fp) !=  E->lmesh.npno+1)
Maxwelltime:Checkpoints.c:      if(fread(E->U[m], sizeof(double), E->lmesh.neq, fp) != E->lmesh.neq)
Maxwelltime:Checkpoints.c:    E->monitor.vdotv = global_v_norm2(E, E->U);
Maxwelltime:Checkpoints.c:    E->monitor.pdotp = global_p_norm2(E, E->P);
Maxwelltime:Checkpoints.c:    /* init E->NP */
Maxwelltime:Checkpoints.c:    p_to_nodes(E, E->P, E->NP, lev);
Maxwelltime:Citcom_init.c:  E->control.PID = get_process_identifier();
Maxwelltime:Citcom_init.c:  E->parallel.world = *world;
Maxwelltime:Citcom_init.c:  E->parallel.nproc = nproc;
Maxwelltime:Citcom_init.c:  E->parallel.me = rank;
Maxwelltime:Citcom_init.c:          rank, nproc, E, E->control.PID); */
Maxwelltime:Citcom_init.c:  E->monitor.solution_cycles=0;
Maxwelltime:Citcom_init.c:  E->control.keep_going=1;
Maxwelltime:Citcom_init.c:  E->control.total_iteration_cycles=0;
Maxwelltime:Citcom_init.c:  E->control.total_v_solver_calls=0;
Maxwelltime:Composition_related.c:    int m = E->parallel.me;
Maxwelltime:Composition_related.c:		  &(E->composition.ichemical_buoyancy),
Maxwelltime:Composition_related.c:    if (E->control.tracer && E->composition.ichemical_buoyancy) {
Maxwelltime:Composition_related.c:        input_int("buoy_type",&(E->composition.ibuoy_type),"1,0,nomax",m);
Maxwelltime:Composition_related.c:        if (E->composition.ibuoy_type!=1) {
Maxwelltime:Composition_related.c:        if (E->composition.ibuoy_type==0)
Maxwelltime:Composition_related.c:            E->composition.ncomp = E->trace.nflavors;
Maxwelltime:Composition_related.c:        else if (E->composition.ibuoy_type==1)
Maxwelltime:Composition_related.c:            E->composition.ncomp = E->trace.nflavors - 1;
Maxwelltime:Composition_related.c:        E->composition.buoyancy_ratio = (double*) malloc(E->composition.ncomp
Maxwelltime:Composition_related.c:        for (i=0; i<E->composition.ncomp; i++)
Maxwelltime:Composition_related.c:            E->composition.buoyancy_ratio[i] = 1.0;
Maxwelltime:Composition_related.c:        input_double_vector("buoyancy_ratio", E->composition.ncomp,
Maxwelltime:Composition_related.c:                            E->composition.buoyancy_ratio,m);
Maxwelltime:Composition_related.c:    E->composition.icompositional_rheology = 0;
Maxwelltime:Composition_related.c:              &(E->composition.icompositional_rheology),"1,0,nomax",m);
Maxwelltime:Composition_related.c:    if (E->composition.icompositional_rheology==1) {
Maxwelltime:Composition_related.c:                     &(E->composition.compositional_rheology_prefactor),
Maxwelltime:Composition_related.c:    if (E->composition.ichemical_buoyancy ||
Maxwelltime:Composition_related.c:        E->composition.icompositional_rheology)
Maxwelltime:Composition_related.c:        E->composition.on = 1;
Maxwelltime:Composition_related.c:    if (E->composition.on) {
Maxwelltime:Composition_related.c:        if (E->trace.nflavors < 1) {
Maxwelltime:Composition_related.c:            fprintf(E->trace.fpt, "Tracer flavors must be greater than 1 to track composition\n");
Maxwelltime:Composition_related.c:        if (!E->composition.ichemical_buoyancy)
Maxwelltime:Composition_related.c:	  fprintf(E->trace.fpt,"Passive Tracers\n");
Maxwelltime:Composition_related.c:	  fprintf(E->trace.fpt,"Active Tracers\n");
Maxwelltime:Composition_related.c:        if (E->composition.ibuoy_type==1)
Maxwelltime:Composition_related.c:	  fprintf(E->trace.fpt,"Ratio Method\n");
Maxwelltime:Composition_related.c:        if (E->composition.ibuoy_type==0)
Maxwelltime:Composition_related.c:	  fprintf(E->trace.fpt,"Absolute Method\n");
Maxwelltime:Composition_related.c:        for(k=0; k<E->composition.ncomp; k++) {
Maxwelltime:Composition_related.c:            fprintf(E->trace.fpt,"Buoyancy Ratio: %f\n", E->composition.buoyancy_ratio[k]);
Maxwelltime:Composition_related.c:        if (E->composition.icompositional_rheology==0) {
Maxwelltime:Composition_related.c:            fprintf(E->trace.fpt,"Compositional Rheology - OFF\n");
Maxwelltime:Composition_related.c:        else if (E->composition.icompositional_rheology>0) {
Maxwelltime:Composition_related.c:            fprintf(E->trace.fpt,"Compositional Rheology - ON\n");
Maxwelltime:Composition_related.c:            fprintf(E->trace.fpt,"Compositional Prefactor: %f\n",
Maxwelltime:Composition_related.c:            E->composition.compositional_rheology_prefactor);
Maxwelltime:Composition_related.c:        fflush(E->trace.fpt);
Maxwelltime:Composition_related.c:    if (E->composition.ibuoy_type==1) {
Maxwelltime:Composition_related.c:    if (E->composition.ibuoy_type!=1) {
Maxwelltime:Composition_related.c:        fprintf(E->trace.fpt,"Error(compute...)-only ratio method now\n");
Maxwelltime:Composition_related.c:        fflush(E->trace.fpt);
Maxwelltime:Composition_related.c:    for (i=0; i<E->composition.ncomp; i++) {
Maxwelltime:Composition_related.c:        E->composition.bulk_composition = (double*) malloc(E->composition.ncomp*sizeof(double));
Maxwelltime:Composition_related.c:        E->composition.initial_bulk_composition = (double*) malloc(E->composition.ncomp*sizeof(double));
Maxwelltime:Composition_related.c:        E->composition.error_fraction = (double*) malloc(E->composition.ncomp*sizeof(double));
Maxwelltime:Composition_related.c:    E->Have.C = (float **)malloc((E->composition.ncomp+1)*sizeof(float*));
Maxwelltime:Composition_related.c:    for (i=0; i<E->composition.ncomp; i++) {
Maxwelltime:Composition_related.c:        E->Have.C[i] = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Maxwelltime:Composition_related.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Composition_related.c:        if ((E->composition.comp_el[j]=(double **)malloc((E->composition.ncomp)*sizeof(double*)))==NULL) {
Maxwelltime:Composition_related.c:            fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 8987y\n");
Maxwelltime:Composition_related.c:            fflush(E->trace.fpt);
Maxwelltime:Composition_related.c:        if ((E->composition.comp_node[j]=(double **)malloc((E->composition.ncomp)*sizeof(double*)))==NULL) {
Maxwelltime:Composition_related.c:            fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 8988y\n");
Maxwelltime:Composition_related.c:            fflush(E->trace.fpt);
Maxwelltime:Composition_related.c:        for (i=0; i<E->composition.ncomp; i++) {
Maxwelltime:Composition_related.c:            if ((E->composition.comp_el[j][i]=(double *)malloc((E->lmesh.nel+1)*sizeof(double)))==NULL) {
Maxwelltime:Composition_related.c:                fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 8989y\n");
Maxwelltime:Composition_related.c:                fflush(E->trace.fpt);
Maxwelltime:Composition_related.c:            if ((E->composition.comp_node[j][i]=(double *)malloc((E->lmesh.nno+1)*sizeof(double)))==NULL) {
Maxwelltime:Composition_related.c:                fprintf(E->trace.fpt,"AKM(allocate_composition_memory)-no memory 983rk\n");
Maxwelltime:Composition_related.c:                fflush(E->trace.fpt);
Maxwelltime:Composition_related.c:    if (E->composition.ibuoy_type==1) {
Maxwelltime:Composition_related.c:    if (E->composition.ibuoy_type!=1) {
Maxwelltime:Composition_related.c:        fprintf(E->trace.fpt,"Error(compute...)-only ratio method now\n");
Maxwelltime:Composition_related.c:        fflush(E->trace.fpt);
Maxwelltime:Composition_related.c:    if (E->composition.ibuoy_type == 1) {
Maxwelltime:Composition_related.c:        if (E->trace.istat_iempty) {
Maxwelltime:Composition_related.c:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Maxwelltime:Composition_related.c:        for (e=1; e<=E->lmesh.nel; e++) {
Maxwelltime:Composition_related.c:            for (flavor=0; flavor<E->trace.nflavors; flavor++)
Maxwelltime:Composition_related.c:                numtracers += E->trace.ntracer_flavor[j][flavor][e];
Maxwelltime:Composition_related.c:                /* fprintf(E->trace.fpt, "No tracer in element %d!\n", e); */
Maxwelltime:Composition_related.c:            for(i=0;i<E->composition.ncomp;i++) {
Maxwelltime:Composition_related.c:                E->composition.comp_el[j][i][e] =
Maxwelltime:Composition_related.c:                    E->trace.ntracer_flavor[j][flavor][e] / (double)numtracers;
Maxwelltime:Composition_related.c:            if ((1.0*iempty/E->lmesh.nel)>0.80) {
Maxwelltime:Composition_related.c:                fprintf(E->trace.fpt,"WARNING(compute_elemental...)-number of tracers is REALLY LOW\n");
Maxwelltime:Composition_related.c:                fflush(E->trace.fpt);
Maxwelltime:Composition_related.c:                if (E->trace.itracer_warnings) exit(10);
Maxwelltime:Composition_related.c:    E->trace.istat_iempty += iempty;
Maxwelltime:Composition_related.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Composition_related.c:        for(i=0;i<E->composition.ncomp;i++) {
Maxwelltime:Composition_related.c:            for (kk=1;kk<=E->lmesh.nno;kk++)
Maxwelltime:Composition_related.c:                E->composition.comp_node[j][i][kk]=0.0;
Maxwelltime:Composition_related.c:        for (nelem=1;nelem<=E->lmesh.nel;nelem++) {
Maxwelltime:Composition_related.c:                n = E->ien[j][nelem].node[nodenum];
Maxwelltime:Composition_related.c:                for(i=0;i<E->composition.ncomp;i++) {
Maxwelltime:Composition_related.c:                    E->composition.comp_node[j][i][n] +=
Maxwelltime:Composition_related.c:                        E->composition.comp_el[j][i][nelem]*
Maxwelltime:Composition_related.c:                        E->TWW[E->mesh.levmax][j][nelem].node[nodenum];
Maxwelltime:Composition_related.c:    for(i=0;i<E->composition.ncomp;i++) {
Maxwelltime:Composition_related.c:        for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Composition_related.c:            tmp[j] = E->composition.comp_node[j][i];
Maxwelltime:Composition_related.c:        (E->exchange_node_d)(E,tmp,E->mesh.levmax);
Maxwelltime:Composition_related.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Composition_related.c:        for(i=0;i<E->composition.ncomp;i++)
Maxwelltime:Composition_related.c:            for (kk=1;kk<=E->lmesh.nno;kk++)
Maxwelltime:Composition_related.c:                E->composition.comp_node[j][i][kk] *= E->MASS[E->mesh.levmax][j][kk];
Maxwelltime:Composition_related.c:        for(i=0;i<E->composition.ncomp;i++)
Maxwelltime:Composition_related.c:            for (kk=1;kk<=E->lmesh.nel;kk++) {
Maxwelltime:Composition_related.c:                fprintf(E->trace.fpt,"%d %f\n",kk,E->composition.comp_el[j][i][kk]);
Maxwelltime:Composition_related.c:        for(i=0;i<E->composition.ncomp;i++)
Maxwelltime:Composition_related.c:            for (kk=1;kk<=E->lmesh.nno;kk++) {
Maxwelltime:Composition_related.c:                fprintf(E->trace.fpt,"%d %f %f\n",kk,E->sx[j][3][kk],E->composition.comp_node[j][i][kk]);
Maxwelltime:Composition_related.c:        fflush(E->trace.fpt);
Maxwelltime:Composition_related.c:    fprintf(E->trace.fpt,"WARNING(check_initial_composition)-number of tracers is low, %d elements contain no tracer initially\n", E->trace.istat_iempty);
Maxwelltime:Composition_related.c:    fprintf(E->trace.fpt,"Using neighboring elements for initial composition...\n");
Maxwelltime:Composition_related.c:    nghbrs[0] = E->lmesh.elz;
Maxwelltime:Composition_related.c:    nghbrs[1] = -E->lmesh.elz;
Maxwelltime:Composition_related.c:    nghbrs[2] = E->lmesh.elz * E->lmesh.elx;
Maxwelltime:Composition_related.c:    nghbrs[3] = -E->lmesh.elz * E->lmesh.elx;
Maxwelltime:Composition_related.c:    is_empty = (int *)calloc(E->lmesh.nel+1, sizeof(int));
Maxwelltime:Composition_related.c:    sum = (double *)malloc(E->composition.ncomp * sizeof(double));
Maxwelltime:Composition_related.c:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Maxwelltime:Composition_related.c:        for (e=1; e<=E->lmesh.nel; e++) {
Maxwelltime:Composition_related.c:            for (flavor=0; flavor<E->trace.nflavors; flavor++)
Maxwelltime:Composition_related.c:                numtracers += E->trace.ntracer_flavor[j][flavor][e];
Maxwelltime:Composition_related.c:        for (e=1; e<=E->lmesh.nel; e++) {
Maxwelltime:Composition_related.c:                for (i=0; i<E->composition.ncomp; i++)
Maxwelltime:Composition_related.c:                    if((ee>0) && (ee<=E->lmesh.nel) && (!is_empty[ee])) {
Maxwelltime:Composition_related.c:                        for (i=0; i<E->composition.ncomp; i++)
Maxwelltime:Composition_related.c:                            sum[i] += E->composition.comp_el[j][i][ee];
Maxwelltime:Composition_related.c:                    fprintf(E->trace.fpt,"Error(fill_composition_from_neighbors)-all neighboring elements are empty\n");
Maxwelltime:Composition_related.c:                    fflush(E->trace.fpt);
Maxwelltime:Composition_related.c:                for (i=0; i<E->composition.ncomp; i++)
Maxwelltime:Composition_related.c:                    E->composition.comp_el[j][i][e] = sum[i] / count;
Maxwelltime:Composition_related.c:    fprintf(E->trace.fpt,"Done.\n");
Maxwelltime:Composition_related.c:    fflush(E->trace.fpt);
Maxwelltime:Composition_related.c:    for (i=0; i<E->composition.ncomp; i++) {
Maxwelltime:Composition_related.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Composition_related.c:            tmp[m] = E->composition.comp_node[m][i];
Maxwelltime:Composition_related.c:        E->composition.bulk_composition[i] = volume;
Maxwelltime:Composition_related.c:        E->composition.initial_bulk_composition[i] = volume;
Maxwelltime:Composition_related.c:    for (i=0; i<E->composition.ncomp; i++) {
Maxwelltime:Composition_related.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Composition_related.c:            tmp[m] = E->composition.comp_node[m][i];
Maxwelltime:Composition_related.c:        E->composition.bulk_composition[i] = volume;
Maxwelltime:Composition_related.c:        E->composition.error_fraction[i] = (volume - E->composition.initial_bulk_composition[i]) / E->composition.initial_bulk_composition[i];
Maxwelltime:Construct_arrays.c:  const int dims=E->mesh.nsd;
Maxwelltime:Construct_arrays.c:  for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)  {
Maxwelltime:Construct_arrays.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Construct_arrays.c:      elx = E->lmesh.ELX[lev];
Maxwelltime:Construct_arrays.c:      elz = E->lmesh.ELZ[lev];
Maxwelltime:Construct_arrays.c:      ely = E->lmesh.ELY[lev];
Maxwelltime:Construct_arrays.c:      nox = E->lmesh.NOX[lev];
Maxwelltime:Construct_arrays.c:      noz = E->lmesh.NOZ[lev];
Maxwelltime:Construct_arrays.c:      noy = E->lmesh.NOY[lev];
Maxwelltime:Construct_arrays.c:      nel=E->lmesh.NEL[lev];
Maxwelltime:Construct_arrays.c:      nno=E->lmesh.NNO[lev];
Maxwelltime:Construct_arrays.c:               E->IEN[lev][j][element].node[rr]= start
Maxwelltime:Construct_arrays.c:/* if(E->control.verbose)  { */
Maxwelltime:Construct_arrays.c:/*   for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)  { */
Maxwelltime:Construct_arrays.c:/*     fprintf(E->fp_out,"output_IEN_arrays me=%d lev=%d \n",E->parallel.me,lev); */
Maxwelltime:Construct_arrays.c:/*   for (j=1;j<=E->sphere.caps_per_proc;j++) { */
Maxwelltime:Construct_arrays.c:/*     fprintf(E->fp_out,"output_IEN_arrays me=%d %d %d\n",E->parallel.me,j,E->sphere.capid[j]); */
Maxwelltime:Construct_arrays.c:/*     for (i=1;i<=E->lmesh.NEL[lev];i++) */
Maxwelltime:Construct_arrays.c:/*        fprintf(E->fp_out,"%d %d %d %d %d %d %d %d %d\n",i,E->IEN[lev][j][i].node[1],E->IEN[lev][j][i].node[2],E->IEN[lev][j][i].node[3],E->IEN[lev][j][i].node[4],E->IEN[lev][j][i].node[5],E->IEN[lev][j][i].node[6],E->IEN[lev][j][i].node[7],E->IEN[lev][j][i].node[8]); */
Maxwelltime:Construct_arrays.c:/*   fflush (E->fp_out); */
Maxwelltime:Construct_arrays.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Construct_arrays.c:    for(element=1;element<=E->lmesh.nel;element++)
Maxwelltime:Construct_arrays.c:      if ( element%E->lmesh.elz==0) { /* top */
Maxwelltime:Construct_arrays.c:        E->sien[j][e].node[1] = E->ien[j][element].node[5]/E->lmesh.noz;
Maxwelltime:Construct_arrays.c:        E->sien[j][e].node[2] = E->ien[j][element].node[6]/E->lmesh.noz;
Maxwelltime:Construct_arrays.c:        E->sien[j][e].node[3] = E->ien[j][element].node[7]/E->lmesh.noz;
Maxwelltime:Construct_arrays.c:        E->sien[j][e].node[4] = E->ien[j][element].node[8]/E->lmesh.noz;
Maxwelltime:Construct_arrays.c:        E->surf_element[j][e] = element;
Maxwelltime:Construct_arrays.c:    E->lmesh.snel = e;
Maxwelltime:Construct_arrays.c:    for (i=1;i<=E->lmesh.nsf;i++)
Maxwelltime:Construct_arrays.c:      E->surf_node[j][i] = i*E->lmesh.noz;
Maxwelltime:Construct_arrays.c:  if(E->control.verbose) {
Maxwelltime:Construct_arrays.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Construct_arrays.c:      for(e=1;e<=E->lmesh.snel;e++) {
Maxwelltime:Construct_arrays.c:        fprintf(E->fp_out, "sien sel=%d node=%d %d %d %d\n",
Maxwelltime:Construct_arrays.c:		e, E->sien[j][e].node[1], E->sien[j][e].node[2], E->sien[j][e].node[3], E->sien[j][e].node[4]);
Maxwelltime:Construct_arrays.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Construct_arrays.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)  {
Maxwelltime:Construct_arrays.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Construct_arrays.c:      for(node=1;node<=E->lmesh.NNO[lev];node++)
Maxwelltime:Construct_arrays.c:          E->ID[lev][j][node].doff[doff] = eqn_count;
Maxwelltime:Construct_arrays.c:      E->lmesh.NEQ[lev] = eqn_count;
Maxwelltime:Construct_arrays.c:      for(node=1;node<=E->lmesh.NNO[lev];node++) {
Maxwelltime:Construct_arrays.c:        if (E->NODE[lev][j][node] & SKIP)
Maxwelltime:Construct_arrays.c:          E->parallel.Skip_id[lev][j][i] = E->ID[lev][j][node].doff[doff];
Maxwelltime:Construct_arrays.c:      E->parallel.Skip_neq[lev][j] = i;
Maxwelltime:Construct_arrays.c:      neq = E->lmesh.NEQ[lev] - E->parallel.Skip_neq[lev][j];
Maxwelltime:Construct_arrays.c:      MPI_Allreduce(&neq, &gneq, 1, MPI_INT, MPI_SUM, E->parallel.world);
Maxwelltime:Construct_arrays.c:      E->mesh.NEQ[lev] = gneq;
Maxwelltime:Construct_arrays.c:    E->lmesh.neq = E->lmesh.NEQ[E->mesh.levmax];
Maxwelltime:Construct_arrays.c:    E->mesh.neq = E->mesh.NEQ[E->mesh.levmax];
Maxwelltime:Construct_arrays.c:/*     if (E->control.verbose) { */
Maxwelltime:Construct_arrays.c:/*       fprintf(E->fp_out,"output_ID_arrays \n"); */
Maxwelltime:Construct_arrays.c:/*       for(j=1;j<=E->sphere.caps_per_proc;j++)    */
Maxwelltime:Construct_arrays.c:/*         for (i=1;i<=E->lmesh.nno;i++) */
Maxwelltime:Construct_arrays.c:/*           fprintf(E->fp_out,"%d %d %d %d %d\n",eqn_count,i,E->ID[lev][j][i].doff[1],E->ID[lev][j][i].doff[2],E->ID[lev][j][i].doff[3]); */
Maxwelltime:Construct_arrays.c:/*       fflush(E->fp_out); */
Maxwelltime:Construct_arrays.c:    const int nno=E->lmesh.NNO[level];
Maxwelltime:Construct_arrays.c:      if ( (E->NODE[level][m][i] & VBX) != 0 )  {
Maxwelltime:Construct_arrays.c:        E->zero_resid[level][m][j] = E->ID[level][m][i].doff[1];
Maxwelltime:Construct_arrays.c:      if ( (E->NODE[level][m][i] & VBY) != 0 )  {
Maxwelltime:Construct_arrays.c:        E->zero_resid[level][m][j] = E->ID[level][m][i].doff[2];
Maxwelltime:Construct_arrays.c:      if ( (E->NODE[level][m][i] & VBZ) != 0 )  {
Maxwelltime:Construct_arrays.c:        E->zero_resid[level][m][j] = E->ID[level][m][i].doff[3];
Maxwelltime:Construct_arrays.c:    E->num_zero_resid[level][m] = j;
Maxwelltime:Construct_arrays.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Construct_arrays.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Construct_arrays.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Maxwelltime:Construct_arrays.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)             {
Maxwelltime:Construct_arrays.c:       neq=E->lmesh.NEQ[lev];
Maxwelltime:Construct_arrays.c:       nno=E->lmesh.NNO[lev];
Maxwelltime:Construct_arrays.c:       noxz = E->lmesh.NOX[lev]*E->lmesh.NOZ[lev];
Maxwelltime:Construct_arrays.c:       noz = E->lmesh.NOZ[lev];
Maxwelltime:Construct_arrays.c:       noy = E->lmesh.NOY[lev];
Maxwelltime:Construct_arrays.c:       nox = E->lmesh.NOX[lev];
Maxwelltime:Construct_arrays.c:       E->Node_map[lev][m]=(int *) malloc (matrix*sizeof(int));
Maxwelltime:Construct_arrays.c:	   E->Node_map[lev][m][i] = neq;  /* neq indicates an invalid eqn # */
Maxwelltime:Construct_arrays.c:	   E->Node_map[lev][m][(nn-1)*max_eqn+doff-1] = E->ID[lev][m][nn].doff[doff];
Maxwelltime:Construct_arrays.c:                   E->Node_map[lev][m][(nn-1)*max_eqn+ia*dims+doff-1]=E->ID[lev][m][ja].doff[doff];
Maxwelltime:Construct_arrays.c:       E->Eqn_k1[lev][m] = (higher_precision *)malloc(matrix*sizeof(higher_precision));
Maxwelltime:Construct_arrays.c:       E->Eqn_k2[lev][m] = (higher_precision *)malloc(matrix*sizeof(higher_precision));
Maxwelltime:Construct_arrays.c:       E->Eqn_k3[lev][m] = (higher_precision *)malloc(matrix*sizeof(higher_precision));
Maxwelltime:Construct_arrays.c:       E->mesh.matrix_size[lev] = matrix;
Maxwelltime:Construct_arrays.c:       if(E->control.verbose) {
Maxwelltime:Construct_arrays.c:           fprintf(E->fp_out, "output Node_map lev=%d m=%d\n", lev, m);
Maxwelltime:Construct_arrays.c:           fprintf(E->fp_out, "neq=%d nno=%d max_eqn=%d matrix=%d\n", neq, nno, max_eqn, matrix);
Maxwelltime:Construct_arrays.c://               fprintf(E->fp_out, "%d %d\n", i, E->Node_map[lev][m][i]);
Maxwelltime:Construct_arrays.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Construct_arrays.c:    const int lms=loc_mat_size[E->mesh.nsd];
Maxwelltime:Construct_arrays.c:   for(level=E->mesh.gridmax;level>=E->mesh.gridmin;level--)   {
Maxwelltime:Construct_arrays.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Maxwelltime:Construct_arrays.c:        neq=E->lmesh.NEQ[level];
Maxwelltime:Construct_arrays.c:        nel=E->lmesh.NEL[level];
Maxwelltime:Construct_arrays.c:        nno=E->lmesh.NNO[level];
Maxwelltime:Construct_arrays.c:	    E->BI[level][m][i] = zero;
Maxwelltime:Construct_arrays.c:        for(i=0;i<E->mesh.matrix_size[level];i++) {
Maxwelltime:Construct_arrays.c:            E->Eqn_k1[level][m][i] = zero;
Maxwelltime:Construct_arrays.c:            E->Eqn_k2[level][m][i] = zero;
Maxwelltime:Construct_arrays.c:            E->Eqn_k3[level][m][i] = zero;
Maxwelltime:Construct_arrays.c:	    if (E->control.augmented_Lagr && !E->ve_data_cont.compressible)
Maxwelltime:Construct_arrays.c:	       node=E->IEN[level][m][element].node[i];
Maxwelltime:Construct_arrays.c:	       if(E->NODE[level][m][node] & VBX) w1=0.0;
Maxwelltime:Construct_arrays.c:	       if(E->NODE[level][m][node] & VBZ) w3=0.0;
Maxwelltime:Construct_arrays.c:	       if(E->NODE[level][m][node] & VBY) w2=0.0;
Maxwelltime:Construct_arrays.c:	         node1=E->IEN[level][m][element].node[j];
Maxwelltime:Construct_arrays.c:		    eqn1=E->ID[level][m][node1].doff[1];
Maxwelltime:Construct_arrays.c:		    eqn2=E->ID[level][m][node1].doff[2];
Maxwelltime:Construct_arrays.c:		    eqn3=E->ID[level][m][node1].doff[3];
Maxwelltime:Construct_arrays.c:		    if(E->NODE[level][m][node1] & VBX) ww1=0.0;
Maxwelltime:Construct_arrays.c:		    if(E->NODE[level][m][node1] & VBZ) ww3=0.0;
Maxwelltime:Construct_arrays.c:		    if(E->NODE[level][m][node1] & VBY) ww2=0.0;
Maxwelltime:Construct_arrays.c:		      if(E->Node_map[level][m][loc0+k] == eqn1) { /* found, index next equation */
Maxwelltime:Construct_arrays.c:		    E->Eqn_k1[level][m][loc0+index] +=  w1*ww1*elt_K[pp*lms+qq]; /* direction 1 */
Maxwelltime:Construct_arrays.c:		    E->Eqn_k2[level][m][loc0+index] +=  w2*ww1*elt_K[(pp+1)*lms+qq]; /* direction 1 */
Maxwelltime:Construct_arrays.c:		    E->Eqn_k3[level][m][loc0+index] +=  w3*ww1*elt_K[(pp+2)*lms+qq]; /* direction 1 */
Maxwelltime:Construct_arrays.c:			if(E->Node_map[level][m][loc0+k] == eqn2) { /* found, index next equation */
Maxwelltime:Construct_arrays.c:		    E->Eqn_k1[level][m][loc0+index] += w1*ww2*elt_K[pp*lms+qq+1]; /* direction 1 */
Maxwelltime:Construct_arrays.c:		    E->Eqn_k2[level][m][loc0+index] += w2*ww2*elt_K[(pp+1)*lms+qq+1]; /* direction 2 */
Maxwelltime:Construct_arrays.c:		    E->Eqn_k3[level][m][loc0+index] += w3*ww2*elt_K[(pp+2)*lms+qq+1]; /* direction 3 */
Maxwelltime:Construct_arrays.c:		    if(E->Node_map[level][m][loc0+k] == eqn3) { /* found, index next equation */
Maxwelltime:Construct_arrays.c:		    E->Eqn_k1[level][m][loc0+index] += w1*ww3*elt_K[pp*lms+qq+2]; /* direction 1 */
Maxwelltime:Construct_arrays.c:                    E->Eqn_k2[level][m][loc0+index] += w2*ww3*elt_K[(pp+1)*lms+qq+2]; /* direction 2 */
Maxwelltime:Construct_arrays.c:		    E->Eqn_k3[level][m][loc0+index] += w3*ww3*elt_K[(pp+2)*lms+qq+2]; /* direction 3 */
Maxwelltime:Construct_arrays.c:     (E->solver.exchange_id_d)(E, E->BI[level], level);
Maxwelltime:Construct_arrays.c:     for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Maxwelltime:Construct_arrays.c:        neq=E->lmesh.NEQ[level];
Maxwelltime:Construct_arrays.c:            if(E->BI[level][m][j] ==0.0)  fprintf(stderr,"me= %d level %d, equation %d/%d has zero diagonal term\n",E->parallel.me,level,j,neq);
Maxwelltime:Construct_arrays.c:	    assert( E->BI[level][m][j] != 0 /* diagonal of matrix = 0, not acceptable */);
Maxwelltime:Construct_arrays.c:            E->BI[level][m][j]  = (double) 1.0/E->BI[level][m][j];
Maxwelltime:Construct_arrays.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Construct_arrays.c:   for(level=E->mesh.gridmax;level>=E->mesh.gridmin;level--)   {
Maxwelltime:Construct_arrays.c:     for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Construct_arrays.c:        for(j=0;j<=E->lmesh.NEQ[level];j++)
Maxwelltime:Construct_arrays.c:            E->temp[m][j]=0.0;
Maxwelltime:Construct_arrays.c:        for(i=1;i<=E->lmesh.NNO[level];i++)  {
Maxwelltime:Construct_arrays.c:            eqn1=E->ID[level][m][i].doff[1];
Maxwelltime:Construct_arrays.c:            eqn2=E->ID[level][m][i].doff[2];
Maxwelltime:Construct_arrays.c:            eqn3=E->ID[level][m][i].doff[3];
Maxwelltime:Construct_arrays.c:            C=E->Node_map[level][m] + (i-1)*max_eqn;
Maxwelltime:Construct_arrays.c:            B1=E->Eqn_k1[level][m]+(i-1)*max_eqn;
Maxwelltime:Construct_arrays.c:            B2=E->Eqn_k2[level][m]+(i-1)*max_eqn;
Maxwelltime:Construct_arrays.c:            B3=E->Eqn_k3[level][m]+(i-1)*max_eqn;
Maxwelltime:Construct_arrays.c:                E->temp[m][eqn1] += fabs(B1[j]);
Maxwelltime:Construct_arrays.c:                E->temp[m][eqn2] += fabs(B2[j]);
Maxwelltime:Construct_arrays.c:                E->temp[m][eqn3] += fabs(B3[j]);
Maxwelltime:Construct_arrays.c:                E->temp[m][C[j]] += fabs(B1[j]) + fabs(B2[j]) + fabs(B3[j]);
Maxwelltime:Construct_arrays.c:     (E->solver.exchange_id_d)(E, E->temp, level);
Maxwelltime:Construct_arrays.c:     for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Construct_arrays.c:        for(i=0;i<E->lmesh.NEQ[level];i++)  {
Maxwelltime:Construct_arrays.c:            E->temp[m][i] = E->temp[m][i] - 1.0/E->BI[level][m][i];
Maxwelltime:Construct_arrays.c:        for(i=1;i<=E->lmesh.NNO[level];i++)
Maxwelltime:Construct_arrays.c:          if (E->NODE[level][m][i] & OFFSIDE)   {
Maxwelltime:Construct_arrays.c:            eqn1=E->ID[level][m][i].doff[1];
Maxwelltime:Construct_arrays.c:            eqn2=E->ID[level][m][i].doff[2];
Maxwelltime:Construct_arrays.c:            eqn3=E->ID[level][m][i].doff[3];
Maxwelltime:Construct_arrays.c:            E->BI[level][m][eqn1] = (double) 1.0/E->temp[m][eqn1];
Maxwelltime:Construct_arrays.c:            E->BI[level][m][eqn2] = (double) 1.0/E->temp[m][eqn2];
Maxwelltime:Construct_arrays.c:            E->BI[level][m][eqn3] = (double) 1.0/E->temp[m][eqn3];
Maxwelltime:Construct_arrays.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Maxwelltime:Construct_arrays.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)           {
Maxwelltime:Construct_arrays.c:      elz = E->lmesh.ELZ[lev];
Maxwelltime:Construct_arrays.c:      ely = E->lmesh.ELY[lev];
Maxwelltime:Construct_arrays.c:      noy = E->lmesh.NOY[lev];
Maxwelltime:Construct_arrays.c:      noz = E->lmesh.NOZ[lev];
Maxwelltime:Construct_arrays.c:      nno = E->lmesh.NNO[lev];
Maxwelltime:Construct_arrays.c:        if (E->parallel.me_loc[3]==0 )
Maxwelltime:Construct_arrays.c:          for (i=1;i<=E->parallel.NUM_NNO[lev][j].bound[5];i++)   {
Maxwelltime:Construct_arrays.c:            node = E->parallel.NODE[lev][j][i].bound[5];
Maxwelltime:Construct_arrays.c: 	    E->NODE[lev][j][node] = E->NODE[lev][j][node] | TZEDGE;
Maxwelltime:Construct_arrays.c:        if ( E->parallel.me_loc[3]==E->parallel.nprocz-1 )
Maxwelltime:Construct_arrays.c:          for (i=1;i<=E->parallel.NUM_NNO[lev][j].bound[6];i++)   {
Maxwelltime:Construct_arrays.c:  	    node = E->parallel.NODE[lev][j][i].bound[6];
Maxwelltime:Construct_arrays.c:	    E->NODE[lev][j][node] = E->NODE[lev][j][node] | TZEDGE;
Maxwelltime:Construct_arrays.c:/*   if (E->control.verbose) { */
Maxwelltime:Construct_arrays.c:/*     for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)  */
Maxwelltime:Construct_arrays.c:/*       for (j=1;j<=E->sphere.caps_per_proc;j++)           { */
Maxwelltime:Construct_arrays.c:/*         for (i=1;i<=E->parallel.NUM_NNO[lev][j].bound[5];i++)   {  */
Maxwelltime:Construct_arrays.c:/* 	  node = E->parallel.NODE[lev][j][i].bound[5]; */
Maxwelltime:Construct_arrays.c:/* 	  fprintf(E->fp_out,"bound=5  NODE[lev=%1d][node=%3d]=%d\n",lev,node,E->NODE[lev][j][node]); */
Maxwelltime:Construct_arrays.c:/*         for (i=1;i<=E->parallel.NUM_NNO[lev][j].bound[6];i++)   {  */
Maxwelltime:Construct_arrays.c:/* 	  node = E->parallel.NODE[lev][j][i].bound[6]; */
Maxwelltime:Construct_arrays.c:/* 	  fprintf(E->fp_out,"bound=6  NODE[lev=%1d][node=%3d]=%d\n",lev,node,E->NODE[lev][j][node]); */
Maxwelltime:Construct_arrays.c:/*     fflush(E->fp_out); */
Maxwelltime:Construct_arrays.c:  for(lev=E->mesh.levmax-1;lev>=E->mesh.levmin;lev--)
Maxwelltime:Construct_arrays.c:     for (m=1;m<=E->sphere.caps_per_proc;m++)       {
Maxwelltime:Construct_arrays.c:          elx = E->lmesh.ELX[lev];
Maxwelltime:Construct_arrays.c:	  elz = E->lmesh.ELZ[lev];
Maxwelltime:Construct_arrays.c:	  ely = E->lmesh.ELY[lev];
Maxwelltime:Construct_arrays.c:          nox = E->lmesh.NOX[lev];
Maxwelltime:Construct_arrays.c:          noy = E->lmesh.NOY[lev];
Maxwelltime:Construct_arrays.c:          noz = E->lmesh.NOZ[lev];
Maxwelltime:Construct_arrays.c:	  elz = E->lmesh.ELZ[lev];
Maxwelltime:Construct_arrays.c:	  ely = E->lmesh.ELY[lev];
Maxwelltime:Construct_arrays.c:          if (!E->control.NMULTIGRID)  {
Maxwelltime:Construct_arrays.c:             if (lev == E->mesh.levmax-1)
Maxwelltime:Construct_arrays.c:                 elzu = E->lmesh.ELZ[E->mesh.levmax];
Maxwelltime:Construct_arrays.c:		  for(l=1;l<=enodes[E->mesh.nsd];l++)   {
Maxwelltime:Construct_arrays.c:		      E->EL[lev][m][elt].sub[l] = eltu
Maxwelltime:Construct_arrays.c:    const int dims=E->mesh.nsd;
Maxwelltime:Construct_arrays.c:    const int n=loc_mat_size[E->mesh.nsd];
Maxwelltime:Construct_arrays.c:/*     if(E->parallel.me==0) */
Maxwelltime:Construct_arrays.c:    for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Maxwelltime:Construct_arrays.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Maxwelltime:Construct_arrays.c:	for(el=1;el<=E->lmesh.NEL[lev];el++)    {
Maxwelltime:Construct_arrays.c:	    get_elt_k(E,el,E->elt_k[lev][m][el].k,lev,m,0);
Maxwelltime:Construct_arrays.c:	    if (E->control.augmented_Lagr)
Maxwelltime:Construct_arrays.c:	        get_aug_k(E,el,E->elt_k[lev][m][el].k,lev,m);
Maxwelltime:Construct_arrays.c:            build_diagonal_of_K(E,el,E->elt_k[lev][m][el].k,lev,m);
Maxwelltime:Construct_arrays.c:      (E->solver.exchange_id_d)(E, E->BI[lev], lev);    /*correct BI   */
Maxwelltime:Construct_arrays.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Construct_arrays.c:            for(j=0;j<E->lmesh.NEQ[lev];j++) {
Maxwelltime:Construct_arrays.c:	       if(E->BI[lev][m][j] ==0.0)  fprintf(stderr,"me= %d level %d, equation %d/%d has zero diagonal term\n",E->parallel.me,lev,j,E->lmesh.NEQ[lev]);
Maxwelltime:Construct_arrays.c:               assert( E->BI[lev][m][j] != 0 /* diagonal of matrix = 0, not acceptable */);
Maxwelltime:Construct_arrays.c:               E->BI[lev][m][j]  = (double) 1.0/E->BI[lev][m][j];
Maxwelltime:Construct_arrays.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Construct_arrays.c:/*   if(E->control.verbose && E->parallel.me==0) */
Maxwelltime:Construct_arrays.c:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Maxwelltime:Construct_arrays.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Construct_arrays.c:      for(el=1;el<=E->lmesh.NEL[lev];el++)
Maxwelltime:Construct_arrays.c:        get_elt_g(E,el,E->elt_del[lev][m][el].g,lev,m);
Maxwelltime:Construct_arrays.c:/*     if(E->control.verbose && E->parallel.me==0) */
Maxwelltime:Construct_arrays.c:    for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Maxwelltime:Construct_arrays.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Construct_arrays.c:            for(el=1;el<=E->lmesh.NEL[lev];el++) {
Maxwelltime:Construct_arrays.c:                get_elt_c(E,el,E->elt_c[lev][m][el].c,lev,m);
Maxwelltime:Construct_arrays.c:  if (E->control.NMULTIGRID)
Maxwelltime:Construct_arrays.c:  if (E->control.NMULTIGRID || E->control.NASSEMBLE) {
Maxwelltime:Construct_arrays.c:  if (E->control.NMULTIGRID || (E->control.NASSEMBLE && !E->control.CONJ_GRAD))
Maxwelltime:Construct_arrays.c:if E->viscosity.z... set to Earth values, and old, num_mat=4 style is
Maxwelltime:Construct_arrays.c:  rl = r + E->sphere.ro;
Maxwelltime:Construct_arrays.c:  if (r> (E->sphere.ro - E->viscosity.zbase_layer[E->viscosity.rheol_layers-1])){
Maxwelltime:Construct_arrays.c:    i = E->viscosity.rheol_layers;
Maxwelltime:Construct_arrays.c:    for(i=0;i<E->viscosity.rheol_layers-1;i++)
Maxwelltime:Construct_arrays.c:      if(r >= (E->sphere.ro - E->viscosity.zbase_layer[i] - 1e-6) && r<(E->sphere.ro - E->viscosity.zbase_layer[i+1]+1e-6)){
Maxwelltime:Construct_arrays.c:  return(layers_r(E,E->sx[m][3][node]));
Maxwelltime:Construct_arrays.c:  if (kk >= E->viscosity.nbase_layer[E->viscosity.rheol_layers-1])  {
Maxwelltime:Construct_arrays.c:     i = E->viscosity.rheol_layers;
Maxwelltime:Construct_arrays.c:    for(i=0;i<E->viscosity.rheol_layers-1;i++)
Maxwelltime:Construct_arrays.c:      if (kk >= E->viscosity.nbase_layer[i]&&kk<E->viscosity.nbase_layer[i+1]){
Maxwelltime:Construct_arrays.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Construct_arrays.c:/*  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Construct_arrays.c:    for(el=1;el<=E->lmesh.nel;el++) {
Maxwelltime:Construct_arrays.c:      E->mat[m][el] = 1;
Maxwelltime:Construct_arrays.c:      nodea = E->ien[m][el].node[2];
Maxwelltime:Construct_arrays.c:	E->mat[m][el] = llayer;
Maxwelltime:Construct_arrays.c: for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Construct_arrays.c:   for (k=1;k<=E->lmesh.elz;k++)  {
Maxwelltime:Construct_arrays.c:     kk = k + E->lmesh.ezs; 
Maxwelltime:Construct_arrays.c:     for (j=1;j<=E->lmesh.ely;j++)
Maxwelltime:Construct_arrays.c:     for (i=1;i<=E->lmesh.elx;i++)   {
Maxwelltime:Construct_arrays.c:        el = k + (i-1)*E->lmesh.elz+(j-1)*E->lmesh.elx*E->lmesh.elz;
Maxwelltime:Construct_arrays.c:        E->mat[m][el] = llayer;
Maxwelltime:Construct_arrays.c:  if (E->ve_data_cont.variable_te) {
Maxwelltime:Construct_arrays.c:     read_reg_grids(E,E->ve_data_cont.te_file,E->slice_ve.elast_thick);
Maxwelltime:Construct_arrays.c:     modify_mat_te(E,E->slice_ve.elast_thick);
Maxwelltime:Construct_arrays.c:  if (E->ve_data_cont.plate_margins) {
Maxwelltime:Construct_arrays.c:     read_reg_grids(E,E->ve_data_cont.platemargins_file,E->slice_ve.plate_margins);
Maxwelltime:Construct_arrays.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Construct_arrays.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   
Maxwelltime:Construct_arrays.c:  for (i=1;i<=E->lmesh.nsf;i++) {
Maxwelltime:Construct_arrays.c:    elast_thick[m][i] = E->sphere.ro - elast_thick[m][i]*1000.0/E->sphere.dradius;
Maxwelltime:Construct_arrays.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   
Maxwelltime:Construct_arrays.c:    for (j=1;j<=E->lmesh.ely;j++)  
Maxwelltime:Construct_arrays.c:    for (i=1;i<=E->lmesh.elx;i++)  {
Maxwelltime:Construct_arrays.c:      els = i + (j-1)*E->lmesh.elx;
Maxwelltime:Construct_arrays.c:      te_ele = 0.25*(elast_thick[m][E->sien[m][els].node[1]]
Maxwelltime:Construct_arrays.c:                    +elast_thick[m][E->sien[m][els].node[2]]
Maxwelltime:Construct_arrays.c:                    +elast_thick[m][E->sien[m][els].node[3]]
Maxwelltime:Construct_arrays.c:                    +elast_thick[m][E->sien[m][els].node[4]]);
Maxwelltime:Construct_arrays.c:      for (k=1;k<=E->lmesh.elz;k++)   {
Maxwelltime:Construct_arrays.c:        el = k + (i-1)*E->lmesh.elz + (j-1)*E->lmesh.elz*E->lmesh.elx;
Maxwelltime:Construct_arrays.c:           center_r += E->sx[m][3][E->ien[m][el].node[a]];
Maxwelltime:Construct_arrays.c:        E->mat[m][el] = 1;
Maxwelltime:Construct_arrays.c:        kk = k + E->lmesh.ezs; 
Maxwelltime:Construct_arrays.c: 	   E->mat[m][el] = 2;   // elastic lithosphere
Maxwelltime:Construct_arrays.c://        else if (kk>=E->viscosity.nlith1) 
Maxwelltime:Construct_arrays.c://           E->mat[m][el] = 3;
Maxwelltime:Construct_arrays.c:        else if (kk>=E->viscosity.n410) 
Maxwelltime:Construct_arrays.c:           E->mat[m][el] = 4;
Maxwelltime:Construct_arrays.c:        else if (kk>=E->viscosity.nlm) 
Maxwelltime:Construct_arrays.c:           E->mat[m][el] = 5;
Maxwelltime:Construct_arrays.c:        else if (kk>=E->viscosity.nlm1) 
Maxwelltime:Construct_arrays.c:           E->mat[m][el] = 6;
Maxwelltime:Convection.c:    E->control.CONVECTION = 1;
Maxwelltime:Convection.c:    E->advection.timestep = 0.0;
Maxwelltime:Convection.c:    E->advection.timesteps = 0;
Maxwelltime:Convection.c:    E->advection.temp_iterations = 2; /* petrov-galerkin iterations: minimum value. */
Maxwelltime:Convection.c:    E->advection.total_timesteps = 1;
Maxwelltime:Convection.c:    E->advection.sub_iterations = 1;
Maxwelltime:Convection.c:    E->advection.last_sub_iterations = 1;
Maxwelltime:Convection.c:    E->advection.gamma = 0.5;
Maxwelltime:Convection.c:    E->advection.dt_reduced = 1.0;
Maxwelltime:Convection.c:    E->monitor.T_maxvaried = 1.05;
Maxwelltime:Convection.c:    E->next_buoyancy_field = PG_timestep;
Maxwelltime:Convection.c:    E->next_buoyancy_field_init = PG_timestep_init;
Maxwelltime:Convection.c:    E->special_process_new_buoyancy = twiddle_thumbs;
Maxwelltime:Convection.c:    E->problem_settings = read_convection_settings;
Maxwelltime:Convection.c:    E->problem_derived_values = convection_derived_values;
Maxwelltime:Convection.c:    E->problem_allocate_vars = convection_allocate_memory;
Maxwelltime:Convection.c:    E->problem_boundary_conds = convection_boundary_conditions;
Maxwelltime:Convection.c:    E->problem_initial_fields = convection_initial_fields;
Maxwelltime:Convection.c:    E->problem_update_node_positions = twiddle_thumbs;
Maxwelltime:Convection.c:    E->problem_update_bcs = twiddle_thumbs;
Maxwelltime:Convection.c:    (E->solver.velocity_boundary_conditions)(E);      /* universal */
Maxwelltime:Convection.c:    (E->solver.temperature_boundary_conditions)(E);
Maxwelltime:Determine_net_rotation.c:  const int dims = E->mesh.nsd;
Maxwelltime:Determine_net_rotation.c:  elz = E->lmesh.elz;elx = E->lmesh.elx;ely = E->lmesh.ely;
Maxwelltime:Determine_net_rotation.c:    for (m=1;m <= E->sphere.caps_per_proc;m++)
Maxwelltime:Determine_net_rotation.c:          lnode[1] = E->ien[m][el].node[1];
Maxwelltime:Determine_net_rotation.c:          lnode[2] = E->ien[m][el].node[2];
Maxwelltime:Determine_net_rotation.c:          lnode[3] = E->ien[m][el].node[3];
Maxwelltime:Determine_net_rotation.c:          lnode[4] = E->ien[m][el].node[4];
Maxwelltime:Determine_net_rotation.c:          for(nint=1;nint <= onedvpoints[E->mesh.nsd];nint++)   {
Maxwelltime:Determine_net_rotation.c:            for(d=1;d <= onedvpoints[E->mesh.nsd];d++){
Maxwelltime:Determine_net_rotation.c:	      vtmp = E->M.vpt[GMVINDEX(d,nint)] * dGamma.vpt[GMVGAMMA(0,nint)];
Maxwelltime:Determine_net_rotation.c:	      x[0] += E->x[m][1][lnode[d]] * vtmp; /* coords */
Maxwelltime:Determine_net_rotation.c:	      x[1] += E->x[m][2][lnode[d]] * vtmp;
Maxwelltime:Determine_net_rotation.c:	      x[2] += E->x[m][3][lnode[d]] * vtmp;
Maxwelltime:Determine_net_rotation.c:              v[0] += E->sphere.cap[m].V[1][lnode[d]] * vtmp; /* theta */
Maxwelltime:Determine_net_rotation.c:              v[1] += E->sphere.cap[m].V[2][lnode[d]] * vtmp; /* phi */
Maxwelltime:Determine_net_rotation.c:            lnode[1] = E->ien[m][el].node[5];
Maxwelltime:Determine_net_rotation.c:            lnode[2] = E->ien[m][el].node[6];
Maxwelltime:Determine_net_rotation.c:            lnode[3] = E->ien[m][el].node[7];
Maxwelltime:Determine_net_rotation.c:            lnode[4] = E->ien[m][el].node[8];
Maxwelltime:Determine_net_rotation.c:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Maxwelltime:Determine_net_rotation.c:              for(d=1;d<=onedvpoints[E->mesh.nsd];d++){
Maxwelltime:Determine_net_rotation.c:		vtmp = E->M.vpt[GMVINDEX(d,nint)] * dGamma.vpt[GMVGAMMA(1,nint)];
Maxwelltime:Determine_net_rotation.c:		x[0] += E->x[m][1][lnode[d]] * vtmp; /* coords */
Maxwelltime:Determine_net_rotation.c:		x[1] += E->x[m][2][lnode[d]] * vtmp;
Maxwelltime:Determine_net_rotation.c:		x[2] += E->x[m][3][lnode[d]] * vtmp;
Maxwelltime:Determine_net_rotation.c:		v[0] += E->sphere.cap[m].V[1][lnode[d]] * vtmp;
Maxwelltime:Determine_net_rotation.c:		v[1] += E->sphere.cap[m].V[2][lnode[d]] * vtmp;
Maxwelltime:Determine_net_rotation.c:  MPI_Allreduce(coef,acoef,elz9,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Maxwelltime:Determine_net_rotation.c:  rr = E->sx[1][3][E->ien[1][elz].node[5]] - E->sx[1][3][E->ien[1][1].node[1]];
Maxwelltime:Determine_net_rotation.c:    r1 = E->sx[1][3][E->ien[1][i+1].node[1]]; /* nodal radii for the
Maxwelltime:Determine_net_rotation.c:    r2 = E->sx[1][3][E->ien[1][i+1].node[5]];
Maxwelltime:Determine_net_rotation.c:    //if(E->parallel.me == 0)
Maxwelltime:Determine_net_rotation.c:  if(E->parallel.me == 0)
Maxwelltime:Determine_net_rotation.c://   ADDED BY -OrbData-, AND NODE-VELOCITY OUTPUT FROM -SHELLS-,
Maxwelltime:Drive_solvers.c:  if (E->control.NMULTIGRID || E->control.NASSEMBLE)
Maxwelltime:Drive_solvers.c:    for (i=E->mesh.gridmin;i<=E->mesh.gridmax;i++)
Maxwelltime:Drive_solvers.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Drive_solvers.c:	E->elt_k[i][m]=(struct EK *)malloc((E->lmesh.NEL[i]+1)*sizeof(struct EK));
Maxwelltime:Drive_solvers.c: if (E->parallel.me==0) fprintf(stderr,"done for stokes_solver_setup\n");
Maxwelltime:Drive_solvers.c:  const int nno = E->lmesh.nno;
Maxwelltime:Drive_solvers.c:  const int nel = E->lmesh.nel;
Maxwelltime:Drive_solvers.c:  const int neq = E->lmesh.neq;
Maxwelltime:Drive_solvers.c:  const int vpts = vpoints[E->mesh.nsd];
Maxwelltime:Drive_solvers.c:  const int dims = E->mesh.nsd;
Maxwelltime:Drive_solvers.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Drive_solvers.c:  for (m=1;m<=E->sphere.caps_per_proc;m++) 
Maxwelltime:Drive_solvers.c:  if(E->parallel.me==0)  time=CPU_time0();
Maxwelltime:Drive_solvers.c:  E->viscosity.iterate=0;
Maxwelltime:Drive_solvers.c:  velocities_conform_bcs(E,E->U);
Maxwelltime:Drive_solvers.c:if (  !E->viscosity.SDEPV  )   {
Maxwelltime:Drive_solvers.c:      get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Maxwelltime:Drive_solvers.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Drive_solvers.c:	  delta_U[m][i] = E->U[m][i] - oldU[m][i];
Maxwelltime:Drive_solvers.c:	  oldU[m][i] = E->U[m][i];
Maxwelltime:Drive_solvers.c:      if (E->ve_data_cont.polar_wander) {
Maxwelltime:Drive_solvers.c:        dPW_mag = sqrt( ((E->ve_data_cont.PW_incr[0]-pwold[0])*(E->ve_data_cont.PW_incr[0]-pwold[0]))
Maxwelltime:Drive_solvers.c:                      + ((E->ve_data_cont.PW_incr[1]-pwold[1])*(E->ve_data_cont.PW_incr[1]-pwold[1])) );
Maxwelltime:Drive_solvers.c:        pwold[0] = E->ve_data_cont.PW_incr[0];
Maxwelltime:Drive_solvers.c:        pwold[1] = E->ve_data_cont.PW_incr[1];
Maxwelltime:Drive_solvers.c:      Udot_mag  = sqrt(global_vdot(E,oldU,oldU,E->mesh.levmax));
Maxwelltime:Drive_solvers.c:      dUdot_mag = sqrt(global_vdot(E,delta_U,delta_U,E->mesh.levmax));
Maxwelltime:Drive_solvers.c:      if(E->parallel.me==0) {
Maxwelltime:Drive_solvers.c:	fprintf(E->fp,"!!! iteration=%d relative change %g  %g m0 m1 %g %g potl_d %g timestep %d elapse time %g\n",
Maxwelltime:Drive_solvers.c:		count,dUdot_mag,dPW_mag,pwold[0],pwold[1],E->ve_data_cont.potential_vary_PW,E->monitor.solution_cycles,time);
Maxwelltime:Drive_solvers.c:        fflush(E->fp);
Maxwelltime:Drive_solvers.c://     } while ( (count<50) && ((dUdot_mag > E->viscosity.sdepv_misfit) || (dPW_mag > (E->viscosity.sdepv_misfit*3))) && E->ve_data_cont.SELFG);     // for BM
Maxwelltime:Drive_solvers.c://     } while ( (count<50) && ((dUdot_mag > E->viscosity.sdepv_misfit) || (dPW_mag > 0.03)) && E->ve_data_cont.SELFG);
Maxwelltime:Drive_solvers.c:     } while ( (count<50) && ((dUdot_mag > E->viscosity.sdepv_misfit) || (E->ve_data_cont.potential_vary_PW > 3*E->viscosity.sdepv_misfit)) && E->ve_data_cont.SELFG);
Maxwelltime:Drive_solvers.c://     } while ( (count<50) && (dUdot_mag > E->viscosity.sdepv_misfit) && E->ve_data_cont.SELFG);
Maxwelltime:Drive_solvers.c:else if (E->viscosity.SDEPV ) {
Maxwelltime:Drive_solvers.c:   E->viscosity.iterate=0;
Maxwelltime:Drive_solvers.c:       get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Maxwelltime:Drive_solvers.c:       for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Drive_solvers.c:	  delta_U[m][i] = E->U[m][i] - oldU[m][i];
Maxwelltime:Drive_solvers.c:	  oldU[m][i] = E->U[m][i];
Maxwelltime:Drive_solvers.c:       if (E->ve_data_cont.polar_wander) {
Maxwelltime:Drive_solvers.c:         dPW_mag = sqrt( ((E->ve_data_cont.PW_incr[0]-pwold[0])*(E->ve_data_cont.PW_incr[0]-pwold[0]))
Maxwelltime:Drive_solvers.c:                       + ((E->ve_data_cont.PW_incr[1]-pwold[1])*(E->ve_data_cont.PW_incr[1]-pwold[1])) );
Maxwelltime:Drive_solvers.c:         pwold[0] = E->ve_data_cont.PW_incr[0];
Maxwelltime:Drive_solvers.c:         pwold[1] = E->ve_data_cont.PW_incr[1];
Maxwelltime:Drive_solvers.c:       Udot_mag  = sqrt(global_vdot(E,oldU,oldU,E->mesh.levmax));
Maxwelltime:Drive_solvers.c:       dUdot_mag = sqrt(global_vdot(E,delta_U,delta_U,E->mesh.levmax));
Maxwelltime:Drive_solvers.c:       Udot_mag1  = sqrt(global_vdot_e(E,oldU,oldU,E->mesh.levmax));
Maxwelltime:Drive_solvers.c:       dUdot_mag1 = sqrt(global_vdot_e(E,delta_U,delta_U,E->mesh.levmax));
Maxwelltime:Drive_solvers.c:       if(E->parallel.me==0) {
Maxwelltime:Drive_solvers.c:	 fprintf(E->fp,"!!! iteration=%d relative change %g %g %g m0 m1 %g %g timestep %d elapse time %g\n",
Maxwelltime:Drive_solvers.c:		count,dUdot_mag,dUdot_mag1,dPW_mag,pwold[0],pwold[1],E->monitor.solution_cycles,time);
Maxwelltime:Drive_solvers.c:       fflush(E->fp);
Maxwelltime:Drive_solvers.c:      E->viscosity.iterate++;
Maxwelltime:Drive_solvers.c://      } while ( (count<50) && ((dUdot_mag1 > E->viscosity.sdepv_misfit) || (dPW_mag >0.03)) && E->ve_data_cont.SELFG);
Maxwelltime:Drive_solvers.c:      } while ( (count<50) && ((dUdot_mag1 > E->viscosity.sdepv_misfit) ) && E->ve_data_cont.SELFG);
Maxwelltime:Drive_solvers.c:  if((E->sphere.caps == 12) &&
Maxwelltime:Drive_solvers.c:     (E->control.remove_rigid_rotation || E->control.remove_angular_momentum)) {
Maxwelltime:Drive_solvers.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Drive_solvers.c:  if(E->ve_data_cont.DIRECT){
Maxwelltime:Drive_solvers.c:    if(E->control.restart){	
Maxwelltime:Drive_solvers.c:      if(E->monitor.solution_cycles ==  E->monitor.solution_cycles_init + 1)
Maxwelltime:Drive_solvers.c:      if(E->monitor.solution_cycles == 0)
Maxwelltime:Drive_solvers.c:  const int nno = E->lmesh.nno;
Maxwelltime:Drive_solvers.c:  const int nel = E->lmesh.nel;
Maxwelltime:Drive_solvers.c:  const int neq = E->lmesh.neq;
Maxwelltime:Drive_solvers.c:  const int vpts = vpoints[E->mesh.nsd];
Maxwelltime:Drive_solvers.c:  const int dims = E->mesh.nsd;
Maxwelltime:Drive_solvers.c:  velocities_conform_bcs(E,E->U);
Maxwelltime:Drive_solvers.c:  E->monitor.stop_topo_loop = 0;
Maxwelltime:Drive_solvers.c:  E->monitor.topo_loop = 0;
Maxwelltime:Drive_solvers.c:  if(E->monitor.solution_cycles==0) std_timestep(E);
Maxwelltime:Drive_solvers.c:  while(E->monitor.stop_topo_loop == 0) {
Maxwelltime:Drive_solvers.c:	    get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Maxwelltime:Drive_solvers.c:	  if (E->viscosity.SDEPV || E->viscosity.PDEPV) {
Maxwelltime:Drive_solvers.c:		  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Drive_solvers.c:			  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Drive_solvers.c:					  delta_U[m][i] = E->U[m][i] - oldU[m][i];
Maxwelltime:Drive_solvers.c:					  oldU[m][i] = E->U[m][i];
Maxwelltime:Drive_solvers.c:			  Udot_mag  = sqrt(global_vdot(E,oldU,oldU,E->mesh.levmax));
Maxwelltime:Drive_solvers.c:			  dUdot_mag = vnorm_nonnewt(E,delta_U,oldU,E->mesh.levmax);
Maxwelltime:Drive_solvers.c:			  if(E->parallel.me==0){
Maxwelltime:Drive_solvers.c:				  fprintf(E->fp,"Stress dependent viscosity: DUdot = %.4e (%.4e) for iteration %d\n",dUdot_mag,Udot_mag,count);
Maxwelltime:Drive_solvers.c:				  fflush(E->fp);
Maxwelltime:Drive_solvers.c:			  if (count>50 || dUdot_mag<E->viscosity.sdepv_misfit)
Maxwelltime:Drive_solvers.c:			  get_system_viscosity(E,1,E->EVI[E->mesh.levmax],E->VI[E->mesh.levmax]);
Maxwelltime:Drive_solvers.c:		  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Drive_solvers.c:	  E->monitor.topo_loop++;
Maxwelltime:Drive_solvers.c:  if((E->sphere.caps == 12) &&
Maxwelltime:Drive_solvers.c:     (E->control.remove_rigid_rotation || E->control.remove_angular_momentum)) {
Maxwelltime:Drive_solvers.c:  get_STD_freesurf(E,E->slice.freesurf);
Maxwelltime:Element_calculations.c:  const int dims=E->mesh.nsd;
Maxwelltime:Element_calculations.c:  const int ends=enodes[E->mesh.nsd];
Maxwelltime:Element_calculations.c:    node = E->ien[m][e].node[a];
Maxwelltime:Element_calculations.c:    a1=E->id[m][node].doff[1];
Maxwelltime:Element_calculations.c:    E->F[m][a1] += elt_f[p];
Maxwelltime:Element_calculations.c:    a2=E->id[m][node].doff[2];
Maxwelltime:Element_calculations.c:    E->F[m][a2] += elt_f[p+1];
Maxwelltime:Element_calculations.c:    a3=E->id[m][node].doff[3];
Maxwelltime:Element_calculations.c:    E->F[m][a3] += elt_f[p+2];
Maxwelltime:Element_calculations.c:  const int neq=E->lmesh.neq;
Maxwelltime:Element_calculations.c:  const int nel=E->lmesh.nel;
Maxwelltime:Element_calculations.c:  const int lev=E->mesh.levmax;
Maxwelltime:Element_calculations.c:  const int ends = enodes[E->mesh.nsd];
Maxwelltime:Element_calculations.c:  const int dims = E->mesh.nsd;
Maxwelltime:Element_calculations.c://  get_buoyancy(E,E->buoyancy);
Maxwelltime:Element_calculations.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Element_calculations.c:   if (E->ve_data_cont.SELFG)
Maxwelltime:Element_calculations.c:      //Sets E->potential[1][m][j] and E->potential[0][m][j]
Maxwelltime:Element_calculations.c:   if (E->ve_data_cont.SLE)
Maxwelltime:Element_calculations.c:       // calculate E->slice.oceanload according to sea level equation
Maxwelltime:Element_calculations.c:       //  (based on E->potential[0] and E->slice.surf[3])
Maxwelltime:Element_calculations.c:    //   E->slice.load[1][m][j]  and   E->slice.load[3][m][j]
Maxwelltime:Element_calculations.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Element_calculations.c:                node = E->ien[m][e].node[a];
Maxwelltime:Element_calculations.c:                a1=E->id[m][node].doff[1];
Maxwelltime:Element_calculations.c:                a2=E->id[m][node].doff[2];
Maxwelltime:Element_calculations.c:                a3=E->id[m][node].doff[3];
Maxwelltime:Element_calculations.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Element_calculations.c:      E->F[m][a] = 0.0;
Maxwelltime:Element_calculations.c:                node = E->ien[m][e].node[a];
Maxwelltime:Element_calculations.c:                a1=E->id[m][node].doff[1];
Maxwelltime:Element_calculations.c:                E->F[m][a1] += elt_f[p];
Maxwelltime:Element_calculations.c:                a2=E->id[m][node].doff[2];
Maxwelltime:Element_calculations.c:                E->F[m][a2] += elt_f[p+1];
Maxwelltime:Element_calculations.c:                a3=E->id[m][node].doff[3];
Maxwelltime:Element_calculations.c:                E->F[m][a3] += elt_f[p+2];
Maxwelltime:Element_calculations.c:  E->monitor.fdotf = sqrt(global_vdot(E, E->F, E->F, lev));
Maxwelltime:Element_calculations.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Element_calculations.c:        E->F[m][a] = E->F[m][a] + F0[m][a];
Maxwelltime:Element_calculations.c:  (E->solver.exchange_id_d)(E, E->F, lev);
Maxwelltime:Element_calculations.c:  strip_bcs_from_residual(E,E->F,lev);
Maxwelltime:Element_calculations.c:  /* compute the norm of E->F */
Maxwelltime:Element_calculations.c:  if(E->parallel.me==0) {
Maxwelltime:Element_calculations.c:              E->monitor.fdotf,temp1);
Maxwelltime:Element_calculations.c:      fprintf(E->fp, "Momentum equation force %.9e %.9e\n",
Maxwelltime:Element_calculations.c:              E->monitor.fdotf,temp1);
Maxwelltime:Element_calculations.c:  const int neq=E->lmesh.neq;
Maxwelltime:Element_calculations.c:  const int nel=E->lmesh.nel;
Maxwelltime:Element_calculations.c:  const int lev=E->mesh.levmax;
Maxwelltime:Element_calculations.c:  get_buoyancy(E,E->buoyancy);
Maxwelltime:Element_calculations.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Element_calculations.c:      E->F[m][a] = 0.0;
Maxwelltime:Element_calculations.c:    for(i=1; i<=E->boundary.nel; i++) {
Maxwelltime:Element_calculations.c:      e = E->boundary.element[m][i];
Maxwelltime:Element_calculations.c:  (E->solver.exchange_id_d)(E, E->F, lev);
Maxwelltime:Element_calculations.c:  strip_bcs_from_residual(E,E->F,lev);
Maxwelltime:Element_calculations.c:    const int nn=loc_mat_size[E->mesh.nsd];
Maxwelltime:Element_calculations.c:    const int dims=E->mesh.nsd;
Maxwelltime:Element_calculations.c:    stress_scaling = E->data.density*E->data.grav_acc*E->sphere.dradius/E->ve_data_cont.shear_mod;
Maxwelltime:Element_calculations.c:    if (iconv || (el-1)%E->lmesh.ELZ[lev]==0)
Maxwelltime:Element_calculations.c:      construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,lev,m,0);
Maxwelltime:Element_calculations.c:      W[k]=g_point[k].weight[dims-1]*E->GDA[lev][m][el].vpt[k]*E->EVI[lev][m][(el-1)*vpts+k];
Maxwelltime:Element_calculations.c:   if(E->ve_data_cont.compressible)  {
Maxwelltime:Element_calculations.c:       W1[k]=g_point[k].weight[dims-1]*E->GDA[lev][m][el].vpt[k]*E->elambda[lev][m][el];
Maxwelltime:Element_calculations.c:       W2[k]=g_point[k].weight[dims-1]*E->GDA[lev][m][el].vpt[k]*E->erho[lev][m][el]*E->egrav[lev][m][el]*stress_scaling;
Maxwelltime:Element_calculations.c:    get_ba(&(E->N), &(E->GNX[lev][m][el]), &E->element_Cc, &E->element_Ccx,
Maxwelltime:Element_calculations.c:           rtf, E->mesh.nsd, ba);
Maxwelltime:Element_calculations.c:/*      if(E->control.inv_gruneisen != 0)
Maxwelltime:Element_calculations.c:      if(E->ve_data_cont.compressible)  {
Maxwelltime:Element_calculations.c:                                 E->N.vpt[GNVINDEX(b,k)]*E->element_Cc.vpt[BVINDEX(3,j,b,k)];
Maxwelltime:Element_calculations.c:                                 E->N.vpt[GNVINDEX(a,k)]*E->element_Cc.vpt[BVINDEX(3,i,a,k)];
Maxwelltime:Element_calculations.c:  if(E->control.NMULTIGRID||E->control.NASSEMBLE)
Maxwelltime:Element_calculations.c:  const int n=loc_mat_size[E->mesh.nsd];
Maxwelltime:Element_calculations.c:  const int ends=enodes[E->mesh.nsd];
Maxwelltime:Element_calculations.c:  const int dims=E->mesh.nsd;
Maxwelltime:Element_calculations.c:  const int nel=E->lmesh.NEL[level];
Maxwelltime:Element_calculations.c:  const int neq=E->lmesh.NEQ[level];
Maxwelltime:Element_calculations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Element_calculations.c:	ii = E->IEN[level][m][e].node[a];
Maxwelltime:Element_calculations.c:	a1 = E->ID[level][m][ii].doff[1];
Maxwelltime:Element_calculations.c:	a2 = E->ID[level][m][ii].doff[2];
Maxwelltime:Element_calculations.c:	a3 = E->ID[level][m][ii].doff[3];
Maxwelltime:Element_calculations.c:	        nodeb = E->IEN[level][m][e].node[b];
Maxwelltime:Element_calculations.c:		        E->elt_k[level][m][e].k[ii] *
Maxwelltime:Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[1]]
Maxwelltime:Element_calculations.c:		      + E->elt_k[level][m][e].k[ii+1] *
Maxwelltime:Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[2]]
Maxwelltime:Element_calculations.c:		      + E->elt_k[level][m][e].k[ii+2] *
Maxwelltime:Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[3]];
Maxwelltime:Element_calculations.c:		        E->elt_k[level][m][e].k[ii+n] *
Maxwelltime:Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[1]]
Maxwelltime:Element_calculations.c:		      + E->elt_k[level][m][e].k[ii+n+1] *
Maxwelltime:Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[2]]
Maxwelltime:Element_calculations.c:		      + E->elt_k[level][m][e].k[ii+n+2] *
Maxwelltime:Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[3]];
Maxwelltime:Element_calculations.c:		        E->elt_k[level][m][e].k[ii+n+n] *
Maxwelltime:Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[1]]
Maxwelltime:Element_calculations.c:		      + E->elt_k[level][m][e].k[ii+n+n+1] *
Maxwelltime:Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[2]]
Maxwelltime:Element_calculations.c:		      + E->elt_k[level][m][e].k[ii+n+n+2] *
Maxwelltime:Element_calculations.c:			u[m][E->ID[level][m][nodeb].doff[3]];
Maxwelltime:Element_calculations.c:    (E->solver.exchange_id_d)(E, Au, level);
Maxwelltime:Element_calculations.c:    const int neq=E->lmesh.NEQ[level];
Maxwelltime:Element_calculations.c:    const int nno=E->lmesh.NNO[level];
Maxwelltime:Element_calculations.c:    const int dims=E->mesh.nsd;
Maxwelltime:Element_calculations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Element_calculations.c:       eqn1=E->ID[level][m][e].doff[1];
Maxwelltime:Element_calculations.c:       eqn2=E->ID[level][m][e].doff[2];
Maxwelltime:Element_calculations.c:       eqn3=E->ID[level][m][e].doff[3];
Maxwelltime:Element_calculations.c:       C=E->Node_map[level][m] + (e-1)*max_eqn;
Maxwelltime:Element_calculations.c:       B1=E->Eqn_k1[level][m]+(e-1)*max_eqn;
Maxwelltime:Element_calculations.c:       B2=E->Eqn_k2[level][m]+(e-1)*max_eqn;
Maxwelltime:Element_calculations.c:       B3=E->Eqn_k3[level][m]+(e-1)*max_eqn;
Maxwelltime:Element_calculations.c:     (E->solver.exchange_id_d)(E, Au, level);
Maxwelltime:Element_calculations.c:    const int n=loc_mat_size[E->mesh.nsd];
Maxwelltime:Element_calculations.c:    const int dims=E->mesh.nsd;
Maxwelltime:Element_calculations.c:    const int ends=enodes[E->mesh.nsd];
Maxwelltime:Element_calculations.c:	    node=E->IEN[level][m][el].node[a];
Maxwelltime:Element_calculations.c:	    a1 = E->ID[level][m][node].doff[1];
Maxwelltime:Element_calculations.c:	    E->BI[level][m][a1] += elt_k[p*n+p];
Maxwelltime:Element_calculations.c:	    a2 = E->ID[level][m][node].doff[2];
Maxwelltime:Element_calculations.c:	    E->BI[level][m][a2] += elt_k[p*n+p];
Maxwelltime:Element_calculations.c:	    a1 = E->ID[level][m][node].doff[3];
Maxwelltime:Element_calculations.c:	    E->BI[level][m][a1] += elt_k[p*n+p];
Maxwelltime:Element_calculations.c: for (level=E->mesh.gridmin;level<=E->mesh.gridmax;level++)
Maxwelltime:Element_calculations.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Element_calculations.c:     npno = E->lmesh.NPNO[level];
Maxwelltime:Element_calculations.c:     neq=E->lmesh.NEQ[level];
Maxwelltime:Element_calculations.c:	E->BPI[level][m][e]=1.0;
Maxwelltime:Element_calculations.c:     if(!E->control.precondition)
Maxwelltime:Element_calculations.c:	    E->BPI[level][m][e] = 1.0/BU;
Maxwelltime:Element_calculations.c:	    E->BPI[level][m][e] = 1.0;
Maxwelltime:Element_calculations.c:    const int nel = E->lmesh.NEL[level];
Maxwelltime:Element_calculations.c:    const int ends = enodes[E->mesh.nsd];
Maxwelltime:Element_calculations.c:    const int dims = E->mesh.nsd;
Maxwelltime:Element_calculations.c:    const int npno = E->lmesh.NPNO[level];
Maxwelltime:Element_calculations.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Element_calculations.c:                b = E->IEN[level][m][e].node[a];
Maxwelltime:Element_calculations.c:                j1= E->ID[level][m][b].doff[1];
Maxwelltime:Element_calculations.c:                j2= E->ID[level][m][b].doff[2];
Maxwelltime:Element_calculations.c:                j3= E->ID[level][m][b].doff[3];
Maxwelltime:Element_calculations.c:                result[m][e] += E->elt_c[level][m][e].c[p  ][0] * U[m][j1]
Maxwelltime:Element_calculations.c:                              + E->elt_c[level][m][e].c[p+1][0] * U[m][j2]
Maxwelltime:Element_calculations.c:                              + E->elt_c[level][m][e].c[p+2][0] * U[m][j3];
Maxwelltime:Element_calculations.c:    const int nel=E->lmesh.NEL[level];
Maxwelltime:Element_calculations.c:    const int ends=enodes[E->mesh.nsd];
Maxwelltime:Element_calculations.c:    const int dims=E->mesh.nsd;
Maxwelltime:Element_calculations.c:    const int npno=E->lmesh.NPNO[level];
Maxwelltime:Element_calculations.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Element_calculations.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Element_calculations.c:	    b = E->IEN[level][m][e].node[a];
Maxwelltime:Element_calculations.c:	    j1= E->ID[level][m][b].doff[1];
Maxwelltime:Element_calculations.c:            j2= E->ID[level][m][b].doff[2];
Maxwelltime:Element_calculations.c:	    j3= E->ID[level][m][b].doff[3];
Maxwelltime:Element_calculations.c:	    divU[m][e] += E->elt_del[level][m][e].g[p  ][0] * U[m][j1]
Maxwelltime:Element_calculations.c:	                + E->elt_del[level][m][e].g[p+1][0] * U[m][j2]
Maxwelltime:Element_calculations.c:	                + E->elt_del[level][m][e].g[p+2][0] * U[m][j3];
Maxwelltime:Element_calculations.c:  const int ends=enodes[E->mesh.nsd];
Maxwelltime:Element_calculations.c:  const int dims=E->mesh.nsd;
Maxwelltime:Element_calculations.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Element_calculations.c:    nel=E->lmesh.NEL[lev];
Maxwelltime:Element_calculations.c:    neq=E->lmesh.NEQ[lev];
Maxwelltime:Element_calculations.c:	     b = E->IEN[lev][m][e].node[a];
Maxwelltime:Element_calculations.c:	     j1= E->ID[lev][m][b].doff[1];
Maxwelltime:Element_calculations.c:	     j2= E->ID[lev][m][b].doff[2];
Maxwelltime:Element_calculations.c:	     j3= E->ID[lev][m][b].doff[3];
Maxwelltime:Element_calculations.c:		        /*for(b=0;b<ploc_mat_size[E->mesh.nsd];b++)  */
Maxwelltime:Element_calculations.c:             gradP[m][j1] += E->elt_del[lev][m][e].g[p  ][0] * P[m][e];
Maxwelltime:Element_calculations.c:             gradP[m][j2] += E->elt_del[lev][m][e].g[p+1][0] * P[m][e];
Maxwelltime:Element_calculations.c:             gradP[m][j3] += E->elt_del[lev][m][e].g[p+2][0] * P[m][e];
Maxwelltime:Element_calculations.c:  (E->solver.exchange_id_d)(E, gradP,  lev); /*  correct gradP   */
Maxwelltime:Element_calculations.c:    const int ends=enodes[E->mesh.nsd];
Maxwelltime:Element_calculations.c:    const int dims=E->mesh.nsd;
Maxwelltime:Element_calculations.c:    npno=E->lmesh.NPNO[level];
Maxwelltime:Element_calculations.c:      node = E->IEN[level][m][e].node[a];
Maxwelltime:Element_calculations.c:      j=E->ID[level][m][node].doff[1];
Maxwelltime:Element_calculations.c:      gradP[p] += E->BI[level][m][j]*E->elt_del[level][m][e].g[p][0];
Maxwelltime:Element_calculations.c:      j=E->ID[level][m][node].doff[2];
Maxwelltime:Element_calculations.c:      gradP[p+1] += E->BI[level][m][j]*E->elt_del[level][m][e].g[p+1][0];
Maxwelltime:Element_calculations.c:      j=E->ID[level][m][node].doff[3];
Maxwelltime:Element_calculations.c:      gradP[p+2] += E->BI[level][m][j]*E->elt_del[level][m][e].g[p+2][0];
Maxwelltime:Element_calculations.c:      divU +=E->elt_del[level][m][e].g[p][0] * gradP[p];
Maxwelltime:Element_calculations.c:      divU +=E->elt_del[level][m][e].g[p+1][0] * gradP[p+1];
Maxwelltime:Element_calculations.c:      divU +=E->elt_del[level][m][e].g[p+2][0] * gradP[p+2];
Maxwelltime:Element_calculations.c:    const int dims = E->mesh.nsd;
Maxwelltime:Element_calculations.c:    if ((el-1)%E->lmesh.ELZ[lev]==0)
Maxwelltime:Element_calculations.c:        construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,lev,m,1);
Maxwelltime:Element_calculations.c:    temp = p_point[1].weight[dims-1] * E->GDA[lev][m][el].ppt[1];
Maxwelltime:Element_calculations.c:    switch (E->refstate.choice) {
Maxwelltime:Element_calculations.c:        beta = - E->control.disptn_number * E->control.inv_gruneisen;
Maxwelltime:Element_calculations.c:                x[i] = E->N.ppt[GNPINDEX(a,1)]
Maxwelltime:Element_calculations.c:                    * E->element_Cc.ppt[BPINDEX(3,i,a,1)];
Maxwelltime:Element_calculations.c:            j = E->IEN[lev][m][el].node[a];
Maxwelltime:Element_calculations.c:            nz = (j - 1) % E->lmesh.noz + 1;
Maxwelltime:Element_calculations.c:            rho[a] = E->refstate.rho[nz];
Maxwelltime:Element_calculations.c:                x[i] = rho[a] * E->GNX[lev][m][el].ppt[GNPXINDEX(2,a,1)]
Maxwelltime:Element_calculations.c:                    * E->N.ppt[GNPINDEX(a,1)]
Maxwelltime:Element_calculations.c:                    * E->element_Cc.ppt[BPINDEX(3,i,a,1)];
Maxwelltime:Element_calculations.c:   const int dims=E->mesh.nsd;
Maxwelltime:Element_calculations.c:   if ((el-1)%E->lmesh.ELZ[lev]==0)
Maxwelltime:Element_calculations.c:      construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,lev,m,1);
Maxwelltime:Element_calculations.c:   temp=p_point[1].weight[dims-1] * E->GDA[lev][m][el].ppt[1];
Maxwelltime:Element_calculations.c:       x[i]=E->GNX[lev][m][el].ppt[GNPXINDEX(2,a,1)]*E->element_Cc.ppt[BPINDEX(3,i,a,1)]
Maxwelltime:Element_calculations.c:        + 2.0*ra*E->N.ppt[GNPINDEX(a,1)]*E->element_Cc.ppt[BPINDEX(3,i,a,1)]
Maxwelltime:Element_calculations.c:        + ra*(E->GNX[lev][m][el].ppt[GNPXINDEX(0,a,1)]*E->element_Cc.ppt[BPINDEX(1,i,a,1)]
Maxwelltime:Element_calculations.c:        +E->N.ppt[GNPINDEX(a,1)]*E->element_Ccx.ppt[BPXINDEX(1,i,1,a,1)]
Maxwelltime:Element_calculations.c:        +ct*E->N.ppt[GNPINDEX(a,1)]*E->element_Cc.ppt[BPINDEX(1,i,a,1)]
Maxwelltime:Element_calculations.c:        +si*(E->GNX[lev][m][el].ppt[GNPXINDEX(1,a,1)]*E->element_Cc.ppt[BPINDEX(2,i,a,1)]
Maxwelltime:Element_calculations.c:        +E->N.ppt[GNPINDEX(a,1)]*E->element_Ccx.ppt[BPXINDEX(2,i,2,a,1)]));
Maxwelltime:Element_calculations.c:      /* fprintf (E->fp,"B= %d %d %g %g %g %g %g\n",el,a,E->GDA[lev][m][el].ppt[1],E->GNX[lev][m][el].ppt[GNPXINDEX(0,a,1)],E->GNX[lev][m][el].ppt[GNPXINDEX(1,a,1)],elt_del[p][0],elt_del[p+1][0]);
Maxwelltime:Element_calculations.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Element_calculations.c:    const int lev=E->mesh.levmax;
Maxwelltime:Element_calculations.c:    gnxx = E->gNX[m][el].vpt;
Maxwelltime:Element_calculations.c:    gnda = E->gDA[m][el].vpt;
Maxwelltime:Element_calculations.c:    es = (el-1)/E->lmesh.elz + 1;
Maxwelltime:Element_calculations.c:            ss[1][j] = E->Sxx[m][(el-1)*vpts+j]*E->Maxwelltime[m][el];
Maxwelltime:Element_calculations.c:            ss[2][j] = E->Syy[m][(el-1)*vpts+j]*E->Maxwelltime[m][el];
Maxwelltime:Element_calculations.c:            ss[3][j] = E->Szz[m][(el-1)*vpts+j]*E->Maxwelltime[m][el];
Maxwelltime:Element_calculations.c:            ss[4][j] = E->Sxy[m][(el-1)*vpts+j]*E->Maxwelltime[m][el];
Maxwelltime:Element_calculations.c:            ss[5][j] = E->Sxz[m][(el-1)*vpts+j]*E->Maxwelltime[m][el];
Maxwelltime:Element_calculations.c:            ss[6][j] = E->Szy[m][(el-1)*vpts+j]*E->Maxwelltime[m][el];
Maxwelltime:Element_calculations.c:                               + ss[2][j]*ct[j]*E->N.vpt[GNVINDEX(a,j)]
Maxwelltime:Element_calculations.c:                                            - E->N.vpt[GNVINDEX(a,j)]) )
Maxwelltime:Element_calculations.c:                                          *E->N.vpt[GNVINDEX(a,j)])+
Maxwelltime:Element_calculations.c:                                          /rtf[3][j]-E->N.vpt[GNVINDEX(a,j)])) 
Maxwelltime:Element_calculations.c:               elt_f[p+2] -= ((ss[1][j]+ss[2][j])*E->N.vpt[GNVINDEX(a,j)]+
Maxwelltime:Element_calculations.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Element_calculations.c:    const int lev=E->mesh.levmax;
Maxwelltime:Element_calculations.c:   stress_scaling = E->data.density*E->data.grav_acc*E->sphere.dradius/E->ve_data_cont.shear_mod;
Maxwelltime:Element_calculations.c:   if (E->control.SELFG)
Maxwelltime:Element_calculations.c:      con = E->ve_data_cont.Rsg;
Maxwelltime:Element_calculations.c:    gnxx = E->gNX[m][el].vpt;
Maxwelltime:Element_calculations.c:    gnda = E->gDA[m][el].vpt;
Maxwelltime:Element_calculations.c:    es = (el-1)/E->lmesh.elz + 1;
Maxwelltime:Element_calculations.c:   if (E->ve_data_cont.compressible)   {
Maxwelltime:Element_calculations.c:      if ((el-1)%E->lmesh.elz==0)
Maxwelltime:Element_calculations.c:         construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,E->mesh.levmax,m,0);
Maxwelltime:Element_calculations.c:        VV[1][i] = E->sphere.cap[m].total_VS[1][E->ien[m][el].node[i]];
Maxwelltime:Element_calculations.c:        VV[2][i] = E->sphere.cap[m].total_VS[2][E->ien[m][el].node[i]];
Maxwelltime:Element_calculations.c:        VV[3][i] = E->sphere.cap[m].total_VS[3][E->ien[m][el].node[i]];
Maxwelltime:Element_calculations.c:      maxwelltime = E->Maxwelltime[m][el]; 
Maxwelltime:Element_calculations.c:      esmu = E->esmu[E->mesh.levmax][el];
Maxwelltime:Element_calculations.c:      erho = E->erho[E->mesh.levmax][el];
Maxwelltime:Element_calculations.c:      egrav= E->egrav[E->mesh.levmax][el];
Maxwelltime:Element_calculations.c:        skk[j] = E->Sxx[m][(el-1)*vpts+j] + E->Syy[m][(el-1)*vpts+j] + E->Szz[m][(el-1)*vpts+j];
Maxwelltime:Element_calculations.c:            Ur[j] += VV[k][i]*E->N.vpt[GNVINDEX(i,j)]*E->E->element_Cc.vpt[BVINDEX(3,k,i,j)];
Maxwelltime:Element_calculations.c:                 (gnxx[GNVXINDEX(0,i,j)]*E->element_Cc.vpt[BVINDEX(1,k,i,j)]
Maxwelltime:Element_calculations.c:                 +E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(1,k,1,i,j)]
Maxwelltime:Element_calculations.c:                 +E->N.vpt[GNVINDEX(i,j)]*E->element_Cc.vpt[BVINDEX(3,k,i,j)])
Maxwelltime:Element_calculations.c:                (E->N.vpt[GNVINDEX(i,j)]*E->element_Cc.vpt[BVINDEX(1,k,i,j)]*ct[j]
Maxwelltime:Element_calculations.c:                +E->N.vpt[GNVINDEX(i,j)]*E->element_Cc.vpt[BVINDEX(3,k,i,j)]
Maxwelltime:Element_calculations.c:                +(gnxx[GNVXINDEX(1,i,j)]*E->element_Cc.vpt[BVINDEX(2,k,i,j)]
Maxwelltime:Element_calculations.c:                +E->N.vpt[GNVINDEX(i,j)]*E->element_Ccx.vpt[BVXINDEX(2,k,2,i,j)])/sinaa[j])
Maxwelltime:Element_calculations.c:                          +gnxx[GNVXINDEX(2,i,j)]*E->element_Cc.vpt[BVINDEX(3,k,i,j)];
Maxwelltime:Element_calculations.c:       ss[1][j] = E->Sxx[m][(el-1)*vpts+j]*maxwelltime;
Maxwelltime:Element_calculations.c:       ss[2][j] = E->Syy[m][(el-1)*vpts+j]*maxwelltime;
Maxwelltime:Element_calculations.c:       ss[3][j] = E->Szz[m][(el-1)*vpts+j]*maxwelltime;
Maxwelltime:Element_calculations.c:       ss[4][j] = E->Sxy[m][(el-1)*vpts+j]*maxwelltime;
Maxwelltime:Element_calculations.c:       ss[5][j] = E->Sxz[m][(el-1)*vpts+j]*maxwelltime;
Maxwelltime:Element_calculations.c:       ss[6][j] = E->Szy[m][(el-1)*vpts+j]*maxwelltime;
Maxwelltime:Element_calculations.c:       if (E->ve_data_cont.compressible)   {
Maxwelltime:Element_calculations.c:                          + ss[2][j]*ct[j]*E->N.vpt[GNVINDEX(a,j)]
Maxwelltime:Element_calculations.c:                                            - E->N.vpt[GNVINDEX(a,j)]) )
Maxwelltime:Element_calculations.c:                                     *E->N.vpt[GNVINDEX(a,j)])+
Maxwelltime:Element_calculations.c:                                     /rtf[3][j]-E->N.vpt[GNVINDEX(a,j)])) 
Maxwelltime:Element_calculations.c:           elt_f[p+2] -= ((ss[1][j]+ss[2][j])*E->N.vpt[GNVINDEX(a,j)]+
Maxwelltime:Element_calculations.c:        if (E->ve_data_cont.compressible)   {
Maxwelltime:Element_calculations.c:             (E->Ekk[m][(el-1)*vpts+j]*E->N.vpt[GNVINDEX(a,j)]*E->element_Cc.vpt[BVINDEX(3,1,a,j)]
Maxwelltime:Element_calculations.c:             (E->Ekk[m][(el-1)*vpts+j]*E->N.vpt[GNVINDEX(a,j)]*E->element_Cc.vpt[BVINDEX(3,2,a,j)]
Maxwelltime:Element_calculations.c:             (E->Ekk[m][(el-1)*vpts+j]*E->N.vpt[GNVINDEX(a,j)]*E->element_Cc.vpt[BVINDEX(3,3,a,j)]
Maxwelltime:Element_calculations.c:  const int dims=E->mesh.nsd;
Maxwelltime:Element_calculations.c:  es = (el-1)/E->lmesh.elz + 1;
Maxwelltime:Element_calculations.c:  if ((el-1)%E->lmesh.elz==0)
Maxwelltime:Element_calculations.c:      construct_c3x3matrix_el(E,el,&E->element_Cc,&E->element_Ccx,E->mesh.levmax,m,0);
Maxwelltime:Element_calculations.c:    force[p] = E->buoyancy[m][E->ien[m][el].node[p]];
Maxwelltime:Element_calculations.c:      force_at_gs[j] += force[k] * E->N.vpt[GNVINDEX(k,j)] ;
Maxwelltime:Element_calculations.c:      nodea=E->ien[m][el].node[a];
Maxwelltime:Element_calculations.c:        elt_f[p] += force_at_gs[j] * E->N.vpt[GNVINDEX(a,j)]
Maxwelltime:Element_calculations.c:           *E->gDA[m][el].vpt[j]*g_point[j].weight[dims-1]
Maxwelltime:Element_calculations.c:           *E->element_Cc.vpt[BVINDEX(3,i,a,j)];
Maxwelltime:Element_calculations.c:            nodeb=E->ien[m][el].node[b];
Maxwelltime:Element_calculations.c:            if ((E->node[m][nodeb]&type)&&(E->sphere.cap[m].VB[j][nodeb]!=0.0)){
Maxwelltime:Element_calculations.c:                get_elt_k(E,el,elt_k,E->mesh.levmax,m,1);
Maxwelltime:Element_calculations.c:                elt_f[p] -= elt_k[p*n+q] * E->sphere.cap[m].VB[j][nodeb];
Maxwelltime:Element_calculations.c:	const int dims=E->mesh.nsd;
Maxwelltime:Element_calculations.c:	int el = E->boundary.element[m][bel];
Maxwelltime:Element_calculations.c:	const float rho = E->data.density;
Maxwelltime:Element_calculations.c:	const float g = E->data.grav_acc;
Maxwelltime:Element_calculations.c:	const float eta = E->data.ref_viscosity;
Maxwelltime:Element_calculations.c:	const float kappa = E->data.therm_diff;
Maxwelltime:Element_calculations.c:	if(E->control.side_sbcs)
Maxwelltime:Element_calculations.c:			nodea = E->ien[m][el].node[ sidenodes[side][a] ];
Maxwelltime:Element_calculations.c:				value = E->sbc.SB[m][side][d][ E->sbc.node[m][nodea] ];
Maxwelltime:Element_calculations.c:				flagged = (E->node[m][nodea] & sbc_flag[d]) && (value);
Maxwelltime:Element_calculations.c:				nodea = E->ien[m][el].node[ sidenodes[side][a] ];
Maxwelltime:Element_calculations.c:					value = E->sphere.cap[m].VB[d][nodea];
Maxwelltime:Element_calculations.c:					flagged = (E->node[m][nodea] & sbc_flag[d]) && (value);
Maxwelltime:Element_calculations.c:				     E->mesh.levmax,m,0,side);
Maxwelltime:Element_calculations.c:				traction_at_gs[d][k] += traction[d][j] * E->M.vpt[GMVINDEX(j,k)] ;
Maxwelltime:Element_calculations.c:				elt_tr[p] += tmp * E->M.vpt[GMVINDEX(j,k)]
Maxwelltime:Element_calculations.c:					* E->boundary.det[m][side][k][bel] * g_1d[k].weight[dims-1];
Maxwelltime:Element_calculations.c:	const int dims=E->mesh.nsd;
Maxwelltime:Element_calculations.c:	int el = E->boundary.element[m][bel];
Maxwelltime:Element_calculations.c:	const float rho = E->data.density;
Maxwelltime:Element_calculations.c:	const float g = E->data.grav_acc;
Maxwelltime:Element_calculations.c:	const float eta = E->data.ref_viscosity;
Maxwelltime:Element_calculations.c:	const float kappa = E->data.therm_diff;
Maxwelltime:Element_calculations.c:	if(E->control.side_sbcs)
Maxwelltime:Element_calculations.c:			nodea = E->ien[m][el].node[ sidenodes[side][a] ];
Maxwelltime:Element_calculations.c:				value = E->sbc.SB[m][side][d][ E->sbc.node[m][nodea] ];
Maxwelltime:Element_calculations.c:				flagged = (E->node[m][nodea] & sbc_flag[d]) && (value);
Maxwelltime:Element_calculations.c:		if( side == SIDE_TOP && E->parallel.me_loc[3]==E->parallel.nprocz-1 && (el%E->lmesh.elz==0)) {
Maxwelltime:Element_calculations.c:				nodea = E->ien[m][el].node[ sidenodes[side][a] ];
Maxwelltime:Element_calculations.c:				nodeas = E->ien[m][el].node[ sidenodes[side][a] ]/E->lmesh.noz;
Maxwelltime:Element_calculations.c:					*(E->slice.freesurf[m][nodeas]+E->sphere.cap[m].V[3][nodea]*E->advection.timestep);
Maxwelltime:Element_calculations.c:				if(E->parallel.me==11 && nodea==3328)
Maxwelltime:Element_calculations.c:					fprintf(stderr,"traction=%e vnew=%e timestep=%e coeff=%e\n",traction[3][a],E->sphere.cap[m].V[3][nodea],E->advection.timestep,-1.0*factor*rho*g*(R*R*R)/(eta*kappa));
Maxwelltime:Element_calculations.c:				if(found && E->parallel.me==1)
Maxwelltime:Element_calculations.c:						E->parallel.me,bel,el,side,SIDE_TOP,a,sidenodes[side][a],
Maxwelltime:Element_calculations.c:						E->ien[m][el].node[ sidenodes[side][a] ],E->lmesh.noz,
Maxwelltime:Element_calculations.c:				nodea = E->ien[m][el].node[ sidenodes[side][a] ];
Maxwelltime:Element_calculations.c:					value = E->sphere.cap[m].VB[d][nodea];
Maxwelltime:Element_calculations.c:					flagged = (E->node[m][nodea] & sbc_flag[d]) && (value);
Maxwelltime:Element_calculations.c:				     E->mesh.levmax,m,0,side);
Maxwelltime:Element_calculations.c:				traction_at_gs[d][k] += traction[d][j] * E->M.vpt[GMVINDEX(j,k)] ;
Maxwelltime:Element_calculations.c:				elt_tr[p] += tmp * E->M.vpt[GMVINDEX(j,k)]
Maxwelltime:Element_calculations.c:					* E->boundary.det[m][side][k][bel] * g_1d[k].weight[dims-1];
Maxwelltime:Element_calculations.c:     const int n=loc_mat_size[E->mesh.nsd];
Maxwelltime:Element_calculations.c:     const int ends=enodes[E->mesh.nsd];
Maxwelltime:Element_calculations.c:     const int vpts=vpoints[E->mesh.nsd];
Maxwelltime:Element_calculations.c:     const int dims=E->mesh.nsd;
Maxwelltime:Element_calculations.c:	  Visc += E->EVI[level][m][(el-1)*vpts+a];
Maxwelltime:Element_calculations.c:        nodea=E->IEN[level][m][el].node[a];
Maxwelltime:Element_calculations.c:           nodeb=E->IEN[level][m][el].node[b];      /* for Kab dims*dims  */
Maxwelltime:Element_calculations.c:	   elt_k[i  ] += Visc*E->control.augmented*
Maxwelltime:Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]][0]*
Maxwelltime:Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]][0];   /*for 11 */
Maxwelltime:Element_calculations.c:	   elt_k[i+1] += Visc*E->control.augmented*
Maxwelltime:Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]][0]*
Maxwelltime:Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]+1][0];  /* for 12 */
Maxwelltime:Element_calculations.c:	   elt_k[i+n] += Visc*E->control.augmented*
Maxwelltime:Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]+1][0]*
Maxwelltime:Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]][0];    /* for 21 */
Maxwelltime:Element_calculations.c:	   elt_k[i+n+1] += Visc*E->control.augmented*
Maxwelltime:Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]+1][0]*
Maxwelltime:Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]+1][0];  /* for 22 */
Maxwelltime:Element_calculations.c:	       elt_k[i+2] += Visc*E->control.augmented*
Maxwelltime:Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]][0]*
Maxwelltime:Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]+2][0];  /* for 13 */
Maxwelltime:Element_calculations.c:	       elt_k[i+n+2] += Visc*E->control.augmented*
Maxwelltime:Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]+1][0]*
Maxwelltime:Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]+2][0];  /* for 23 */
Maxwelltime:Element_calculations.c:	       elt_k[i+n+n] += Visc*E->control.augmented*
Maxwelltime:Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]+2][0]*
Maxwelltime:Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]][0];    /* for 31 */
Maxwelltime:Element_calculations.c:	       elt_k[i+n+n+1] += Visc*E->control.augmented*
Maxwelltime:Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]+2][0]*
Maxwelltime:Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]+1][0];  /* for 32 */
Maxwelltime:Element_calculations.c:	       elt_k[i+n+n+2] += Visc*E->control.augmented*
Maxwelltime:Element_calculations.c:	              E->elt_del[level][m][el].g[p[a]+2][0]*
Maxwelltime:Element_calculations.c:		      E->elt_del[level][m][el].g[p[b]+2][0];  /* for 33 */
Maxwelltime:Free_surfaces.c:    if (E->parallel.me_loc[3] == 0)                      { 
Maxwelltime:Free_surfaces.c:        for (lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Free_surfaces.c:        for (i=1;i<=E->lmesh.NEL[lev];i++)    
Maxwelltime:Free_surfaces.c:        if ((i-1)%E->lmesh.ELZ[lev]==0)   {
Maxwelltime:Free_surfaces.c:            E->ELEMENT[lev][m][i] = E->ELEMENT[lev][m][i] | BOUNDARIES;
Maxwelltime:Free_surfaces.c:            E->ELEMENT[lev][m][i] = E->ELEMENT[lev][m][i] | BOUNDARY2;    /*CMB*/
Maxwelltime:Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[1]] = E->NODE[lev][m][E->IEN[lev][m][i].node[1]] | RESTORE;    /*CMB*/
Maxwelltime:Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[2]] = E->NODE[lev][m][E->IEN[lev][m][i].node[2]] | RESTORE;    /*CMB*/
Maxwelltime:Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[3]] = E->NODE[lev][m][E->IEN[lev][m][i].node[3]] | RESTORE;    /*CMB*/
Maxwelltime:Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[4]] = E->NODE[lev][m][E->IEN[lev][m][i].node[4]] | RESTORE;    /*CMB*/
Maxwelltime:Free_surfaces.c:    if (E->parallel.me_loc[3] == E->parallel.nprocz-1)   {
Maxwelltime:Free_surfaces.c:        for (lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Free_surfaces.c:        for (i=1;i<=E->lmesh.NEL[lev];i++)    
Maxwelltime:Free_surfaces.c:        if (i%E->lmesh.ELZ[lev]==0)   {
Maxwelltime:Free_surfaces.c:            E->ELEMENT[lev][m][i] = E->ELEMENT[lev][m][i] | BOUNDARIES;
Maxwelltime:Free_surfaces.c:            E->ELEMENT[lev][m][i] = E->ELEMENT[lev][m][i] | BOUNDARY1;    /*Surface*/
Maxwelltime:Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[5]] = E->NODE[lev][m][E->IEN[lev][m][i].node[5]] | RESTORE;
Maxwelltime:Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[6]] = E->NODE[lev][m][E->IEN[lev][m][i].node[6]] | RESTORE;
Maxwelltime:Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[7]] = E->NODE[lev][m][E->IEN[lev][m][i].node[7]] | RESTORE;
Maxwelltime:Free_surfaces.c:            E->NODE[lev][m][E->IEN[lev][m][i].node[8]] = E->NODE[lev][m][E->IEN[lev][m][i].node[8]] | RESTORE;
Maxwelltime:Free_surfaces.c:    density_cmb = (E->data.density_below-E->data.density)/E->data.density;
Maxwelltime:Free_surfaces.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Maxwelltime:Free_surfaces.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:            for (j=1;j<=E->lmesh.nsf;j++)    {
Maxwelltime:Free_surfaces.c:                i = j*E->lmesh.noz;
Maxwelltime:Free_surfaces.c:                E->slice_ve.surf[2][m][j] = E->U[m][E->id[m][i].doff[3]]
Maxwelltime:Free_surfaces.c:                                               * E->ve_data_cont.surf_scaling
Maxwelltime:Free_surfaces.c:                                        + E->slice_ve.dynamic_oceanload[m][j];
Maxwelltime:Free_surfaces.c:            remove_average(E,E->slice_ve.surf[2],1);
Maxwelltime:Free_surfaces.c:        if (E->parallel.me_loc[3]==0)   {
Maxwelltime:Free_surfaces.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:            for (j=1;j<=E->lmesh.nsf;j++)    {
Maxwelltime:Free_surfaces.c:                i = (j-1)*E->lmesh.noz + 1;
Maxwelltime:Free_surfaces.c:                E->slice_ve.botm[2][m][j] = E->U[m][E->id[m][i].doff[3]];
Maxwelltime:Free_surfaces.c:                E->slice_ve.botm[2][m][j] *= E->ve_data_cont.botm_scaling;
Maxwelltime:Free_surfaces.c:            remove_average(E,E->slice_ve.botm[2],0);
Maxwelltime:Free_surfaces.c:        load_to_CM_grav( E, E->slice_ve.surf[2], E->slice_ve.botm[2], 0 );
Maxwelltime:Free_surfaces.c:    const int lev = E->mesh.levmax;
Maxwelltime:Free_surfaces.c:    const int onedp = onedvpoints[E->mesh.nsd];
Maxwelltime:Free_surfaces.c:    const int vpts=vpoints[E->mesh.nsd];
Maxwelltime:Free_surfaces.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Free_surfaces.c:  if (!E->ve_data_cont.compressible)  {
Maxwelltime:Free_surfaces.c:    if (E->parallel.me_loc[3]==0 || E->parallel.me_loc[3]==E->parallel.nprocz-1)  {
Maxwelltime:Free_surfaces.c:        if (el%E->lmesh.elz==0 && E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Maxwelltime:Free_surfaces.c:            e = el/E->lmesh.elz;
Maxwelltime:Free_surfaces.c:            for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Maxwelltime:Free_surfaces.c:                lnode[k] = E->sien[m][e].node[k];
Maxwelltime:Free_surfaces.c:                force[k] = E->slice_ve.load[1][m][ lnode[k] ];
Maxwelltime:Free_surfaces.c:        else if ((el-1)%E->lmesh.elz==0 && E->parallel.me_loc[3]==0)  {
Maxwelltime:Free_surfaces.c:            e = (el-1)/E->lmesh.elz+1;
Maxwelltime:Free_surfaces.c:            for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Maxwelltime:Free_surfaces.c:                lnode[k] = E->sien[m][e].node[k];
Maxwelltime:Free_surfaces.c:                force[k] = E->slice_ve.load[3][m][ lnode[k] ];
Maxwelltime:Free_surfaces.c:        for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   
Maxwelltime:Free_surfaces.c:        for (i=1;i<=onedvpoints[E->mesh.nsd];i++)   {
Maxwelltime:Free_surfaces.c:            for(k=1;k<=onedvpoints[E->mesh.nsd];k++)
Maxwelltime:Free_surfaces.c:                force_at_gs[i] += force[k] * E->M.vpt[GMVINDEX(k,i)];
Maxwelltime:Free_surfaces.c:                elt_f[3*nn[k]-1] += E->B_R[lev][m][nn[k]][(e-1)*onedp+i] * force_at_gs[i];
Maxwelltime:Free_surfaces.c:  else if (E->ve_data_cont.compressible) {
Maxwelltime:Free_surfaces.c:    if (E->ve_data_cont.SELFG)
Maxwelltime:Free_surfaces.c:       con = E->ve_data_cont.Rsg;
Maxwelltime:Free_surfaces.c:    e = (el-1)/E->lmesh.elz+1;
Maxwelltime:Free_surfaces.c:    for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Maxwelltime:Free_surfaces.c:      lnode[k] = E->ien[m][el].node[k+onedp];
Maxwelltime:Free_surfaces.c:      force[k] = E->all_load[m][lnode[k]];
Maxwelltime:Free_surfaces.c:    radius2 = E->sx[m][3][lnode[1]]*E->sx[m][3][lnode[1]];
Maxwelltime:Free_surfaces.c:    for (i=1;i<=onedvpoints[E->mesh.nsd];i++)   {
Maxwelltime:Free_surfaces.c:      for(k=1;k<=onedvpoints[E->mesh.nsd];k++)
Maxwelltime:Free_surfaces.c:        force_at_gs[i] += force[k] * E->M.vpt[GMVINDEX(k,i)];
Maxwelltime:Free_surfaces.c:        elt_f[3*(k+onedp)-1] += radius2*E->B_R[lev][m][k+onedp][(e-1)*onedp+i] * force_at_gs[i];
Maxwelltime:Free_surfaces.c:    if ((el-1)%E->lmesh.elz==0 && E->parallel.me_loc[3]==0)  {
Maxwelltime:Free_surfaces.c:      for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Maxwelltime:Free_surfaces.c:        lnode[k] = E->ien[m][el].node[k];
Maxwelltime:Free_surfaces.c:        force[k] = E->all_load[m][lnode[k]];
Maxwelltime:Free_surfaces.c:      for (i=1;i<=onedvpoints[E->mesh.nsd];i++)   {
Maxwelltime:Free_surfaces.c:        for(k=1;k<=onedvpoints[E->mesh.nsd];k++)
Maxwelltime:Free_surfaces.c:          force_at_gs[i] += force[k] * E->M.vpt[GMVINDEX(k,i)];
Maxwelltime:Free_surfaces.c:          elt_f[3*k-1] += E->B_R[lev][m][k][(e-1)*onedp+i] * force_at_gs[i];
Maxwelltime:Free_surfaces.c:      node[a] = E->ien[m][el].node[a];
Maxwelltime:Free_surfaces.c:      force[a] = con*E->total_potential[m][node[a]];
Maxwelltime:Free_surfaces.c:        force_at_gs[i] += E->erho[lev][m][el]*force[k]*E->N.vpt[GNVINDEX(k,i)];
Maxwelltime:Free_surfaces.c:    gnxx = E->gNX[m][el].vpt;
Maxwelltime:Free_surfaces.c:    gnda = E->gDA[m][el].vpt;
Maxwelltime:Free_surfaces.c:    get_rtf_at_vpts(E,m,E->mesh.levmax,el,rtf);
Maxwelltime:Free_surfaces.c:    if ((el-1)%E->lmesh.elz==0)
Maxwelltime:Free_surfaces.c:      construct_c3x3matrix_el(E,el,&Cc,&Ccx,E->mesh.levmax,m,0);
Maxwelltime:Free_surfaces.c:                 +E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(1,k,1,i,j)]
Maxwelltime:Free_surfaces.c:                 +E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(3,k,i,j)])
Maxwelltime:Free_surfaces.c:                (E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(1,k,i,j)]*ct[j]
Maxwelltime:Free_surfaces.c:                +E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(3,k,i,j)]
Maxwelltime:Free_surfaces.c:                 +E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(2,k,2,i,j)])/sinaa[j])
Maxwelltime:Free_surfaces.c:    int m1 = E->parallel.me;
Maxwelltime:Free_surfaces.c:    E->ve_data_cont.potential_scaling = 4.0*M_PI*E->data.grav_const*E->data.density
Maxwelltime:Free_surfaces.c:        *E->sphere.dradius*E->sphere.dradius;
Maxwelltime:Free_surfaces.c:    E->ve_data_cont.rotation_rate = E->ve_data_cont.rotation_rate*2.0*M_PI/(24.0*3600.0);
Maxwelltime:Free_surfaces.c:        E->ve_data_cont.Rsg = 4.0*M_PI*E->data.grav_const*E->data.density
Maxwelltime:Free_surfaces.c:            *E->data.density*E->sphere.dradius*E->sphere.dradius
Maxwelltime:Free_surfaces.c:            /E->ve_data_cont.shear_mod;
Maxwelltime:Free_surfaces.c:        E->ve_data_cont.botm_scaling = (E->data.density_below-E->data.density)
Maxwelltime:Free_surfaces.c:                              *E->data.grav_acc
Maxwelltime:Free_surfaces.c:                              *E->sphere.dradius/E->ve_data_cont.shear_mod;
Maxwelltime:Free_surfaces.c:        E->ve_data_cont.surf_scaling = E->data.density*E->data.grav_acc
Maxwelltime:Free_surfaces.c:                              *E->sphere.dradius /E->ve_data_cont.shear_mod;
Maxwelltime:Free_surfaces.c:    E->ve_data_cont.ice_stress_scale = E->ve_data_cont.surf_scaling*density_ice/E->data.density;
Maxwelltime:Free_surfaces.c:    if (E->parallel.me==0)  {
Maxwelltime:Free_surfaces.c:        fprintf(E->fp,"scale %.5e %.5e %.5e %.5e\n",
Maxwelltime:Free_surfaces.c:                      E->ve_data_cont.botm_scaling,
Maxwelltime:Free_surfaces.c:                      E->ve_data_cont.surf_scaling,
Maxwelltime:Free_surfaces.c:                      E->ve_data_cont.ice_stress_scale,E->ve_data_cont.tau);
Maxwelltime:Free_surfaces.c:        fflush(E->fp); 
Maxwelltime:Free_surfaces.c://    input_int("stages",&(E->ve_data_cont.stages),"1",m1);
Maxwelltime:Free_surfaces.c://    input_int_vector("step",E->ve_data_cont.stages,(E->ve_data_cont.stages_step),m1);
Maxwelltime:Free_surfaces.c://    input_double_vector("timestep",E->ve_data_cont.stages,(E->ve_data_cont.stages_time),m1);
Maxwelltime:Free_surfaces.c:    for (i=0;i<E->ve_data_cont.stages;i++)  {
Maxwelltime:Free_surfaces.c:        if (E->ve_data_cont.Heaviside==1)
Maxwelltime:Free_surfaces.c:            E->ve_data_cont.stages_timestep[i] = E->ve_data_cont.stages_time[i]
Maxwelltime:Free_surfaces.c:                /((E->ve_data_cont.stages_step[i]-oldstep));
Maxwelltime:Free_surfaces.c:            E->ve_data_cont.stages_timestep[i] = E->ve_data_cont.stages_time[i]
Maxwelltime:Free_surfaces.c:                /(E->ve_data_cont.tau*(E->ve_data_cont.stages_step[i]-oldstep));
Maxwelltime:Free_surfaces.c:        oldstep = E->ve_data_cont.stages_step[i];
Maxwelltime:Free_surfaces.c:    if (E->ve_data_cont.Heaviside==1)   { 
Maxwelltime:Free_surfaces.c:        E->monitor.elapsed_time=0.0;
Maxwelltime:Free_surfaces.c:        E->ve_data_cont.DIRECT=1;
Maxwelltime:Free_surfaces.c:        E->monitor.elapsed_time=E->ve_data_cont.stages_timestep[0];
Maxwelltime:Free_surfaces.c:        E->advection.timestep=E->ve_data_cont.stages_timestep[0];
Maxwelltime:Free_surfaces.c:        E->monitor.solution_cycles = 1;
Maxwelltime:Free_surfaces.c:        E->ve_data_cont.DIRECT=1;
Maxwelltime:Free_surfaces.c:    E->ve_data_cont.change_of_load = 1;  // used by apply_new_loads
Maxwelltime:Free_surfaces.c:    if (E->ve_data_cont.Heaviside==1)    {
Maxwelltime:Free_surfaces.c:        mm = E->convection.perturb_mm[0];
Maxwelltime:Free_surfaces.c:        ll = E->convection.perturb_ll[0];
Maxwelltime:Free_surfaces.c:        con = E->convection.perturb_mag[0];
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)    {
Maxwelltime:Free_surfaces.c:            i = j*E->lmesh.noz;
Maxwelltime:Free_surfaces.c:            t1 = E->SX[E->mesh.levmax][m][1][i];
Maxwelltime:Free_surfaces.c:            f1 = E->SX[E->mesh.levmax][m][2][i];
Maxwelltime:Free_surfaces.c:            if (E->ve_data_cont.apply_potential==0)
Maxwelltime:Free_surfaces.c:                E->Xsurf[3][m][j] = con*modified_plgndr_a(ll,mm,t1)*cos(mm*f1);
Maxwelltime:Free_surfaces.c:            else if (E->ve_data_cont.apply_potential==1) { 
Maxwelltime:Free_surfaces.c:                E->Xsurf[3][m][j] = 0.0;
Maxwelltime:Free_surfaces.c:                E->init_potential[0][m][j] = con*E->sphere.ro*E->sphere.ro*modified_plgndr_a(ll,mm,t1)*cos(mm*f1);
Maxwelltime:Free_surfaces.c:                E->init_potential[1][m][j] = con*E->sphere.ri*E->sphere.ri*modified_plgndr_a(ll,mm,t1)*cos(mm*f1);
Maxwelltime:Free_surfaces.c:        remove_average(E,E->Xsurf[3],1);
Maxwelltime:Free_surfaces.c:        sphere_expansion_output(E,1,E->Xsurf[3],
Maxwelltime:Free_surfaces.c:                                E->sphere.sphc[0],E->sphere.sphs[0],
Maxwelltime:Free_surfaces.c:                                E->monitor.solution_cycles,"init_surf");
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)    {
Maxwelltime:Free_surfaces.c:            E->slice_ve.surf[2][m][j] = E->Xsurf[3][m][j]*E->ve_data_cont.surf_scaling;
Maxwelltime:Free_surfaces.c:            E->slice_ve.botm[2][m][j] = 0.0 ;
Maxwelltime:Free_surfaces.c:        load_to_CM_grav( E, E->slice_ve.surf[2], E->slice_ve.botm[2], 1 );
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)    {
Maxwelltime:Free_surfaces.c:            E->slice_ve.load[0][m][j] = E->slice_ve.surf[2][m][j] ;
Maxwelltime:Free_surfaces.c:            E->slice_ve.load[2][m][j] = E->slice_ve.botm[2][m][j] ;
Maxwelltime:Free_surfaces.c:    else if (E->ve_data_cont.Heaviside==2)  {   /* ice-model */
Maxwelltime:Free_surfaces.c:        get_iceModel(E,E->slice_ve.iceload[0]);  
Maxwelltime:Free_surfaces.c:        if (E->ve_data_cont.SLE) get_static_oceanload(E);
Maxwelltime:Free_surfaces.c:    if (E->ve_data_cont.Heaviside==1)  
Maxwelltime:Free_surfaces.c:        E->ve_data_cont.change_of_load = 0; // no more load changes in this case
Maxwelltime:Free_surfaces.c:    if (E->ve_data_cont.SELFG)  {// for conversion of potential -> geoid 
Maxwelltime:Free_surfaces.c:        con1 = E->ve_data_cont.Rsg; // surface
Maxwelltime:Free_surfaces.c:        con =  E->ve_data_cont.Rsg  // CMB
Maxwelltime:Free_surfaces.c:               * (E->data.density_below-E->data.density) / E->data.density;
Maxwelltime:Free_surfaces.c:    if (E->parallel.me_loc[3]==E->parallel.nprocz-1)          // surface
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)    {
Maxwelltime:Free_surfaces.c:            E->slice_ve.load[1][m][j] = -(  E->slice_ve.load[0][m][j] 
Maxwelltime:Free_surfaces.c:                                       + E->slice_ve.dynamic_oceanload[m][j] )
Maxwelltime:Free_surfaces.c:                                     + con1*E->potential[0][m][j];
Maxwelltime:Free_surfaces.c:            /* E->slice_ve.load[1][m][j] = -E->slice_ve.load[1][m][j] 
Maxwelltime:Free_surfaces.c:                                     + con1*E->potential[m][is];*/
Maxwelltime:Free_surfaces.c:    if (E->parallel.me_loc[3]==0)                              // CMB
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)    {
Maxwelltime:Free_surfaces.c:            E->slice_ve.load[3][m][j] = - ( E->slice_ve.load[2][m][j] 
Maxwelltime:Free_surfaces.c:                                         - con*E->potential[1][m][j] ) ; 
Maxwelltime:Free_surfaces.c:            /* E->slice_ve.load[3][m][j] = - ( E->slice_ve.load[3][m][j] 
Maxwelltime:Free_surfaces.c:                                        - con*E->potential[m][ib]) ; */
Maxwelltime:Free_surfaces.c:        sphere_expansion_output(E,1,E->slice_ve.load[1],
Maxwelltime:Free_surfaces.c:                                E->sphere.sphc[0],E->sphere.sphs[0],
Maxwelltime:Free_surfaces.c:                                E->monitor.solution_cycles,"surfaceload");
Maxwelltime:Free_surfaces.c: * If E->control.polar_wander is true, it further changes the potential arrays
Maxwelltime:Free_surfaces.c: *     X_surf/cmb must be nondimensional stresses (such as E->iceload).
Maxwelltime:Free_surfaces.c:    ri = E->sphere.ri;
Maxwelltime:Free_surfaces.c:    ro = E->sphere.ro;
Maxwelltime:Free_surfaces.c:    density_cmb = (E->data.density_below-E->data.density)/E->data.density;
Maxwelltime:Free_surfaces.c:        for (ll=1;ll<=E->output.llmax;ll++)    {
Maxwelltime:Free_surfaces.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:   for (j=1;j<=E->lmesh.nsf;j++) {
Maxwelltime:Free_surfaces.c:        E->Xsurf[1][m][j] = 0.0;
Maxwelltime:Free_surfaces.c:        E->Xsurf[2][m][j] = 0.0;
Maxwelltime:Free_surfaces.c:    if (E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)   {
Maxwelltime:Free_surfaces.c:            E->Xsurf[1][m][j] = X_surf[m][j]/E->ve_data_cont.surf_scaling;
Maxwelltime:Free_surfaces.c:        sphere_expansion_VE(E,1,E->Xsurf[1],
Maxwelltime:Free_surfaces.c:                         E->sphere.sphc[0],E->sphere.sphs[0],E->output.llmax);
Maxwelltime:Free_surfaces.c:        for (ll=0;ll<=E->output.llmax;ll++)
Maxwelltime:Free_surfaces.c:            p = E->sphere.hindex[ll][mm];
Maxwelltime:Free_surfaces.c:            E->sphere.sphc[0][p] *= density_surf;
Maxwelltime:Free_surfaces.c:            E->sphere.sphs[0][p] *= density_surf;
Maxwelltime:Free_surfaces.c:    if (E->parallel.me_loc[3]==0)  {
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)   {
Maxwelltime:Free_surfaces.c:            E->Xsurf[2][m][j] = X_cmb[m][j]/E->ve_data_cont.botm_scaling;
Maxwelltime:Free_surfaces.c:        sphere_expansion_VE(E,0,E->Xsurf[2],
Maxwelltime:Free_surfaces.c:                          E->sphere.sphc[1],E->sphere.sphs[1],E->output.llmax);
Maxwelltime:Free_surfaces.c:        for (ll=0;ll<=E->output.llmax;ll++)
Maxwelltime:Free_surfaces.c:            p = E->sphere.hindex[ll][mm];
Maxwelltime:Free_surfaces.c:            E->sphere.sphc[1][p] *= density_cmb;
Maxwelltime:Free_surfaces.c:            E->sphere.sphs[1][p] *= density_cmb;
Maxwelltime:Free_surfaces.c:    if (E->parallel.nprocz>1)  // if >1 cap in z-direction (probably not)
Maxwelltime:Free_surfaces.c:        exchange_sphcs(E,E->sphere.sphc[0],E->sphere.sphs[0],
Maxwelltime:Free_surfaces.c:                         E->sphere.sphc[1],E->sphere.sphs[1]);
Maxwelltime:Free_surfaces.c:    if (E->parallel.me_loc[3]==0)  {
Maxwelltime:Free_surfaces.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:      for (j=1;j<=E->lmesh.nsf;j++) {
Maxwelltime:Free_surfaces.c:        for (ll=1;ll<=E->output.llmax;ll++)  
Maxwelltime:Free_surfaces.c:            p = E->sphere.hindex[ll][mm]; 
Maxwelltime:Free_surfaces.c:            potential_cmb[m][j] += ( E->Tbl_cs[m][mm][j]*
Maxwelltime:Free_surfaces.c:              (brll1[ll]*E->sphere.sphc[0][p] + brll2[ll]*E->sphere.sphc[1][p])
Maxwelltime:Free_surfaces.c:               + E->Tbl_sn[m][mm][j]*
Maxwelltime:Free_surfaces.c:              (brll1[ll]*E->sphere.sphs[0][p] + brll2[ll]*E->sphere.sphs[1][p]))
Maxwelltime:Free_surfaces.c:                *E->Tbl_lm[m][p][j];
Maxwelltime:Free_surfaces.c:    if (E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Maxwelltime:Free_surfaces.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:      for (j=1;j<=E->lmesh.nsf;j++) {
Maxwelltime:Free_surfaces.c:        for (ll=1;ll<=E->output.llmax;ll++)   
Maxwelltime:Free_surfaces.c:            p = E->sphere.hindex[ll][mm]; 
Maxwelltime:Free_surfaces.c:            potential_surf[m][j] += ( E->Tbl_cs[m][mm][j]*
Maxwelltime:Free_surfaces.c:             (srll1[ll]*E->sphere.sphc[0][p] + srll2[ll]*E->sphere.sphc[1][p])
Maxwelltime:Free_surfaces.c:                    + E->Tbl_sn[m][mm][j]*
Maxwelltime:Free_surfaces.c:             (srll1[ll]*E->sphere.sphs[0][p] + srll2[ll]*E->sphere.sphs[1][p]) )
Maxwelltime:Free_surfaces.c:                *E->Tbl_lm[m][p][j];
Maxwelltime:Free_surfaces.c:    if (E->ve_data_cont.polar_wander && icon==1)  
Maxwelltime:Free_surfaces.c://        polar_wander_effects( E, E->Xsurf[1], E->Xsurf[2], 
Maxwelltime:Free_surfaces.c:    ri = E->sphere.ri;
Maxwelltime:Free_surfaces.c:    ro = E->sphere.ro;
Maxwelltime:Free_surfaces.c:    density_cmb = (E->data.density_below-E->data.density)/E->data.density;
Maxwelltime:Free_surfaces.c:    if (E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)   {
Maxwelltime:Free_surfaces.c:            E->Xsurf[1][m][j] = X_surf[m][j]/E->ve_data_cont.surf_scaling;
Maxwelltime:Free_surfaces.c:        sphere_expansion_VE(E,1,E->Xsurf[1],
Maxwelltime:Free_surfaces.c:                             E->sphere.sphc[0],E->sphere.sphs[0],llmax);
Maxwelltime:Free_surfaces.c:            p = E->sphere.hindex[ll][mm];
Maxwelltime:Free_surfaces.c:            E->sphere.sphc[0][p] *= density_surf;
Maxwelltime:Free_surfaces.c:            E->sphere.sphs[0][p] *= density_surf;
Maxwelltime:Free_surfaces.c:    if (E->parallel.me_loc[3]==0)  {
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)   {
Maxwelltime:Free_surfaces.c:            E->Xsurf[2][m][j] = X_cmb[m][j]/E->ve_data_cont.botm_scaling;
Maxwelltime:Free_surfaces.c:        sphere_expansion_VE(E,0,E->Xsurf[2],
Maxwelltime:Free_surfaces.c:                             E->sphere.sphc[1],E->sphere.sphs[1],llmax);
Maxwelltime:Free_surfaces.c:            p = E->sphere.hindex[ll][mm];
Maxwelltime:Free_surfaces.c:            E->sphere.sphc[1][p] *= density_cmb;
Maxwelltime:Free_surfaces.c:            E->sphere.sphs[1][p] *= density_cmb;
Maxwelltime:Free_surfaces.c:    if (E->parallel.nprocz>1)  // if >1 cap in z-direction (probably not)
Maxwelltime:Free_surfaces.c:        exchange_sphcs(E,E->sphere.sphc[0],E->sphere.sphs[0],
Maxwelltime:Free_surfaces.c:                         E->sphere.sphc[1],E->sphere.sphs[1]);
Maxwelltime:Free_surfaces.c:    p = E->sphere.hindex[ll][mm]; 
Maxwelltime:Free_surfaces.c:    E->ve_data_cont.CM_pot[0]= srll1[ll]*E->sphere.sphc[0][p]+srll2[ll]*E->sphere.sphc[1][p];
Maxwelltime:Free_surfaces.c:    p = E->sphere.hindex[ll][mm]; 
Maxwelltime:Free_surfaces.c:    E->ve_data_cont.CM_pot[1]= srll1[ll]*E->sphere.sphc[0][p]+srll2[ll]*E->sphere.sphc[1][p];
Maxwelltime:Free_surfaces.c:    E->ve_data_cont.CM_pot[2]= srll1[ll]*E->sphere.sphs[0][p]+srll2[ll]*E->sphere.sphs[1][p];
Maxwelltime:Free_surfaces.c:    p = E->sphere.hindex[ll][mm]; 
Maxwelltime:Free_surfaces.c:    E->ve_data_cont.PW_pot[0]= srll1[ll]*E->sphere.sphc[0][p]+srll2[ll]*E->sphere.sphc[1][p];
Maxwelltime:Free_surfaces.c:    E->ve_data_cont.PW_pot[1]= srll1[ll]*E->sphere.sphs[0][p]+srll2[ll]*E->sphere.sphs[1][p];
Maxwelltime:Free_surfaces.c: * Sets E->potential[0/1], the nondim grav'l potential at the surface/cmb.
Maxwelltime:Free_surfaces.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:    TG[m] = (double *)malloc((E->lmesh.nsf+1)*sizeof(double));
Maxwelltime:Free_surfaces.c:            // We are performing self-grav iteration. So initialize E->potential
Maxwelltime:Free_surfaces.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:            for (j=1;j<=E->lmesh.nsf;j++)   {
Maxwelltime:Free_surfaces.c:                E->potential[1][m][j] = E->init_potential[1][m][j];
Maxwelltime:Free_surfaces.c:                E->potential[0][m][j] = E->init_potential[0][m][j];
Maxwelltime:Free_surfaces.c:        // calculate E->incr_potential[0/1] from E->slice.surf/botm[2]:
Maxwelltime:Free_surfaces.c:        calculate_potential( E, E->slice_ve.surf[2], E->slice_ve.botm[2], 
Maxwelltime:Free_surfaces.c:                             E->incr_potential[0], E->incr_potential[1], 1);
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)   {
Maxwelltime:Free_surfaces.c:            E->potential[1][m][j] =  E->init_potential[1][m][j] 
Maxwelltime:Free_surfaces.c:                                   + E->incr_potential[1][m][j];  // cmb
Maxwelltime:Free_surfaces.c:            E->potential[0][m][j] =  E->init_potential[0][m][j] 
Maxwelltime:Free_surfaces.c:                                   + E->incr_potential[0][m][j];  // surface
Maxwelltime:Free_surfaces.c:for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:    for (j=1;j<=E->lmesh.nsf;j++)  { 
Maxwelltime:Free_surfaces.c:         TG[m][j] = fabs(E->potential[0][m][j]);
Maxwelltime:Free_surfaces.c:if (E->parallel.me==0) fprintf(stderr,"in get_potential %g count %d\n",temp1,count);
Maxwelltime:Free_surfaces.c:  const int onedp=onedvpoints[E->mesh.nsd];
Maxwelltime:Free_surfaces.c: if (E->parallel.me_loc[3]==E->parallel.nprocz-1 || E->parallel.me_loc[3]==0)  {
Maxwelltime:Free_surfaces.c: for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)     
Maxwelltime:Free_surfaces.c: for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Free_surfaces.c:   if (E->parallel.me_loc[3]==E->parallel.nprocz-1)  
Maxwelltime:Free_surfaces.c:     for (e=1;e<=E->lmesh.SNEL[lev];e++)    {
Maxwelltime:Free_surfaces.c:       el = e*E->lmesh.ELZ[lev];
Maxwelltime:Free_surfaces.c:           E->B_R[lev][m][nn[k]][(e-1)*onedp+i] =
Maxwelltime:Free_surfaces.c:                     E->M.vpt[GMVINDEX(k,i)]
Maxwelltime:Free_surfaces.c:   if (E->parallel.me_loc[3]==0)  
Maxwelltime:Free_surfaces.c:     for (e=1;e<=E->lmesh.SNEL[lev];e++)     {
Maxwelltime:Free_surfaces.c:       el = (e-1)*E->lmesh.ELZ[lev]+1;
Maxwelltime:Free_surfaces.c:           E->B_R[lev][m][nn[k]][(e-1)*onedp+i] =
Maxwelltime:Free_surfaces.c:                     E->M.vpt[GMVINDEX(k,i)]
Maxwelltime:Free_surfaces.c:    const int onedp=onedvpoints[E->mesh.nsd];
Maxwelltime:Free_surfaces.c:    if (E->parallel.me_loc[3]==E->parallel.nprocz-1)  {
Maxwelltime:Free_surfaces.c:        for (e=1;e<=E->lmesh.SNEL[lev];e++)   {
Maxwelltime:Free_surfaces.c:            el=e*E->lmesh.ELZ[lev];
Maxwelltime:Free_surfaces.c:                nn[k] = E->ID[lev][m][E->IEN[lev][m][el].node[k+onedp]].doff[3];
Maxwelltime:Free_surfaces.c:                force[k] = E->ve_data_cont.surf_scaling*u[m][nn[k]];
Maxwelltime:Free_surfaces.c:                    force_at_gs[i] += force[k] * E->M.vpt[GMVINDEX(k,i)];
Maxwelltime:Free_surfaces.c:                Au[m][nn[k]] += E->B_R[lev][m][k+onedp][(e-1)*onedp+i] * force_at_gs[i];
Maxwelltime:Free_surfaces.c:    if (E->parallel.me_loc[3]==0)  {
Maxwelltime:Free_surfaces.c:        for (e=1;e<=E->lmesh.SNEL[lev];e++)   {
Maxwelltime:Free_surfaces.c:            el=(e-1)*E->lmesh.ELZ[lev]+1;
Maxwelltime:Free_surfaces.c:                nn[k] = E->ID[lev][m][E->IEN[lev][m][el].node[k]].doff[3];
Maxwelltime:Free_surfaces.c:                force[k] = E->ve_data_cont.botm_scaling*u[m][nn[k]];
Maxwelltime:Free_surfaces.c:                    force_at_gs[i] += force[k] * E->M.vpt[GMVINDEX(k,i)];
Maxwelltime:Free_surfaces.c:                Au[m][nn[k]] += E->B_R[lev][m][k][(e-1)*onedp+i] * force_at_gs[i];
Maxwelltime:Free_surfaces.c: * About the flag E->control.change_of_load:
Maxwelltime:Free_surfaces.c:    if (E->ve_data_cont.change_of_load==0) {  // no more ice or static ocean load
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:        for (i=1;i<=E->lmesh.nsf;i++)   {
Maxwelltime:Free_surfaces.c:            E->incr_potential[2][m][i] = 0.0 ;
Maxwelltime:Free_surfaces.c:            E->incr_potential[3][m][i] = 0.0 ;
Maxwelltime:Free_surfaces.c:    if (E->ve_data_cont.Heaviside==2) {  // only for ice-model type loading
Maxwelltime:Free_surfaces.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Maxwelltime:Free_surfaces.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Free_surfaces.c:            for (i=1;i<=E->lmesh.nsf;i++)
Maxwelltime:Free_surfaces.c:                E->slice_ve.surf[2][m][i] =  E->slice_ve.iceload[0][m][i]
Maxwelltime:Free_surfaces.c:                                        + E->slice_ve.static_oceanload[m][i];
Maxwelltime:Free_surfaces.c:        if (E->parallel.me_loc[3]==0)
Maxwelltime:Free_surfaces.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Free_surfaces.c:            for (i=1;i<=E->lmesh.nsf;i++)
Maxwelltime:Free_surfaces.c:                E->slice_ve.botm[2][m][i] = 0.0;
Maxwelltime:Free_surfaces.c:        load_to_CM_grav( E, E->slice_ve.surf[2], E->slice_ve.botm[2], 1 );
Maxwelltime:Free_surfaces.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Maxwelltime:Free_surfaces.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Free_surfaces.c:            for (i=1;i<=E->lmesh.nsf;i++)
Maxwelltime:Free_surfaces.c:                E->slice_ve.load[0][m][i] +=  E->slice_ve.surf[2][m][i];
Maxwelltime:Free_surfaces.c:        if (E->parallel.me_loc[3]==0)
Maxwelltime:Free_surfaces.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Free_surfaces.c:            for (i=1;i<=E->lmesh.nsf;i++)
Maxwelltime:Free_surfaces.c:                E->slice_ve.load[2][m][i] += E->slice_ve.botm[2][m][i];
Maxwelltime:Free_surfaces.c:    if (E->ve_data_cont.SELFG)   {
Maxwelltime:Free_surfaces.c:        if (E->ve_data_cont.change_of_load==1 || E->ve_data_cont.SLE)
Maxwelltime:Free_surfaces.c:            calculate_potential( E, E->slice_ve.surf[2], E->slice_ve.botm[2], 
Maxwelltime:Free_surfaces.c:                                 E->incr_potential[2], E->incr_potential[3], 1);
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:        for (i=1;i<=E->lmesh.nsf;i++)   {
Maxwelltime:Free_surfaces.c:            E->init_potential[0][m][i] += E->incr_potential[2][m][i];
Maxwelltime:Free_surfaces.c:            E->init_potential[1][m][i] += E->incr_potential[3][m][i];
Maxwelltime:Free_surfaces.c: * About the flag E->control.change_of_load:
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Free_surfaces.c:            E->slice_ve.ice_height_prev[m] = (double *)
Maxwelltime:Free_surfaces.c:                              malloc((E->lmesh.nsf+2)*sizeof(double));
Maxwelltime:Free_surfaces.c:            E->slice_ve.ice_height_curr[m] = (double *)
Maxwelltime:Free_surfaces.c:                              malloc((E->lmesh.nsf+2)*sizeof(double));
Maxwelltime:Free_surfaces.c:            for (n=1;n<=E->lmesh.nsf;n++)  {  
Maxwelltime:Free_surfaces.c:                E->slice_ve.ice_height_prev[m][n] = 0.0;
Maxwelltime:Free_surfaces.c:                E->slice_ve.ice_height_curr[m][n] = 0.0;
Maxwelltime:Free_surfaces.c:   if (E->ve_data_cont.DIRECT == 0 && been_here!=0) 
Maxwelltime:Free_surfaces.c:    ifile = E->ve_data_cont.stage + 1;
Maxwelltime:Free_surfaces.c:    E->ve_data_cont.change_of_load = 1;
Maxwelltime:Free_surfaces.c:            E->ve_data_cont.ice_file, E->sphere.elx, E->sphere.ely, ifile-1);
Maxwelltime:Free_surfaces.c:        read_reg_grids(E,outfile,E->slice_ve.ice_height_prev);
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)  {
Maxwelltime:Free_surfaces.c:           E->slice_ve.ice_height_prev[m][j] = E->slice_ve.ice_height_prev[m][j]/E->sphere.dradius; // non-dimensionalized by the Earth's radius
Maxwelltime:Free_surfaces.c:           E->slice_ve.ice_height_prev[m][j] = 0.0; // reset to be ice free
Maxwelltime:Free_surfaces.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:        for (j=1;j<=E->lmesh.nsf;j++)  
Maxwelltime:Free_surfaces.c:            E->slice_ve.ice_height_prev[m][j] = E->slice_ve.ice_height_curr[m][j];   
Maxwelltime:Free_surfaces.c:        step_prev = E->ve_data_cont.stages_step[E->ve_data_cont.stage-1];
Maxwelltime:Free_surfaces.c:                E->ve_data_cont.ice_file, E->sphere.elx, E->sphere.ely, ifile);
Maxwelltime:Free_surfaces.c:    read_reg_grids(E,outfile,E->slice_ve.ice_height_curr);
Maxwelltime:Free_surfaces.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:    for (j=1;j<=E->lmesh.nsf;j++)  {
Maxwelltime:Free_surfaces.c:        E->slice_ve.ice_height_curr[m][j] = E->slice_ve.ice_height_curr[m][j]/E->sphere.dradius; // non-dimensionalized by the Earth's radius
Maxwelltime:Free_surfaces.c:    temp1 = E->ve_data_cont.ice_stress_scale/(E->ve_data_cont.stages_step[E->ve_data_cont.stage] - step_prev);
Maxwelltime:Free_surfaces.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:    for (j=1;j<=E->lmesh.nsf;j++) 
Maxwelltime:Free_surfaces.c:        iceload[m][j] = ( E->slice_ve.ice_height_curr[m][j]
Maxwelltime:Free_surfaces.c:                         -E->slice_ve.ice_height_prev[m][j])*temp1;
Maxwelltime:Free_surfaces.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:    for (n=1;n<=E->lmesh.nsf;n++)    
Maxwelltime:Free_surfaces.c:        E->Xsurf[3][m][n] = iceload[m][n];
Maxwelltime:Free_surfaces.c:    remove_average(E,E->Xsurf[3],1);
Maxwelltime:Free_surfaces.c:    sphere_expansion_output( E, 1, E->Xsurf[3], 
Maxwelltime:Free_surfaces.c:                             E->sphere.sphc[0], E->sphere.sphs[0],
Maxwelltime:Free_surfaces.c:                             E->monitor.solution_cycles,outfile );
Maxwelltime:Free_surfaces.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Free_surfaces.c:    for (n=1;n<=E->lmesh.nsf;n++)
Maxwelltime:Free_surfaces.c:        iceload[m][n] = E->Xsurf[3][m][n];
Maxwelltime:Free_surfaces.c: if (E->sphere.nox==181) {
Maxwelltime:Free_surfaces.c: else if (E->sphere.nox==361) {
Maxwelltime:Free_surfaces.c:   for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Free_surfaces.c:   for (node=1;node<=E->lmesh.nno;node++)   {
Maxwelltime:Free_surfaces.c:     theta=E->sx[j][1][node];
Maxwelltime:Free_surfaces.c:     phi  =E->sx[j][2][node];
Maxwelltime:Free_surfaces.c:     if (node%E->lmesh.noz==0)  {
Maxwelltime:Free_surfaces.c:   del_degree=180.0/(E->sphere.nox-1); /* increments given in input file */
Maxwelltime:Free_surfaces.c:   numtheta=E->sphere.nox-1;       /* number of theta increments */
Maxwelltime:Free_surfaces.c:   for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Free_surfaces.c:   for (node=1;node<=E->lmesh.nno;node++)   {
Maxwelltime:Free_surfaces.c:     theta=E->sx[j][1][node];
Maxwelltime:Free_surfaces.c:     phi  =E->sx[j][2][node];
Maxwelltime:Free_surfaces.c:     if (node%E->lmesh.noz==0)  {
Maxwelltime:Free_surfaces.c:   for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Free_surfaces.c:   for (node=1;node<=E->lmesh.nno;node++)   {
Maxwelltime:Free_surfaces.c:     theta=E->sx[j][1][node];
Maxwelltime:Free_surfaces.c:     phi  =E->sx[j][2][node];
Maxwelltime:Free_surfaces.c:     if (node%E->lmesh.noz==0)  {
Maxwelltime:Full_boundary_conditions.c:  for(lv=E->mesh.gridmax;lv>=E->mesh.gridmin;lv--)
Maxwelltime:Full_boundary_conditions.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)     {
Maxwelltime:Full_boundary_conditions.c:      noz = E->mesh.NOZ[lv];
Maxwelltime:Full_boundary_conditions.c:      if(E->mesh.topvbc != 1) {	/* free stress top, note: free-slip BC is removed */
Maxwelltime:Full_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,1,0.0,VBX,0,lv,j);
Maxwelltime:Full_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,VBZ,0,lv,j);
Maxwelltime:Full_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,2,0.0,VBY,0,lv,j);
Maxwelltime:Full_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,1,E->control.VBXtopval,SBX,1,lv,j);
Maxwelltime:Full_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,3,E->control.VBZtopval,SBZ,1,lv,j);
Maxwelltime:Full_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,2,E->control.VBYtopval,SBY,1,lv,j);
Maxwelltime:Full_boundary_conditions.c:      if(E->mesh.botvbc != 1) {	/* free stress bottom */
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,0.0,VBX,0,lv,j);
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,VBZ,0,lv,j);
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,0.0,VBY,0,lv,j);
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,E->control.VBXbotval,SBX,1,lv,j);
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,E->control.VBZbotval,SBZ,1,lv,j);
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,E->control.VBYbotval,SBY,1,lv,j);
Maxwelltime:Full_boundary_conditions.c:      if(E->mesh.topvbc == 1) {	/* velocity/no slip BC */
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,E->control.VBXtopval,VBX,1,lv,j);
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,VBZ,1,lv,j);
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,E->control.VBYtopval,VBY,1,lv,j);
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,0.0,SBX,0,lv,j);
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,SBZ,0,lv,j);
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,0.0,SBY,0,lv,j);
Maxwelltime:Full_boundary_conditions.c:        if(E->control.vbcs_file){ /* this should either only be called
Maxwelltime:Full_boundary_conditions.c:	  if((lv == E->mesh.gridmin) && (j == E->sphere.caps_per_proc))
Maxwelltime:Full_boundary_conditions.c:      if(E->mesh.botvbc == 1) {	/* velocity bottom BC */
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,E->control.VBXbotval,VBX,1,lv,j);
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,VBZ,1,lv,j);
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,E->control.VBYbotval,VBY,1,lv,j);
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,0.0,SBX,0,lv,j);
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,SBZ,0,lv,j);
Maxwelltime:Full_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,0.0,SBY,0,lv,j);
Maxwelltime:Full_boundary_conditions.c:      if(E->control.side_sbcs)
Maxwelltime:Full_boundary_conditions.c:/* if(E->control.verbose) { */
Maxwelltime:Full_boundary_conditions.c:/*  for (j=1;j<=E->sphere.caps_per_proc;j++) */
Maxwelltime:Full_boundary_conditions.c:/*    for (node=1;node<=E->lmesh.nno;node++) */
Maxwelltime:Full_boundary_conditions.c:/*       fprintf(E->fp_out,"m=%d VB== %d %g %g %g flag %u %u %u\n",j,node,E->sphere.cap[j].VB[1][node],E->sphere.cap[j].VB[2][node],E->sphere.cap[j].VB[3][node],E->node[j][node]&VBX,E->node[j][node]&VBY,E->node[j][node]&VBZ); */
Maxwelltime:Full_boundary_conditions.c:/*  fflush(E->fp_out); */
Maxwelltime:Full_boundary_conditions.c:  lev = E->mesh.levmax;
Maxwelltime:Full_boundary_conditions.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)    {
Maxwelltime:Full_boundary_conditions.c:    noz = E->mesh.noz;
Maxwelltime:Full_boundary_conditions.c:    if(E->mesh.toptbc == 1)    {
Maxwelltime:Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,TBZ,1,lev,j);
Maxwelltime:Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,FBZ,0,lev,j);
Maxwelltime:Full_boundary_conditions.c:      if(E->control.tbcs_file)
Maxwelltime:Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,TBZ,0,lev,j);
Maxwelltime:Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,FBZ,1,lev,j);
Maxwelltime:Full_boundary_conditions.c:    if(E->mesh.bottbc == 1)    {
Maxwelltime:Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,TBZ,1,lev,j);
Maxwelltime:Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,FBZ,0,lev,j);
Maxwelltime:Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,TBZ,0,lev,j);
Maxwelltime:Full_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,FBZ,1,lev,j);
Maxwelltime:Full_boundary_conditions.c:    if(E->control.lith_age_time==1)  {
Maxwelltime:Full_boundary_conditions.c:  E->temperatures_conform_bcs = temperatures_conform_bcs;
Maxwelltime:Full_boundary_conditions.c:  if(dirn > E->mesh.nsd)
Maxwelltime:Full_boundary_conditions.c:      rowl = E->lmesh.NOZ[level];
Maxwelltime:Full_boundary_conditions.c:  if ( ( (ROW==1) && (E->parallel.me_loc[3]==0) ) ||
Maxwelltime:Full_boundary_conditions.c:       ( (ROW==E->mesh.NOZ[level]) && (E->parallel.me_loc[3]==E->parallel.nprocz-1) ) ) {
Maxwelltime:Full_boundary_conditions.c:      for(j=1;j<=E->lmesh.NOY[level];j++)
Maxwelltime:Full_boundary_conditions.c:    	for(i=1;i<=E->lmesh.NOX[level];i++)     {
Maxwelltime:Full_boundary_conditions.c:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+(j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Maxwelltime:Full_boundary_conditions.c:    	  E->NODE[level][m][node] = E->NODE[level][m][node] & (~ mask);
Maxwelltime:Full_boundary_conditions.c:      for(j=1;j<=E->lmesh.NOY[level];j++)
Maxwelltime:Full_boundary_conditions.c:        for(i=1;i<=E->lmesh.NOX[level];i++)       {
Maxwelltime:Full_boundary_conditions.c:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+(j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Maxwelltime:Full_boundary_conditions.c:    	  E->NODE[level][m][node] = E->NODE[level][m][node] | (mask);
Maxwelltime:Full_boundary_conditions.c:    	  if(level==E->mesh.levmax)   /* NB */
Maxwelltime:Full_boundary_conditions.c:  fprintf(E->fp,"Periodic boundary conditions\n");
Maxwelltime:Full_boundary_conditions.c: fprintf(E->fp,"Periodic temperature boundary conditions\n");
Maxwelltime:Full_geometry_cartesian.c:  E->mesh.nsd = 2;
Maxwelltime:Full_geometry_cartesian.c:  E->mesh.dof = 2;
Maxwelltime:Full_geometry_cartesian.c:  E->mesh.nsd = 2;
Maxwelltime:Full_geometry_cartesian.c:  E->mesh.dof = 3;
Maxwelltime:Full_geometry_cartesian.c:  E->mesh.nsd = 3;
Maxwelltime:Full_geometry_cartesian.c:  E->mesh.dof = 3;
Maxwelltime:Full_geometry_cartesian.c:  E->mesh.nsd = 3;
Maxwelltime:Full_geometry_cartesian.c:  E->mesh.dof = 3;
Maxwelltime:Full_geometry_cartesian.c:  E->sphere.caps = 12;
Maxwelltime:Full_geometry_cartesian.c:  E->sphere.max_connections = 6;
Maxwelltime:Full_obsolete.c:  E->parallel.me = 0;
Maxwelltime:Full_obsolete.c:  E->parallel.nproc = 1;
Maxwelltime:Full_obsolete.c:  E->parallel.me_loc[1] = 0;
Maxwelltime:Full_obsolete.c:  E->parallel.me_loc[2] = 0;
Maxwelltime:Full_obsolete.c:  E->parallel.me_loc[3] = 0;
Maxwelltime:Full_obsolete.c:  MPI_Comm_rank(E->parallel.world, &(E->parallel.me) );
Maxwelltime:Full_obsolete.c:  MPI_Comm_size(E->parallel.world, &(E->parallel.nproc) );
Maxwelltime:Full_obsolete.c: const int dims = E->mesh.nsd;
Maxwelltime:Full_obsolete.c: if (E->parallel.nprocz==1)  {
Maxwelltime:Full_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"scatter_to_nlayer should not be called\n");
Maxwelltime:Full_obsolete.c:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Maxwelltime:Full_obsolete.c:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Maxwelltime:Full_obsolete.c:   SD = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Maxwelltime:Full_obsolete.c:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Maxwelltime:Full_obsolete.c:   for (j=0;j<E->parallel.nprocz;j++) {
Maxwelltime:Full_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_obsolete.c:    if (E->parallel.me==rootid)
Maxwelltime:Full_obsolete.c:      for (d=0;d<E->parallel.nprocz;d++)  {
Maxwelltime:Full_obsolete.c:        for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Maxwelltime:Full_obsolete.c:          k1 = k + d*E->lmesh.ELZ[lev];
Maxwelltime:Full_obsolete.c:          for (j=1;j<=E->lmesh.NOY[lev];j++)
Maxwelltime:Full_obsolete.c:            for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Maxwelltime:Full_obsolete.c:              node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Maxwelltime:Full_obsolete.c:              node1= k1+ (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Maxwelltime:Full_obsolete.c:           MPI_Send(SD,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],rootid,E->parallel.world);
Maxwelltime:Full_obsolete.c:           for (i=0;i<E->lmesh.NEQ[lev];i++)
Maxwelltime:Full_obsolete.c:        MPI_Recv(AUo[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,rootid,E->parallel.world,&status);
Maxwelltime:Full_obsolete.c: const int dims = E->mesh.nsd;
Maxwelltime:Full_obsolete.c: if (E->parallel.nprocz==1)  {
Maxwelltime:Full_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Maxwelltime:Full_obsolete.c:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Maxwelltime:Full_obsolete.c:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Maxwelltime:Full_obsolete.c:   RV = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Maxwelltime:Full_obsolete.c:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Maxwelltime:Full_obsolete.c:   for (j=0;j<E->parallel.nprocz;j++) {
Maxwelltime:Full_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_obsolete.c:    if (E->parallel.me!=rootid)
Maxwelltime:Full_obsolete.c:       MPI_Send(AUi[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,E->parallel.me,E->parallel.world);
Maxwelltime:Full_obsolete.c:       for (d=0;d<E->parallel.nprocz;d++) {
Maxwelltime:Full_obsolete.c:	   MPI_Recv(RV,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],processors[d],E->parallel.world,&status);
Maxwelltime:Full_obsolete.c:           for (node=0;node<E->lmesh.NEQ[lev];node++)
Maxwelltime:Full_obsolete.c:         for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Maxwelltime:Full_obsolete.c:           k1 = k + d*E->lmesh.ELZ[lev];
Maxwelltime:Full_obsolete.c:           for (j=1;j<=E->lmesh.NOY[lev];j++)
Maxwelltime:Full_obsolete.c:             for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Maxwelltime:Full_obsolete.c:               node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Maxwelltime:Full_obsolete.c:               node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Maxwelltime:Full_obsolete.c: if (E->parallel.nprocz==1)  {
Maxwelltime:Full_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Maxwelltime:Full_obsolete.c:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Maxwelltime:Full_obsolete.c:   NNO = NOZ*E->lmesh.NOX[lev]*E->lmesh.NOY[lev];
Maxwelltime:Full_obsolete.c:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Maxwelltime:Full_obsolete.c:   RV = (float *)malloc((E->lmesh.NNO[lev]+2)*sizeof(float));
Maxwelltime:Full_obsolete.c:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Maxwelltime:Full_obsolete.c:   for (j=0;j<E->parallel.nprocz;j++) {
Maxwelltime:Full_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_obsolete.c:    if (E->parallel.me!=rootid) {
Maxwelltime:Full_obsolete.c:       MPI_Send(AUi[m],E->lmesh.NNO[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Maxwelltime:Full_obsolete.c:       for (d=0;d<E->parallel.nprocz;d++) {
Maxwelltime:Full_obsolete.c:           MPI_Recv(RV,E->lmesh.NNO[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Maxwelltime:Full_obsolete.c:	   for (node=1;node<=E->lmesh.NNO[lev];node++)
Maxwelltime:Full_obsolete.c:         for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Maxwelltime:Full_obsolete.c:           k1 = k + d*E->lmesh.ELZ[lev];
Maxwelltime:Full_obsolete.c:           for (j=1;j<=E->lmesh.NOY[lev];j++)
Maxwelltime:Full_obsolete.c:             for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Maxwelltime:Full_obsolete.c:               node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Maxwelltime:Full_obsolete.c:               node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Maxwelltime:Full_obsolete.c: if (E->parallel.nprocz==1)  {
Maxwelltime:Full_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Maxwelltime:Full_obsolete.c:   NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz;
Maxwelltime:Full_obsolete.c:   NNO = NOZ*E->lmesh.ELX[lev]*E->lmesh.ELY[lev];
Maxwelltime:Full_obsolete.c:   processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Maxwelltime:Full_obsolete.c:   RV = (float *)malloc((E->lmesh.NEL[lev]+2)*sizeof(float));
Maxwelltime:Full_obsolete.c:   rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Maxwelltime:Full_obsolete.c:   for (j=0;j<E->parallel.nprocz;j++) {
Maxwelltime:Full_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_obsolete.c:    if (E->parallel.me!=rootid) {
Maxwelltime:Full_obsolete.c:       MPI_Send(AUi[m],E->lmesh.NEL[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Maxwelltime:Full_obsolete.c:       for (d=0;d<E->parallel.nprocz;d++) {
Maxwelltime:Full_obsolete.c:           MPI_Recv(RV,E->lmesh.NEL[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Maxwelltime:Full_obsolete.c:	   for (e=1;e<=E->lmesh.NEL[lev];e++)
Maxwelltime:Full_obsolete.c:         for (k=1;k<=E->lmesh.ELZ[lev];k++)   {
Maxwelltime:Full_obsolete.c:           k1 = k + d*E->lmesh.ELZ[lev];
Maxwelltime:Full_obsolete.c:           for (j=1;j<=E->lmesh.ELY[lev];j++)
Maxwelltime:Full_obsolete.c:             for (i=1;i<=E->lmesh.ELX[lev];i++)   {
Maxwelltime:Full_obsolete.c:               e = k + (i-1)*E->lmesh.ELZ[lev] + (j-1)*E->lmesh.ELZ[lev]*E->lmesh.ELX[lev];
Maxwelltime:Full_obsolete.c:               e1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.ELX[lev];
Maxwelltime:Full_obsolete.c: if (E->parallel.nprocxy==1)   return;
Maxwelltime:Full_obsolete.c: nsl = E->sphere.nsf+1;
Maxwelltime:Full_obsolete.c: me = E->parallel.me;
Maxwelltime:Full_obsolete.c:   for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Maxwelltime:Full_obsolete.c:     RG[i] = ( float *)malloc((E->sphere.nsf+1)*sizeof(float));
Maxwelltime:Full_obsolete.c: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Maxwelltime:Full_obsolete.c:   to_everyone = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Maxwelltime:Full_obsolete.c:     MPI_Isend(TG,nsl,MPI_FLOAT,to_everyone,mst,E->parallel.world,&request[idb-1]);
Maxwelltime:Full_obsolete.c: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Maxwelltime:Full_obsolete.c:   from_proc = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Maxwelltime:Full_obsolete.c:      MPI_Irecv(RG[idb],nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&request[idb-1]);
Maxwelltime:Full_obsolete.c: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Maxwelltime:Full_obsolete.c:   for (j=1;j<=E->sphere.nsf; j++)  {
Maxwelltime:Full_obsolete.c: if (E->parallel.nprocz==1)   return;
Maxwelltime:Full_obsolete.c: jumpp = E->sphere.hindice;
Maxwelltime:Full_obsolete.c: nsl = E->sphere.hindice*2;
Maxwelltime:Full_obsolete.c: me = E->parallel.me;
Maxwelltime:Full_obsolete.c: if (E->parallel.me_loc[3]==dest_proc)
Maxwelltime:Full_obsolete.c: for (i=0;i<E->sphere.hindice;i++)   {
Maxwelltime:Full_obsolete.c: if (E->parallel.me_loc[3]!=dest_proc)    {  /* send TG */
Maxwelltime:Full_obsolete.c:     to_proc = E->parallel.me_sph*E->parallel.nprocz+E->parallel.nprocz-1;
Maxwelltime:Full_obsolete.c:     MPI_Send(TG,nsl,MPI_FLOAT,to_proc,mst,E->parallel.world);
Maxwelltime:Full_obsolete.c: if (E->parallel.me_loc[3]==dest_proc)  {
Maxwelltime:Full_obsolete.c:   for (i=1;i<E->parallel.nprocz;i++) {
Maxwelltime:Full_obsolete.c:      MPI_Recv(RG,nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&status1);
Maxwelltime:Full_obsolete.c:      for (j=0;j<E->sphere.hindice;j++)   {
Maxwelltime:Full_obsolete.c: if (E->parallel.me_loc[3]==dest_proc)
Maxwelltime:Full_obsolete.c: if (E->parallel.nprocxy==1)   return;
Maxwelltime:Full_obsolete.c: nsl = E->sphere.hindice*2;
Maxwelltime:Full_obsolete.c: me = E->parallel.me;
Maxwelltime:Full_obsolete.c: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Maxwelltime:Full_obsolete.c: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Maxwelltime:Full_obsolete.c:   to_everyone = E->parallel.nprocz*(i-1) + loc_proc;
Maxwelltime:Full_obsolete.c:     MPI_Isend(TG,nsl,MPI_FLOAT,to_everyone,mst,E->parallel.world,&request[idb-1]);
Maxwelltime:Full_obsolete.c: for (i=1;i<=E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)  {
Maxwelltime:Full_obsolete.c:   from_proc = E->parallel.nprocz*(i-1) + loc_proc;
Maxwelltime:Full_obsolete.c:      MPI_Irecv(RG[idb],nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&request[idb-1]);
Maxwelltime:Full_obsolete.c: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Maxwelltime:Full_obsolete.c: for (i=1;i<E->parallel.nprocxy*E->parallel.surf_proc_per_cap;i++)
Maxwelltime:Full_obsolete.c:  i = cases[E->sphere.caps_per_proc];
Maxwelltime:Full_obsolete.c:  E->parallel.nproc_sph[1] = incases3[i].xy[0];
Maxwelltime:Full_obsolete.c:  E->parallel.nproc_sph[2] = incases3[i].xy[1];
Maxwelltime:Full_obsolete.c:  E->sphere.lelx = E->sphere.elx/E->parallel.nproc_sph[1];
Maxwelltime:Full_obsolete.c:  E->sphere.lely = E->sphere.ely/E->parallel.nproc_sph[2];
Maxwelltime:Full_obsolete.c:  E->sphere.lsnel = E->sphere.lely*E->sphere.lelx;
Maxwelltime:Full_obsolete.c:  E->sphere.lnox = E->sphere.lelx + 1;
Maxwelltime:Full_obsolete.c:  E->sphere.lnoy = E->sphere.lely + 1;
Maxwelltime:Full_obsolete.c:  E->sphere.lnsf = E->sphere.lnox*E->sphere.lnoy;
Maxwelltime:Full_obsolete.c:  for (i=0;i<=E->parallel.nprocz-1;i++)
Maxwelltime:Full_obsolete.c:    if (E->parallel.me_loc[3] == i)    {
Maxwelltime:Full_obsolete.c:      E->parallel.me_sph = (E->parallel.me-i)/E->parallel.nprocz;
Maxwelltime:Full_obsolete.c:      E->parallel.me_loc_sph[1] = E->parallel.me_sph%E->parallel.nproc_sph[1];
Maxwelltime:Full_obsolete.c:      E->parallel.me_loc_sph[2] = E->parallel.me_sph/E->parallel.nproc_sph[1];
Maxwelltime:Full_obsolete.c:  E->sphere.lexs = E->sphere.lelx * E->parallel.me_loc_sph[1];
Maxwelltime:Full_obsolete.c:  E->sphere.leys = E->sphere.lely * E->parallel.me_loc_sph[2];
Maxwelltime:Full_obsolete.c:    record_h = E->control.record_every;
Maxwelltime:Full_obsolete.c:    if ( (ii == 0) || ((ii % record_h) == 0) || E->control.DIRECTII)    {
Maxwelltime:Full_obsolete.c:    if ( ((ii == 0) || ((ii % E->control.record_every) == 0))
Maxwelltime:Full_obsolete.c:	 || E->control.DIRECTII)     {
Maxwelltime:Full_obsolete.c:  int lev = E->mesh.levmax;
Maxwelltime:Full_obsolete.c:  const int nno = E->lmesh.nno;
Maxwelltime:Full_obsolete.c:  const int nsd = E->mesh.nsd;
Maxwelltime:Full_obsolete.c:/*       ii = E->lmesh.nsf; */
Maxwelltime:Full_obsolete.c:/*       m = (E->parallel.me_loc[3]==0)?ii:0; */
Maxwelltime:Full_obsolete.c:      /* size2 = (E->lmesh.nel+1)*sizeof(float); */
Maxwelltime:Full_obsolete.c:  sprintf(output_file,"%s.coord.%d",E->control.data_file,E->parallel.me);
Maxwelltime:Full_obsolete.c:     fprintf(E->fp,"(Output.c #1) Cannot open %s\n",output_file);
Maxwelltime:Full_obsolete.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Maxwelltime:Full_obsolete.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Maxwelltime:Full_obsolete.c:    for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Full_obsolete.c:      fprintf(fp1,"%.3e %.3e %.3e\n",E->sx[j][1][i],E->sx[j][2][i],E->sx[j][3][i]);
Maxwelltime:Full_obsolete.c:  sprintf(output_file,"%s.visc.%d.%d",E->control.data_file,E->parallel.me,file_number);
Maxwelltime:Full_obsolete.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Maxwelltime:Full_obsolete.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Maxwelltime:Full_obsolete.c:    for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Full_obsolete.c:      fprintf(fp1,"%.3e\n",E->VI[lev][j][i]);
Maxwelltime:Full_obsolete.c:  sprintf(output_file,"%s.velo.%d.%d",E->control.data_file,E->parallel.me,file_number);
Maxwelltime:Full_obsolete.c:  fprintf(fp1,"%d %d %.5e\n",file_number,E->lmesh.nno,E->monitor.elapsed_time);
Maxwelltime:Full_obsolete.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Maxwelltime:Full_obsolete.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Maxwelltime:Full_obsolete.c:     for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Full_obsolete.c:       fprintf(fp1,"%.6e %.6e %.6e %.6e\n",E->sphere.cap[j].V[1][i],E->sphere.cap[j].V[2][i],E->sphere.cap[j].V[3][i],E->T[j][i]);
Maxwelltime:Full_obsolete.c:     /* for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Full_obsolete.c:	fprintf(fp1,"%.6e\n",E->T[j][i]); */
Maxwelltime:Full_obsolete.c:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)      {
Maxwelltime:Full_obsolete.c:    sprintf(output_file,"%s.surf.%d.%d",E->control.data_file,E->parallel.me,file_number);
Maxwelltime:Full_obsolete.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Full_obsolete.c:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Maxwelltime:Full_obsolete.c:      for(i=1;i<=E->lmesh.nsf;i++)   {
Maxwelltime:Full_obsolete.c:	s = i*E->lmesh.noz;
Maxwelltime:Full_obsolete.c:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpg[j][i],E->slice.shflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Maxwelltime:Full_obsolete.c:  if (E->parallel.me_loc[3]==0)      {
Maxwelltime:Full_obsolete.c:    sprintf(output_file,"%s.botm.%d.%d",E->control.data_file,E->parallel.me,file_number);
Maxwelltime:Full_obsolete.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Full_obsolete.c:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Maxwelltime:Full_obsolete.c:      for(i=1;i<=E->lmesh.nsf;i++)  {
Maxwelltime:Full_obsolete.c:	s = (i-1)*E->lmesh.noz + 1;
Maxwelltime:Full_obsolete.c:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpgb[j][i],E->slice.bhflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Maxwelltime:Full_obsolete.c:/*   if (E->parallel.me<E->parallel.nprocz)  { */
Maxwelltime:Full_obsolete.c:/*     sprintf(output_file,"%s.ave_r.%d.%d",E->control.data_file,E->parallel.me,file_number); */
Maxwelltime:Full_obsolete.c:/*     for(j=1;j<=E->lmesh.noz;j++)  { */
Maxwelltime:Full_obsolete.c:/*         fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->sx[1][3][j],E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j]); */
Maxwelltime:Full_obsolete.c:  size2= (E->lmesh.nno+1)*sizeof(float);
Maxwelltime:Full_obsolete.c:  sprintf(output_file,"%s.%05d.SZZ",E->control.data_file,file_number);
Maxwelltime:Full_obsolete.c:  if (E->parallel.me==proc_loc)  {
Maxwelltime:Full_obsolete.c:     sprintf(output_file,"%s.%s_intp",E->control.data_file,filen);
Maxwelltime:Full_obsolete.c:     for (i=E->sphere.nox;i>=1;i--)
Maxwelltime:Full_obsolete.c:     for (j=1;j<=E->sphere.noy;j++)  {
Maxwelltime:Full_obsolete.c:        node = i + (j-1)*E->sphere.nox;
Maxwelltime:Full_obsolete.c:        t = 90-E->sphere.sx[1][node]*rad;
Maxwelltime:Full_obsolete.c:        f = E->sphere.sx[2][node]*rad;
Maxwelltime:Full_obsolete.c:     fprintf(E->fp,"lmaxx=%.4e lminx=%.4e for %s\n",maxx,minx,filen);
Maxwelltime:Full_obsolete.c:     sprintf(output_file,"%s.%s_sharm",E->control.data_file,filen);
Maxwelltime:Full_obsolete.c:     for (ll=0;ll<=E->output.llmax;ll++)
Maxwelltime:Full_obsolete.c:        i = E->sphere.hindex[ll][mm];
Maxwelltime:Full_obsolete.c:	    E->trace.Have_C=(double *)malloc((E->lmesh.noz+2)*sizeof(double));
Maxwelltime:Full_obsolete.c:	    E->trace.Havel_tracers=(double *)malloc((E->lmesh.elz+2)*sizeof(double));
Maxwelltime:Full_obsolete.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Full_obsolete.c:	    reltrac[j]=(double *) malloc((E->lmesh.nel+1)*sizeof(double));
Maxwelltime:Full_obsolete.c:	    for (kk=1;kk<=E->lmesh.nel;kk++)
Maxwelltime:Full_obsolete.c:		    reltrac[j][kk]=(1.0*E->composition.ieltrac[j][kk]);
Maxwelltime:Full_obsolete.c:    return_elementwise_horiz_ave(E,reltrac,E->trace.Havel_tracers);
Maxwelltime:Full_obsolete.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Full_obsolete.c:    if (E->parallel.me<E->parallel.nprocz)
Maxwelltime:Full_obsolete.c:	    sprintf(output_file,"%s.ave_tracers.%d.%d",E->control.data_file,E->parallel.me,E->monitor.solution_cycles);
Maxwelltime:Full_obsolete.c:	    for(kk=1;kk<=E->lmesh.elz;kk++)
Maxwelltime:Full_obsolete.c:		    halfpoint=0.5*(E->sx[1][3][kk+1]+E->sx[1][3][kk]);
Maxwelltime:Full_obsolete.c:		    fprintf(fp2,"%.4e %.4e\n",halfpoint,E->trace.Havel_tracers[kk]);
Maxwelltime:Full_obsolete.c:    if (E->composition.chemical_buoyancy==1)
Maxwelltime:Full_obsolete.c:	    return_horiz_ave(E,E->composition.comp_node,E->trace.Have_C);
Maxwelltime:Full_obsolete.c:	    if (E->parallel.me<E->parallel.nprocz)
Maxwelltime:Full_obsolete.c:		    sprintf(output_file,"%s.ave_c.%d.%d",E->control.data_file,E->parallel.me,E->monitor.solution_cycles);
Maxwelltime:Full_obsolete.c:		    for(kk=1;kk<=E->lmesh.noz;kk++)
Maxwelltime:Full_obsolete.c:			    fprintf(fp2,"%.4e %.4e\n",E->sx[1][3][kk],E->trace.Have_C[kk]);
Maxwelltime:Full_obsolete.c:    fprintf(E->trace.fpt,"ERROR(icheck_regular_neighbors)-this subroutine is no longer used !\n");
Maxwelltime:Full_obsolete.c:    fflush(E->trace.fpt);
Maxwelltime:Full_obsolete.c:                    if ( (new_ntheta>0)&&(new_ntheta<=E->trace.numtheta[j])&&(new_nphi>0)&&(new_nphi<=E->trace.numphi[j]) )
Maxwelltime:Full_obsolete.c:                            iregel=new_ntheta+(new_nphi-1)*E->trace.numtheta[j];
Maxwelltime:Full_obsolete.c:                            if ((iregel>0) && (iregel<=E->trace.numregel[j]))
Maxwelltime:Full_obsolete.c:    fprintf(E->trace.fpt,"ERROR(iquick element)-this routine is no longer used!\n");
Maxwelltime:Full_obsolete.c:    fflush(E->trace.fpt);
Maxwelltime:Full_obsolete.c:      fprintf(E->trace.fpt,"AA: ichoice: %d\n",ichoice);
Maxwelltime:Full_obsolete.c:      fflush(E->trace.fpt);
Maxwelltime:Full_obsolete.c:      iregnode[3]=iregel+nphi+E->trace.numtheta[j]+1;
Maxwelltime:Full_obsolete.c:      iregnode[4]=iregel+nphi+E->trace.numtheta[j];
Maxwelltime:Full_obsolete.c:    itemp2=itemp1+E->trace.numtheta[j];
Maxwelltime:Full_obsolete.c:            if ((iregnode[kk]<1) || (iregnode[kk]>E->trace.numregnodes[j]) )
Maxwelltime:Full_obsolete.c:                    fprintf(E->trace.fpt,"ERROR(iquick)-weird regnode %d\n",iregnode[kk]);
Maxwelltime:Full_obsolete.c:                    fflush(E->trace.fpt);
Maxwelltime:Full_obsolete.c:            if (E->trace.regnodetoel[j][iregnode[kk]]<=0) goto next_corner;
Maxwelltime:Full_obsolete.c:                    if (E->trace.regnodetoel[j][iregnode[kk]]==E->trace.regnodetoel[j][iregnode[pp]]) goto next_corner;
Maxwelltime:Full_obsolete.c:            imap[ichoice]=E->trace.regnodetoel[j][iregnode[kk]];
Maxwelltime:Full_obsolete.c:    E->trace.istat_ichoice[j][ichoice]++;
Maxwelltime:Full_parallel_related.c:  me = E->parallel.me;
Maxwelltime:Full_parallel_related.c:  if ( E->parallel.nprocx != E->parallel.nprocy ) {
Maxwelltime:Full_parallel_related.c:    if (E->parallel.me==0) fprintf(stderr,"!!!! nprocx must equal to nprocy \n");
Maxwelltime:Full_parallel_related.c:  surf_proc_per_cap = E->parallel.nprocx * E->parallel.nprocy;
Maxwelltime:Full_parallel_related.c:  proc_per_cap = surf_proc_per_cap * E->parallel.nprocz;
Maxwelltime:Full_parallel_related.c:  total_proc = E->sphere.caps * proc_per_cap;
Maxwelltime:Full_parallel_related.c:  E->parallel.total_surf_proc = E->sphere.caps * surf_proc_per_cap;
Maxwelltime:Full_parallel_related.c:  if ( total_proc != E->parallel.nproc ) {
Maxwelltime:Full_parallel_related.c:    if (E->parallel.me==0) fprintf(stderr,"!!!! # of requested CPU is incorrect \n");
Maxwelltime:Full_parallel_related.c:  E->sphere.caps_per_proc = max(1,E->sphere.caps*E->parallel.nprocz/E->parallel.nproc);
Maxwelltime:Full_parallel_related.c:  if (E->sphere.caps_per_proc > 1) {
Maxwelltime:Full_parallel_related.c:    if (E->parallel.me==0) fprintf(stderr,"!!!! # caps per proc > 1 is not supported.\n \n");
Maxwelltime:Full_parallel_related.c:  E->parallel.me_loc[3] = (me - cap_id_surf*proc_per_cap) % E->parallel.nprocz;
Maxwelltime:Full_parallel_related.c:  E->parallel.me_loc[1] = ((me - cap_id_surf*proc_per_cap - E->parallel.me_loc[3])/E->parallel.nprocz) % E->parallel.nprocx;
Maxwelltime:Full_parallel_related.c:  E->parallel.me_loc[2] = ((((me - cap_id_surf*proc_per_cap - E->parallel.me_loc[3])/E->parallel.nprocz) - E->parallel.me_loc[1])/E->parallel.nprocx) % E->parallel.nprocy;
Maxwelltime:Full_parallel_related.c:the second oordinate as fi, which goes E-W. Here we use R-L as the first
Maxwelltime:Full_parallel_related.c:[xyz] is x=E->parallel.me_loc[1],y=E->parallel.me_loc[2],z=E->parallel.me_loc[3]
Maxwelltime:Full_parallel_related.c:  i = cases[E->sphere.caps_per_proc]; /* 1 for more than 12 processors */
Maxwelltime:Full_parallel_related.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Full_parallel_related.c:    temp = pid_surf*E->sphere.caps_per_proc + j-1; /* cap number (out of 12) */
Maxwelltime:Full_parallel_related.c:    E->sphere.capid[j] = incases1[i].links[temp]; /* id (1~12) of the current cap */
Maxwelltime:Full_parallel_related.c:     E->sphere.max_connections = 8;
Maxwelltime:Full_parallel_related.c:  E->parallel.loc2proc_map = (int ****) malloc(E->sphere.caps*sizeof(int ***));
Maxwelltime:Full_parallel_related.c:  for (m=0;m<E->sphere.caps;m++)  {
Maxwelltime:Full_parallel_related.c:    E->parallel.loc2proc_map[m] = (int ***) malloc(E->parallel.nprocx*sizeof(int **));
Maxwelltime:Full_parallel_related.c:    for (i=0;i<E->parallel.nprocx;i++) {
Maxwelltime:Full_parallel_related.c:      E->parallel.loc2proc_map[m][i] = (int **) malloc(E->parallel.nprocy*sizeof(int *));
Maxwelltime:Full_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++)
Maxwelltime:Full_parallel_related.c:	E->parallel.loc2proc_map[m][i][j] = (int *) malloc(E->parallel.nprocz*sizeof(int));
Maxwelltime:Full_parallel_related.c:  for (m=0;m<E->sphere.caps;m++)
Maxwelltime:Full_parallel_related.c:    for (i=0;i<E->parallel.nprocx;i++)
Maxwelltime:Full_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++)
Maxwelltime:Full_parallel_related.c:	for (k=0;k<E->parallel.nprocz;k++) {
Maxwelltime:Full_parallel_related.c:	  if (E->sphere.caps_per_proc>1) {
Maxwelltime:Full_parallel_related.c:	    temp = cases[E->sphere.caps_per_proc];
Maxwelltime:Full_parallel_related.c:	    E->parallel.loc2proc_map[m][i][j][k] = incases2[temp].links[m-1];
Maxwelltime:Full_parallel_related.c:	    E->parallel.loc2proc_map[m][i][j][k] = m*proc_per_cap
Maxwelltime:Full_parallel_related.c:	      + j*E->parallel.nprocx*E->parallel.nprocz
Maxwelltime:Full_parallel_related.c:	      + i*E->parallel.nprocz + k;
Maxwelltime:Full_parallel_related.c:  if (E->control.verbose) {
Maxwelltime:Full_parallel_related.c:    fprintf(E->fp_out,"me=%d loc1=%d loc2=%d loc3=%d\n",me,E->parallel.me_loc[1],E->parallel.me_loc[2],E->parallel.me_loc[3]);
Maxwelltime:Full_parallel_related.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Full_parallel_related.c:      fprintf(E->fp_out,"capid[%d]=%d \n",j,E->sphere.capid[j]);
Maxwelltime:Full_parallel_related.c:    for (m=0;m<E->sphere.caps;m++)
Maxwelltime:Full_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++)
Maxwelltime:Full_parallel_related.c:	for (i=0;i<E->parallel.nprocx;i++)
Maxwelltime:Full_parallel_related.c:	  for (k=0;k<E->parallel.nprocz;k++)
Maxwelltime:Full_parallel_related.c:	    fprintf(E->fp_out,"loc2proc_map[cap=%d][x=%d][y=%d][z=%d] = %d\n",
Maxwelltime:Full_parallel_related.c:		    m,i,j,k,E->parallel.loc2proc_map[m][i][j][k]);
Maxwelltime:Full_parallel_related.c:    fflush(E->fp_out);
Maxwelltime:Full_parallel_related.c:  E->exchange_node_d = exchange_node_d;
Maxwelltime:Full_parallel_related.c:  E->exchange_node_f = exchange_node_f;
Maxwelltime:Full_parallel_related.c:  processors = (int *) malloc((E->parallel.total_surf_proc+1)*sizeof(int));
Maxwelltime:Full_parallel_related.c:  k = E->parallel.me_loc[3];
Maxwelltime:Full_parallel_related.c:  for (m=0;m<E->sphere.caps;m++)
Maxwelltime:Full_parallel_related.c:    for (i=0;i<E->parallel.nprocx;i++)
Maxwelltime:Full_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++) {
Maxwelltime:Full_parallel_related.c:	processors[n] = E->parallel.loc2proc_map[m][i][j][k];
Maxwelltime:Full_parallel_related.c:  MPI_Comm_group(E->parallel.world, &world_g);
Maxwelltime:Full_parallel_related.c:  MPI_Group_incl(world_g, E->parallel.total_surf_proc, processors, &horizon_g);
Maxwelltime:Full_parallel_related.c:  MPI_Comm_create(E->parallel.world, horizon_g, &(E->parallel.horizontal_comm));
Maxwelltime:Full_parallel_related.c:  if (E->control.verbose) {
Maxwelltime:Full_parallel_related.c:    fprintf(E->fp_out,"horizontal group of me=%d loc3=%d\n",E->parallel.me,E->parallel.me_loc[3]);
Maxwelltime:Full_parallel_related.c:    for (j=0;j<E->parallel.total_surf_proc;j++) {
Maxwelltime:Full_parallel_related.c:      fprintf(E->fp_out,"%d proc=%d\n",j,processors[j]);
Maxwelltime:Full_parallel_related.c:    fflush(E->fp_out);
Maxwelltime:Full_parallel_related.c:  processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Maxwelltime:Full_parallel_related.c:  m = E->sphere.capid[1] - 1;  /* assume 1 cap per proc. */
Maxwelltime:Full_parallel_related.c:  i = E->parallel.me_loc[1];
Maxwelltime:Full_parallel_related.c:  j = E->parallel.me_loc[2];
Maxwelltime:Full_parallel_related.c:  for (k=0;k<E->parallel.nprocz;k++) {
Maxwelltime:Full_parallel_related.c:      processors[k] = E->parallel.loc2proc_map[m][i][j][k];
Maxwelltime:Full_parallel_related.c:  MPI_Comm_group(E->parallel.world, &world_g);
Maxwelltime:Full_parallel_related.c:  MPI_Group_incl(world_g, E->parallel.nprocz, processors, &vertical_g);
Maxwelltime:Full_parallel_related.c:  MPI_Comm_create(E->parallel.world, vertical_g, &(E->parallel.vertical_comm));
Maxwelltime:Full_parallel_related.c:  if (E->control.verbose) {
Maxwelltime:Full_parallel_related.c:    fprintf(E->fp_out,"vertical group of me=%d loc1=%d loc2=%d\n",E->parallel.me,E->parallel.me_loc[1],E->parallel.me_loc[2]);
Maxwelltime:Full_parallel_related.c:    for (j=0;j<E->parallel.nprocz;j++) {
Maxwelltime:Full_parallel_related.c:      fprintf(E->fp_out,"%d proc=%d\n",j,processors[j]);
Maxwelltime:Full_parallel_related.c:    fflush(E->fp_out);
Maxwelltime:Full_parallel_related.c:  me = E->parallel.me;
Maxwelltime:Full_parallel_related.c:  E->lmesh.elx = E->mesh.elx/E->parallel.nprocx;
Maxwelltime:Full_parallel_related.c:  E->lmesh.elz = E->mesh.elz/E->parallel.nprocz;
Maxwelltime:Full_parallel_related.c:  E->lmesh.ely = E->mesh.ely/E->parallel.nprocy;
Maxwelltime:Full_parallel_related.c:  E->lmesh.nox = E->lmesh.elx + 1;
Maxwelltime:Full_parallel_related.c:  E->lmesh.noz = E->lmesh.elz + 1;
Maxwelltime:Full_parallel_related.c:  E->lmesh.noy = E->lmesh.ely + 1;
Maxwelltime:Full_parallel_related.c:  E->lmesh.exs = E->parallel.me_loc[1]*E->lmesh.elx;
Maxwelltime:Full_parallel_related.c:  E->lmesh.eys = E->parallel.me_loc[2]*E->lmesh.ely;
Maxwelltime:Full_parallel_related.c:  E->lmesh.ezs = E->parallel.me_loc[3]*E->lmesh.elz;
Maxwelltime:Full_parallel_related.c:  E->lmesh.nxs = E->parallel.me_loc[1]*E->lmesh.elx+1;
Maxwelltime:Full_parallel_related.c:  E->lmesh.nys = E->parallel.me_loc[2]*E->lmesh.ely+1;
Maxwelltime:Full_parallel_related.c:  E->lmesh.nzs = E->parallel.me_loc[3]*E->lmesh.elz+1;
Maxwelltime:Full_parallel_related.c:  E->lmesh.nno = E->lmesh.noz*E->lmesh.nox*E->lmesh.noy;
Maxwelltime:Full_parallel_related.c:  E->lmesh.nel = E->lmesh.ely*E->lmesh.elx*E->lmesh.elz;
Maxwelltime:Full_parallel_related.c:  E->lmesh.npno = E->lmesh.nel;
Maxwelltime:Full_parallel_related.c:  E->lmesh.nsf = E->lmesh.nno/E->lmesh.noz;
Maxwelltime:Full_parallel_related.c:  E->lmesh.snel = E->lmesh.elx*E->lmesh.ely;
Maxwelltime:Full_parallel_related.c:  for(i=E->mesh.levmax;i>=E->mesh.levmin;i--)   {
Maxwelltime:Full_parallel_related.c:     if (E->control.NMULTIGRID)  {
Maxwelltime:Full_parallel_related.c:        nox = E->lmesh.elx/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Maxwelltime:Full_parallel_related.c:        noy = E->lmesh.ely/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Maxwelltime:Full_parallel_related.c:        noz = E->lmesh.elz/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Maxwelltime:Full_parallel_related.c:        E->parallel.redundant[i]=0;
Maxwelltime:Full_parallel_related.c:        { noz = E->lmesh.noz;
Maxwelltime:Full_parallel_related.c:          noy = E->lmesh.noy;
Maxwelltime:Full_parallel_related.c:          nox = E->lmesh.nox;
Maxwelltime:Full_parallel_related.c:     E->lmesh.ELX[i] = nox-1;
Maxwelltime:Full_parallel_related.c:     E->lmesh.ELY[i] = noy-1;
Maxwelltime:Full_parallel_related.c:     E->lmesh.ELZ[i] = noz-1;
Maxwelltime:Full_parallel_related.c:     E->lmesh.NOZ[i] = noz;
Maxwelltime:Full_parallel_related.c:     E->lmesh.NOY[i] = noy;
Maxwelltime:Full_parallel_related.c:     E->lmesh.NOX[i] = nox;
Maxwelltime:Full_parallel_related.c:     E->lmesh.NNO[i] = nox * noz * noy;
Maxwelltime:Full_parallel_related.c:     E->lmesh.NNOV[i] = E->lmesh.NNO[i];
Maxwelltime:Full_parallel_related.c:     E->lmesh.SNEL[i] = E->lmesh.ELX[i]*E->lmesh.ELY[i];
Maxwelltime:Full_parallel_related.c:     E->lmesh.NEL[i] = (nox-1) * (noz-1) * (noy-1);
Maxwelltime:Full_parallel_related.c:     E->lmesh.NPNO[i] = E->lmesh.NEL[i] ;
Maxwelltime:Full_parallel_related.c:     E->lmesh.NEQ[i] = E->mesh.nsd * E->lmesh.NNOV[i] ;
Maxwelltime:Full_parallel_related.c:     E->lmesh.EXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i];
Maxwelltime:Full_parallel_related.c:     E->lmesh.EYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i];
Maxwelltime:Full_parallel_related.c:     E->lmesh.EZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i];
Maxwelltime:Full_parallel_related.c:     E->lmesh.NXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i]+1;
Maxwelltime:Full_parallel_related.c:     E->lmesh.NYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i]+1;
Maxwelltime:Full_parallel_related.c:     E->lmesh.NZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i]+1;
Maxwelltime:Full_parallel_related.c:fprintf(stderr,"b %d %d %d %d %d %d %d\n",E->parallel.me,E->parallel.me_loc[1],E->parallel.me_loc[2],E->parallel.me_loc[3],E->lmesh.nzs,E->lmesh.nys,E->lmesh.noy);
Maxwelltime:Full_parallel_related.c:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)   {
Maxwelltime:Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_parallel_related.c:      nel = E->lmesh.NEL[lev];
Maxwelltime:Full_parallel_related.c:      elx = E->lmesh.ELX[lev];
Maxwelltime:Full_parallel_related.c:      elz = E->lmesh.ELZ[lev];
Maxwelltime:Full_parallel_related.c:      ely = E->lmesh.ELY[lev];
Maxwelltime:Full_parallel_related.c:      nox = E->lmesh.NOX[lev];
Maxwelltime:Full_parallel_related.c:      noy = E->lmesh.NOY[lev];
Maxwelltime:Full_parallel_related.c:      noz = E->lmesh.NOZ[lev];
Maxwelltime:Full_parallel_related.c:      nno = E->lmesh.NNO[lev];
Maxwelltime:Full_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] =  node;
Maxwelltime:Full_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Maxwelltime:Full_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Maxwelltime:Full_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] =  node;
Maxwelltime:Full_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Maxwelltime:Full_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Maxwelltime:Full_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Maxwelltime:Full_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Maxwelltime:Full_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Maxwelltime:Full_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Maxwelltime:Full_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Maxwelltime:Full_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Maxwelltime:Full_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Maxwelltime:Full_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Maxwelltime:Full_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Maxwelltime:Full_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Maxwelltime:Full_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Maxwelltime:Full_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Maxwelltime:Full_parallel_related.c:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[2];lnode++) {
Maxwelltime:Full_parallel_related.c:          node = E->parallel.NODE[lev][m][lnode].bound[2];
Maxwelltime:Full_parallel_related.c:          E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Maxwelltime:Full_parallel_related.c:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[3];lnode++) {
Maxwelltime:Full_parallel_related.c:          node = E->parallel.NODE[lev][m][lnode].bound[3];
Maxwelltime:Full_parallel_related.c:          E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Maxwelltime:Full_parallel_related.c:      if (E->sphere.capid[m] == 1 &&
Maxwelltime:Full_parallel_related.c:          E->parallel.me_loc[1] == 0 &&
Maxwelltime:Full_parallel_related.c:          E->parallel.me_loc[2] == 0)
Maxwelltime:Full_parallel_related.c:              E->NODE[lev][m][node] = E->NODE[lev][m][node] & ~SKIP;
Maxwelltime:Full_parallel_related.c:      if (E->sphere.capid[m] == E->sphere.caps &&
Maxwelltime:Full_parallel_related.c:          E->parallel.me_loc[1] == E->parallel.nprocx-1 &&
Maxwelltime:Full_parallel_related.c:          E->parallel.me_loc[2] == E->parallel.nprocy-1)
Maxwelltime:Full_parallel_related.c:              E->NODE[lev][m][node] = E->NODE[lev][m][node] & ~SKIP;
Maxwelltime:Full_parallel_related.c:      if (E->parallel.me_loc[3]!=E->parallel.nprocz-1 )
Maxwelltime:Full_parallel_related.c:          for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[6];lnode++) {
Maxwelltime:Full_parallel_related.c:              node = E->parallel.NODE[lev][m][lnode].bound[6];
Maxwelltime:Full_parallel_related.c:              E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Maxwelltime:Full_parallel_related.c:if (E->control.verbose) {
Maxwelltime:Full_parallel_related.c: fprintf(E->fp_out,"output_shared_nodes %d \n",E->parallel.me);
Maxwelltime:Full_parallel_related.c: for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Maxwelltime:Full_parallel_related.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)      {
Maxwelltime:Full_parallel_related.c:    fprintf(E->fp_out,"lev=%d  me=%d capid=%d m=%d \n",lev,E->parallel.me,E->sphere.capid[m],m);
Maxwelltime:Full_parallel_related.c:      for (i=1;i<=E->parallel.NUM_NNO[lev][m].bound[ii];i++)
Maxwelltime:Full_parallel_related.c:        fprintf(E->fp_out,"ii=%d   %d %d \n",ii,i,E->parallel.NODE[lev][m][i].bound[ii]);
Maxwelltime:Full_parallel_related.c:    for (node=1;node<=E->lmesh.NNO[lev];node++)
Maxwelltime:Full_parallel_related.c:      if((E->NODE[lev][m][node] & SKIP)) {
Maxwelltime:Full_parallel_related.c:        fprintf(E->fp_out,"skip %d %d \n",lnode,node);
Maxwelltime:Full_parallel_related.c: fflush(E->fp_out);
Maxwelltime:Full_parallel_related.c:  const int dims=E->mesh.nsd;
Maxwelltime:Full_parallel_related.c:  me = E->parallel.me;
Maxwelltime:Full_parallel_related.c:  nprocx = E->parallel.nprocx;
Maxwelltime:Full_parallel_related.c:  nprocy = E->parallel.nprocy;
Maxwelltime:Full_parallel_related.c:  nprocz = E->parallel.nprocz;
Maxwelltime:Full_parallel_related.c:  tscaps = E->parallel.total_surf_proc;
Maxwelltime:Full_parallel_related.c:  lx = E->parallel.me_loc[1];
Maxwelltime:Full_parallel_related.c:  ly = E->parallel.me_loc[2];
Maxwelltime:Full_parallel_related.c:  lz = E->parallel.me_loc[3];
Maxwelltime:Full_parallel_related.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Maxwelltime:Full_parallel_related.c:    nox = E->lmesh.NOX[lev];
Maxwelltime:Full_parallel_related.c:    noz = E->lmesh.NOZ[lev];
Maxwelltime:Full_parallel_related.c:    noy = E->lmesh.NOY[lev];
Maxwelltime:Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Full_parallel_related.c:      cap = E->sphere.capid[m] - 1;  /* which cap I am in (0~11) */
Maxwelltime:Full_parallel_related.c:	target = E->parallel.loc2proc_map[cap][lx-1][ly][lz];
Maxwelltime:Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][nprocx-1][ly][lz];
Maxwelltime:Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][ly][0][lz];
Maxwelltime:Full_parallel_related.c:      E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Maxwelltime:Full_parallel_related.c:	target = E->parallel.loc2proc_map[cap][lx+1][ly][lz];
Maxwelltime:Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][0][ly][lz];
Maxwelltime:Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][ly][nprocy-1][lz];
Maxwelltime:Full_parallel_related.c:      E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Maxwelltime:Full_parallel_related.c:	target = E->parallel.loc2proc_map[cap][lx][ly-1][lz];
Maxwelltime:Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][lx][nprocy-1][lz];
Maxwelltime:Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][0][lx][lz];
Maxwelltime:Full_parallel_related.c:      E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Maxwelltime:Full_parallel_related.c:	target = E->parallel.loc2proc_map[cap][lx][ly+1][lz];
Maxwelltime:Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][lx][0][lz];
Maxwelltime:Full_parallel_related.c:	  target = E->parallel.loc2proc_map[temp][nprocx-1][lx][lz];
Maxwelltime:Full_parallel_related.c:      E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Maxwelltime:Full_parallel_related.c:	    target = E->parallel.loc2proc_map[temp][lx][ly][lz];
Maxwelltime:Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[1] - nprocz;
Maxwelltime:Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[3] - nprocxz;
Maxwelltime:Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[1] - nprocxz;
Maxwelltime:Full_parallel_related.c:	  E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Maxwelltime:Full_parallel_related.c:	    target = E->parallel.loc2proc_map[temp][lx][ly][lz];
Maxwelltime:Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[2] + nprocz;
Maxwelltime:Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[4] + nprocxz;
Maxwelltime:Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[2] + nprocxz;
Maxwelltime:Full_parallel_related.c:	  E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Maxwelltime:Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[4] - nprocxz;
Maxwelltime:Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[1] + nprocz;
Maxwelltime:Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[1] + nprocxz;
Maxwelltime:Full_parallel_related.c:	  E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Maxwelltime:Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[2] - nprocz;
Maxwelltime:Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[3] + nprocxz;
Maxwelltime:Full_parallel_related.c:	    target = E->parallel.PROCESSOR[lev][m].pass[2] - nprocxz;
Maxwelltime:Full_parallel_related.c:	  E->parallel.PROCESSOR[lev][m].pass[npass] = target;
Maxwelltime:Full_parallel_related.c:      E->parallel.TNUM_PASS[lev][m] = npass;
Maxwelltime:Full_parallel_related.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Maxwelltime:Full_parallel_related.c:      E->parallel.NUM_PASSz[lev].bound[ii] = 1;
Maxwelltime:Full_parallel_related.c:	E->parallel.NUM_PASSz[lev].bound[ii] = 0;
Maxwelltime:Full_parallel_related.c:	E->parallel.NUM_PASSz[lev].bound[ii] = 0;
Maxwelltime:Full_parallel_related.c:      for (p=1;p<=E->parallel.NUM_PASSz[lev].bound[ii];p++)  {
Maxwelltime:Full_parallel_related.c:	kkkp = kkk + E->sphere.max_connections;
Maxwelltime:Full_parallel_related.c:	E->parallel.NUM_NODEz[lev].pass[kkk] = 0;
Maxwelltime:Full_parallel_related.c:	E->parallel.NUM_NEQz[lev].pass[kkk] = 0;
Maxwelltime:Full_parallel_related.c:	for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Full_parallel_related.c:	  cap = E->sphere.capid[m] - 1;  /* which cap I am in (0~11) */
Maxwelltime:Full_parallel_related.c:	  E->parallel.PROCESSORz[lev].pass[kkk] =
Maxwelltime:Full_parallel_related.c:	    E->parallel.loc2proc_map[cap][lx][ly][lz+((ii==5)?-1:1)];
Maxwelltime:Full_parallel_related.c:	  for (k=1;k<=E->parallel.NUM_NNO[lev][m].bound[ii];k++)   {
Maxwelltime:Full_parallel_related.c:	    node = E->parallel.NODE[lev][m][k].bound[ii];
Maxwelltime:Full_parallel_related.c:	    E->parallel.EXCHANGE_NODE[lev][m][++kk].pass[kkkp] = node;
Maxwelltime:Full_parallel_related.c:	      E->parallel.EXCHANGE_ID[lev][m][++jj].pass[kkkp] =
Maxwelltime:Full_parallel_related.c:		E->ID[lev][m][node].doff[doff];
Maxwelltime:Full_parallel_related.c:	  E->parallel.NUM_NODE[lev][m].pass[kkkp] = kk;
Maxwelltime:Full_parallel_related.c:	  E->parallel.NUM_NEQ[lev][m].pass[kkkp] = jj;
Maxwelltime:Full_parallel_related.c:	  E->parallel.NUM_NODEz[lev].pass[kkk] += kk;
Maxwelltime:Full_parallel_related.c:	  E->parallel.NUM_NEQz[lev].pass[kkk] += jj;
Maxwelltime:Full_parallel_related.c:    E->parallel.TNUM_PASSz[lev] = kkk;
Maxwelltime:Full_parallel_related.c:  if(E->control.verbose) {
Maxwelltime:Full_parallel_related.c:    for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Maxwelltime:Full_parallel_related.c:      fprintf(E->fp_out,"output_communication route surface for lev=%d \n",lev);
Maxwelltime:Full_parallel_related.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Full_parallel_related.c:	fprintf(E->fp_out,"  me= %d cap=%d pass  %d \n",E->parallel.me,E->sphere.capid[m],E->parallel.TNUM_PASS[lev][m]);
Maxwelltime:Full_parallel_related.c:	for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Maxwelltime:Full_parallel_related.c:	  fprintf(E->fp_out,"proc %d and pass  %d to proc %d with %d eqn and %d node\n",E->parallel.me,k,E->parallel.PROCESSOR[lev][m].pass[k],E->parallel.NUM_NEQ[lev][m].pass[k],E->parallel.NUM_NODE[lev][m].pass[k]);
Maxwelltime:Full_parallel_related.c:	  fprintf(E->fp_out,"Eqn:\n");  
Maxwelltime:Full_parallel_related.c:	  for (ii=1;ii<=E->parallel.NUM_NEQ[lev][m].pass[k];ii++)  
Maxwelltime:Full_parallel_related.c:	    fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_ID[lev][m][ii].pass[k]);  
Maxwelltime:Full_parallel_related.c:	  fprintf(E->fp_out,"Node:\n");  
Maxwelltime:Full_parallel_related.c:	  for (ii=1;ii<=E->parallel.NUM_NODE[lev][m].pass[k];ii++)  
Maxwelltime:Full_parallel_related.c:	    fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_NODE[lev][m][ii].pass[k]);  
Maxwelltime:Full_parallel_related.c:      fprintf(E->fp_out,"output_communication route vertical \n");
Maxwelltime:Full_parallel_related.c:      fprintf(E->fp_out," me= %d pass  %d \n",E->parallel.me,E->parallel.TNUM_PASSz[lev]);
Maxwelltime:Full_parallel_related.c:      for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)   {
Maxwelltime:Full_parallel_related.c:	kkkp = k + E->sphere.max_connections;
Maxwelltime:Full_parallel_related.c:	fprintf(E->fp_out,"proc %d and pass  %d to proc %d\n",E->parallel.me,k,E->parallel.PROCESSORz[lev].pass[k]);
Maxwelltime:Full_parallel_related.c:	for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Full_parallel_related.c:	  fprintf(E->fp_out,"cap=%d eqn=%d node=%d\n",E->sphere.capid[m],E->parallel.NUM_NEQ[lev][m].pass[kkkp],E->parallel.NUM_NODE[lev][m].pass[kkkp]);
Maxwelltime:Full_parallel_related.c:	  for (ii=1;ii<=E->parallel.NUM_NEQ[lev][m].pass[kkkp];ii++) 
Maxwelltime:Full_parallel_related.c:	    fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_ID[lev][m][ii].pass[kkkp]); 
Maxwelltime:Full_parallel_related.c:	  for (ii=1;ii<=E->parallel.NUM_NODE[lev][m].pass[kkkp];ii++) 
Maxwelltime:Full_parallel_related.c:	    fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_NODE[lev][m][ii].pass[kkkp]); 
Maxwelltime:Full_parallel_related.c:    fflush(E->fp_out);
Maxwelltime:Full_parallel_related.c:  const int dims=E->mesh.nsd;
Maxwelltime:Full_parallel_related.c:  me = E->parallel.me;
Maxwelltime:Full_parallel_related.c:  nprocz = E->parallel.nprocz;
Maxwelltime:Full_parallel_related.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Maxwelltime:Full_parallel_related.c:    nox = E->lmesh.NOX[lev];
Maxwelltime:Full_parallel_related.c:    noz = E->lmesh.NOZ[lev];
Maxwelltime:Full_parallel_related.c:    noy = E->lmesh.NOY[lev];
Maxwelltime:Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Full_parallel_related.c:      j = E->sphere.capid[m];
Maxwelltime:Full_parallel_related.c:      for (kkk=1;kkk<=E->parallel.TNUM_PASS[lev][m];kkk++) {
Maxwelltime:Full_parallel_related.c:          E->parallel.NUM_sNODE[lev][m].pass[kkk] =
Maxwelltime:Full_parallel_related.c:                           E->parallel.NUM_NNO[lev][m].bound[ii]/noz;
Maxwelltime:Full_parallel_related.c:          for (k=1;k<=E->parallel.NUM_sNODE[lev][m].pass[kkk];k++)   {
Maxwelltime:Full_parallel_related.c:            node = (E->parallel.NODE[lev][m][lnode].bound[ii]-1)/noz + 1;
Maxwelltime:Full_parallel_related.c:            E->parallel.EXCHANGE_sNODE[lev][m][k].pass[kkk] = node;
Maxwelltime:Full_parallel_related.c:          E->parallel.NUM_sNODE[lev][m].pass[kkk]=1;
Maxwelltime:Full_parallel_related.c:          for (k=1;k<=E->parallel.NUM_sNODE[lev][m].pass[kkk];k++)   {
Maxwelltime:Full_parallel_related.c:            node = E->parallel.EXCHANGE_NODE[lev][m][k].pass[kkk]/noz + 1;
Maxwelltime:Full_parallel_related.c:            E->parallel.EXCHANGE_sNODE[lev][m][k].pass[kkk] = node;
Maxwelltime:Full_parallel_related.c:  if(E->control.verbose) {
Maxwelltime:Full_parallel_related.c:    for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Maxwelltime:Full_parallel_related.c:      fprintf(E->fp_out,"output_communication route surface for lev=%d \n",lev);
Maxwelltime:Full_parallel_related.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Full_parallel_related.c:	fprintf(E->fp_out,"  me= %d cap=%d pass  %d \n",E->parallel.me,E->sphere.capid[m],E->parallel.TNUM_PASS[lev][m]);
Maxwelltime:Full_parallel_related.c:	for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++) {
Maxwelltime:Full_parallel_related.c:	  fprintf(E->fp_out,"proc %d and pass  %d to proc %d with %d node\n",E->parallel.me,k,E->parallel.PROCESSOR[lev][m].pass[k],E->parallel.NUM_sNODE[lev][m].pass[k]);
Maxwelltime:Full_parallel_related.c:	  fprintf(E->fp_out,"Node:\n");
Maxwelltime:Full_parallel_related.c:	  for (ii=1;ii<=E->parallel.NUM_sNODE[lev][m].pass[k];ii++)
Maxwelltime:Full_parallel_related.c:	    fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_sNODE[lev][m][ii].pass[k]);
Maxwelltime:Full_parallel_related.c:    fflush(E->fp_out);
Maxwelltime:Full_parallel_related.c:  const int dims=E->mesh.nsd;
Maxwelltime:Full_parallel_related.c:  E->parallel.NUM_NODE[lev][m].pass[npass] = E->parallel.NUM_NNO[lev][m].bound[bd];
Maxwelltime:Full_parallel_related.c:  for (kk=1;kk<=E->parallel.NUM_NODE[lev][m].pass[npass];kk++)   {
Maxwelltime:Full_parallel_related.c:    node = E->parallel.NODE[lev][m][kk].bound[bd];
Maxwelltime:Full_parallel_related.c:    E->parallel.EXCHANGE_NODE[lev][m][kk].pass[npass] = node;
Maxwelltime:Full_parallel_related.c:      E->parallel.EXCHANGE_ID[lev][m][++jj].pass[npass] = E->ID[lev][m][node].doff[doff];
Maxwelltime:Full_parallel_related.c:  E->parallel.NUM_NEQ[lev][m].pass[npass] = jj;
Maxwelltime:Full_parallel_related.c:  const int dims=E->mesh.nsd;
Maxwelltime:Full_parallel_related.c:  E->parallel.NUM_NODE[lev][m].pass[npass] = num_node;
Maxwelltime:Full_parallel_related.c:  for (kk=1;kk<=E->parallel.NUM_NODE[lev][m].pass[npass];kk++)   {
Maxwelltime:Full_parallel_related.c:    E->parallel.EXCHANGE_NODE[lev][m][kk].pass[npass] = node;
Maxwelltime:Full_parallel_related.c:      E->parallel.EXCHANGE_ID[lev][m][++jj].pass[npass] = E->ID[lev][m][node].doff[doff];
Maxwelltime:Full_parallel_related.c:  E->parallel.NUM_NEQ[lev][m].pass[npass] = jj;
Maxwelltime:Full_parallel_related.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Full_parallel_related.c:     for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Maxwelltime:Full_parallel_related.c:       sizeofk = (1+E->parallel.NUM_NEQ[lev][m].pass[k])*sizeof(double);
Maxwelltime:Full_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Full_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Maxwelltime:Full_parallel_related.c:     sizeofk = (1+E->parallel.NUM_NEQ[lev][m].pass[k])*sizeof(double);
Maxwelltime:Full_parallel_related.c: for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Maxwelltime:Full_parallel_related.c:   kk = (1+E->parallel.NUM_NEQz[lev].pass[k])*sizeof(double);
Maxwelltime:Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)     {
Maxwelltime:Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[k];j++) {
Maxwelltime:Full_parallel_related.c:        S[k][j-1] = U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[k] ];
Maxwelltime:Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k] != E->parallel.me &&
Maxwelltime:Full_parallel_related.c:	  E->parallel.PROCESSOR[lev][m].pass[k] != -1) {
Maxwelltime:Full_parallel_related.c:          MPI_Isend(S[k], E->parallel.NUM_NEQ[lev][m].pass[k], MPI_DOUBLE,
Maxwelltime:Full_parallel_related.c:		    E->parallel.PROCESSOR[lev][m].pass[k], 1,
Maxwelltime:Full_parallel_related.c:		    E->parallel.world, &request[idb-1]);
Maxwelltime:Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Maxwelltime:Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k] != E->parallel.me &&
Maxwelltime:Full_parallel_related.c:	  E->parallel.PROCESSOR[lev][m].pass[k] != -1) {
Maxwelltime:Full_parallel_related.c:	 MPI_Irecv(R[k],E->parallel.NUM_NEQ[lev][m].pass[k], MPI_DOUBLE,
Maxwelltime:Full_parallel_related.c:		   E->parallel.PROCESSOR[lev][m].pass[k], 1,
Maxwelltime:Full_parallel_related.c:		   E->parallel.world, &request[idb-1]);
Maxwelltime:Full_parallel_related.c:	for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[k];j++)
Maxwelltime:Full_parallel_related.c:           U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[k] ] += S[k][j-1];
Maxwelltime:Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Maxwelltime:Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k] != E->parallel.me &&
Maxwelltime:Full_parallel_related.c:	  E->parallel.PROCESSOR[lev][m].pass[k] != -1) {
Maxwelltime:Full_parallel_related.c:	for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[k];j++)
Maxwelltime:Full_parallel_related.c:	  U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[k] ] += R[k][j-1];
Maxwelltime:Full_parallel_related.c:  for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Maxwelltime:Full_parallel_related.c:    kk = k + E->sphere.max_connections;
Maxwelltime:Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[kk];j++)
Maxwelltime:Full_parallel_related.c:        SV[jj++] = U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[kk] ];
Maxwelltime:Full_parallel_related.c:    MPI_Sendrecv(SV, E->parallel.NUM_NEQz[lev].pass[k], MPI_DOUBLE,
Maxwelltime:Full_parallel_related.c:		 E->parallel.PROCESSORz[lev].pass[k], 1,
Maxwelltime:Full_parallel_related.c:                 RV, E->parallel.NUM_NEQz[lev].pass[k], MPI_DOUBLE,
Maxwelltime:Full_parallel_related.c:		 E->parallel.PROCESSORz[lev].pass[k], 1,
Maxwelltime:Full_parallel_related.c:		 E->parallel.world, &status1);
Maxwelltime:Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[kk];j++)
Maxwelltime:Full_parallel_related.c:        U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[kk] ] += RV[jj++];
Maxwelltime:Full_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Full_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Maxwelltime:Full_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Full_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Maxwelltime:Full_parallel_related.c:     sizeofk = (1+E->parallel.NUM_NODE[lev][m].pass[k])*sizeof(double);
Maxwelltime:Full_parallel_related.c: for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Maxwelltime:Full_parallel_related.c:   sizeofk = (1+E->parallel.NUM_NODEz[lev].pass[k])*sizeof(double);
Maxwelltime:Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)     {
Maxwelltime:Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Maxwelltime:Full_parallel_related.c:        S[kk][j-1] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ];
Maxwelltime:Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me) {
Maxwelltime:Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Maxwelltime:Full_parallel_related.c:        MPI_Isend(S[kk],E->parallel.NUM_NODE[lev][m].pass[k],MPI_DOUBLE,
Maxwelltime:Full_parallel_related.c:             E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Maxwelltime:Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Maxwelltime:Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)  {
Maxwelltime:Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Maxwelltime:Full_parallel_related.c:         MPI_Irecv(R[kk],E->parallel.NUM_NODE[lev][m].pass[k],MPI_DOUBLE,
Maxwelltime:Full_parallel_related.c:         E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Maxwelltime:Full_parallel_related.c:         for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Maxwelltime:Full_parallel_related.c:           U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += S[kk][j-1];
Maxwelltime:Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Maxwelltime:Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)
Maxwelltime:Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Maxwelltime:Full_parallel_related.c:        for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Maxwelltime:Full_parallel_related.c:           U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += R[kk][j-1];
Maxwelltime:Full_parallel_related.c:  for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Maxwelltime:Full_parallel_related.c:    kk = k + E->sphere.max_connections;
Maxwelltime:Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[kk];j++)
Maxwelltime:Full_parallel_related.c:        SV[jj++] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[kk] ];
Maxwelltime:Full_parallel_related.c:    MPI_Sendrecv(SV,E->parallel.NUM_NODEz[lev].pass[k],MPI_DOUBLE,
Maxwelltime:Full_parallel_related.c:             E->parallel.PROCESSORz[lev].pass[k],1,
Maxwelltime:Full_parallel_related.c:                 RV,E->parallel.NUM_NODEz[lev].pass[k],MPI_DOUBLE,
Maxwelltime:Full_parallel_related.c:             E->parallel.PROCESSORz[lev].pass[k],1,E->parallel.world,&status1);
Maxwelltime:Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[kk];j++)
Maxwelltime:Full_parallel_related.c:        U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[kk] ] += RV[jj++];
Maxwelltime:Full_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Full_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Maxwelltime:Full_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Full_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Maxwelltime:Full_parallel_related.c:     sizeofk = (1+E->parallel.NUM_NODE[lev][m].pass[k])*sizeof(float);
Maxwelltime:Full_parallel_related.c: for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Maxwelltime:Full_parallel_related.c:   sizeofk = (1+E->parallel.NUM_NODEz[lev].pass[k])*sizeof(float);
Maxwelltime:Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)     {
Maxwelltime:Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Maxwelltime:Full_parallel_related.c:        S[kk][j-1] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ];
Maxwelltime:Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me) {
Maxwelltime:Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Maxwelltime:Full_parallel_related.c:        MPI_Isend(S[kk],E->parallel.NUM_NODE[lev][m].pass[k],MPI_FLOAT,
Maxwelltime:Full_parallel_related.c:             E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Maxwelltime:Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Maxwelltime:Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)  {
Maxwelltime:Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Maxwelltime:Full_parallel_related.c:         MPI_Irecv(R[kk],E->parallel.NUM_NODE[lev][m].pass[k],MPI_FLOAT,
Maxwelltime:Full_parallel_related.c:         E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Maxwelltime:Full_parallel_related.c:         for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Maxwelltime:Full_parallel_related.c:           U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += S[kk][j-1];
Maxwelltime:Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Maxwelltime:Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)
Maxwelltime:Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Maxwelltime:Full_parallel_related.c:        for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Maxwelltime:Full_parallel_related.c:           U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += R[kk][j-1];
Maxwelltime:Full_parallel_related.c:  for (k=1;k<=E->parallel.TNUM_PASSz[lev];k++)  {
Maxwelltime:Full_parallel_related.c:    kk = k + E->sphere.max_connections;
Maxwelltime:Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[kk];j++)
Maxwelltime:Full_parallel_related.c:        SV[jj++] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[kk] ];
Maxwelltime:Full_parallel_related.c:    MPI_Sendrecv(SV,E->parallel.NUM_NODEz[lev].pass[k],MPI_FLOAT,
Maxwelltime:Full_parallel_related.c:             E->parallel.PROCESSORz[lev].pass[k],1,
Maxwelltime:Full_parallel_related.c:                 RV,E->parallel.NUM_NODEz[lev].pass[k],MPI_FLOAT,
Maxwelltime:Full_parallel_related.c:             E->parallel.PROCESSORz[lev].pass[k],1,E->parallel.world,&status1);
Maxwelltime:Full_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[kk];j++)
Maxwelltime:Full_parallel_related.c:        U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[kk] ] += RV[jj++];
Maxwelltime:Full_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Full_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Maxwelltime:Full_parallel_related.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Full_parallel_related.c:     for (k=1;k<=E->parallel.TNUM_PASS[E->mesh.levmax][m];k++)  {
Maxwelltime:Full_parallel_related.c:       sizeofk = (1+2*E->parallel.NUM_sNODE[E->mesh.levmax][m].pass[k])*sizeof(float);
Maxwelltime:Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)     {
Maxwelltime:Full_parallel_related.c:      for (j=1;j<=E->parallel.NUM_sNODE[lev][m].pass[k];j++)  {
Maxwelltime:Full_parallel_related.c:        S[kk][j-1] = U1[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ];
Maxwelltime:Full_parallel_related.c:        S[kk][j-1+E->parallel.NUM_sNODE[lev][m].pass[k]]
Maxwelltime:Full_parallel_related.c:                   = U2[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ];
Maxwelltime:Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me) {
Maxwelltime:Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Maxwelltime:Full_parallel_related.c:         MPI_Isend(S[kk],2*E->parallel.NUM_sNODE[lev][m].pass[k],MPI_FLOAT,
Maxwelltime:Full_parallel_related.c:             E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Maxwelltime:Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Maxwelltime:Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)  {
Maxwelltime:Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Maxwelltime:Full_parallel_related.c:         MPI_Irecv(R[kk],2*E->parallel.NUM_sNODE[lev][m].pass[k],MPI_FLOAT,
Maxwelltime:Full_parallel_related.c:           E->parallel.PROCESSOR[lev][m].pass[k],1,E->parallel.world,&request[idb-1]);
Maxwelltime:Full_parallel_related.c:         for (j=1;j<=E->parallel.NUM_sNODE[lev][m].pass[k];j++)     {
Maxwelltime:Full_parallel_related.c:           U1[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] += S[kk][j-1];
Maxwelltime:Full_parallel_related.c:           U2[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] +=
Maxwelltime:Full_parallel_related.c:                               S[kk][j-1+E->parallel.NUM_sNODE[lev][m].pass[k]];
Maxwelltime:Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Maxwelltime:Full_parallel_related.c:      if (E->parallel.PROCESSOR[lev][m].pass[k]!=E->parallel.me)
Maxwelltime:Full_parallel_related.c:	if (E->parallel.PROCESSOR[lev][m].pass[k]!=-1) {
Maxwelltime:Full_parallel_related.c:        for (j=1;j<=E->parallel.NUM_sNODE[lev][m].pass[k];j++)    {
Maxwelltime:Full_parallel_related.c:           U1[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] += R[kk][j-1];
Maxwelltime:Full_parallel_related.c:           U2[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] +=
Maxwelltime:Full_parallel_related.c:                              R[kk][j-1+E->parallel.NUM_sNODE[lev][m].pass[k]];
Maxwelltime:Full_parallel_related.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Full_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[E->mesh.levmax][m];k++)  {
Maxwelltime:Full_parallel_related.c:   idb = 2*E->sphere.hindice;
Maxwelltime:Full_parallel_related.c:  if (E->parallel.me_loc[3] == 0)  {
Maxwelltime:Full_parallel_related.c:    for (p=0;p<E->sphere.hindice;p++)  {
Maxwelltime:Full_parallel_related.c:      SV[p+E->sphere.hindice] = sphs1[p];
Maxwelltime:Full_parallel_related.c:    target_proc= E->parallel.me + E->parallel.nprocz-1;
Maxwelltime:Full_parallel_related.c:  else if (E->parallel.me_loc[3] == E->parallel.nprocz-1)  {
Maxwelltime:Full_parallel_related.c:    for (p=0;p<E->sphere.hindice;p++)  {
Maxwelltime:Full_parallel_related.c:      SV[p+E->sphere.hindice] = sphs0[p];
Maxwelltime:Full_parallel_related.c:    target_proc = E->parallel.me - E->parallel.nprocz+1;
Maxwelltime:Full_parallel_related.c:  if (E->parallel.me_loc[3] == 0)  {
Maxwelltime:Full_parallel_related.c:    for (p=0;p<E->sphere.hindice;p++)  {
Maxwelltime:Full_parallel_related.c:      sphs0[p] = RV[p+E->sphere.hindice];
Maxwelltime:Full_parallel_related.c:  else if (E->parallel.me_loc[3] == E->parallel.nprocz-1)  {
Maxwelltime:Full_parallel_related.c:    for (p=0;p<E->sphere.hindice;p++)  {
Maxwelltime:Full_parallel_related.c:      sphs1[p] = RV[p+E->sphere.hindice];
Maxwelltime:Full_read_input_from_files.c:    const int dims=E->mesh.nsd;
Maxwelltime:Full_read_input_from_files.c:    nox=E->mesh.nox;
Maxwelltime:Full_read_input_from_files.c:    noy=E->mesh.noy;
Maxwelltime:Full_read_input_from_files.c:    noz=E->mesh.noz;
Maxwelltime:Full_read_input_from_files.c:    nox1=E->lmesh.nox;
Maxwelltime:Full_read_input_from_files.c:    noz1=E->lmesh.noz;
Maxwelltime:Full_read_input_from_files.c:    noy1=E->lmesh.noy;
Maxwelltime:Full_read_input_from_files.c:    elx=E->lmesh.elx;
Maxwelltime:Full_read_input_from_files.c:    elz=E->lmesh.elz;
Maxwelltime:Full_read_input_from_files.c:    ely=E->lmesh.ely;
Maxwelltime:Full_read_input_from_files.c:    emax=E->mesh.elx*E->mesh.elz*E->mesh.ely;
Maxwelltime:Full_read_input_from_files.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Full_read_input_from_files.c:      cap = E->sphere.capid[m] - 1;  /* capid: 1-12 */
Maxwelltime:Full_read_input_from_files.c:	if(!E->control.ggrd.vtop_control){
Maxwelltime:Full_read_input_from_files.c:	sprintf(output_file1,"%s%0.0f.%d",E->control.velocity_boundary_file,newage1,cap);
Maxwelltime:Full_read_input_from_files.c:	sprintf(output_file2,"%s%0.0f.%d",E->control.velocity_boundary_file,newage2,cap);
Maxwelltime:Full_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #4) Cannot open %s\n",output_file1);
Maxwelltime:Full_read_input_from_files.c:	    fprintf(E->fp,"(Problem_related #5) Cannot open %s\n",output_file2);
Maxwelltime:Full_read_input_from_files.c:	if((E->parallel.me==0) && (output==1))   {
Maxwelltime:Full_read_input_from_files.c:	  fprintf(E->fp,"Velocity: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Maxwelltime:Full_read_input_from_files.c:	  fprintf(E->fp,"Velocity: File1 = %s\n",output_file1);
Maxwelltime:Full_read_input_from_files.c:	    fprintf(E->fp,"Velocity: File2 = %s\n",output_file2);
Maxwelltime:Full_read_input_from_files.c:	    fprintf(E->fp,"Velocity: File2 = No file inputted (negative age)\n");
Maxwelltime:Full_read_input_from_files.c:	if(!E->control.ggrd.age_control){
Maxwelltime:Full_read_input_from_files.c:	sprintf(output_file1,"%s%0.0f.%d",E->control.lith_age_file,newage1,cap);
Maxwelltime:Full_read_input_from_files.c:	sprintf(output_file2,"%s%0.0f.%d",E->control.lith_age_file,newage2,cap);
Maxwelltime:Full_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #6) Cannot open %s\n",output_file1);
Maxwelltime:Full_read_input_from_files.c:	    fprintf(E->fp,"(Problem_related #7) Cannot open %s\n",output_file2);
Maxwelltime:Full_read_input_from_files.c:	if((E->parallel.me==0) && (output==1))   {
Maxwelltime:Full_read_input_from_files.c:	  fprintf(E->fp,"Age: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Maxwelltime:Full_read_input_from_files.c:	  fprintf(E->fp,"Age: File1 = %s\n",output_file1);
Maxwelltime:Full_read_input_from_files.c:	    fprintf(E->fp,"Age: File2 = %s\n",output_file2);
Maxwelltime:Full_read_input_from_files.c:	    fprintf(E->fp,"Age: File2 = No file inputted (negative age)\n");
Maxwelltime:Full_read_input_from_files.c:	if(!E->control.ggrd.mat_control){
Maxwelltime:Full_read_input_from_files.c:	sprintf(output_file1,"%s%0.0f.%d",E->control.mat_file,newage1,cap);
Maxwelltime:Full_read_input_from_files.c:	sprintf(output_file2,"%s%0.0f.%d",E->control.mat_file,newage2,cap);
Maxwelltime:Full_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #8) Cannot open %s\n",output_file1);
Maxwelltime:Full_read_input_from_files.c:	    fprintf(E->fp,"(Problem_related #9) Cannot open %s\n",output_file2);
Maxwelltime:Full_read_input_from_files.c:	if((E->parallel.me==0) && (output==1))   {
Maxwelltime:Full_read_input_from_files.c:	  fprintf(E->fp,"Mat: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Maxwelltime:Full_read_input_from_files.c:	  fprintf(E->fp,"Mat: File1 = %s\n",output_file1);
Maxwelltime:Full_read_input_from_files.c:	    fprintf(E->fp,"Mat: File2 = %s\n",output_file2);
Maxwelltime:Full_read_input_from_files.c:	    fprintf(E->fp,"Mat: File2 = No file inputted (negative age)\n");
Maxwelltime:Full_read_input_from_files.c:	sprintf(output_file1,"%s%0.0f.%d",E->control.temperature_boundary_file,newage1,cap);
Maxwelltime:Full_read_input_from_files.c:	sprintf(output_file2,"%s%0.0f.%d",E->control.temperature_boundary_file,newage2,cap);
Maxwelltime:Full_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #10) Cannot open %s\n",output_file1);
Maxwelltime:Full_read_input_from_files.c:	    fprintf(E->fp,"(Problem_related #11) Cannot open %s\n",output_file2);
Maxwelltime:Full_read_input_from_files.c:	if((E->parallel.me==0) && (output==1))   {
Maxwelltime:Full_read_input_from_files.c:	  fprintf(E->fp,"Surface Temperature: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Maxwelltime:Full_read_input_from_files.c:	  fprintf(E->fp,"Surface Temperature: File1 = %s\n",output_file1);
Maxwelltime:Full_read_input_from_files.c:	    fprintf(E->fp,"Surface Temperature: File2 = %s\n",output_file2);
Maxwelltime:Full_read_input_from_files.c:	    fprintf(E->fp,"Velocity: File2 = No file inputted (negative age)\n");
Maxwelltime:Full_read_input_from_files.c:	if(E->control.ggrd.vtop_control){
Maxwelltime:Full_read_input_from_files.c:	  VB1[1][i] *= E->data.timedir;
Maxwelltime:Full_read_input_from_files.c:	  VB1[2][i] *= E->data.timedir;
Maxwelltime:Full_read_input_from_files.c:	    VB2[1][i] *= E->data.timedir;
Maxwelltime:Full_read_input_from_files.c:	    VB2[2][i] *= E->data.timedir;
Maxwelltime:Full_read_input_from_files.c:	  /* if( E->parallel.me ==0)
Maxwelltime:Full_read_input_from_files.c:	if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Maxwelltime:Full_read_input_from_files.c:	      nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Maxwelltime:Full_read_input_from_files.c:		E->sphere.cap[m].VB[1][nodel] = (VB1[1][nodeg] + (VB2[1][nodeg]-VB1[1][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Maxwelltime:Full_read_input_from_files.c:		E->sphere.cap[m].VB[2][nodel] = (VB1[2][nodeg] + (VB2[2][nodeg]-VB1[2][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Maxwelltime:Full_read_input_from_files.c:		E->sphere.cap[m].VB[3][nodel] = 0.0;
Maxwelltime:Full_read_input_from_files.c:		E->sphere.cap[m].VB[1][nodel] = VB1[1][nodeg] * E->data.scalev;
Maxwelltime:Full_read_input_from_files.c:		E->sphere.cap[m].VB[2][nodel] = VB1[2][nodeg] * E->data.scalev;
Maxwelltime:Full_read_input_from_files.c:		E->sphere.cap[m].VB[3][nodel] = 0.0;
Maxwelltime:Full_read_input_from_files.c:	}   /* end of E->parallel.me_loc[3]==E->parallel.nproczl-1   */
Maxwelltime:Full_read_input_from_files.c:	if(E->control.ggrd.age_control){
Maxwelltime:Full_read_input_from_files.c:              E->age_t[node] = (inputage1 + (inputage2-inputage1)/(newage2-newage1)*(age-newage1))/E->data.scalet;
Maxwelltime:Full_read_input_from_files.c:              E->age_t[node] = inputage1;
Maxwelltime:Full_read_input_from_files.c:	if(E->control.ggrd.mat_control){ /* use netcdf grids */
Maxwelltime:Full_read_input_from_files.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Full_read_input_from_files.c:            nodea = E->ien[m][el].node[2];
Maxwelltime:Full_read_input_from_files.c:              E->mat[m][el] = llayer;
Maxwelltime:Full_read_input_from_files.c:          for (m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Full_read_input_from_files.c:                  el = j + (i-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Maxwelltime:Full_read_input_from_files.c:                  elg = E->lmesh.ezs+j + (E->lmesh.exs+i-1)*E->mesh.elz + (E->lmesh.eys+k-1)*E->mesh.elz*E->mesh.elx;
Maxwelltime:Full_read_input_from_files.c:                  E->VIP[m][el] = VIP1[elg]+(VIP2[elg]-VIP1[elg])/(newage2-newage1)*(age-newage1);
Maxwelltime:Full_read_input_from_files.c:                  /* E->mat[m][el] = LL1[elg]; */ /*get material numbers from radius internally */
Maxwelltime:Full_read_input_from_files.c:	if(E->control.ggrd.ray_control)
Maxwelltime:Full_read_input_from_files.c:	if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Maxwelltime:Full_read_input_from_files.c:	      nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Maxwelltime:Full_read_input_from_files.c:		E->sphere.cap[m].TB[1][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Maxwelltime:Full_read_input_from_files.c:		E->sphere.cap[m].TB[2][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Maxwelltime:Full_read_input_from_files.c:		E->sphere.cap[m].TB[3][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Maxwelltime:Full_read_input_from_files.c:		E->sphere.cap[m].TB[1][nodel] = TB1[nodeg];
Maxwelltime:Full_read_input_from_files.c:		E->sphere.cap[m].TB[2][nodel] = TB1[nodeg];
Maxwelltime:Full_read_input_from_files.c:		E->sphere.cap[m].TB[3][nodel] = TB1[nodeg];
Maxwelltime:Full_read_input_from_files.c:	}   /* end of E->parallel.me_loc[3]==E->parallel.nproczl-1   */
Maxwelltime:Full_read_input_from_files.c:    fflush(E->fp);
Maxwelltime:Full_solver.c:    E->solver.velocity_boundary_conditions = full_velocity_boundary_conditions;
Maxwelltime:Full_solver.c:    E->solver.temperature_boundary_conditions = full_temperature_boundary_conditions;
Maxwelltime:Full_solver.c:    E->solver.set_2dc_defaults = full_set_2dc_defaults;
Maxwelltime:Full_solver.c:    E->solver.set_2pt5dc_defaults = full_set_2pt5dc_defaults;
Maxwelltime:Full_solver.c:    E->solver.set_3dc_defaults = full_set_3dc_defaults;
Maxwelltime:Full_solver.c:    E->solver.set_3dsphere_defaults = full_set_3dsphere_defaults;
Maxwelltime:Full_solver.c:    E->solver.lith_age_read_files = full_lith_age_read_files;
Maxwelltime:Full_solver.c:    E->solver.parallel_processor_setup = full_parallel_processor_setup;
Maxwelltime:Full_solver.c:    E->solver.parallel_domain_decomp0 = full_parallel_domain_decomp0;
Maxwelltime:Full_solver.c:    E->solver.parallel_domain_boundary_nodes = full_parallel_domain_boundary_nodes;
Maxwelltime:Full_solver.c:    E->solver.parallel_communication_routs_v = full_parallel_communication_routs_v;
Maxwelltime:Full_solver.c:    E->solver.parallel_communication_routs_s = full_parallel_communication_routs_s;
Maxwelltime:Full_solver.c:    E->solver.exchange_id_d = full_exchange_id_d;
Maxwelltime:Full_solver.c:    E->solver.read_input_files_for_timesteps = full_read_input_files_for_timesteps;
Maxwelltime:Full_solver.c:    E->solver.node_locations = full_node_locations;
Maxwelltime:Full_solver.c:    E->solver.construct_boundary = full_construct_boundary;
Maxwelltime:Full_sphere_related.c:  temp = max(E->mesh.noy, E->mesh.nox);
Maxwelltime:Full_sphere_related.c:  temp = E->mesh.noy * E->mesh.nox;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[1] = 0.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[2] = M_PI/4.0+offset;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[3] = M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[4] = M_PI/4.0+offset;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[1] = 0.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[2] = (i-1)*M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[3] = (i-1)*M_PI/2.0 + M_PI/4.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[4] = i*M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[1] = M_PI/4.0+offset;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[2] = M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[3] = 3*M_PI/4.0-offset;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[4] = M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[1] = i*M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[2] = i*M_PI/2.0 - M_PI/4.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[3] = i*M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[4] = i*M_PI/2.0 + M_PI/4.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].theta[1] = M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].theta[2] = 3*M_PI/4.0-offset;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].theta[3] = M_PI;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].theta[4] = 3*M_PI/4.0-offset;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].fi[1] = (i-1)*M_PI/2.0 + M_PI/4.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].fi[2] = (i-1)*M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].fi[3] = 0.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].fi[4] = i*M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    x[i] = E->data.ra * sin(E->sphere.cap[icap].theta[i])*cos(E->sphere.cap[icap].fi[i]);
Maxwelltime:Full_sphere_related.c:    y[i] = E->data.ra * sin(E->sphere.cap[icap].theta[i])*sin(E->sphere.cap[icap].fi[i]);
Maxwelltime:Full_sphere_related.c:    z[i] = E->data.rc * cos(E->sphere.cap[icap].theta[i]);
Maxwelltime:Full_sphere_related.c:    x[i] = sin(E->sphere.cap[icap].theta[i])*cos(E->sphere.cap[icap].fi[i]);
Maxwelltime:Full_sphere_related.c:    y[i] = sin(E->sphere.cap[icap].theta[i])*sin(E->sphere.cap[icap].fi[i]);
Maxwelltime:Full_sphere_related.c:    z[i] = cos(E->sphere.cap[icap].theta[i]);
Maxwelltime:Full_sphere_related.c:  lev = E->mesh.levmax;
Maxwelltime:Full_sphere_related.c:     elx = E->lmesh.ELX[lev]*E->parallel.nprocx;
Maxwelltime:Full_sphere_related.c:     ely = E->lmesh.ELY[lev]*E->parallel.nprocy;
Maxwelltime:Full_sphere_related.c:     lelx = E->lmesh.ELX[lev];
Maxwelltime:Full_sphere_related.c:     lely = E->lmesh.ELY[lev];
Maxwelltime:Full_sphere_related.c:     for (j=0, i=E->lmesh.nxs; j<lnox; j++, i++) {
Maxwelltime:Full_sphere_related.c:     for (j=0, i=E->lmesh.nxs; j<lnox; j++, i++) {
Maxwelltime:Full_sphere_related.c:     for (k=0, i=E->lmesh.nys; k<lnoy; k++, i++) {
Maxwelltime:Full_sphere_related.c:     for (k=0, i=E->lmesh.nys; k<lnoy; k++, i++) {
Maxwelltime:Full_sphere_related.c:                 fprintf(stderr, "Error(Full_coord_of_cap): cannot find intersection point! rank=%d, nx=%d, ny=%d\n", E->parallel.me, j, k);
Maxwelltime:Full_sphere_related.c:     if(E->parallel.me_loc[2] == 0) {
Maxwelltime:Full_sphere_related.c:     if(E->parallel.me_loc[2] == E->parallel.nprocy-1) {
Maxwelltime:Full_sphere_related.c:     if(E->parallel.me_loc[1] == 0) {
Maxwelltime:Full_sphere_related.c:     if(E->parallel.me_loc[1] == E->parallel.nprocx-1) {
Maxwelltime:Full_sphere_related.c:     efac2 = E->data.ellipticity*(2.0 - E->data.ellipticity)/
Maxwelltime:Full_sphere_related.c:       ((1.- E->data.ellipticity)*(1.-E->data.ellipticity));
Maxwelltime:Full_sphere_related.c:     for (lev=E->mesh.levmax, step=1; lev>=E->mesh.levmin; lev--, step*=2) {
Maxwelltime:Full_sphere_related.c:       lvnox = E->lmesh.NOX[lev];
Maxwelltime:Full_sphere_related.c:       lvnoy = E->lmesh.NOY[lev];
Maxwelltime:Full_sphere_related.c:       lvnoz = E->lmesh.NOZ[lev];
Maxwelltime:Full_sphere_related.c:	   rfac = E->data.ra*1./sqrt(1.0+efac2*cost*cost);
Maxwelltime:Full_sphere_related.c:	     E->SX[lev][m][1][node] = theta;
Maxwelltime:Full_sphere_related.c:	     E->SX[lev][m][2][node] = fi;
Maxwelltime:Full_sphere_related.c:	     E->SX[lev][m][3][node] = rfac * E->sphere.R[lev][i];
Maxwelltime:Full_sphere_related.c:	     E->X[lev][m][1][node] = E->data.ra * E->sphere.R[lev][i]*sint*cosf;
Maxwelltime:Full_sphere_related.c:	     E->X[lev][m][2][node] = E->data.ra * E->sphere.R[lev][i]*sint*sinf;
Maxwelltime:Full_sphere_related.c:	     E->X[lev][m][3][node] = E->data.rc * E->sphere.R[lev][i]*cost;
Maxwelltime:Full_sphere_related.c:     for (lev=E->mesh.levmax, step=1; lev>=E->mesh.levmin; lev--, step*=2) {
Maxwelltime:Full_sphere_related.c:       lvnox = E->lmesh.NOX[lev];
Maxwelltime:Full_sphere_related.c:       lvnoy = E->lmesh.NOY[lev];
Maxwelltime:Full_sphere_related.c:       lvnoz = E->lmesh.NOZ[lev];
Maxwelltime:Full_sphere_related.c:	     E->SX[lev][m][1][node] = theta;
Maxwelltime:Full_sphere_related.c:	     E->SX[lev][m][2][node] = fi;
Maxwelltime:Full_sphere_related.c:	     E->SX[lev][m][3][node] = E->sphere.R[lev][i];
Maxwelltime:Full_sphere_related.c:	     E->X[lev][m][1][node]  = E->sphere.R[lev][i]*sint*cosf;
Maxwelltime:Full_sphere_related.c:	     E->X[lev][m][2][node]  = E->sphere.R[lev][i]*sint*sinf;
Maxwelltime:Full_sphere_related.c:	     E->X[lev][m][3][node]  = E->sphere.R[lev][i]*cost;
Maxwelltime:Full_sphere_related.c:  temp = max(E->lmesh.NOY[E->mesh.levmax],E->lmesh.NOX[E->mesh.levmax]);
Maxwelltime:Full_sphere_related.c:  temp = E->lmesh.NOY[E->mesh.levmax]*E->lmesh.NOX[E->mesh.levmax];
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[1] = 0.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[2] = M_PI/4.0+offset;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[3] = M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].theta[4] = M_PI/4.0+offset;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[1] = 0.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[2] = (i-1)*M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[3] = (i-1)*M_PI/2.0 + M_PI/4.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+1].fi[4] = i*M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[1] = M_PI/4.0+offset;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[2] = M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[3] = 3*M_PI/4.0-offset;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].theta[4] = M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[1] = i*M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[2] = i*M_PI/2.0 - M_PI/4.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[3] = i*M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[(i-1)*3+2].fi[4] = i*M_PI/2.0 + M_PI/4.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].theta[1] = M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].theta[2] = 3*M_PI/4.0-offset;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].theta[3] = M_PI;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].theta[4] = 3*M_PI/4.0-offset;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].fi[1] = (i-1)*M_PI/2.0 + M_PI/4.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].fi[2] = (i-1)*M_PI/2.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].fi[3] = 0.0;
Maxwelltime:Full_sphere_related.c:    E->sphere.cap[j].fi[4] = i*M_PI/2.0;
Maxwelltime:Full_sphere_related.c:     x[i] = sin(E->sphere.cap[icap].theta[i])*cos(E->sphere.cap[icap].fi[i]);
Maxwelltime:Full_sphere_related.c:     y[i] = sin(E->sphere.cap[icap].theta[i])*sin(E->sphere.cap[icap].fi[i]);
Maxwelltime:Full_sphere_related.c:     z[i] = cos(E->sphere.cap[icap].theta[i]);
Maxwelltime:Full_sphere_related.c:/*     fprintf(E->fp_out,"m=%d %d x=%g y=%g z=%g t=%g f=%g\n",icap,i,x[i],y[i],z[i],E->sphere.cap[icap].theta[i],E->sphere.cap[icap].fi[i]);        */
Maxwelltime:Full_sphere_related.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Maxwelltime:Full_sphere_related.c:     elx = E->lmesh.ELX[lev];
Maxwelltime:Full_sphere_related.c:     ely = E->lmesh.ELY[lev];
Maxwelltime:Full_sphere_related.c:     nox = E->lmesh.NOX[lev];
Maxwelltime:Full_sphere_related.c:     noy = E->lmesh.NOY[lev];
Maxwelltime:Full_sphere_related.c:     noz = E->lmesh.NOZ[lev];
Maxwelltime:Full_sphere_related.c:/*       fprintf(E->fp_out,"m=%d %d x=%g y=%g z=%g t=%g f=%g\n",icap,j,xx[1],yy[1],zz[1],theta1[j],fi1[j]);
Maxwelltime:Full_sphere_related.c:       fprintf(E->fp_out,"m=%d %d x=%g y=%g z=%g t=%g f=%g\n",icap,j,xx[2],yy[2],zz[2],theta2[j],fi2[j]);             */
Maxwelltime:Full_sphere_related.c:                E->SX[lev][m][1][node] = SX[0][nodes];
Maxwelltime:Full_sphere_related.c:                E->SX[lev][m][2][node] = SX[1][nodes];
Maxwelltime:Full_sphere_related.c:                E->SX[lev][m][3][node] = E->sphere.R[lev][i];
Maxwelltime:Full_sphere_related.c:                E->X[lev][m][1][node] = 
Maxwelltime:Full_sphere_related.c:                            E->sphere.R[lev][i]*sin(SX[0][nodes])*cos(SX[1][nodes]);
Maxwelltime:Full_sphere_related.c:                E->X[lev][m][2][node] = 
Maxwelltime:Full_sphere_related.c:                            E->sphere.R[lev][i]*sin(SX[0][nodes])*sin(SX[1][nodes]);
Maxwelltime:Full_sphere_related.c:                E->X[lev][m][3][node] = 
Maxwelltime:Full_sphere_related.c:                            E->sphere.R[lev][i]*cos(SX[0][nodes]);
Maxwelltime:Full_sphere_related.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Maxwelltime:Full_sphere_related.c:    for (i=1;i<=E->lmesh.NNO[lev];i++)  {
Maxwelltime:Full_sphere_related.c:/*      t[0] = E->X[lev][m][1][i]*E->sphere.dircos[1][1]+ 
Maxwelltime:Full_sphere_related.c:             E->X[lev][m][2][i]*E->sphere.dircos[1][2]+ 
Maxwelltime:Full_sphere_related.c:             E->X[lev][m][3][i]*E->sphere.dircos[1][3]; 
Maxwelltime:Full_sphere_related.c:      t[1] = E->X[lev][m][1][i]*E->sphere.dircos[2][1]+ 
Maxwelltime:Full_sphere_related.c:             E->X[lev][m][2][i]*E->sphere.dircos[2][2]+ 
Maxwelltime:Full_sphere_related.c:             E->X[lev][m][3][i]*E->sphere.dircos[2][3]; 
Maxwelltime:Full_sphere_related.c:      t[2] = E->X[lev][m][1][i]*E->sphere.dircos[3][1]+ 
Maxwelltime:Full_sphere_related.c:             E->X[lev][m][2][i]*E->sphere.dircos[3][2]+ 
Maxwelltime:Full_sphere_related.c:             E->X[lev][m][3][i]*E->sphere.dircos[3][3]; 
Maxwelltime:Full_sphere_related.c:      E->X[lev][m][1][i] = t[0];
Maxwelltime:Full_sphere_related.c:      E->X[lev][m][2][i] = t[1];
Maxwelltime:Full_sphere_related.c:      E->X[lev][m][3][i] = t[2];
Maxwelltime:Full_sphere_related.c:      E->SX[lev][m][1][i] = acos(t[2]/E->SX[lev][m][3][i]);
Maxwelltime:Full_sphere_related.c:      E->SX[lev][m][2][i] = myatan(t[1],t[0]);
Maxwelltime:Full_tracer_advection.c:    int m = E->parallel.me;
Maxwelltime:Full_tracer_advection.c:    E->trace.deltheta[0]=1.0;
Maxwelltime:Full_tracer_advection.c:    E->trace.delphi[0]=1.0;
Maxwelltime:Full_tracer_advection.c:    input_double("regular_grid_deltheta",&(E->trace.deltheta[0]),"1.0",m);
Maxwelltime:Full_tracer_advection.c:    input_double("regular_grid_delphi",&(E->trace.delphi[0]),"1.0",m);
Maxwelltime:Full_tracer_advection.c:    E->trace.ianalytical_tracer_test=0;
Maxwelltime:Full_tracer_advection.c:    /* input_int("analytical_tracer_test",&(E->trace.ianalytical_tracer_test),
Maxwelltime:Full_tracer_advection.c:    if (E->sphere.caps_per_proc>1) {
Maxwelltime:Full_tracer_advection.c:    sprintf(output_file,"%s.tracer_log.%d",E->control.data_file,E->parallel.me);
Maxwelltime:Full_tracer_advection.c:    E->trace.fpt=fopen(output_file,"w");
Maxwelltime:Full_tracer_advection.c:    E->trace.istat_isend=0;
Maxwelltime:Full_tracer_advection.c:    E->trace.istat_iempty=0;
Maxwelltime:Full_tracer_advection.c:    E->trace.istat_elements_checked=0;
Maxwelltime:Full_tracer_advection.c:    E->trace.istat1=0;
Maxwelltime:Full_tracer_advection.c:    E->trace.box_cushion=0.00001;
Maxwelltime:Full_tracer_advection.c:    E->trace.number_of_basic_quantities=12;
Maxwelltime:Full_tracer_advection.c:    E->trace.number_of_extra_quantities = 0;
Maxwelltime:Full_tracer_advection.c:    if (E->trace.nflavors > 0)
Maxwelltime:Full_tracer_advection.c:        E->trace.number_of_extra_quantities += 1;
Maxwelltime:Full_tracer_advection.c:    E->trace.number_of_tracer_quantities =
Maxwelltime:Full_tracer_advection.c:        E->trace.number_of_basic_quantities +
Maxwelltime:Full_tracer_advection.c:        E->trace.number_of_extra_quantities;
Maxwelltime:Full_tracer_advection.c:    if (E->trace.number_of_basic_quantities>99) {
Maxwelltime:Full_tracer_advection.c:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of basic in tracer_defs.h\n");
Maxwelltime:Full_tracer_advection.c:        fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    if (E->trace.number_of_extra_quantities>99) {
Maxwelltime:Full_tracer_advection.c:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of extraq in tracer_defs.h\n");
Maxwelltime:Full_tracer_advection.c:        fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    if (E->trace.number_of_tracer_quantities>99) {
Maxwelltime:Full_tracer_advection.c:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of rlater in tracer_defs.h\n");
Maxwelltime:Full_tracer_advection.c:        fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    if (E->trace.ianalytical_tracer_test==1) {
Maxwelltime:Full_tracer_advection.c:    if (E->composition.on)
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt, "Tracer intiailization takes %f seconds.\n",
Maxwelltime:Full_tracer_advection.c:    /* This code works only if E->sphere.caps_per_proc==1 */
Maxwelltime:Full_tracer_advection.c:    int lev=E->mesh.levmax;
Maxwelltime:Full_tracer_advection.c:    int num_ngb = E->parallel.TNUM_PASS[lev][j];
Maxwelltime:Full_tracer_advection.c:    if(E->control.verbose)
Maxwelltime:Full_tracer_advection.c:      fprintf(E->trace.fpt, "Entering lost_souls()\n");
Maxwelltime:Full_tracer_advection.c:    E->trace.istat_isend=E->trace.ilater[j];
Maxwelltime:Full_tracer_advection.c:    for (kk=1; kk<=E->trace.istat_isend; kk++) {
Maxwelltime:Full_tracer_advection.c:        fprintf(E->trace.fpt, "tracer#=%d xx=(%g,%g,%g)\n", kk,
Maxwelltime:Full_tracer_advection.c:                E->trace.rlater[j][0][kk],
Maxwelltime:Full_tracer_advection.c:                E->trace.rlater[j][1][kk],
Maxwelltime:Full_tracer_advection.c:                E->trace.rlater[j][2][kk]);
Maxwelltime:Full_tracer_advection.c:    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    isize[j]=E->trace.ilater[j]*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Error(lost souls)-no memory (u389)\n");
Maxwelltime:Full_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    ithiscap=E->sphere.capid[j];
Maxwelltime:Full_tracer_advection.c:        ithatcap=E->parallel.PROCESSOR[lev][j].pass[kk];
Maxwelltime:Full_tracer_advection.c:        fprintf(E->trace.fpt,"cap: %d me %d TNUM: %d rank: %d\n",
Maxwelltime:Full_tracer_advection.c:                ithiscap,E->parallel.me,kk,ithatcap);
Maxwelltime:Full_tracer_advection.c:    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    if (E->parallel.nprocz>1) {
Maxwelltime:Full_tracer_advection.c:        idestination_proc=E->parallel.PROCESSOR[lev][j].pass[kk];
Maxwelltime:Full_tracer_advection.c:                  11,E->parallel.world,&request[idb++]);
Maxwelltime:Full_tracer_advection.c:                  11,E->parallel.world,&request[idb++]);
Maxwelltime:Full_tracer_advection.c:	  isource_proc=E->parallel.me;
Maxwelltime:Full_tracer_advection.c:	  isource_proc=E->parallel.PROCESSOR[lev][j].pass[kk];
Maxwelltime:Full_tracer_advection.c:	fprintf(E->trace.fpt,"%d send %d to proc %d\n",
Maxwelltime:Full_tracer_advection.c:		E->parallel.me,isend[j][kk],isource_proc);
Maxwelltime:Full_tracer_advection.c:	fprintf(E->trace.fpt,"%d recv %d from proc %d\n",
Maxwelltime:Full_tracer_advection.c:		E->parallel.me,ireceive[j][kk],isource_proc);
Maxwelltime:Full_tracer_advection.c:        isize[j]=ireceive[j][ithatcap]*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Error(lost souls)-no memory (c721)\n");
Maxwelltime:Full_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    if (E->parallel.nprocz>1) {
Maxwelltime:Full_tracer_advection.c:        isize[j]=isend[j][ithatcap]*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:        idestination_proc=E->parallel.PROCESSOR[lev][j].pass[kk];
Maxwelltime:Full_tracer_advection.c:        isize[j]=isend[j][kk]*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:                  11,E->parallel.world,&request[idb++]);
Maxwelltime:Full_tracer_advection.c:        isize[j]=ireceive[j][kk]*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:                  11,E->parallel.world,&request[idb++]);
Maxwelltime:Full_tracer_advection.c:    isize[j]=isum[j]*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:        fprintf(E->trace.fpt,"Error(lost souls)-no memory (g323)\n");
Maxwelltime:Full_tracer_advection.c:        fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:            ipos=pp*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:            for (mm=0;mm<E->trace.number_of_tracer_quantities;mm++) {
Maxwelltime:Full_tracer_advection.c:    if (E->parallel.nprocz>1) {
Maxwelltime:Full_tracer_advection.c:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Maxwelltime:Full_tracer_advection.c:            isize[j]=itracers_subject_to_vertical_transport[j]*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:                fprintf(E->trace.fpt,"Error(lost souls)-no memory (c721)\n");
Maxwelltime:Full_tracer_advection.c:                fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:        for (ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Maxwelltime:Full_tracer_advection.c:            ithat_processor=E->parallel.PROCESSORz[lev].pass[ivertical_neighbor];
Maxwelltime:Full_tracer_advection.c:                ireceive_position=it*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:                    isend_position=isend_z[j][ivertical_neighbor]*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:                    ilast_receiver_position=(irec[j]-1)*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:                    for (mm=0;mm<=(E->trace.number_of_tracer_quantities-1);mm++) {
Maxwelltime:Full_tracer_advection.c:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Maxwelltime:Full_tracer_advection.c:            idestination_proc = E->parallel.PROCESSORz[lev].pass[kk];
Maxwelltime:Full_tracer_advection.c:                      14,E->parallel.world,&request[idb++]);
Maxwelltime:Full_tracer_advection.c:                      14,E->parallel.world,&request[idb++]);
Maxwelltime:Full_tracer_advection.c:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt, "PROC: %d IVN: %d (P: %d) "
Maxwelltime:Full_tracer_advection.c:                    E->parallel.me,kk,E->parallel.PROCESSORz[lev].pass[kk],
Maxwelltime:Full_tracer_advection.c:        fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Maxwelltime:Full_tracer_advection.c:            isize[j]=ireceive_z[j][kk]*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:                fprintf(E->trace.fpt,"Error(lost souls)-no memory (t590)\n");
Maxwelltime:Full_tracer_advection.c:                fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:        for (kk=1;kk<=E->parallel.TNUM_PASSz[lev];kk++) {
Maxwelltime:Full_tracer_advection.c:            idestination_proc = E->parallel.PROCESSORz[lev].pass[kk];
Maxwelltime:Full_tracer_advection.c:            isize_send=isend_z[j][kk]*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:                      15,E->parallel.world,&request[idb++]);
Maxwelltime:Full_tracer_advection.c:            isize_receive=ireceive_z[j][kk]*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:                      15,E->parallel.world,&request[idb++]);
Maxwelltime:Full_tracer_advection.c:        for (ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Maxwelltime:Full_tracer_advection.c:        isize[j]=isum[j]*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:                fprintf(E->trace.fpt,"Error(lost souls)-no memory (i981)\n");
Maxwelltime:Full_tracer_advection.c:                fprintf(E->trace.fpt,"isize: %d\n",isize[j]);
Maxwelltime:Full_tracer_advection.c:                fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:        for (ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Maxwelltime:Full_tracer_advection.c:                irec_position=irec[j]*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:                ireceive_position=kk*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:                for (mm=0;mm<E->trace.number_of_tracer_quantities;mm++) {
Maxwelltime:Full_tracer_advection.c:        for (ivertical_neighbor=1;ivertical_neighbor<=E->parallel.TNUM_PASSz[lev];ivertical_neighbor++) {
Maxwelltime:Full_tracer_advection.c:        E->trace.ntracers[j]++;
Maxwelltime:Full_tracer_advection.c:        if (E->trace.ntracers[j]>(E->trace.max_ntracers[j]-5)) expand_tracer_arrays(E,j);
Maxwelltime:Full_tracer_advection.c:        ireceive_position=kk*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:        for (mm=0;mm<E->trace.number_of_basic_quantities;mm++) {
Maxwelltime:Full_tracer_advection.c:            E->trace.basicq[j][mm][E->trace.ntracers[j]]=REC[j][ipos];
Maxwelltime:Full_tracer_advection.c:        for (mm=0;mm<E->trace.number_of_extra_quantities;mm++) {
Maxwelltime:Full_tracer_advection.c:            ipos=ireceive_position+E->trace.number_of_basic_quantities+mm;
Maxwelltime:Full_tracer_advection.c:            E->trace.extraq[j][mm][E->trace.ntracers[j]]=REC[j][ipos];
Maxwelltime:Full_tracer_advection.c:        theta=E->trace.basicq[j][0][E->trace.ntracers[j]];
Maxwelltime:Full_tracer_advection.c:        phi=E->trace.basicq[j][1][E->trace.ntracers[j]];
Maxwelltime:Full_tracer_advection.c:        rad=E->trace.basicq[j][2][E->trace.ntracers[j]];
Maxwelltime:Full_tracer_advection.c:        x=E->trace.basicq[j][3][E->trace.ntracers[j]];
Maxwelltime:Full_tracer_advection.c:        y=E->trace.basicq[j][4][E->trace.ntracers[j]];
Maxwelltime:Full_tracer_advection.c:        z=E->trace.basicq[j][5][E->trace.ntracers[j]];
Maxwelltime:Full_tracer_advection.c:        iel=(E->trace.iget_element)(E,j,-99,x,y,z,theta,phi,rad);
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Error(lost souls) - element not here?\n");
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"x,y,z-theta,phi,rad: %f %f %f - %f %f %f\n",x,y,z,theta,phi,rad);
Maxwelltime:Full_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:        E->trace.ielement[j][E->trace.ntracers[j]]=iel;
Maxwelltime:Full_tracer_advection.c:    if(E->control.verbose){
Maxwelltime:Full_tracer_advection.c:      fprintf(E->trace.fpt,"Freeing memory in lost_souls()\n");
Maxwelltime:Full_tracer_advection.c:      fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    if(E->control.verbose){
Maxwelltime:Full_tracer_advection.c:      fprintf(E->trace.fpt,"Leaving lost_souls()\n");
Maxwelltime:Full_tracer_advection.c:      fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    E->trace.lost_souls_time += CPU_time0() - begin_time;
Maxwelltime:Full_tracer_advection.c:    int lev = E->mesh.levmax;
Maxwelltime:Full_tracer_advection.c:    numtracers=E->trace.ilater[j];
Maxwelltime:Full_tracer_advection.c:        rad=E->trace.rlater[j][2][kk];
Maxwelltime:Full_tracer_advection.c:        x=E->trace.rlater[j][3][kk];
Maxwelltime:Full_tracer_advection.c:        y=E->trace.rlater[j][4][kk];
Maxwelltime:Full_tracer_advection.c:        z=E->trace.rlater[j][5][kk];
Maxwelltime:Full_tracer_advection.c:        if (E->parallel.nprocz>1) {
Maxwelltime:Full_tracer_advection.c:        for (pp=1;pp<=E->parallel.TNUM_PASS[lev][j];pp++) {
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Error(lost souls)-should not be here\n");
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"x: %f y: %f z: %f rad: %f\n",x,y,z,rad);
Maxwelltime:Full_tracer_advection.c:            if (icheck==1) fprintf(E->trace.fpt," icheck here!\n");
Maxwelltime:Full_tracer_advection.c:            else fprintf(E->trace.fpt,"icheck not here!\n");
Maxwelltime:Full_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:        isend_position=(isend[j][ithatcap]-1)*E->trace.number_of_tracer_quantities;
Maxwelltime:Full_tracer_advection.c:        for (pp=0;pp<=(E->trace.number_of_tracer_quantities-1);pp++) {
Maxwelltime:Full_tracer_advection.c:            send[j][ithatcap][ipos]=E->trace.rlater[j][pp][kk];
Maxwelltime:Full_tracer_advection.c:    int maxlevel=E->mesh.levmax;
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ERROR(gnomonic_interpolation)-inum>3!\n");
Maxwelltime:Full_tracer_advection.c:                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ERROR(gnomonic_interpolation)-inum>1\n");
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"shape %f %f %f\n",shape2d[1],shape2d[2],shape2d[3]);
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"u %f v %f element: %d \n",u,v, nelem);
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"Element uv boundaries: \n");
Maxwelltime:Full_tracer_advection.c:                        i = (E->ien[j][nelem].node[kk] - 1) / E->lmesh.noz + 1;
Maxwelltime:Full_tracer_advection.c:                        fprintf(E->trace.fpt,"%d: U: %f V:%f\n",kk,E->gnomonic[i].u,E->gnomonic[i].v);
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"theta: %f phi: %f rad: %f\n",theta,phi,rad);
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"Element theta-phi boundaries: \n");
Maxwelltime:Full_tracer_advection.c:                        fprintf(E->trace.fpt,"%d: Theta: %f Phi:%f\n",kk,E->sx[j][1][E->ien[j][nelem].node[kk]],E->sx[j][2][E->ien[j][nelem].node[kk]]);
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ICHECK?: %d\n",ival);
Maxwelltime:Full_tracer_advection.c:                    ival=(E->trace.iget_element)(E,j,-99,x,y,z,theta,phi,rad);
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"New Element?: %d\n",ival);
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"New Element (neighs)?: %d\n",ival);
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ICHECK?: %d\n",ival);
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"NO LUCK\n");
Maxwelltime:Full_tracer_advection.c:                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt, "shp: %e %e %e %e %e %e\n",
Maxwelltime:Full_tracer_advection.c:    int n = (nelem - 1) / E->lmesh.elz + 1;
Maxwelltime:Full_tracer_advection.c:    a0=E->trace.shape_coefs[j][iwedge][1][n];
Maxwelltime:Full_tracer_advection.c:    a1=E->trace.shape_coefs[j][iwedge][2][n];
Maxwelltime:Full_tracer_advection.c:    a2=E->trace.shape_coefs[j][iwedge][3][n];
Maxwelltime:Full_tracer_advection.c:    a0=E->trace.shape_coefs[j][iwedge][4][n];
Maxwelltime:Full_tracer_advection.c:    a1=E->trace.shape_coefs[j][iwedge][5][n];
Maxwelltime:Full_tracer_advection.c:    a2=E->trace.shape_coefs[j][iwedge][6][n];
Maxwelltime:Full_tracer_advection.c:    a0=E->trace.shape_coefs[j][iwedge][7][n];
Maxwelltime:Full_tracer_advection.c:    a1=E->trace.shape_coefs[j][iwedge][8][n];
Maxwelltime:Full_tracer_advection.c:    a2=E->trace.shape_coefs[j][iwedge][9][n];
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt, "el=%d els=%d iwedge=%d shape=(%e %e %e)\n",
Maxwelltime:Full_tracer_advection.c:    node1=E->ien[j][nelem].node[1];
Maxwelltime:Full_tracer_advection.c:    node5=E->ien[j][nelem].node[5];
Maxwelltime:Full_tracer_advection.c:    rad1=E->sx[j][3][node1];
Maxwelltime:Full_tracer_advection.c:    rad5=E->sx[j][3][node5];
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"ERROR(get_radial_shape)\n");
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"shaperad[1]: %f \n",shaperad[1]);
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"shaperad[2]: %f \n",shaperad[2]);
Maxwelltime:Full_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    phi_f = E->gnomonic_reference_phi;
Maxwelltime:Full_tracer_advection.c:    cos_theta_f = E->gnomonic[0].u;
Maxwelltime:Full_tracer_advection.c:    sin_theta_f = E->gnomonic[0].v;
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt, "(%e %e) -> (%e %e)\n",
Maxwelltime:Full_tracer_advection.c:    elz=E->lmesh.elz;
Maxwelltime:Full_tracer_advection.c:    nelsurf=E->lmesh.elx*E->lmesh.ely;
Maxwelltime:Full_tracer_advection.c:    expansion=2.0*0.5*(M_PI/4.0)/(1.0*E->lmesh.elx);
Maxwelltime:Full_tracer_advection.c:    if (E->parallel.me==0) fprintf(stderr,"Generating Regular Grid\n");
Maxwelltime:Full_tracer_advection.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Full_tracer_advection.c:            for (kk=1;kk<=E->lmesh.nno;kk=kk+E->lmesh.noz)
Maxwelltime:Full_tracer_advection.c:                    theta=E->sx[j][1][kk];
Maxwelltime:Full_tracer_advection.c:                    phi=E->sx[j][2][kk];
Maxwelltime:Full_tracer_advection.c:            deltheta=E->trace.deltheta[0]*M_PI/180.0;
Maxwelltime:Full_tracer_advection.c:            delphi=E->trace.delphi[0]*M_PI/180.0;
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"Error(make_regular_grid): numtheta: %d numphi: %d\n",numtheta,numphi);
Maxwelltime:Full_tracer_advection.c:                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:            E->trace.deltheta[j]=deltheta;
Maxwelltime:Full_tracer_advection.c:            E->trace.delphi[j]=delphi;
Maxwelltime:Full_tracer_advection.c:            E->trace.numtheta[j]=numtheta;
Maxwelltime:Full_tracer_advection.c:            E->trace.numphi[j]=numphi;
Maxwelltime:Full_tracer_advection.c:            E->trace.thetamax[j]=thetamax;
Maxwelltime:Full_tracer_advection.c:            E->trace.thetamin[j]=thetamin;
Maxwelltime:Full_tracer_advection.c:            E->trace.phimax[j]=phimax;
Maxwelltime:Full_tracer_advection.c:            E->trace.phimin[j]=phimin;
Maxwelltime:Full_tracer_advection.c:            E->trace.numregel[j]=numregel;
Maxwelltime:Full_tracer_advection.c:            E->trace.numregnodes[j]=numregnodes;
Maxwelltime:Full_tracer_advection.c:            if ( ((1.0*numregel)/(1.0*E->lmesh.elx*E->lmesh.ely)) < 0.5 )
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"\n ! WARNING: regular/real ratio low: %f ! \n",
Maxwelltime:Full_tracer_advection.c:                            ((1.0*numregel)/(1.0*E->lmesh.nel)) );
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt," Should reduce size of regular mesh\n");
Maxwelltime:Full_tracer_advection.c:                            ((1.0*numregel)/(1.0*E->lmesh.nel)) );
Maxwelltime:Full_tracer_advection.c:                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                    if (E->trace.itracer_warnings) exit(10);
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"\nRegular grid:\n");
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Theta min: %f max: %f \n",thetamin,thetamax);
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Phi min: %f max: %f \n",phimin,phimax);
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Adjusted deltheta: %f delphi: %f\n",deltheta,delphi);
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"(numtheta: %d  numphi: %d)\n",numtheta,numphi);
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Number of regular elements: %d  (nodes: %d)\n",numregel,numregnodes);
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"regular/real ratio: %f\n",((1.0*numregel)/(1.0*E->lmesh.elx*E->lmesh.ely)));
Maxwelltime:Full_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:            if ((E->trace.regnodetoel[j]=(int *)malloc((numregnodes+1)*sizeof(int)))==NULL)
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ERROR(make regular) -no memory - uh3ud\n");
Maxwelltime:Full_tracer_advection.c:                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                    E->trace.regnodetoel[j][kk]=-99;
Maxwelltime:Full_tracer_advection.c:            if (E->parallel.me==0) fprintf(stderr,"Beginning Mapping\n");
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Maxwelltime:Full_tracer_advection.c:                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Maxwelltime:Full_tracer_advection.c:                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Maxwelltime:Full_tracer_advection.c:                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"ERROR(make regular) -no memory - 7t1a\n");
Maxwelltime:Full_tracer_advection.c:                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:            for (mm=elz;mm<=E->lmesh.nel;mm=mm+elz)
Maxwelltime:Full_tracer_advection.c:                            node=E->ien[j][mm].node[pp];
Maxwelltime:Full_tracer_advection.c:                            theta=E->sx[j][1][node];
Maxwelltime:Full_tracer_advection.c:                            phi=E->sx[j][2][node];
Maxwelltime:Full_tracer_advection.c:            rad=E->sphere.ro;
Maxwelltime:Full_tracer_advection.c:                    E->trace.regnodetoel[j][kk]=-99;
Maxwelltime:Full_tracer_advection.c:                      for (mm=elz;mm<=E->lmesh.nel;mm=mm+elz)
Maxwelltime:Full_tracer_advection.c:                      E->trace.regnodetoel[j][kk]=mm;
Maxwelltime:Full_tracer_advection.c:                            E->trace.regnodetoel[j][kk]=ilast_el;
Maxwelltime:Full_tracer_advection.c:                            E->trace.regnodetoel[j][kk]=ival;
Maxwelltime:Full_tracer_advection.c:                    for (mm=elz;mm<=E->lmesh.nel;mm=mm+elz)
Maxwelltime:Full_tracer_advection.c:                                            E->trace.regnodetoel[j][kk]=mm;
Maxwelltime:Full_tracer_advection.c:                    if (E->trace.regnodetoel[j][kk]>0) imap++;
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"percentage mapped: %f\n", (1.0*imap)/(1.0*numregnodes)*100.0);
Maxwelltime:Full_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Full_tracer_advection.c:                    if (E->trace.regnodetoel[j][kk]!=-99)
Maxwelltime:Full_tracer_advection.c:                            if ( (E->trace.regnodetoel[j][kk]<1)||(E->trace.regnodetoel[j][kk]>E->lmesh.nel) )
Maxwelltime:Full_tracer_advection.c:                                    fprintf(stderr,"Error(make_regular_grid)-invalid element: %d\n",E->trace.regnodetoel[j][kk]);
Maxwelltime:Full_tracer_advection.c:                                    fprintf(E->trace.fpt,"Error(make_regular_grid)-invalid element: %d\n",E->trace.regnodetoel[j][kk]);
Maxwelltime:Full_tracer_advection.c:                                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    if (E->parallel.me==0) fprintf(stderr,"Beginning Regtoel submapping \n");
Maxwelltime:Full_tracer_advection.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Full_tracer_advection.c:            numregel= E->trace.numregel[j];
Maxwelltime:Full_tracer_advection.c:                    if ((E->trace.regtoel[j][pp]=(int *)malloc((numregel+1)*sizeof(int)))==NULL)
Maxwelltime:Full_tracer_advection.c:                            fprintf(E->trace.fpt,"ERROR(make regular)-no memory 98d (%d %d %d)\n",pp,numregel,j);
Maxwelltime:Full_tracer_advection.c:                            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:            numtheta=E->trace.numtheta[j];
Maxwelltime:Full_tracer_advection.c:            numphi=E->trace.numphi[j];
Maxwelltime:Full_tracer_advection.c:                            for (pp=0;pp<=4;pp++) E->trace.regtoel[j][pp][iregel]=-33;
Maxwelltime:Full_tracer_advection.c:                                    fprintf(E->trace.fpt,"ERROR(make_regular_grid)-weird iregel: %d (max: %d)\n",iregel,numregel);
Maxwelltime:Full_tracer_advection.c:                                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                            iregnode[3]=iregel+nphi+E->trace.numtheta[j]+1;
Maxwelltime:Full_tracer_advection.c:                            iregnode[4]=iregel+nphi+E->trace.numtheta[j];
Maxwelltime:Full_tracer_advection.c:                                            fprintf(E->trace.fpt,"ERROR(make regular)-bad regnode %d\n",iregnode[kk]);
Maxwelltime:Full_tracer_advection.c:                                            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                                    if (E->trace.regnodetoel[j][iregnode[kk]]>E->lmesh.nel)
Maxwelltime:Full_tracer_advection.c:                                            fprintf(E->trace.fpt,"AABB HERE %d %d %d %d\n",iregel,iregnode[kk],kk,E->trace.regnodetoel[j][iregnode[kk]]);
Maxwelltime:Full_tracer_advection.c:                                            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                                    if (E->trace.regnodetoel[j][iregnode[kk]]<=0) goto next_corner;
Maxwelltime:Full_tracer_advection.c:                                            if (E->trace.regnodetoel[j][iregnode[kk]]==E->trace.regnodetoel[j][iregnode[pp]]) goto next_corner;
Maxwelltime:Full_tracer_advection.c:                                    itemp[ichoice]=E->trace.regnodetoel[j][iregnode[kk]];
Maxwelltime:Full_tracer_advection.c:                                            fprintf(E->trace.fpt,"ERROR(make regular) - weird ichoice %d \n",ichoice);
Maxwelltime:Full_tracer_advection.c:                                            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                                    if ((itemp[ichoice]<0) || (itemp[ichoice]>E->lmesh.nel) )
Maxwelltime:Full_tracer_advection.c:                                            fprintf(E->trace.fpt,"ERROR(make regular) - weird element choice %d %d\n",itemp[ichoice],ichoice);
Maxwelltime:Full_tracer_advection.c:                                            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                                    fprintf(E->trace.fpt,"ERROR(make_regular)-wierd ichoice %d\n",ichoice);
Maxwelltime:Full_tracer_advection.c:                                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                                    E->trace.regtoel[j][0][iregel]=-1;
Maxwelltime:Full_tracer_advection.c:                                      fprintf(E->trace.fpt,"HH1: (%p) iregel: %d ichoice: %d value: %d %d\n",&E->trace.regtoel[j][1][iregel],iregel,ichoice,E->trace.regtoel[j][0][iregel],E->trace.regtoel[j][1][iregel]);
Maxwelltime:Full_tracer_advection.c:                                    E->trace.regtoel[j][0][iregel]=0;
Maxwelltime:Full_tracer_advection.c:                                    E->trace.regtoel[j][1][iregel]=itemp[1];
Maxwelltime:Full_tracer_advection.c:                                      fprintf(E->trace.fpt,"HH2: (%p) iregel: %d ichoice: %d value: %d %d\n",&E->trace.regtoel[j][1][iregel],iregel,ichoice,E->trace.regtoel[j][0][iregel],E->trace.regtoel[j][1][iregel]);
Maxwelltime:Full_tracer_advection.c:                                    if (itemp[1]<1 || itemp[1]>E->lmesh.nel)
Maxwelltime:Full_tracer_advection.c:                                            fprintf(E->trace.fpt,"ERROR(make_regular)-huh? wierd itemp\n");
Maxwelltime:Full_tracer_advection.c:                                            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                                    E->trace.regtoel[j][0][iregel]=ichoice;
Maxwelltime:Full_tracer_advection.c:                                            E->trace.regtoel[j][pp][iregel]=itemp[pp];
Maxwelltime:Full_tracer_advection.c:                                              fprintf(E->trace.fpt,"HH:(%p)  iregel: %d ichoice: %d pp: %d value: %d %d\n",&E->trace.regtoel[j][pp][iregel],iregel,ichoice,pp,itemp[pp],E->trace.regtoel[j][pp][iregel]);
Maxwelltime:Full_tracer_advection.c:                                            if (itemp[pp]<1 || itemp[pp]>E->lmesh.nel)
Maxwelltime:Full_tracer_advection.c:                                                    fprintf(E->trace.fpt,"ERROR(make_regular)-huh? wierd itemp 2 \n");
Maxwelltime:Full_tracer_advection.c:                                                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                                    fprintf(E->trace.fpt,"ERROR(make_regular)- should not be here! %d\n",ichoice);
Maxwelltime:Full_tracer_advection.c:                                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:            free (E->trace.regnodetoel[j]);
Maxwelltime:Full_tracer_advection.c:            for (kk=1;kk<=E->trace.numregel[j];kk++)
Maxwelltime:Full_tracer_advection.c:                    if ((E->trace.regtoel[j][0][kk]<-1)||(E->trace.regtoel[j][0][kk]>4))
Maxwelltime:Full_tracer_advection.c:                            fprintf(E->trace.fpt,"ERROR(make regular) regtoel ichoice0? %d %d \n",kk,E->trace.regtoel[j][pp][kk]);
Maxwelltime:Full_tracer_advection.c:                            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                            if (((E->trace.regtoel[j][pp][kk]<1)&&(E->trace.regtoel[j][pp][kk]!=-33))||(E->trace.regtoel[j][pp][kk]>E->lmesh.nel))
Maxwelltime:Full_tracer_advection.c:                                    fprintf(E->trace.fpt,"ERROR(make regular) (%p) regtoel? %d %d(%d) %d\n",&E->trace.regtoel[j][pp][kk],kk,pp,E->trace.regtoel[j][0][kk],E->trace.regtoel[j][pp][kk]);
Maxwelltime:Full_tracer_advection.c:                                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"Mapping completed (%f seconds)\n",CPU_time0()-start_time);
Maxwelltime:Full_tracer_advection.c:    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    if (E->parallel.me==0) fprintf(stderr,"Mapping completed (%f seconds)\n",CPU_time0()-start_time);
Maxwelltime:Full_tracer_advection.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"\n\nInformation regarding number of real elements per regular elements\n");
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt," (stats done on regular elements that were used)\n");
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Ichoice is number of real elements touched by a regular element\n");
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"  (ichoice=0 is optimal)\n");
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Ichoice=0: %f percent\n",(100.0*istat_ichoice[j][0])/(1.0*isum));
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Ichoice=1: %f percent\n",(100.0*istat_ichoice[j][1])/(1.0*isum));
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Ichoice=2: %f percent\n",(100.0*istat_ichoice[j][2])/(1.0*isum));
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Ichoice=3: %f percent\n",(100.0*istat_ichoice[j][3])/(1.0*isum));
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Ichoice=4: %f percent\n",(100.0*istat_ichoice[j][4])/(1.0*isum));
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"\nTracing Activated! (proc: %d)\n",E->parallel.me);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"   Allen K. McNamara 12-2003\n\n");
Maxwelltime:Full_tracer_advection.c:    if (E->trace.ic_method==0)
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Generating New Tracer Array\n");
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Tracers per element: %d\n",E->trace.itperel);
Maxwelltime:Full_tracer_advection.c:    if (E->trace.ic_method==1)
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Reading tracer file %s\n",E->trace.tracer_file);
Maxwelltime:Full_tracer_advection.c:    if (E->trace.ic_method==2)
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Reading individual tracer files\n");
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"Number of tracer flavors: %d\n", E->trace.nflavors);
Maxwelltime:Full_tracer_advection.c:    if (E->trace.nflavors && E->trace.ic_method==0) {
Maxwelltime:Full_tracer_advection.c:        fprintf(E->trace.fpt,"Initialized tracer flavors by: %d\n", E->trace.ic_method_for_flavors);
Maxwelltime:Full_tracer_advection.c:        if (E->trace.ic_method_for_flavors == 0) {
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Layered tracer flavors\n");
Maxwelltime:Full_tracer_advection.c:            for (i=0; i<E->trace.nflavors-1; i++)
Maxwelltime:Full_tracer_advection.c:                fprintf(E->trace.fpt,"Interface Height: %d %f\n",i,E->trace.z_interface[i]);
Maxwelltime:Full_tracer_advection.c:	else if((E->trace.ic_method_for_flavors == 1)||(E->trace.ic_method_for_flavors == 99)) {
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"netcdf grd assigned tracer flavors\n");
Maxwelltime:Full_tracer_advection.c:	    if( E->trace.ggrd_layers > 0)
Maxwelltime:Full_tracer_advection.c:	      fprintf(E->trace.fpt,"file: %s top %i layers\n",E->trace.ggrd_file,
Maxwelltime:Full_tracer_advection.c:		      E->trace.ggrd_layers);
Maxwelltime:Full_tracer_advection.c:	      fprintf(E->trace.fpt,"file: %s only layer %i\n",E->trace.ggrd_file,
Maxwelltime:Full_tracer_advection.c:		      -E->trace.ggrd_layers);
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Sorry-This IC methods for Flavors are Unavailable %d\n",E->trace.ic_method_for_flavors);
Maxwelltime:Full_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    for (i=0; i<E->trace.nflavors-2; i++) {
Maxwelltime:Full_tracer_advection.c:        if (E->trace.z_interface[i] < E->trace.z_interface[i+1]) {
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Sorry - The %d-th z_interface is smaller than the next one.\n", i);
Maxwelltime:Full_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"Regular Grid-> deltheta: %f delphi: %f\n",
Maxwelltime:Full_tracer_advection.c:            E->trace.deltheta[0],E->trace.delphi[0]);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"Box Cushion: %f\n",E->trace.box_cushion);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"Number of Basic Quantities: %d\n",
Maxwelltime:Full_tracer_advection.c:            E->trace.number_of_basic_quantities);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"Number of Extra Quantities: %d\n",
Maxwelltime:Full_tracer_advection.c:            E->trace.number_of_extra_quantities);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"Total Number of Tracer Quantities: %d\n",
Maxwelltime:Full_tracer_advection.c:            E->trace.number_of_tracer_quantities);
Maxwelltime:Full_tracer_advection.c:    if (E->trace.ianalytical_tracer_test==1)
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"\n\n ! Analytical Test Being Performed ! \n");
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"(some of the above parameters may not be used or applied\n");
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Velocity functions given in main code\n");
Maxwelltime:Full_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    if (E->trace.itracer_warnings==0)
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"\n WARNING EXITS ARE TURNED OFF! TURN THEM ON!\n");
Maxwelltime:Full_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    elx=E->lmesh.elx;
Maxwelltime:Full_tracer_advection.c:    ely=E->lmesh.ely;
Maxwelltime:Full_tracer_advection.c:    elz=E->lmesh.elz;
Maxwelltime:Full_tracer_advection.c:            if ((neighbor[kk]>=1)&&(neighbor[kk]<=E->lmesh.nel))
Maxwelltime:Full_tracer_advection.c:    int elz=E->lmesh.elz;
Maxwelltime:Full_tracer_advection.c:    int numel=E->lmesh.nel;
Maxwelltime:Full_tracer_advection.c:    ibottom_node=E->ien[1][nel].node[1];
Maxwelltime:Full_tracer_advection.c:    itop_node=E->ien[1][nel].node[5];
Maxwelltime:Full_tracer_advection.c:    bottom_rad=E->sx[1][3][ibottom_node];
Maxwelltime:Full_tracer_advection.c:    top_rad=E->sx[1][3][itop_node];
Maxwelltime:Full_tracer_advection.c:    int lev = E->mesh.levmax;
Maxwelltime:Full_tracer_advection.c:    E->trace.istat_elements_checked++;
Maxwelltime:Full_tracer_advection.c:            node=E->ien[j][nel].node[kk+4];
Maxwelltime:Full_tracer_advection.c:            rnode[kk][1]=E->x[j][1][node];
Maxwelltime:Full_tracer_advection.c:            rnode[kk][2]=E->x[j][2][node];
Maxwelltime:Full_tracer_advection.c:            rnode[kk][3]=E->x[j][3][node];
Maxwelltime:Full_tracer_advection.c:            rnode[kk][4]=E->sx[j][1][node];
Maxwelltime:Full_tracer_advection.c:            rnode[kk][5]=E->sx[j][2][node];
Maxwelltime:Full_tracer_advection.c:            rnode[kk][6]=E->SinCos[lev][j][2][node]; /* cos(theta) */
Maxwelltime:Full_tracer_advection.c:            rnode[kk][7]=E->SinCos[lev][j][0][node]; /* sin(theta) */
Maxwelltime:Full_tracer_advection.c:            rnode[kk][8]=E->SinCos[lev][j][3][node]; /* cos(phi) */
Maxwelltime:Full_tracer_advection.c:            rnode[kk][9]=E->SinCos[lev][j][1][node]; /* sin(phi) */
Maxwelltime:Full_tracer_advection.c:            rnode[kk][1]=E->trace.xcap[icap][kk];
Maxwelltime:Full_tracer_advection.c:            rnode[kk][2]=E->trace.ycap[icap][kk];
Maxwelltime:Full_tracer_advection.c:            rnode[kk][3]=E->trace.zcap[icap][kk];
Maxwelltime:Full_tracer_advection.c:            rnode[kk][4]=E->trace.theta_cap[icap][kk];
Maxwelltime:Full_tracer_advection.c:            rnode[kk][5]=E->trace.phi_cap[icap][kk];
Maxwelltime:Full_tracer_advection.c:            rnode[kk][6]=E->trace.cos_theta[icap][kk];
Maxwelltime:Full_tracer_advection.c:            rnode[kk][7]=E->trace.sin_theta[icap][kk];
Maxwelltime:Full_tracer_advection.c:            rnode[kk][8]=E->trace.cos_phi[icap][kk];
Maxwelltime:Full_tracer_advection.c:            rnode[kk][9]=E->trace.sin_phi[icap][kk];
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Error(icheck_bounds)-too many tries\n");
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Rads: %f %f %f %f\n",rad1,rad2,rad3,rad4);
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Test Point: %f %f %f  \n",test_point[1],test_point[2],test_point[3]);
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Nodal points: 1: %f %f %f\n",rnode1[1],rnode1[2],rnode1[3]);
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Nodal points: 2: %f %f %f\n",rnode2[1],rnode2[2],rnode2[3]);
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Nodal points: 3: %f %f %f\n",rnode3[1],rnode3[2],rnode3[3]);
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Nodal points: 4: %f %f %f\n",rnode4[1],rnode4[2],rnode4[3]);
Maxwelltime:Full_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:      fprintf(stderr,"%d: icheck: %d\n",E->parallel.me,icheck);
Maxwelltime:Full_tracer_advection.c:      fprintf(stderr,"%d: rads: %f %f %f %f\n",E->parallel.me,rad1,rad2,rad3,rad4);
Maxwelltime:Full_tracer_advection.c:    max_radius = E->sphere.ro - E->trace.box_cushion;
Maxwelltime:Full_tracer_advection.c:    min_radius = E->sphere.ri + E->trace.box_cushion;
Maxwelltime:Full_tracer_advection.c:    elx=E->lmesh.elx;
Maxwelltime:Full_tracer_advection.c:    ely=E->lmesh.ely;
Maxwelltime:Full_tracer_advection.c:    elz=E->lmesh.elz;
Maxwelltime:Full_tracer_advection.c:    if (E->parallel.nprocz>1)
Maxwelltime:Full_tracer_advection.c:    if (E->trace.regtoel[j][0][iregel]==0)
Maxwelltime:Full_tracer_advection.c:            iel=E->trace.regtoel[j][1][iregel];
Maxwelltime:Full_tracer_advection.c:    if (E->trace.regtoel[j][0][iregel]>0)
Maxwelltime:Full_tracer_advection.c:            ichoice=E->trace.regtoel[j][0][iregel];
Maxwelltime:Full_tracer_advection.c:                    nelem=E->trace.regtoel[j][kk][iregel];
Maxwelltime:Full_tracer_advection.c:                            ineighbor=E->trace.regtoel[j][kk][iregel];
Maxwelltime:Full_tracer_advection.c:    E->trace.istat1++;
Maxwelltime:Full_tracer_advection.c:      fprintf(E->trace.fpt,"WARNING(full_iget_element)-doing a full search!\n");
Maxwelltime:Full_tracer_advection.c:      fprintf(E->trace.fpt,"  Most often means tracers have moved more than 1 element away\n");
Maxwelltime:Full_tracer_advection.c:      fprintf(E->trace.fpt,"  or regular element resolution is way too low.\n");
Maxwelltime:Full_tracer_advection.c:      fprintf(E->trace.fpt,"  COLUMN: %d \n",iel);
Maxwelltime:Full_tracer_advection.c:      fprintf(E->trace.fpt,"  PREVIOUS ELEMENT: %d \n",iprevious_element);
Maxwelltime:Full_tracer_advection.c:      fprintf(E->trace.fpt,"  x,y,z,theta,phi,rad: %f %f %f   %f %f %f\n",x,y,z,theta,phi,rad);
Maxwelltime:Full_tracer_advection.c:      fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:      if (E->trace.itracer_warnings) exit(10);
Maxwelltime:Full_tracer_advection.c:    if (E->trace.istat1%100==0)
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"Checked all elements %d times already this turn\n",E->trace.istat1);
Maxwelltime:Full_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"Error(full_iget_element) - element not found\n");
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"x,y,z,theta,phi,iregel %.15e %.15e %.15e %.15e %.15e %d\n",
Maxwelltime:Full_tracer_advection.c:    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    int elz=E->lmesh.elz;
Maxwelltime:Full_tracer_advection.c:            node=E->ien[j][iradial_element].node[8];
Maxwelltime:Full_tracer_advection.c:            top_rad=E->sx[j][3][node];
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"Error(iget_radial_element)-out of range %f %d %d %d\n",rad,j,iel,ibottom_element);
Maxwelltime:Full_tracer_advection.c:    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    if (theta<E->trace.thetamin[j]) return -99;
Maxwelltime:Full_tracer_advection.c:    if (theta>E->trace.thetamax[j]) return -99;
Maxwelltime:Full_tracer_advection.c:    rdum=theta-E->trace.thetamin[j];
Maxwelltime:Full_tracer_advection.c:    idum=rdum/E->trace.deltheta[j];
Maxwelltime:Full_tracer_advection.c:    rdum=phi-E->trace.phimin[j];
Maxwelltime:Full_tracer_advection.c:    idum=rdum/E->trace.delphi[j];
Maxwelltime:Full_tracer_advection.c:    iregel=*ntheta+(*nphi-1)*E->trace.numtheta[j];
Maxwelltime:Full_tracer_advection.c:    if (iregel>E->trace.numregel[j]) return -99;
Maxwelltime:Full_tracer_advection.c:/* E->gnomonic[node].u = u                                      */
Maxwelltime:Full_tracer_advection.c:/* E->gnomonic[node].v = v                                      */
Maxwelltime:Full_tracer_advection.c:    const int lev = E->mesh.levmax;
Maxwelltime:Full_tracer_advection.c:    if ((E->gnomonic = malloc((E->lmesh.nsf+1)*sizeof(struct CITCOM_GNOMONIC)))
Maxwelltime:Full_tracer_advection.c:    sint = E->SinCos[lev][j][0];
Maxwelltime:Full_tracer_advection.c:    sinf = E->SinCos[lev][j][1];
Maxwelltime:Full_tracer_advection.c:    cost = E->SinCos[lev][j][2];
Maxwelltime:Full_tracer_advection.c:    cosf = E->SinCos[lev][j][3];
Maxwelltime:Full_tracer_advection.c:    refnode = 1 + E->lmesh.noz * ((E->lmesh.noy / 2) * E->lmesh.nox
Maxwelltime:Full_tracer_advection.c:                                  + E->lmesh.nox / 2);
Maxwelltime:Full_tracer_advection.c:    phi_f = E->gnomonic_reference_phi = E->sx[j][2][refnode];
Maxwelltime:Full_tracer_advection.c:    theta_f = E->sx[j][1][refnode];
Maxwelltime:Full_tracer_advection.c:    for (i=1; i<=E->lmesh.nsf; i++) {
Maxwelltime:Full_tracer_advection.c:        fprintf(E->trace.fpt, "i=%d (%e %e %e %e)\n",
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt, "%d %d %d ref=(%e %e)\n",
Maxwelltime:Full_tracer_advection.c:            E->lmesh.noz, E->lmesh.nsf, refnode, theta_f, phi_f);
Maxwelltime:Full_tracer_advection.c:    E->gnomonic[0].u = cost[refnode];
Maxwelltime:Full_tracer_advection.c:    E->gnomonic[0].v = sint[refnode];
Maxwelltime:Full_tracer_advection.c:    for (i=1, n=1; i<=E->lmesh.nsf; i++, n+=E->lmesh.noz) {
Maxwelltime:Full_tracer_advection.c:        dphi = E->sx[j][2][n] - phi_f;
Maxwelltime:Full_tracer_advection.c:        E->gnomonic[i].u = u;
Maxwelltime:Full_tracer_advection.c:        E->gnomonic[i].v = v;
Maxwelltime:Full_tracer_advection.c:        fprintf(E->trace.fpt, "n=%d ns=%d cosc=%e (%e %e) -> (%e %e)\n",
Maxwelltime:Full_tracer_advection.c:                n, i, cosc, E->sx[j][1][n], E->sx[j][2][n], u, v);
Maxwelltime:Full_tracer_advection.c:            if ((E->trace.shape_coefs[j][iwedge][kk] =
Maxwelltime:Full_tracer_advection.c:                 (double *)malloc((E->lmesh.snel+1)*sizeof(double))) == NULL) {
Maxwelltime:Full_tracer_advection.c:                fprintf(E->trace.fpt,"ERROR(find shape coefs)-not enough memory(a)\n");
Maxwelltime:Full_tracer_advection.c:                fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    for (i=1, nelem=1; i<=E->lmesh.snel; i++, nelem+=E->lmesh.elz) {
Maxwelltime:Full_tracer_advection.c:            snode = (E->ien[j][nelem].node[kk]-1) / E->lmesh.noz + 1;
Maxwelltime:Full_tracer_advection.c:            u[kk] = E->gnomonic[snode].u;
Maxwelltime:Full_tracer_advection.c:            v[kk] = E->gnomonic[snode].v;
Maxwelltime:Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][1][i] = a0;
Maxwelltime:Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][2][i] = a1;
Maxwelltime:Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][3][i] = a2;
Maxwelltime:Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][4][i] = a0;
Maxwelltime:Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][5][i] = a1;
Maxwelltime:Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][6][i] = a2;
Maxwelltime:Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][7][i] = a0;
Maxwelltime:Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][8][i] = a1;
Maxwelltime:Full_tracer_advection.c:            E->trace.shape_coefs[j][iwedge][9][i] = a2;
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt, "el=%d els=%d iwedge=%d shape=(%e %e %e, %e %e %e, %e %e %e)\n",
Maxwelltime:Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][1][i],
Maxwelltime:Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][2][i],
Maxwelltime:Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][3][i],
Maxwelltime:Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][4][i],
Maxwelltime:Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][5][i],
Maxwelltime:Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][6][i],
Maxwelltime:Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][7][i],
Maxwelltime:Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][8][i],
Maxwelltime:Full_tracer_advection.c:                    E->trace.shape_coefs[j][iwedge][9][i]);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"Starting Analytical Test\n");
Maxwelltime:Full_tracer_advection.c:    if (E->parallel.me==0) fprintf(stderr,"Starting Analytical Test\n");
Maxwelltime:Full_tracer_advection.c:    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    E->trace.box_cushion=0.0000;
Maxwelltime:Full_tracer_advection.c:    E->advection.timestep=dt;
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"steps: %d  dt: %f\n",nsteps,dt);
Maxwelltime:Full_tracer_advection.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Full_tracer_advection.c:            for (kk=1;kk<=E->lmesh.nno;kk++)
Maxwelltime:Full_tracer_advection.c:                    theta=E->sx[j][1][kk];
Maxwelltime:Full_tracer_advection.c:                    phi=E->sx[j][2][kk];
Maxwelltime:Full_tracer_advection.c:                    rad=E->sx[j][3][kk];
Maxwelltime:Full_tracer_advection.c:                    E->sphere.cap[j].V[1][kk]=vel_s[1];
Maxwelltime:Full_tracer_advection.c:                    E->sphere.cap[j].V[2][kk]=vel_s[2];
Maxwelltime:Full_tracer_advection.c:                    E->sphere.cap[j].V[3][kk]=vel_s[3];
Maxwelltime:Full_tracer_advection.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Full_tracer_advection.c:            if (E->trace.ntracers[j]>10)
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"Warning(analytical)-too many tracers to print!\n");
Maxwelltime:Full_tracer_advection.c:                    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:                    if (E->trace.itracer_warnings) exit(10);
Maxwelltime:Full_tracer_advection.c:    E->monitor.solution_cycles=0;
Maxwelltime:Full_tracer_advection.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Full_tracer_advection.c:            for (pp=1;pp<=E->trace.ntracers[j];pp++)
Maxwelltime:Full_tracer_advection.c:                    theta=E->trace.basicq[j][0][pp];
Maxwelltime:Full_tracer_advection.c:                    phi=E->trace.basicq[j][1][pp];
Maxwelltime:Full_tracer_advection.c:                    rad=E->trace.basicq[j][2][pp];
Maxwelltime:Full_tracer_advection.c:                    fprintf(E->trace.fpt,"(%d) time: %f theta: %f phi: %f rad: %f\n",E->monitor.solution_cycles,time,theta,phi,rad);
Maxwelltime:Full_tracer_advection.c:                    if (pp==1) fprintf(stderr,"(%d) time: %f theta: %f phi: %f rad: %f\n",E->monitor.solution_cycles,time,theta,phi,rad);
Maxwelltime:Full_tracer_advection.c:            E->monitor.solution_cycles=kk;
Maxwelltime:Full_tracer_advection.c:            for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Full_tracer_advection.c:                    for (pp=1;pp<=E->trace.ntracers[j];pp++)
Maxwelltime:Full_tracer_advection.c:                            theta=E->trace.basicq[j][0][pp];
Maxwelltime:Full_tracer_advection.c:                            phi=E->trace.basicq[j][1][pp];
Maxwelltime:Full_tracer_advection.c:                            rad=E->trace.basicq[j][2][pp];
Maxwelltime:Full_tracer_advection.c:                            fprintf(E->trace.fpt,"(%d) time: %f theta: %f phi: %f rad: %f\n",E->monitor.solution_cycles,time,theta,phi,rad);
Maxwelltime:Full_tracer_advection.c:                            if (pp==1) fprintf(stderr,"(%d) time: %f theta: %f phi: %f rad: %f\n",E->monitor.solution_cycles,time,theta,phi,rad);
Maxwelltime:Full_tracer_advection.c:    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"\n\nComparison to Runge-Kutte\n");
Maxwelltime:Full_tracer_advection.c:    if (E->parallel.me==0) fprintf(stderr,"Comparison to Runge-Kutte\n");
Maxwelltime:Full_tracer_advection.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Full_tracer_advection.c:            my_number=E->trace.ntracers[j];
Maxwelltime:Full_tracer_advection.c:    MPI_Allreduce(&my_number,&number,1,MPI_INT,MPI_SUM,E->parallel.world);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"Number of tracers: %d\n", number);
Maxwelltime:Full_tracer_advection.c:    if (E->parallel.me==0) fprintf(stderr,"Number of tracers: %d\n", number);
Maxwelltime:Full_tracer_advection.c:            fprintf(E->trace.fpt,"(Note: RK comparison only appropriate for one tracing particle (%d here) \n",number);
Maxwelltime:Full_tracer_advection.c:            if (E->parallel.me==0) fprintf(stderr,"(Note: RK comparison only appropriate for one tracing particle (%d here) \n",number);
Maxwelltime:Full_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    MPI_Allreduce(&my_theta0,&theta0,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Full_tracer_advection.c:    MPI_Allreduce(&my_phi0,&phi0,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Full_tracer_advection.c:    MPI_Allreduce(&my_rad0,&rad0,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Full_tracer_advection.c:    MPI_Allreduce(&my_thetaf,&thetaf,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Full_tracer_advection.c:    MPI_Allreduce(&my_phif,&phif,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Full_tracer_advection.c:    MPI_Allreduce(&my_radf,&radf,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"Citcom calculation: steps: %d  dt: %f\n",nsteps,dt);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"  (nodes per cap: %d x %d x %d)\n",E->lmesh.nox,E->lmesh.noy,(E->lmesh.noz-1)*E->parallel.nprocz+1);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"                    starting position: theta: %f phi: %f rad: %f\n", theta0,phi0,rad0);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"                    final position: theta: %f phi: %f rad: %f\n", thetaf,phif,radf);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"                    (final time: %f) \n",time );
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"\n\nRunge-Kutte calculation: steps: %d  dt: %g\n",nrunge_steps,runge_dt);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"                    starting position: theta: %f phi: %f rad: %f\n", theta0,phi0,rad0);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"                    final position: theta: %f phi: %f rad: %f\n",xf_s[1],xf_s[2],xf_s[3]);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"                    path length: %f \n",runge_path_length );
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"                    (final time: %f) \n",runge_time );
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"\n\n Difference between Citcom and RK: %e  (diff per path length: %e)\n\n",difference,difperpath);
Maxwelltime:Full_tracer_advection.c:    if (E->parallel.me==0)
Maxwelltime:Full_tracer_advection.c:            fprintf(stderr,"  (nodes per cap: %d x %d x %d)\n",E->lmesh.nox,E->lmesh.noy,(E->lmesh.noz-1)*E->parallel.nprocz+1);
Maxwelltime:Full_tracer_advection.c:    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"HERE (Before Sync): %d\n",i);
Maxwelltime:Full_tracer_advection.c:    fflush(E->trace.fpt);
Maxwelltime:Full_tracer_advection.c:    fprintf(E->trace.fpt,"HERE (After Sync): %d\n",i);
Maxwelltime:Full_tracer_advection.c:    fflush(E->trace.fpt);
Maxwelltime:Full_version_dependent.c:    for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Maxwelltime:Full_version_dependent.c:        for (i=1;i<=E->lmesh.NNO[lev];i++) {
Maxwelltime:Full_version_dependent.c:            t[0] = E->X[lev][m][1][i]*dircos[1][1]+
Maxwelltime:Full_version_dependent.c:                E->X[lev][m][2][i]*dircos[1][2]+
Maxwelltime:Full_version_dependent.c:                E->X[lev][m][3][i]*dircos[1][3];
Maxwelltime:Full_version_dependent.c:            t[1] = E->X[lev][m][1][i]*dircos[2][1]+
Maxwelltime:Full_version_dependent.c:                E->X[lev][m][2][i]*dircos[2][2]+
Maxwelltime:Full_version_dependent.c:                E->X[lev][m][3][i]*dircos[2][3];
Maxwelltime:Full_version_dependent.c:            t[2] = E->X[lev][m][1][i]*dircos[3][1]+
Maxwelltime:Full_version_dependent.c:                E->X[lev][m][2][i]*dircos[3][2]+
Maxwelltime:Full_version_dependent.c:                E->X[lev][m][3][i]*dircos[3][3];
Maxwelltime:Full_version_dependent.c:            E->X[lev][m][1][i] = t[0];
Maxwelltime:Full_version_dependent.c:            E->X[lev][m][2][i] = t[1];
Maxwelltime:Full_version_dependent.c:            E->X[lev][m][3][i] = t[2];
Maxwelltime:Full_version_dependent.c:            E->SX[lev][m][1][i] = acos(t[2]/E->SX[lev][m][3][i]);
Maxwelltime:Full_version_dependent.c:            E->SX[lev][m][2][i] = myatan(t[1],t[0]);
Maxwelltime:Full_version_dependent.c:  rr = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Maxwelltime:Full_version_dependent.c:  RR = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Maxwelltime:Full_version_dependent.c:  switch(E->control.coor){
Maxwelltime:Full_version_dependent.c:    dr = (E->sphere.ro-E->sphere.ri)/(E->mesh.noz-1);
Maxwelltime:Full_version_dependent.c:    for (k=1;k <= E->mesh.noz;k++)  {
Maxwelltime:Full_version_dependent.c:      rr[k] = E->sphere.ri + (k-1)*dr;
Maxwelltime:Full_version_dependent.c:    sprintf(output_file,"%s",E->control.coor_file);
Maxwelltime:Full_version_dependent.c:      fprintf(E->fp,"(Nodal_mesh.c #1) Cannot open %s\n",output_file);
Maxwelltime:Full_version_dependent.c:    for (k=1;k<=E->mesh.noz;k++)  {
Maxwelltime:Full_version_dependent.c:  for (i=1;i<=E->lmesh.noz;i++)  {
Maxwelltime:Full_version_dependent.c:    k = E->lmesh.nzs+i-1;
Maxwelltime:Full_version_dependent.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Maxwelltime:Full_version_dependent.c:    if (E->control.NMULTIGRID)
Maxwelltime:Full_version_dependent.c:        step = (int) pow(2.0,(double)(E->mesh.levmax-lev));
Maxwelltime:Full_version_dependent.c:      for (i=1;i<=E->lmesh.NOZ[lev];i++)
Maxwelltime:Full_version_dependent.c:         E->sphere.R[lev][i] = RR[(i-1)*step+1];
Maxwelltime:Full_version_dependent.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Maxwelltime:Full_version_dependent.c:     ii = E->sphere.capid[j];
Maxwelltime:Full_version_dependent.c:  if (E->control.verbose) {
Maxwelltime:Full_version_dependent.c:      for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)   {
Maxwelltime:Full_version_dependent.c:          fprintf(E->fp_out,"output_coordinates before rotation %d \n",lev);
Maxwelltime:Full_version_dependent.c:          for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Full_version_dependent.c:              for (i=1;i<=E->lmesh.NNO[lev];i++)
Maxwelltime:Full_version_dependent.c:                  if(i%E->lmesh.NOZ[lev]==1)
Maxwelltime:Full_version_dependent.c:                      fprintf(E->fp_out,"%d %d %g %g %g\n",j,i,E->SX[lev][j][1][i],E->SX[lev][j][2][i],E->SX[lev][j][3][i]);
Maxwelltime:Full_version_dependent.c:      fflush(E->fp_out);
Maxwelltime:Full_version_dependent.c:  ro = -0.5*(M_PI/4.0)/E->mesh.elx;
Maxwelltime:Full_version_dependent.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Maxwelltime:Full_version_dependent.c:     ii = E->sphere.capid[j];
Maxwelltime:Full_version_dependent.c:  if (E->control.verbose) {
Maxwelltime:Full_version_dependent.c:      for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)   {
Maxwelltime:Full_version_dependent.c:          fprintf(E->fp_out,"output_coordinates after rotation %d \n",lev);
Maxwelltime:Full_version_dependent.c:          for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Full_version_dependent.c:              for (i=1;i<=E->lmesh.NNO[lev];i++)
Maxwelltime:Full_version_dependent.c:                  if(i%E->lmesh.NOZ[lev]==1)
Maxwelltime:Full_version_dependent.c:                      fprintf(E->fp_out,"%d %d %g %g %g\n",j,i,E->SX[lev][j][1][i],E->SX[lev][j][2][i],E->SX[lev][j][3][i]);
Maxwelltime:Full_version_dependent.c:      fflush(E->fp_out);
Maxwelltime:Full_version_dependent.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Maxwelltime:Full_version_dependent.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Full_version_dependent.c:      for (i=1;i<=E->lmesh.NNO[lev];i++)  {
Maxwelltime:Full_version_dependent.c:	tg = theta_g(E->SX[lev][j][1][i],E);
Maxwelltime:Full_version_dependent.c:	E->SinCos[lev][j][0][i] = sin(tg); /*  */
Maxwelltime:Full_version_dependent.c:	E->SinCos[lev][j][1][i] = sin(E->SX[lev][j][2][i]);
Maxwelltime:Full_version_dependent.c:	E->SinCos[lev][j][2][i] = cos(tg);
Maxwelltime:Full_version_dependent.c:	E->SinCos[lev][j][3][i] = cos(E->SX[lev][j][2][i]);
Maxwelltime:Full_version_dependent.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Maxwelltime:Full_version_dependent.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Full_version_dependent.c:      for (i=1;i<=E->lmesh.NNO[lev];i++)  {
Maxwelltime:Full_version_dependent.c:	E->SinCos[lev][j][0][i] = sin(E->SX[lev][j][1][i]); /* sin(theta) */
Maxwelltime:Full_version_dependent.c:	E->SinCos[lev][j][1][i] = sin(E->SX[lev][j][2][i]); /* sin(phi) */
Maxwelltime:Full_version_dependent.c:	E->SinCos[lev][j][2][i] = cos(E->SX[lev][j][1][i]); /* cos(theta) */
Maxwelltime:Full_version_dependent.c:	E->SinCos[lev][j][3][i] = cos(E->SX[lev][j][2][i]); /* cos(phi) */
Maxwelltime:Full_version_dependent.c:  const int dims=E->mesh.nsd;
Maxwelltime:Full_version_dependent.c:  int max_size = 2*E->lmesh.elx*E->lmesh.ely + 1;
Maxwelltime:Full_version_dependent.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Full_version_dependent.c:    E->boundary.element[m] = (int *)malloc(max_size*sizeof(int));
Maxwelltime:Full_version_dependent.c:      E->boundary.normal[m][d] = (int *)malloc(max_size*sizeof(int));
Maxwelltime:Full_version_dependent.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Full_version_dependent.c:    for(k=1; k<=E->lmesh.ely; k++)
Maxwelltime:Full_version_dependent.c:      for(j=1; j<=E->lmesh.elx; j++) {
Maxwelltime:Full_version_dependent.c:	if(E->parallel.me_loc[3] == 0) {
Maxwelltime:Full_version_dependent.c:	  el = i + (j-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Maxwelltime:Full_version_dependent.c:	  E->boundary.element[m][count] = el;
Maxwelltime:Full_version_dependent.c:	  E->boundary.normal[m][dims][count] = -1;
Maxwelltime:Full_version_dependent.c:	      E->boundary.normal[m][d][count] = 0;
Maxwelltime:Full_version_dependent.c:	if(E->parallel.me_loc[3] == E->parallel.nprocz - 1) {
Maxwelltime:Full_version_dependent.c:	  i = E->lmesh.elz;
Maxwelltime:Full_version_dependent.c:	  el = i + (j-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Maxwelltime:Full_version_dependent.c:	  E->boundary.element[m][count] = el;
Maxwelltime:Full_version_dependent.c:	  E->boundary.normal[m][dims][count] = 1;
Maxwelltime:Full_version_dependent.c:	    E->boundary.normal[m][d][count] = 0;
Maxwelltime:Full_version_dependent.c:    E->boundary.nel = count - 1;
Maxwelltime:General_matrix_functions.c:  neq  = E->lmesh.NEQ[high_lev];
Maxwelltime:General_matrix_functions.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c:  r0=residual=sqrt(global_vdot(E,F,F,high_lev)/E->mesh.neq);
Maxwelltime:General_matrix_functions.c:  if (!E->control.NMULTIGRID) {
Maxwelltime:General_matrix_functions.c:    cycles = E->control.v_steps_low;
Maxwelltime:General_matrix_functions.c:    if(E->parallel.me==0){	/* output */
Maxwelltime:General_matrix_functions.c:	fprintf(E->fp,"resi = %.6e for iter %d acc %.6e\n",residual,counts,acc);
Maxwelltime:General_matrix_functions.c:      if(E->parallel.me==0){	/* output  */
Maxwelltime:General_matrix_functions.c:	fprintf(E->fp,"resi = %.6e for iter %d acc %.6e\n",residual,counts,acc);
Maxwelltime:General_matrix_functions.c:    }  while (!valid && counts < E->control.max_mg_cycles);
Maxwelltime:General_matrix_functions.c:  if(E->control.print_convergence&&E->parallel.me==0)   {
Maxwelltime:General_matrix_functions.c:    fprintf(E->fp,"%s residual (%03d) = %.3e from %.3e to %.3e in %5.2f secs \n",
Maxwelltime:General_matrix_functions.c:    fflush(E->fp);
Maxwelltime:General_matrix_functions.c:  E->monitor.momentum_residual = residual;
Maxwelltime:General_matrix_functions.c:  E->control.total_iteration_cycles += count;
Maxwelltime:General_matrix_functions.c:  E->control.total_v_solver_calls += 1;
Maxwelltime:General_matrix_functions.c:    const int levmin = E->mesh.levmin;
Maxwelltime:General_matrix_functions.c:    const int levmax = E->mesh.levmax;
Maxwelltime:General_matrix_functions.c:    for(i=E->mesh.levmin;i<=E->mesh.levmax;i++)
Maxwelltime:General_matrix_functions.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:General_matrix_functions.c:	del_vel[i][m]=(double *)malloc((E->lmesh.NEQ[i]+1)*sizeof(double));
Maxwelltime:General_matrix_functions.c:	AU[i][m] = (double *)malloc((E->lmesh.NEQ[i]+1)*sizeof(double));
Maxwelltime:General_matrix_functions.c:	vel[i][m]=(double *)malloc((E->lmesh.NEQ[i]+1)*sizeof(double));
Maxwelltime:General_matrix_functions.c:	res[i][m]=(double *)malloc((E->lmesh.NEQ[i])*sizeof(double));
Maxwelltime:General_matrix_functions.c:	if (i<E->mesh.levmax)
Maxwelltime:General_matrix_functions.c:	  fl[i][m]=(double *)malloc((E->lmesh.NEQ[i])*sizeof(double));
Maxwelltime:General_matrix_functions.c:    Vnmax = E->control.mg_cycle;
Maxwelltime:General_matrix_functions.c:    cycles = E->control.v_steps_low;
Maxwelltime:General_matrix_functions.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c:          for(j=0;j<E->lmesh.NEQ[lev];j++)
Maxwelltime:General_matrix_functions.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c:          for(j=0;j<E->lmesh.NEQ[lev];j++)
Maxwelltime:General_matrix_functions.c:          cycles=((dlev==levmax)?E->control.v_steps_high:E->control.down_heavy);
Maxwelltime:General_matrix_functions.c:          for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c:             for(i=0;i<E->lmesh.NEQ[dlev];i++)  {
Maxwelltime:General_matrix_functions.c:       cycles = E->control.v_steps_low;
Maxwelltime:General_matrix_functions.c:            cycles=((ulev==levmax)?E->control.v_steps_high:E->control.up_heavy);
Maxwelltime:General_matrix_functions.c:            for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c:              for(i=0;i<E->lmesh.NEQ[ulev];i++)   {
Maxwelltime:General_matrix_functions.c:              for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c:                for(i=0;i<E->lmesh.NEQ[ulev];i++)   {
Maxwelltime:General_matrix_functions.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c:     for(j=0;j<E->lmesh.NEQ[levmax];j++)   {
Maxwelltime:General_matrix_functions.c:     residual = sqrt(global_vdot(E,F,F,hl)/E->mesh.NEQ[hl]);
Maxwelltime:General_matrix_functions.c:      for(i=E->mesh.levmin;i<=E->mesh.levmax;i++)
Maxwelltime:General_matrix_functions.c:        for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:General_matrix_functions.c:	  if (i<E->mesh.levmax)
Maxwelltime:General_matrix_functions.c:    const int mem_lev=E->mesh.levmax;
Maxwelltime:General_matrix_functions.c:    const int high_neq = E->lmesh.NEQ[level];
Maxwelltime:General_matrix_functions.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:General_matrix_functions.c:      r0[m] = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
Maxwelltime:General_matrix_functions.c:      r1[m] = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
Maxwelltime:General_matrix_functions.c:      r2[m] = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
Maxwelltime:General_matrix_functions.c:      z0[m] = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
Maxwelltime:General_matrix_functions.c:      z1[m] = (double *)malloc(E->lmesh.NEQ[mem_lev]*sizeof(double));
Maxwelltime:General_matrix_functions.c:      p1[m] = (double *)malloc((1+E->lmesh.NEQ[mem_lev])*sizeof(double));
Maxwelltime:General_matrix_functions.c:      p2[m] = (double *)malloc((1+E->lmesh.NEQ[mem_lev])*sizeof(double));
Maxwelltime:General_matrix_functions.c:      Ap[m] = (double *)malloc((1+E->lmesh.NEQ[mem_lev])*sizeof(double));
Maxwelltime:General_matrix_functions.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c:         z1[m][i] = E->BI[level][m][i] * r1[m][i];
Maxwelltime:General_matrix_functions.c:          for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c:            for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:General_matrix_functions.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:General_matrix_functions.c:    const int dims=E->mesh.nsd;
Maxwelltime:General_matrix_functions.c:    const int n=loc_mat_size[E->mesh.nsd];
Maxwelltime:General_matrix_functions.c:    const int neq=E->lmesh.NEQ[level];
Maxwelltime:General_matrix_functions.c:    const int nel=E->lmesh.NEL[level];
Maxwelltime:General_matrix_functions.c:    const int nno=E->lmesh.NNO[level];
Maxwelltime:General_matrix_functions.c:    for (m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c:     for (m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:General_matrix_functions.c:	    elt_k = E->elt_k[level][m][e].k;
Maxwelltime:General_matrix_functions.c:		node=E->IEN[level][m][e].node[i];
Maxwelltime:General_matrix_functions.c:		if(E->NODE[level][m][node] & VBX)
Maxwelltime:General_matrix_functions.c:		if(E->NODE[level][m][node] & VBY)
Maxwelltime:General_matrix_functions.c:		if(E->NODE[level][m][node] & VBZ)
Maxwelltime:General_matrix_functions.c:		node=E->IEN[level][m][e].node[i];
Maxwelltime:General_matrix_functions.c:		eqn1=E->ID[level][m][node].doff[1];
Maxwelltime:General_matrix_functions.c:		eqn2=E->ID[level][m][node].doff[2];
Maxwelltime:General_matrix_functions.c:                eqn3=E->ID[level][m][node].doff[3];
Maxwelltime:General_matrix_functions.c:		    node1=E->IEN[level][m][e].node[j];
Maxwelltime:General_matrix_functions.c:	            eqn11=E->ID[level][m][node1].doff[1];
Maxwelltime:General_matrix_functions.c:		    eqn12=E->ID[level][m][node1].doff[2];
Maxwelltime:General_matrix_functions.c:		    eqn13=E->ID[level][m][node1].doff[3];
Maxwelltime:General_matrix_functions.c:		node=E->IEN[level][m][e].node[i];
Maxwelltime:General_matrix_functions.c:		eqn1=E->ID[level][m][node].doff[1];
Maxwelltime:General_matrix_functions.c:		eqn2=E->ID[level][m][node].doff[2];
Maxwelltime:General_matrix_functions.c:		eqn3=E->ID[level][m][node].doff[3];
Maxwelltime:General_matrix_functions.c:		d0[m][eqn1] += (dd[m][eqn1] = w[(i-1)*dims]*(F[m][eqn1]-Ad[m][eqn1])*E->BI[level][m][eqn1]);
Maxwelltime:General_matrix_functions.c:		d0[m][eqn2] += (dd[m][eqn2] = w[(i-1)*dims+1]*(F[m][eqn2]-Ad[m][eqn2])*E->BI[level][m][eqn2]);
Maxwelltime:General_matrix_functions.c:		d0[m][eqn3] += (dd[m][eqn3] = w[(i-1)*dims+2]*(F[m][eqn3]-Ad[m][eqn3])*E->BI[level][m][eqn3]);
Maxwelltime:General_matrix_functions.c:		   node1=E->IEN[level][m][e].node[j];
Maxwelltime:General_matrix_functions.c:		   eqn11=E->ID[level][m][node1].doff[1];
Maxwelltime:General_matrix_functions.c:		   eqn12=E->ID[level][m][node1].doff[2];
Maxwelltime:General_matrix_functions.c:		   eqn13=E->ID[level][m][node1].doff[3];
Maxwelltime:General_matrix_functions.c:        (E->solver.exchange_id_d)(E, Ad, level);
Maxwelltime:General_matrix_functions.c:        (E->solver.exchange_id_d)(E, d0, level);
Maxwelltime:General_matrix_functions.c:    for (m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:General_matrix_functions.c:    const int dims=E->mesh.nsd;
Maxwelltime:General_matrix_functions.c:    const int n=loc_mat_size[E->mesh.nsd];
Maxwelltime:General_matrix_functions.c:    const int neq=E->lmesh.NEQ[level];
Maxwelltime:General_matrix_functions.c:    const int num_nodes=E->lmesh.NNO[level];
Maxwelltime:General_matrix_functions.c:    const int nox=E->lmesh.NOX[level];
Maxwelltime:General_matrix_functions.c:    const int noz=E->lmesh.NOY[level];
Maxwelltime:General_matrix_functions.c:    const int noy=E->lmesh.NOZ[level];
Maxwelltime:General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c: 	for(j=0;j<=E->lmesh.NEQ[level];j++)
Maxwelltime:General_matrix_functions.c:          E->temp[m][j] = zeroo;
Maxwelltime:General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c: 	for(i=1;i<=E->lmesh.NNO[level];i++)
Maxwelltime:General_matrix_functions.c:          if(E->NODE[level][m][i] & OFFSIDE)   {
Maxwelltime:General_matrix_functions.c:	    eqn1=E->ID[level][m][i].doff[1];
Maxwelltime:General_matrix_functions.c:	    eqn2=E->ID[level][m][i].doff[2];
Maxwelltime:General_matrix_functions.c:	    eqn3=E->ID[level][m][i].doff[3];
Maxwelltime:General_matrix_functions.c:	    E->temp[m][eqn1] = (F[m][eqn1] - Ad[m][eqn1])*E->BI[level][m][eqn1];
Maxwelltime:General_matrix_functions.c:	    E->temp[m][eqn2] = (F[m][eqn2] - Ad[m][eqn2])*E->BI[level][m][eqn2];
Maxwelltime:General_matrix_functions.c:	    E->temp[m][eqn3] = (F[m][eqn3] - Ad[m][eqn3])*E->BI[level][m][eqn3];
Maxwelltime:General_matrix_functions.c:	    E->temp1[m][eqn1] = Ad[m][eqn1];
Maxwelltime:General_matrix_functions.c:	    E->temp1[m][eqn2] = Ad[m][eqn2];
Maxwelltime:General_matrix_functions.c:	    E->temp1[m][eqn3] = Ad[m][eqn3];
Maxwelltime:General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c: 	for(i=1;i<=E->lmesh.NNO[level];i++)     {
Maxwelltime:General_matrix_functions.c:	    eqn1=E->ID[level][m][i].doff[1];
Maxwelltime:General_matrix_functions.c:	    eqn2=E->ID[level][m][i].doff[2];
Maxwelltime:General_matrix_functions.c:	    eqn3=E->ID[level][m][i].doff[3];
Maxwelltime:General_matrix_functions.c:            C=E->Node_map[level][m]+(i-1)*max_eqn;
Maxwelltime:General_matrix_functions.c:	    B1=E->Eqn_k1[level][m]+(i-1)*max_eqn;
Maxwelltime:General_matrix_functions.c:	    B2=E->Eqn_k2[level][m]+(i-1)*max_eqn;
Maxwelltime:General_matrix_functions.c: 	    B3=E->Eqn_k3[level][m]+(i-1)*max_eqn;
Maxwelltime:General_matrix_functions.c:                 UU = E->temp[m][C[j]];
Maxwelltime:General_matrix_functions.c:            if (!(E->NODE[level][m][i]&OFFSIDE))   {
Maxwelltime:General_matrix_functions.c:               E->temp[m][eqn1] = (F[m][eqn1] - Ad[m][eqn1])*E->BI[level][m][eqn1];
Maxwelltime:General_matrix_functions.c:               E->temp[m][eqn2] = (F[m][eqn2] - Ad[m][eqn2])*E->BI[level][m][eqn2];
Maxwelltime:General_matrix_functions.c:               E->temp[m][eqn3] = (F[m][eqn3] - Ad[m][eqn3])*E->BI[level][m][eqn3];
Maxwelltime:General_matrix_functions.c:		    Ad[m][C[j]]  += B1[j]*E->temp[m][eqn1]
Maxwelltime:General_matrix_functions.c:                                 +  B2[j]*E->temp[m][eqn2]
Maxwelltime:General_matrix_functions.c:                                 +  B3[j]*E->temp[m][eqn3];
Maxwelltime:General_matrix_functions.c:	    d0[m][eqn1] += E->temp[m][eqn1];
Maxwelltime:General_matrix_functions.c:	    d0[m][eqn2] += E->temp[m][eqn2];
Maxwelltime:General_matrix_functions.c:	    d0[m][eqn3] += E->temp[m][eqn3];
Maxwelltime:General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c: 	for(i=1;i<=E->lmesh.NNO[level];i++)
Maxwelltime:General_matrix_functions.c:          if(E->NODE[level][m][i] & OFFSIDE)   {
Maxwelltime:General_matrix_functions.c:	    eqn1=E->ID[level][m][i].doff[1];
Maxwelltime:General_matrix_functions.c:	    eqn2=E->ID[level][m][i].doff[2];
Maxwelltime:General_matrix_functions.c:	    eqn3=E->ID[level][m][i].doff[3];
Maxwelltime:General_matrix_functions.c:	    Ad[m][eqn1] -= E->temp1[m][eqn1];
Maxwelltime:General_matrix_functions.c:	    Ad[m][eqn2] -= E->temp1[m][eqn2];
Maxwelltime:General_matrix_functions.c:	    Ad[m][eqn3] -= E->temp1[m][eqn3];
Maxwelltime:General_matrix_functions.c:      (E->solver.exchange_id_d)(E, Ad, level);
Maxwelltime:General_matrix_functions.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:General_matrix_functions.c: 	for(i=1;i<=E->lmesh.NNO[level];i++)
Maxwelltime:General_matrix_functions.c:          if(E->NODE[level][m][i] & OFFSIDE)   {
Maxwelltime:General_matrix_functions.c:	    eqn1=E->ID[level][m][i].doff[1];
Maxwelltime:General_matrix_functions.c:	    eqn2=E->ID[level][m][i].doff[2];
Maxwelltime:General_matrix_functions.c:	    eqn3=E->ID[level][m][i].doff[3];
Maxwelltime:General_matrix_functions.c:	    Ad[m][eqn1] += E->temp1[m][eqn1];
Maxwelltime:General_matrix_functions.c:	    Ad[m][eqn2] += E->temp1[m][eqn2];
Maxwelltime:General_matrix_functions.c:	    Ad[m][eqn3] += E->temp1[m][eqn3];
Maxwelltime:General_matrix_functions.c:/*     for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Ggrd_handling.c:  if (E->parallel.nprocxy == 12){
Maxwelltime:Ggrd_handling.c:  only_one_layer = ((E->trace.ggrd_layers > 0)?(0):(1));
Maxwelltime:Ggrd_handling.c:  if(E->parallel.me > 0){	
Maxwelltime:Ggrd_handling.c:    mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 
Maxwelltime:Ggrd_handling.c:		      0, E->parallel.world, &mpi_stat);
Maxwelltime:Ggrd_handling.c:  if(ggrd_grdtrack_init_general(FALSE,E->trace.ggrd_file,
Maxwelltime:Ggrd_handling.c:  if(E->parallel.me <  E->parallel.nproc-1){
Maxwelltime:Ggrd_handling.c:		      MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Maxwelltime:Ggrd_handling.c:  for (j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Ggrd_handling.c:    number_of_tracers = E->trace.ntracers[j];
Maxwelltime:Ggrd_handling.c:      rad = E->trace.basicq[j][2][kk]; /* tracer radius */
Maxwelltime:Ggrd_handling.c:      if((only_one_layer && (this_layer == -E->trace.ggrd_layers)) ||
Maxwelltime:Ggrd_handling.c:	 ((!only_one_layer)&&(this_layer <= E->trace.ggrd_layers))){
Maxwelltime:Ggrd_handling.c:	phi =   E->trace.basicq[j][1][kk];
Maxwelltime:Ggrd_handling.c:	theta = E->trace.basicq[j][0][kk];
Maxwelltime:Ggrd_handling.c:	E->trace.extraq[j][0][kk]= indbl;
Maxwelltime:Ggrd_handling.c:	E->trace.extraq[j][0][kk] = 0.0;
Maxwelltime:Ggrd_handling.c:  if(E->parallel.me == 0)
Maxwelltime:Ggrd_handling.c:  noy=E->lmesh.noy;
Maxwelltime:Ggrd_handling.c:  nox=E->lmesh.nox;
Maxwelltime:Ggrd_handling.c:  noz=E->lmesh.noz;
Maxwelltime:Ggrd_handling.c:  if(E->parallel.me == 0)
Maxwelltime:Ggrd_handling.c:  if(E->parallel.me > 0){
Maxwelltime:Ggrd_handling.c:    mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1),
Maxwelltime:Ggrd_handling.c:		      0, E->parallel.world, &mpi_stat);
Maxwelltime:Ggrd_handling.c:  if(E->control.ggrd.temp.scale_with_prem){/* initialize PREM */
Maxwelltime:Ggrd_handling.c:    if(prem_read_model(E->control.ggrd.temp.prem.model_filename,
Maxwelltime:Ggrd_handling.c:		       &E->control.ggrd.temp.prem, (E->parallel.me == 0)))
Maxwelltime:Ggrd_handling.c:  E->control.ggrd.temp.d[0].init = FALSE;
Maxwelltime:Ggrd_handling.c:  if(ggrd_grdtrack_init_general(TRUE,E->control.ggrd.temp.gfile,
Maxwelltime:Ggrd_handling.c:				E->control.ggrd.temp.dfile,gmt_string,
Maxwelltime:Ggrd_handling.c:				E->control.ggrd.temp.d,(E->parallel.me == 0),
Maxwelltime:Ggrd_handling.c:  if(E->parallel.me <  E->parallel.nproc-1){
Maxwelltime:Ggrd_handling.c:    mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Maxwelltime:Ggrd_handling.c:	    E->parallel.me);
Maxwelltime:Ggrd_handling.c:  if(E->mesh.bottbc == 1){
Maxwelltime:Ggrd_handling.c:    tbot =  E->control.TBCbotval;
Maxwelltime:Ggrd_handling.c:  tmean = (tbot + E->control.TBCtopval)/2.0 +  E->control.ggrd.temp.offset;
Maxwelltime:Ggrd_handling.c:  for(m=1;m <= E->sphere.caps_per_proc;m++)
Maxwelltime:Ggrd_handling.c:	  if(!ggrd_grdtrack_interpolate_rtp((double)E->sx[m][3][node],(double)E->sx[m][1][node],
Maxwelltime:Ggrd_handling.c:					    (double)E->sx[m][2][node],
Maxwelltime:Ggrd_handling.c:					    E->control.ggrd.temp.d,&tadd,
Maxwelltime:Ggrd_handling.c:	    fprintf(stderr,"%g %g %g\n",E->sx[m][2][node]*57.29577951308232087,
Maxwelltime:Ggrd_handling.c:		    90-E->sx[m][1][node]*57.29577951308232087,(1-E->sx[m][3][node])*6371);
Maxwelltime:Ggrd_handling.c:	  if(E->control.ggrd.temp.scale_with_prem){
Maxwelltime:Ggrd_handling.c:	    prem_get_rho(&rho_prem,(double)E->sx[m][3][node],&E->control.ggrd.temp.prem);
Maxwelltime:Ggrd_handling.c:	    E->T[m][node] = tmean + tadd * E->control.ggrd.temp.scale *
Maxwelltime:Ggrd_handling.c:	      rho_prem / E->data.density;
Maxwelltime:Ggrd_handling.c:	    E->T[m][node] = tmean + tadd * E->control.ggrd.temp.scale;
Maxwelltime:Ggrd_handling.c:	  if(E->control.ggrd.temp.limit_trange){
Maxwelltime:Ggrd_handling.c:	    E->T[m][node] = min(max(E->T[m][node], 0.0),1.0);
Maxwelltime:Ggrd_handling.c:	  //fprintf(stderr,"z: %11g T: %11g\n",E->sx[m][3][node],E->T[m][node]);
Maxwelltime:Ggrd_handling.c:	  if(E->control.ggrd.temp.override_tbc){
Maxwelltime:Ggrd_handling.c:	    if((k == 1) && (E->mesh.bottbc == 1)){ /* bottom TBC */
Maxwelltime:Ggrd_handling.c:	      E->sphere.cap[m].TB[1][node] =  E->T[m][node];
Maxwelltime:Ggrd_handling.c:	      E->sphere.cap[m].TB[2][node] =  E->T[m][node];
Maxwelltime:Ggrd_handling.c:	      E->sphere.cap[m].TB[3][node] =  E->T[m][node];
Maxwelltime:Ggrd_handling.c:	      //fprintf(stderr,"z: %11g TBB: %11g\n",E->sx[m][3][node],E->T[m][node]);
Maxwelltime:Ggrd_handling.c:	    if((k == noz) && (E->mesh.toptbc == 1)){ /* top TBC */
Maxwelltime:Ggrd_handling.c:	      E->sphere.cap[m].TB[1][node] =  E->T[m][node];
Maxwelltime:Ggrd_handling.c:	      E->sphere.cap[m].TB[2][node] =  E->T[m][node];
Maxwelltime:Ggrd_handling.c:	      E->sphere.cap[m].TB[3][node] =  E->T[m][node];
Maxwelltime:Ggrd_handling.c:	      //fprintf(stderr,"z: %11g TBT: %11g\n",E->sx[m][3][node],E->T[m][node]);
Maxwelltime:Ggrd_handling.c:  ggrd_grdtrack_free_gstruc(E->control.ggrd.temp.d);
Maxwelltime:Ggrd_handling.c:layer <=  E->control.ggrd.mat_control
Maxwelltime:Ggrd_handling.c:  const int dims=E->mesh.nsd;
Maxwelltime:Ggrd_handling.c:  nox=E->mesh.nox;noy=E->mesh.noy;noz=E->mesh.noz;
Maxwelltime:Ggrd_handling.c:  nox1=E->lmesh.nox;noz1=E->lmesh.noz;noy1=E->lmesh.noy;
Maxwelltime:Ggrd_handling.c:  elx=E->lmesh.elx;elz=E->lmesh.elz;ely=E->lmesh.ely;
Maxwelltime:Ggrd_handling.c:  if(!E->control.ggrd.time_hist.init){
Maxwelltime:Ggrd_handling.c:    ggrd_init_thist_from_file(&E->control.ggrd.time_hist,
Maxwelltime:Ggrd_handling.c:			      E->control.ggrd.time_hist.file,TRUE,(E->parallel.me == 0));
Maxwelltime:Ggrd_handling.c:    E->control.ggrd.time_hist.init = 1;
Maxwelltime:Ggrd_handling.c:  timedep = (E->control.ggrd.time_hist.nvtimes > 1)?(1):(0);
Maxwelltime:Ggrd_handling.c:  if(!E->control.ggrd.mat_control_init){
Maxwelltime:Ggrd_handling.c:    if(E->parallel.me==0)
Maxwelltime:Ggrd_handling.c:	      E->data.radius_km*E->viscosity.zbase_layer[E->control.ggrd.mat_control-1]);
Maxwelltime:Ggrd_handling.c:    if(E->parallel.me > 0)	/* wait for previous processor */
Maxwelltime:Ggrd_handling.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1),
Maxwelltime:Ggrd_handling.c:			0, E->parallel.world, &mpi_stat);
Maxwelltime:Ggrd_handling.c:    E->control.ggrd.mat = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Maxwelltime:Ggrd_handling.c:    for(i=0;i < E->control.ggrd.time_hist.nvtimes;i++){
Maxwelltime:Ggrd_handling.c:	sprintf(tfilename,"%s",E->control.ggrd.mat_file);
Maxwelltime:Ggrd_handling.c:	sprintf(tfilename,"%s/%i/weak.grd",E->control.ggrd.mat_file,i+1);
Maxwelltime:Ggrd_handling.c:				    gmt_string,(E->control.ggrd.mat+i),(E->parallel.me == 0),FALSE))
Maxwelltime:Ggrd_handling.c:    if(E->parallel.me <  E->parallel.nproc-1){ /* tell the next proc to go ahead */
Maxwelltime:Ggrd_handling.c:			MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Maxwelltime:Ggrd_handling.c:  if(timedep || (!E->control.ggrd.mat_control_init)){
Maxwelltime:Ggrd_handling.c:    if(E->parallel.me == 0)
Maxwelltime:Ggrd_handling.c:      ggrd_interpol_time(age,&E->control.ggrd.time_hist,&i1,&i2,&f1,&f2,
Maxwelltime:Ggrd_handling.c:			 E->control.ggrd.time_hist.vstage_transition);
Maxwelltime:Ggrd_handling.c:    for (m=1;m <= E->sphere.caps_per_proc;m++) {
Maxwelltime:Ggrd_handling.c:	if(E->mat[m][j] <= E->control.ggrd.mat_control ){
Maxwelltime:Ggrd_handling.c:		ind = E->ien[m][el].node[inode];
Maxwelltime:Ggrd_handling.c:		xloc[1] += E->x[m][1][ind];xloc[2] += E->x[m][2][ind];xloc[3] += E->x[m][3][ind];
Maxwelltime:Ggrd_handling.c:	      if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.mat+i1),&indbl,
Maxwelltime:Ggrd_handling.c:						 (E->control.ggrd.mat+i2),&indbl2,
Maxwelltime:Ggrd_handling.c:	      E->VIP[m][el] = vip;
Maxwelltime:Ggrd_handling.c:	      E->VIP[m][el] = 1.0;
Maxwelltime:Ggrd_handling.c:  if((!timedep) && (!E->control.ggrd.mat_control_init)){			/* forget the grid */
Maxwelltime:Ggrd_handling.c:    ggrd_grdtrack_free_gstruc(E->control.ggrd.mat);
Maxwelltime:Ggrd_handling.c:  E->control.ggrd.mat_control_init = 1;
Maxwelltime:Ggrd_handling.c:layer <= E->control.ggrd.ray_control
Maxwelltime:Ggrd_handling.c:  const int dims=E->mesh.nsd;
Maxwelltime:Ggrd_handling.c:  nox=E->mesh.nox;noy=E->mesh.noy;noz=E->mesh.noz;
Maxwelltime:Ggrd_handling.c:  nox1=E->lmesh.nox;noz1=E->lmesh.noz;noy1=E->lmesh.noy;
Maxwelltime:Ggrd_handling.c:  elx=E->lmesh.elx;elz=E->lmesh.elz;ely=E->lmesh.ely;
Maxwelltime:Ggrd_handling.c:  lev=E->mesh.levmax;
Maxwelltime:Ggrd_handling.c:  if(!E->control.ggrd.time_hist.init){
Maxwelltime:Ggrd_handling.c:    ggrd_init_thist_from_file(&E->control.ggrd.time_hist,
Maxwelltime:Ggrd_handling.c:			      E->control.ggrd.time_hist.file,TRUE,(E->parallel.me == 0));
Maxwelltime:Ggrd_handling.c:    E->control.ggrd.time_hist.init = 1;
Maxwelltime:Ggrd_handling.c:  timedep = (E->control.ggrd.time_hist.nvtimes > 1)?(1):(0);
Maxwelltime:Ggrd_handling.c:  if(!E->control.ggrd.ray_control_init){
Maxwelltime:Ggrd_handling.c:    if(E->parallel.me==0)
Maxwelltime:Ggrd_handling.c:      fprintf(stderr,"ggrd_read_ray_from_file: initializing from %s\n",E->control.ggrd.ray_file);
Maxwelltime:Ggrd_handling.c:    if(E->parallel.me > 0)	/* wait for previous processor */
Maxwelltime:Ggrd_handling.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1),
Maxwelltime:Ggrd_handling.c:			0, E->parallel.world, &mpi_stat);
Maxwelltime:Ggrd_handling.c:    E->control.ggrd.ray = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Maxwelltime:Ggrd_handling.c:    for(i=0;i < E->control.ggrd.time_hist.nvtimes;i++){
Maxwelltime:Ggrd_handling.c:	sprintf(tfilename,"%s",E->control.ggrd.ray_file);
Maxwelltime:Ggrd_handling.c:	sprintf(tfilename,"%s/%i/rayleigh.grd",E->control.ggrd.ray_file,i+1);
Maxwelltime:Ggrd_handling.c:				    gmt_string,(E->control.ggrd.ray+i),(E->parallel.me == 0),FALSE))
Maxwelltime:Ggrd_handling.c:    if(E->parallel.me <  E->parallel.nproc-1){ /* tell the next proc to go ahead */
Maxwelltime:Ggrd_handling.c:			MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Maxwelltime:Ggrd_handling.c:    E->control.surface_rayleigh = (float *)malloc(sizeof(float)*(E->lmesh.nsf+2));
Maxwelltime:Ggrd_handling.c:    if(!E->control.surface_rayleigh)
Maxwelltime:Ggrd_handling.c:  if(timedep || (!E->control.ggrd.ray_control_init)){
Maxwelltime:Ggrd_handling.c:      ggrd_interpol_time(age,&E->control.ggrd.time_hist,&i1,&i2,&f1,&f2,
Maxwelltime:Ggrd_handling.c:			 E->control.ggrd.time_hist.vstage_transition);
Maxwelltime:Ggrd_handling.c:    if(E->parallel.me == 0)
Maxwelltime:Ggrd_handling.c:    for (m=1;m <= E->sphere.caps_per_proc;m++) {
Maxwelltime:Ggrd_handling.c:      for (j=1;j <= E->lmesh.nsf;j++)  {
Maxwelltime:Ggrd_handling.c:	node = j * E->lmesh.noz ;
Maxwelltime:Ggrd_handling.c:	rout[1] = (double)E->sx[m][1][node];
Maxwelltime:Ggrd_handling.c:	rout[2] = (double)E->sx[m][2][node];
Maxwelltime:Ggrd_handling.c:	if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.ray+i1),&indbl,
Maxwelltime:Ggrd_handling.c:	//fprintf(stderr,"%i %i %g %g %g\n",j,E->lmesh.nsf,rout[1],rout[2],indbl);
Maxwelltime:Ggrd_handling.c:					   (E->control.ggrd.ray+i2),&indbl2,
Maxwelltime:Ggrd_handling.c:	E->control.surface_rayleigh[j] = vip;
Maxwelltime:Ggrd_handling.c:  if((!timedep) && (!E->control.ggrd.ray_control_init)){			/* forget the grid */
Maxwelltime:Ggrd_handling.c:    ggrd_grdtrack_free_gstruc(E->control.ggrd.ray);
Maxwelltime:Ggrd_handling.c:  E->control.ggrd.ray_control_init = 1;
Maxwelltime:Ggrd_handling.c:  const int dims=E->mesh.nsd;
Maxwelltime:Ggrd_handling.c:  use_codes = (E->control.ggrd_vtop_omega[0] > 1e-7)?(1):(0);
Maxwelltime:Ggrd_handling.c:  if(E->mesh.topvbc != 1)
Maxwelltime:Ggrd_handling.c:  noxg = E->lmesh.nox;nozg=E->lmesh.noz;noyg=E->lmesh.noy;
Maxwelltime:Ggrd_handling.c:  vscale = E->data.scalev * E->data.timedir;
Maxwelltime:Ggrd_handling.c:    vscale *=  E->data.radius_km*1e3/1e6*1e2*M_PI/180.;		/* for deg/Myr -> cm/yr conversion */
Maxwelltime:Ggrd_handling.c:  if (E->parallel.me_loc[3] == E->parallel.nprocz-1) { 
Maxwelltime:Ggrd_handling.c:    if(!E->control.ggrd.time_hist.init){/* init times, if available*/
Maxwelltime:Ggrd_handling.c:      ggrd_init_thist_from_file(&E->control.ggrd.time_hist,E->control.ggrd.time_hist.file,
Maxwelltime:Ggrd_handling.c:				TRUE,(E->parallel.me == 0));
Maxwelltime:Ggrd_handling.c:      E->control.ggrd.time_hist.init = 1;
Maxwelltime:Ggrd_handling.c:    timedep = (E->control.ggrd.time_hist.nvtimes > 1)?(1):(0);
Maxwelltime:Ggrd_handling.c:    if(!E->control.ggrd.vtop_control_init){
Maxwelltime:Ggrd_handling.c:      if(E->parallel.me==0)
Maxwelltime:Ggrd_handling.c:      E->control.ggrd.svt = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Maxwelltime:Ggrd_handling.c:      E->control.ggrd.svp = (struct  ggrd_gt *)calloc(E->control.ggrd.time_hist.nvtimes,sizeof(struct ggrd_gt));
Maxwelltime:Ggrd_handling.c:      E->control.ggrd.svt->bandlim = E->control.ggrd.svp->bandlim = 1e6;
Maxwelltime:Ggrd_handling.c:      for(i=0;i < E->control.ggrd.time_hist.nvtimes;i++){
Maxwelltime:Ggrd_handling.c:	    sprintf(tfilename1,"%s/code.grd",E->control.ggrd.vtop_dir);
Maxwelltime:Ggrd_handling.c:	    sprintf(tfilename1,"%s/vt.grd",E->control.ggrd.vtop_dir);
Maxwelltime:Ggrd_handling.c:	    sprintf(tfilename2,"%s/vp.grd",E->control.ggrd.vtop_dir);
Maxwelltime:Ggrd_handling.c:	    sprintf(tfilename1,"%s/%i/code.grd",E->control.ggrd.vtop_dir,i+1);
Maxwelltime:Ggrd_handling.c:	    sprintf(tfilename1,"%s/%i/vt.grd",E->control.ggrd.vtop_dir,i+1);
Maxwelltime:Ggrd_handling.c:	    sprintf(tfilename2,"%s/%i/vp.grd",E->control.ggrd.vtop_dir,i+1);
Maxwelltime:Ggrd_handling.c:					gmt_string,(E->control.ggrd.svt+i),(E->parallel.me == 0),FALSE))
Maxwelltime:Ggrd_handling.c:					gmt_string,(E->control.ggrd.svt+i),(E->parallel.me == 0),FALSE))
Maxwelltime:Ggrd_handling.c:					gmt_string,(E->control.ggrd.svp+i),(E->parallel.me == 0),FALSE))
Maxwelltime:Ggrd_handling.c:	snprintf(tfilename1,1000,"%s/codes.%d.gz", E->control.data_dir,E->parallel.me);
Maxwelltime:Ggrd_handling.c:      if(E->parallel.me == 0)
Maxwelltime:Ggrd_handling.c:		  E->control.ggrd_vtop_omega[1],
Maxwelltime:Ggrd_handling.c:		  E->control.ggrd_vtop_omega[2],
Maxwelltime:Ggrd_handling.c:		  E->control.ggrd_vtop_omega[3],
Maxwelltime:Ggrd_handling.c:		  (int)E->control.ggrd_vtop_omega[0]);
Maxwelltime:Ggrd_handling.c:		  E->control.ggrd.time_hist.nvtimes,E->control.ggrd.svp->fmaxlim[0]);
Maxwelltime:Ggrd_handling.c:    theta_max = (90-E->control.ggrd.svp[0].south)*M_PI/180-1e-5;
Maxwelltime:Ggrd_handling.c:    theta_min = (90-E->control.ggrd.svp[0].north)*M_PI/180+1e-5;
Maxwelltime:Ggrd_handling.c:    if((E->parallel.me ==0) && (is_global)){
Maxwelltime:Ggrd_handling.c:	      E->control.ggrd.svp[0].south,E->control.ggrd.svp[0].north);
Maxwelltime:Ggrd_handling.c:    if((E->control.ggrd.time_hist.nvtimes > 1)|| (!E->control.ggrd.vtop_control_init)){
Maxwelltime:Ggrd_handling.c:	  i1 = E->control.ggrd.time_hist.nvtimes - 1;
Maxwelltime:Ggrd_handling.c:	  if(E->parallel.me == 0)
Maxwelltime:Ggrd_handling.c:	  ggrd_interpol_time(age,&E->control.ggrd.time_hist,&i1,&i2,&f1,&f2,
Maxwelltime:Ggrd_handling.c:			     E->control.ggrd.time_hist.vstage_transition);
Maxwelltime:Ggrd_handling.c:	  if(E->parallel.me == 0)
Maxwelltime:Ggrd_handling.c:	if(E->parallel.me == 0)
Maxwelltime:Ggrd_handling.c:      if(E->parallel.me==0){
Maxwelltime:Ggrd_handling.c:      if(E->control.ggrd_allow_mixed_vbcs){
Maxwelltime:Ggrd_handling.c:	if(E->parallel.me == 0)
Maxwelltime:Ggrd_handling.c:	cutoff = E->control.ggrd.svp->fmaxlim[0] + 1e-5;	  
Maxwelltime:Ggrd_handling.c:	for(level=E->mesh.gridmax;level>=E->mesh.gridmin;level--){/* multigrid levels */
Maxwelltime:Ggrd_handling.c:	  noxl = E->lmesh.NOX[level];
Maxwelltime:Ggrd_handling.c:	  noyl = E->lmesh.NOY[level];
Maxwelltime:Ggrd_handling.c:	  nozl = E->lmesh.NOZ[level];
Maxwelltime:Ggrd_handling.c:	  for (m=1;m <= E->sphere.caps_per_proc;m++) {
Maxwelltime:Ggrd_handling.c:		rout[1] = E->SX[level][m][1][nodel]; /* theta,phi */
Maxwelltime:Ggrd_handling.c:		rout[2] = E->SX[level][m][2][nodel];
Maxwelltime:Ggrd_handling.c:		if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svp+i1),
Maxwelltime:Ggrd_handling.c:		  if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svp+i2),vin2,
Maxwelltime:Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] & (~VBX);
Maxwelltime:Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] | SBX;
Maxwelltime:Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] & (~VBY);
Maxwelltime:Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] | SBY;
Maxwelltime:Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] | VBX;
Maxwelltime:Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] & (~SBX);
Maxwelltime:Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] | VBY;
Maxwelltime:Ggrd_handling.c:		  E->NODE[level][m][nodel] = E->NODE[level][m][nodel] & (~SBY);
Maxwelltime:Ggrd_handling.c:      for (m=1;m <= E->sphere.caps_per_proc;m++) {
Maxwelltime:Ggrd_handling.c:	  cutoff = E->control.ggrd.svp->fmaxlim[0] * vscale + 1e-5;
Maxwelltime:Ggrd_handling.c:	    gzprintf(fp1,"%3d %7d\n",m,E->lmesh.nsf);
Maxwelltime:Ggrd_handling.c:	    rout[1] = E->sx[m][1][nodel]; /* theta,phi coordinates */
Maxwelltime:Ggrd_handling.c:	    rout[2] = E->sx[m][2][nodel];
Maxwelltime:Ggrd_handling.c:	    if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svt+i1),
Maxwelltime:Ggrd_handling.c:	      if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svp+i1),
Maxwelltime:Ggrd_handling.c:	      if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svt+i2),vin2,
Maxwelltime:Ggrd_handling.c:		if(!ggrd_grdtrack_interpolate_tp(rout[1],rout[2],(E->control.ggrd.svp+i2),(vin2+1),
Maxwelltime:Ggrd_handling.c:	      if((int)E->control.ggrd_vtop_omega[0] == code){
Maxwelltime:Ggrd_handling.c:		vx[1]=E->control.ggrd_vtop_omega[2]*E->x[m][3][nodel] - E->control.ggrd_vtop_omega[3]*E->x[m][2][nodel]; 
Maxwelltime:Ggrd_handling.c:		vx[2]=E->control.ggrd_vtop_omega[3]*E->x[m][1][nodel] - E->control.ggrd_vtop_omega[1]*E->x[m][3][nodel]; 
Maxwelltime:Ggrd_handling.c:		vx[3]=E->control.ggrd_vtop_omega[1]*E->x[m][2][nodel] - E->control.ggrd_vtop_omega[2]*E->x[m][1][nodel]; 
Maxwelltime:Ggrd_handling.c:	      E->sphere.cap[m].VB[1][nodel] = 0;	/* theta */
Maxwelltime:Ggrd_handling.c:	      E->sphere.cap[m].VB[2][nodel] = 0;	/* phi */
Maxwelltime:Ggrd_handling.c:	      E->sphere.cap[m].VB[1][nodel] = v[1];	/* theta */
Maxwelltime:Ggrd_handling.c:	      E->sphere.cap[m].VB[2][nodel] = v[2];	/* phi */
Maxwelltime:Ggrd_handling.c:	    E->sphere.cap[m].VB[3][nodel] = 0.0; /* r */
Maxwelltime:Ggrd_handling.c:      if((!timedep)&&(!E->control.ggrd.vtop_control_init)){			/* forget the grids */
Maxwelltime:Ggrd_handling.c:	ggrd_grdtrack_free_gstruc(E->control.ggrd.svt);
Maxwelltime:Ggrd_handling.c:	ggrd_grdtrack_free_gstruc(E->control.ggrd.svp);
Maxwelltime:Ggrd_handling.c:  E->control.ggrd.vtop_control_init = 1;
Maxwelltime:Ggrd_handling.c:  if(E->parallel.me == 0)fprintf(stderr,"vtop from grd done: %i\n",lc++);
Maxwelltime:Ggrd_handling.c:  if(!E->control.ggrd.ray_control_init)
Maxwelltime:Ggrd_handling.c:  if(E->parallel.me == 0)
Maxwelltime:Ggrd_handling.c:	    E->control.ggrd.ray_control);
Maxwelltime:Ggrd_handling.c:  for(m=1;m <= E->sphere.caps_per_proc;m++){
Maxwelltime:Ggrd_handling.c:    for(snode=1;snode <= E->lmesh.nsf;snode++){ /* loop through surface nodes */
Maxwelltime:Ggrd_handling.c:      if(fabs(E->control.surface_rayleigh[snode]-1.0)>1e-6){
Maxwelltime:Ggrd_handling.c:	for(i=1;i <= E->lmesh.noz;i++){ /* go through depth layers */
Maxwelltime:Ggrd_handling.c:	  node = (snode-1)*E->lmesh.noz + i; /* global node number */
Maxwelltime:Ggrd_handling.c:	  if(layers(E,m,node) <= E->control.ggrd.ray_control){ 
Maxwelltime:Ggrd_handling.c:	    xloc=1.0 + ((1 - E->sx[m][3][node]) - 
Maxwelltime:Ggrd_handling.c:			E->viscosity.zbase_layer[E->control.ggrd.ray_control-1])/
Maxwelltime:Ggrd_handling.c:	      E->viscosity.zbase_layer[E->control.ggrd.ray_control-1];
Maxwelltime:Ggrd_handling.c:	    bnew = buoy[m][node] * E->control.surface_rayleigh[snode]; /* modified rayleigh */
Maxwelltime:Ggrd_handling.c:	    /* 	    	    (1 - E->sx[m][3][node])*E->data.radius_km,E->control.ggrd.ray_control, */
Maxwelltime:Ggrd_handling.c:	    /* 	    	    E->viscosity.zbase_layer[E->control.ggrd.ray_control-1]*E->data.radius_km, */
Maxwelltime:Ggrd_handling.c:	    /* 	    	    fac,E->control.surface_rayleigh[snode],(fac * bnew + (1-fac)*buoy[m][node]),buoy[m][node]); */
Maxwelltime:Global_operations.c:    const int dims = E->mesh.nsd;
Maxwelltime:Global_operations.c:    noy = E->lmesh.noy;
Maxwelltime:Global_operations.c:    noz = E->lmesh.noz;
Maxwelltime:Global_operations.c:    nox = E->lmesh.nox;
Maxwelltime:Global_operations.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:    H = (double *)malloc( (E->lmesh.noz+1)*sizeof(double));
Maxwelltime:Global_operations.c:  const int dims = E->mesh.nsd;
Maxwelltime:Global_operations.c:  sizeofH = (2*E->lmesh.noz+2)*sizeof(double);
Maxwelltime:Global_operations.c:  noz = E->lmesh.noz;
Maxwelltime:Global_operations.c:  noy = E->lmesh.noy;
Maxwelltime:Global_operations.c:  elz = E->lmesh.elz;
Maxwelltime:Global_operations.c:  elx = E->lmesh.elx;
Maxwelltime:Global_operations.c:  ely = E->lmesh.ely;
Maxwelltime:Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:          lnode[1] = E->ien[m][el].node[1];
Maxwelltime:Global_operations.c:          lnode[2] = E->ien[m][el].node[2];
Maxwelltime:Global_operations.c:          lnode[3] = E->ien[m][el].node[3];
Maxwelltime:Global_operations.c:          lnode[4] = E->ien[m][el].node[4];
Maxwelltime:Global_operations.c:          for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Maxwelltime:Global_operations.c:            for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Maxwelltime:Global_operations.c:              temp[i] += X[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Maxwelltime:Global_operations.c:            lnode[1] = E->ien[m][el].node[5];
Maxwelltime:Global_operations.c:            lnode[2] = E->ien[m][el].node[6];
Maxwelltime:Global_operations.c:            lnode[3] = E->ien[m][el].node[7];
Maxwelltime:Global_operations.c:            lnode[4] = E->ien[m][el].node[8];
Maxwelltime:Global_operations.c:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Maxwelltime:Global_operations.c:              for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Maxwelltime:Global_operations.c:                temp[i+1] += X[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Maxwelltime:Global_operations.c:  MPI_Allreduce(temp,Have,noz2+1,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Maxwelltime:Global_operations.c: /* if (E->parallel.me==0)
Maxwelltime:Global_operations.c:      fprintf(stderr,"area %d %d %g\n",E->parallel.me,i,Have[i+noz]);
Maxwelltime:Global_operations.c:  const int dims = E->mesh.nsd;
Maxwelltime:Global_operations.c:  sizeofH = (2*E->lmesh.noz+2)*sizeof(float);
Maxwelltime:Global_operations.c:  noz = E->lmesh.noz;
Maxwelltime:Global_operations.c:  noy = E->lmesh.noy;
Maxwelltime:Global_operations.c:  elz = E->lmesh.elz;
Maxwelltime:Global_operations.c:  elx = E->lmesh.elx;
Maxwelltime:Global_operations.c:  ely = E->lmesh.ely;
Maxwelltime:Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:          lnode[1] = E->ien[m][el].node[1];
Maxwelltime:Global_operations.c:          lnode[2] = E->ien[m][el].node[2];
Maxwelltime:Global_operations.c:          lnode[3] = E->ien[m][el].node[3];
Maxwelltime:Global_operations.c:          lnode[4] = E->ien[m][el].node[4];
Maxwelltime:Global_operations.c:          for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Maxwelltime:Global_operations.c:            for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Maxwelltime:Global_operations.c:              temp[i] += X[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Maxwelltime:Global_operations.c:            lnode[1] = E->ien[m][el].node[5];
Maxwelltime:Global_operations.c:            lnode[2] = E->ien[m][el].node[6];
Maxwelltime:Global_operations.c:            lnode[3] = E->ien[m][el].node[7];
Maxwelltime:Global_operations.c:            lnode[4] = E->ien[m][el].node[8];
Maxwelltime:Global_operations.c:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Maxwelltime:Global_operations.c:              for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Maxwelltime:Global_operations.c:                temp[i+1] += X[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)]
Maxwelltime:Global_operations.c:  MPI_Allreduce(temp,Have,noz2+1,MPI_FLOAT,MPI_SUM,E->parallel.horizontal_comm);
Maxwelltime:Global_operations.c: /* if (E->parallel.me==0)
Maxwelltime:Global_operations.c:      fprintf(stderr,"area %d %d %g\n",E->parallel.me,i,Have[i+noz]);
Maxwelltime:Global_operations.c:  sizeofH = (2*E->lmesh.elz+2)*sizeof(double);
Maxwelltime:Global_operations.c:  noz = E->lmesh.noz;
Maxwelltime:Global_operations.c:  noy = E->lmesh.noy;
Maxwelltime:Global_operations.c:  elz = E->lmesh.elz;
Maxwelltime:Global_operations.c:  elx = E->lmesh.elx;
Maxwelltime:Global_operations.c:  ely = E->lmesh.ely;
Maxwelltime:Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:          temp[i] += X[m][el]*E->ECO[E->mesh.levmax][m][el].area;
Maxwelltime:Global_operations.c:          temp[i+elz] += E->ECO[E->mesh.levmax][m][el].area;
Maxwelltime:Global_operations.c:  MPI_Allreduce(temp,Have,elz2+1,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Maxwelltime:Global_operations.c:    const int vpts = vpoints[E->mesh.nsd];
Maxwelltime:Global_operations.c:    const int ends = enodes[E->mesh.nsd];
Maxwelltime:Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:       for (el=1;el<=E->lmesh.nel;el++)  {
Maxwelltime:Global_operations.c:		n = E->ien[m][el].node[i];
Maxwelltime:Global_operations.c:		volume1 += E->N.vpt[GNVINDEX(i,j)] * E->gDA[m][el].vpt[j];
Maxwelltime:Global_operations.c:		integral1 += Z[m][n] * E->N.vpt[GNVINDEX(i,j)] * E->gDA[m][el].vpt[j];
Maxwelltime:Global_operations.c:    MPI_Allreduce(&volume1  ,&volume  ,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:    MPI_Allreduce(&integral1,&integral,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:    const int vpts = vpoints[E->mesh.nsd];
Maxwelltime:Global_operations.c:    const int ends = enodes[E->mesh.nsd];
Maxwelltime:Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:       for (el=1;el<=E->lmesh.nel;el++)  {
Maxwelltime:Global_operations.c:                n = E->ien[m][el].node[i];
Maxwelltime:Global_operations.c:                volume1 += E->N.vpt[GNVINDEX(i,j)] * E->gDA[m][el].vpt[j];
Maxwelltime:Global_operations.c:                integral1 += Z[m][n] * E->N.vpt[GNVINDEX(i,j)] * E->gDA[m][el].vpt[j];
Maxwelltime:Global_operations.c:    MPI_Allreduce(&volume1  ,&volume  ,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:    MPI_Allreduce(&integral1,&integral,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c: MPI_Allreduce(&Tmax,&ttmax,1,MPI_FLOAT,MPI_MAX,E->parallel.horizontal_comm);
Maxwelltime:Global_operations.c: temp = (double *) malloc((E->sphere.hindice*2+3)*sizeof(double));
Maxwelltime:Global_operations.c: sphcs = (double *) malloc((E->sphere.hindice*2+3)*sizeof(double));
Maxwelltime:Global_operations.c: jumpp = E->sphere.hindice;
Maxwelltime:Global_operations.c: total = E->sphere.hindice*2+3;
Maxwelltime:Global_operations.c: for (j=0;j<E->sphere.hindice;j++)   {
Maxwelltime:Global_operations.c: sphcs[total-1] = sphs[E->sphere.hindice];
Maxwelltime:Global_operations.c: MPI_Allreduce(sphcs,temp,total,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Maxwelltime:Global_operations.c: for (j=0;j<E->sphere.hindice;j++)   {
Maxwelltime:Global_operations.c: sphs[E->sphere.hindice]=temp[total-1];
Maxwelltime:Global_operations.c: temp = (float *) malloc((E->sphere.hindice*2+3)*sizeof(float));
Maxwelltime:Global_operations.c: sphcs = (float *) malloc((E->sphere.hindice*2+3)*sizeof(float));
Maxwelltime:Global_operations.c: jumpp = E->sphere.hindice;
Maxwelltime:Global_operations.c: total = E->sphere.hindice*2+3;
Maxwelltime:Global_operations.c: for (j=0;j<E->sphere.hindice;j++)   {
Maxwelltime:Global_operations.c: sphcs[total-1] = sphs[E->sphere.hindice];
Maxwelltime:Global_operations.c: MPI_Allreduce(sphcs,temp,total,MPI_FLOAT,MPI_SUM,E->parallel.horizontal_comm);
Maxwelltime:Global_operations.c: for (j=0;j<E->sphere.hindice;j++)   {
Maxwelltime:Global_operations.c: sphs[E->sphere.hindice]=temp[total-1];
Maxwelltime:Global_operations.c:  neq=E->lmesh.NEQ[lev];
Maxwelltime:Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Global_operations.c:    neq=E->lmesh.NEQ[lev];
Maxwelltime:Global_operations.c:    for (i=1;i<=E->parallel.Skip_neq[lev][m];i++)
Maxwelltime:Global_operations.c:       temp1 += A[m][E->parallel.Skip_id[lev][m][i]]*B[m][E->parallel.Skip_id[lev][m][i]];
Maxwelltime:Global_operations.c:  MPI_Allreduce(&temp, &prod,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Global_operations.c:    neq=E->lmesh.NEQ[lev];
Maxwelltime:Global_operations.c:    for (i=1;i<=E->parallel.Skip_neq[lev][m];i++)
Maxwelltime:Global_operations.c:      if ((E->parallel.Skip_id[lev][m][i]+1)%3==0)
Maxwelltime:Global_operations.c:        temp1 += A[m][E->parallel.Skip_id[lev][m][i]]*A[m][E->parallel.Skip_id[lev][m][i]];
Maxwelltime:Global_operations.c:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:  const int ends=enodes[E->mesh.nsd];
Maxwelltime:Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Global_operations.c:    nel=E->lmesh.nel;
Maxwelltime:Global_operations.c:      if (E->viscosity.sdepv_expt[E->mat[m][e]-1]>1.01)  {   // for non-Newt 
Maxwelltime:Global_operations.c:          node = E->ien[m][e].node[a];
Maxwelltime:Global_operations.c:          for (j=1;j<=E->mesh.nsd;j++) {
Maxwelltime:Global_operations.c:            i = E->id[m][node].doff[j];
Maxwelltime:Global_operations.c:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Global_operations.c:    neq=E->lmesh.NEQ[lev];
Maxwelltime:Global_operations.c:    for (i=1;i<=E->parallel.Skip_neq[lev][m];i++)
Maxwelltime:Global_operations.c:       temp1 += A[m][E->parallel.Skip_id[lev][m][i]]*B[m][E->parallel.Skip_id[lev][m][i]];
Maxwelltime:Global_operations.c:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:  npno=E->lmesh.NPNO[lev];
Maxwelltime:Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Global_operations.c:    npno=E->lmesh.NPNO[lev];
Maxwelltime:Global_operations.c:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Global_operations.c:        for (i=1; i<=E->lmesh.nno; i++) {
Maxwelltime:Global_operations.c:            eqn1 = E->id[m][i].doff[1];
Maxwelltime:Global_operations.c:            eqn2 = E->id[m][i].doff[2];
Maxwelltime:Global_operations.c:            eqn3 = E->id[m][i].doff[3];
Maxwelltime:Global_operations.c:                     V[m][eqn3] * V[m][eqn3]) * E->NMass[m][i];
Maxwelltime:Global_operations.c:    MPI_Allreduce(&temp, &prod, 1, MPI_DOUBLE, MPI_SUM, E->parallel.world);
Maxwelltime:Global_operations.c:    return (prod/E->mesh.volume);
Maxwelltime:Global_operations.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Global_operations.c:        for (i=1; i<=E->lmesh.npno; i++) {
Maxwelltime:Global_operations.c:            temp += P[m][i] * P[m][i] * E->eco[m][i].area;
Maxwelltime:Global_operations.c:    MPI_Allreduce(&temp, &prod, 1, MPI_DOUBLE, MPI_SUM, E->parallel.world);
Maxwelltime:Global_operations.c:    return (prod/E->mesh.volume);
Maxwelltime:Global_operations.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Global_operations.c:        for (i=1; i<=E->lmesh.npno; i++) {
Maxwelltime:Global_operations.c:            temp += A[m][i] * A[m][i] / E->eco[m][i].area;
Maxwelltime:Global_operations.c:    MPI_Allreduce(&temp, &prod, 1, MPI_DOUBLE, MPI_SUM, E->parallel.world);
Maxwelltime:Global_operations.c:    return (prod/E->mesh.volume);
Maxwelltime:Global_operations.c:  nno=E->lmesh.NNO[lev];
Maxwelltime:Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Global_operations.c:    nno=E->lmesh.NNO[lev];
Maxwelltime:Global_operations.c:    if (!(E->NODE[lev][m][i] & SKIP))
Maxwelltime:Global_operations.c:  MPI_Allreduce(&temp, &prod,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Global_operations.c:    nno=E->lmesh.NNO[lev];
Maxwelltime:Global_operations.c:      if (!(E->NODE[lev][m][i] & SKIP))
Maxwelltime:Global_operations.c:  MPI_Allreduce(&temp, &prod,1,MPI_FLOAT,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:  MPI_Allreduce(&a, &temp,1,MPI_FLOAT,MPI_MIN,E->parallel.world);
Maxwelltime:Global_operations.c:  MPI_Allreduce(&a, &temp,1,MPI_DOUBLE,MPI_MAX,E->parallel.world);
Maxwelltime:Global_operations.c:  MPI_Allreduce(&a, &temp,1,MPI_FLOAT,MPI_MAX,E->parallel.world);
Maxwelltime:Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:    for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Global_operations.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:    for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Global_operations.c: const int dims = E->mesh.nsd;
Maxwelltime:Global_operations.c: const int nel=E->lmesh.nel;
Maxwelltime:Global_operations.c:for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:   /*if (E->mat[m][e]==1)*/
Maxwelltime:Global_operations.c:	 node = E->IEN[lev][m][e].node[a];
Maxwelltime:Global_operations.c:         dtemp += dU[m][ E->ID[lev][m][node].doff[i] ]*
Maxwelltime:Global_operations.c:                  dU[m][ E->ID[lev][m][node].doff[i] ];
Maxwelltime:Global_operations.c:         temp += U[m][ E->ID[lev][m][node].doff[i] ]*
Maxwelltime:Global_operations.c:                 U[m][ E->ID[lev][m][node].doff[i] ];
Maxwelltime:Global_operations.c:  MPI_Allreduce(&dtemp, &temp2,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:  MPI_Allreduce(&temp, &temp1,1,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:    if (E->parallel.nprocz > 1)  {
Maxwelltime:Global_operations.c:	total = E->sphere.hindice*2;
Maxwelltime:Global_operations.c:	jumpp = E->sphere.hindice;
Maxwelltime:Global_operations.c:	for (j=0;j<E->sphere.hindice;j++)   {
Maxwelltime:Global_operations.c:		      E->parallel.vertical_comm);
Maxwelltime:Global_operations.c:	for (j=0;j<E->sphere.hindice;j++)   {
Maxwelltime:Global_operations.c:    if(E->parallel.nprocz == 1) return;
Maxwelltime:Global_operations.c:    jumpp = E->sphere.hindice;
Maxwelltime:Global_operations.c:    total = E->sphere.hindice*2;
Maxwelltime:Global_operations.c:    if (E->parallel.me_loc[3] == root) {
Maxwelltime:Global_operations.c:        for (j=0; j<E->sphere.hindice; j++)   {
Maxwelltime:Global_operations.c:    MPI_Bcast(temp, total, MPI_DOUBLE, root, E->parallel.vertical_comm);
Maxwelltime:Global_operations.c:    if (E->parallel.me_loc[3] != root) {
Maxwelltime:Global_operations.c:        for (j=0; j<E->sphere.hindice; j++)   {
Maxwelltime:Global_operations.c:    const int lev = E->mesh.levmax;
Maxwelltime:Global_operations.c:    const int nno = E->lmesh.nno;
Maxwelltime:Global_operations.c:    if(E->control.remove_angular_momentum) {
Maxwelltime:Global_operations.c:        for (i=1;i<=E->lmesh.elz;i++)
Maxwelltime:Global_operations.c:                0.5*(E->refstate.rho[i] + E->refstate.rho[i+1])*
Maxwelltime:Global_operations.c:                (pow(E->sx[1][3][i+1],5.0) - pow(E->sx[1][3][i],5.0));
Maxwelltime:Global_operations.c:                      MPI_SUM, E->parallel.vertical_comm);
Maxwelltime:Global_operations.c:            (pow(E->sphere.ro,5.0) - pow(E->sphere.ri,5.0));
Maxwelltime:Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Global_operations.c:      for (e=1;e<=E->lmesh.nel;e++) {
Maxwelltime:Global_operations.c:	t = theta_g(E->eco[m][e].centre[1],E);
Maxwelltime:Global_operations.c:	t = E->eco[m][e].centre[1];
Maxwelltime:Global_operations.c:	f = E->eco[m][e].centre[2];
Maxwelltime:Global_operations.c:	r = E->eco[m][e].centre[3];
Maxwelltime:Global_operations.c:	    vx[j] += VV[1][i]*E->N.ppt[GNPINDEX(i,j)]; 
Maxwelltime:Global_operations.c:	    vy[j] += VV[2][i]*E->N.ppt[GNPINDEX(i,j)]; 
Maxwelltime:Global_operations.c:        if(E->control.remove_angular_momentum) {
Maxwelltime:Global_operations.c:            int nz = (e-1) % E->lmesh.elz + 1;
Maxwelltime:Global_operations.c:            rho = 0.5 * (E->refstate.rho[nz] + E->refstate.rho[nz+1]);
Maxwelltime:Global_operations.c:	exyz[1] += (wx*cos_t*cos_f - wy*sin_f) * E->eco[m][e].area * rho;
Maxwelltime:Global_operations.c:	exyz[2] += (wx*cos_t*sin_f + wy*cos_f) * E->eco[m][e].area * rho;
Maxwelltime:Global_operations.c:	exyz[3] -= (wx*sin_t                 ) * E->eco[m][e].area * rho;
Maxwelltime:Global_operations.c:    MPI_Allreduce(exyz,fxyz,4,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:    if (E->parallel.me==0) {
Maxwelltime:Global_operations.c:        if(E->control.remove_angular_momentum) {
Maxwelltime:Global_operations.c:            fprintf(E->fp,"Angular momentum: rot=%e tr=%e fr=%e\n",rot,tr*180/M_PI,fr*180/M_PI);
Maxwelltime:Global_operations.c:            fprintf(E->fp,"Rigid rotation: rot=%e tr=%e fr=%e\n",rot,tr*180/M_PI,fr*180/M_PI);
Maxwelltime:Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Global_operations.c:	vx[0] = fxyz[2]* E->x[m][3][node] - fxyz[3]*E->x[m][2][node];
Maxwelltime:Global_operations.c:	vx[1] = fxyz[3]* E->x[m][1][node] - fxyz[1]*E->x[m][3][node];
Maxwelltime:Global_operations.c:	vx[2] = fxyz[1]* E->x[m][2][node] - fxyz[2]*E->x[m][1][node];
Maxwelltime:Global_operations.c:	E->sphere.cap[m].V[1][node] -= v_theta;
Maxwelltime:Global_operations.c:	E->sphere.cap[m].V[2][node] -= v_phi;
Maxwelltime:Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Global_operations.c:	frd = fr - E->sx[m][2][node];
Maxwelltime:Global_operations.c:	v_theta = E->sx[m][3][node] * sin_t * sin(frd);
Maxwelltime:Global_operations.c:	v_phi =   E->sx[m][3][node] * 
Maxwelltime:Global_operations.c:	  (  E->SinCos[lev][m][0][node] * cos_t - E->SinCos[lev][m][2][node]  * sin_t * cos(frd) );
Maxwelltime:Global_operations.c:	E->sphere.cap[m].V[1][node] -= v_theta;
Maxwelltime:Global_operations.c:	E->sphere.cap[m].V[2][node] -= v_phi;
Maxwelltime:Global_operations.c://        E->U[m][E->id[m][node].doff[1]] = E->sphere.cap[m].V[1][node];
Maxwelltime:Global_operations.c://        E->U[m][E->id[m][node].doff[2]] = E->sphere.cap[m].V[2][node];
Maxwelltime:Global_operations.c:    if (E->parallel.me_loc[3] != E->parallel.nprocz-1)  return;
Maxwelltime:Global_operations.c:    if (E->parallel.me == 0)  time = CPU_time0();
Maxwelltime:Global_operations.c:    sphc = E->sphere.sphc[0] ;
Maxwelltime:Global_operations.c:    sphs = E->sphere.sphs[0] ;
Maxwelltime:Global_operations.c:    for (i=0;i<E->sphere.hindice;i++) sphc[i] = sphs[i] = 0.0 ;
Maxwelltime:Global_operations.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Global_operations.c:    for (es=1;es<=E->lmesh.snel;es++) {
Maxwelltime:Global_operations.c:        el = (E->lmesh.elz*es) ;
Maxwelltime:Global_operations.c:        for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Maxwelltime:Global_operations.c:            for(k1=1;k1<=onedvpoints[E->mesh.nsd];k1++)   
Maxwelltime:Global_operations.c:                temp0[k] +=  X3[j][E->sien[j][es].node[k1]] 
Maxwelltime:Global_operations.c:                           * E->M.vpt[GMVINDEX(k1,k)];
Maxwelltime:Global_operations.c:        area += E->gDA1[j][es].vpt[5];
Maxwelltime:Global_operations.c:        for(k=1;k<=onedvpoints[E->mesh.nsd];k++)
Maxwelltime:Global_operations.c:            temp0[k] = temp0[k]*E->gDA1[j][es].vpt[k];
Maxwelltime:Global_operations.c:            p = E->sphere.hindex[ll][mm];
Maxwelltime:Global_operations.c:            for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Maxwelltime:Global_operations.c:                sphc[p]+= temp0[k] *E->Sph_Harm_Tblcs[j][mm][es].cs[k]
Maxwelltime:Global_operations.c:                                   *E->Sph_Harm_Tbllm[j][p][es].lm[k];
Maxwelltime:Global_operations.c:                sphs[p]+= temp0[k] *E->Sph_Harm_Tblcs[j][mm][es].sn[k]
Maxwelltime:Global_operations.c:                                   *E->Sph_Harm_Tbllm[j][p][es].lm[k];
Maxwelltime:Global_operations.c:    sphs[E->sphere.hindice] = area;
Maxwelltime:Global_operations.c:    area = 4.0*M_PI/sphs[E->sphere.hindice];
Maxwelltime:Global_operations.c:    for (i=0;i<E->sphere.hindice;i++)    {
Maxwelltime:Global_operations.c:    // (but it takes ll from 1 to E->sphere.output_llmax)
Maxwelltime:Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:    for (j=1;j<=E->lmesh.nsf;j++) {
Maxwelltime:Global_operations.c:            p = E->sphere.hindex[ll][mm]; 
Maxwelltime:Global_operations.c:            X3[m][j] += E->Tbl_lm[m][p][j] *
Maxwelltime:Global_operations.c:                        ( E->Tbl_cs[m][mm][j]* sphc[p] 
Maxwelltime:Global_operations.c:                        + E->Tbl_sn[m][mm][j]* sphs[p] ) ;
Maxwelltime:Global_operations.c:    if (verbose && E->parallel.me==0)
Maxwelltime:Global_operations.c:        fp = (i==0)? stderr : E->fp ;
Maxwelltime:Global_operations.c:    const int dims = E->mesh.nsd;
Maxwelltime:Global_operations.c:    const int lev = E->mesh.levmax;
Maxwelltime:Global_operations.c:    nox = E->lmesh.nox;
Maxwelltime:Global_operations.c:    noy = E->lmesh.noy;
Maxwelltime:Global_operations.c:    elx = E->lmesh.elx;
Maxwelltime:Global_operations.c:    ely = E->lmesh.ely;
Maxwelltime:Global_operations.c:    elz = E->lmesh.elz;
Maxwelltime:Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Maxwelltime:Global_operations.c:            lnode[d] = E->sien[m][el].node[d];
Maxwelltime:Global_operations.c:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)
Maxwelltime:Global_operations.c:            for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Maxwelltime:Global_operations.c:                temp[1] += X3[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)] 
Maxwelltime:Global_operations.c:                          * E->gDA0[m][el].vpt[nint];
Maxwelltime:Global_operations.c:            temp[2] += E->gDA0[m][el].vpt[5];
Maxwelltime:Global_operations.c:            for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)
Maxwelltime:Global_operations.c:            for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Maxwelltime:Global_operations.c:                temp[1] += X3[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)] 
Maxwelltime:Global_operations.c:                          * E->gDA1[m][el].vpt[nint];
Maxwelltime:Global_operations.c:            temp[2] += E->gDA1[m][el].vpt[5];
Maxwelltime:Global_operations.c:  MPI_Allreduce(temp,Have,3,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Maxwelltime:Global_operations.c: * E->data.CM_incr will be affected depending on the value of add_incr_CM:
Maxwelltime:Global_operations.c: *    0 => E->data.CM_incr is not changed
Maxwelltime:Global_operations.c: *    1 => the computed CM is put into E->data.CM_incr 
Maxwelltime:Global_operations.c: *    2 => the computed CM is added to E->data.CM_incr 
Maxwelltime:Global_operations.c:    const int dims = E->mesh.nsd;
Maxwelltime:Global_operations.c:    const int lev = E->mesh.levmax;
Maxwelltime:Global_operations.c:        earth_mass =  4.0*M_PI / 3.0 * pow(E->sphere.dradius,3) 
Maxwelltime:Global_operations.c:                     *(   pow(E->sphere.ri,3) * E->data.density_below
Maxwelltime:Global_operations.c:                        + pow(E->sphere.ro,3) * E->data.density      
Maxwelltime:Global_operations.c:                        - pow(E->sphere.ri,3) * E->data.density   );
Maxwelltime:Global_operations.c:        c_surf  = 1.0/ E->ve_data_cont.surf_scaling ; // nondim stress -> nondim height
Maxwelltime:Global_operations.c:        c_surf *= E->sphere.dradius ;    // -> dim'ful height 
Maxwelltime:Global_operations.c:        c_surf *= E->data.density ;      // -> dim'ful mass/area
Maxwelltime:Global_operations.c:        c_surf *= ( E->sphere.dradius*E->sphere.dradius ) / earth_mass; 
Maxwelltime:Global_operations.c:        c_surf *= E->sphere.ro ;
Maxwelltime:Global_operations.c:            c_cmb   = 1.0/ E->ve_data_cont.botm_scaling ;
Maxwelltime:Global_operations.c:            c_cmb  *= E->sphere.dradius ;    // -> dim'ful height 
Maxwelltime:Global_operations.c:            c_cmb  *= (E->data.density_below - E->data.density) ;
Maxwelltime:Global_operations.c:            c_cmb   = E->ve_data_cont.shear_mod ;   // rho.g.h
Maxwelltime:Global_operations.c:            c_cmb  *= 1.0/E->data.grav_acc ;
Maxwelltime:Global_operations.c:        c_cmb  *= ( E->sphere.dradius*E->sphere.dradius ) / earth_mass; 
Maxwelltime:Global_operations.c:        c_cmb  *= E->sphere.ri ;
Maxwelltime:Global_operations.c:        E->ve_data_cont.CM[0] = 0.0 ;
Maxwelltime:Global_operations.c:        E->ve_data_cont.CM[1] = 0.0 ;
Maxwelltime:Global_operations.c:        E->ve_data_cont.CM[2] = 0.0 ;
Maxwelltime:Global_operations.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Global_operations.c:    for (k=1; k<=E->lmesh.ely; k++)
Maxwelltime:Global_operations.c:    for (j=1; j<=E->lmesh.elx; j++) {
Maxwelltime:Global_operations.c:        el = j + (k-1)*E->lmesh.elx;
Maxwelltime:Global_operations.c:        for(d=1;d<=onedvpoints[E->mesh.nsd];d++) {
Maxwelltime:Global_operations.c:            lnode[d] = E->sien[m][el].node[d];
Maxwelltime:Global_operations.c:        for(d =1; d <=onedvpoints[E->mesh.nsd]; d++) 
Maxwelltime:Global_operations.c:        for(d1=1; d1<=onedvpoints[E->mesh.nsd]; d1++) {
Maxwelltime:Global_operations.c:            i = lnode[d1]*E->lmesh.noz;
Maxwelltime:Global_operations.c:            tempx[d] += E->X[E->mesh.levmax][m][1][i]*E->M.vpt[GMVINDEX(d1,d)];
Maxwelltime:Global_operations.c:            tempy[d] += E->X[E->mesh.levmax][m][2][i]*E->M.vpt[GMVINDEX(d1,d)];
Maxwelltime:Global_operations.c:            tempz[d] += E->X[E->mesh.levmax][m][3][i]*E->M.vpt[GMVINDEX(d1,d)];
Maxwelltime:Global_operations.c:            temps[d] += X_surf[m][lnode[d1]]*E->M.vpt[GMVINDEX(d1,d)];
Maxwelltime:Global_operations.c:            tempb[d] += X_cmb[m][lnode[d1]]*E->M.vpt[GMVINDEX(d1,d)];
Maxwelltime:Global_operations.c:        if (E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Maxwelltime:Global_operations.c:          for(d =1; d <=onedvpoints[E->mesh.nsd]; d++)   { 
Maxwelltime:Global_operations.c:                      * E->gDA1[m][el].vpt[d];
Maxwelltime:Global_operations.c:        if (E->parallel.me_loc[3] == 0) {
Maxwelltime:Global_operations.c:          for(d =1; d <=onedvpoints[E->mesh.nsd]; d++)   { 
Maxwelltime:Global_operations.c:                      * E->gDA0[m][el].vpt[d];
Maxwelltime:Global_operations.c:       fprintf(E->fp_out,"CMtemp %g %g %g %d\n",temp[0],temp[1],temp[2],E->parallel.me);
Maxwelltime:Global_operations.c:       fprintf(E->fp_out,"CMtemp %g %g %g %d\n",temp0[0],temp0[1],temp0[2],E->parallel.me);
Maxwelltime:Global_operations.c:        MPI_Allreduce(temp,cm,3,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:       fprintf(E->fp_out,"CMtemp %g %g %g %d\n",temp[0],temp[1],temp[2],E->parallel.me);
Maxwelltime:Global_operations.c:       fprintf(E->fp_out,"CM %g %g %g %d %d %d\n",cm[0],cm[1],cm[2],E->parallel.me,E->monitor.solution_cycles,add_incr_CM);
Maxwelltime:Global_operations.c:       fflush(E->fp_out);
Maxwelltime:Global_operations.c:        for (i=0;i<3;i++) E->ve_data_cont.CM_incr[i] = cm[i] ;
Maxwelltime:Global_operations.c:        for (i=0;i<3;i++) E->ve_data_cont.CM_incr[i] += cm[i] ;
Maxwelltime:Global_operations.c:    load_height_surf = r0 * E->ve_data_cont.surf_scaling  ;
Maxwelltime:Global_operations.c:    load_height_cmb  = r0 * E->ve_data_cont.botm_scaling  ;
Maxwelltime:Global_operations.c:    if (E->parallel.me_loc[3]==E->parallel.nprocz-1) {
Maxwelltime:Global_operations.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:      for (j=1;j<=E->lmesh.nsf;j++)    {
Maxwelltime:Global_operations.c:        i = j*E->lmesh.noz;
Maxwelltime:Global_operations.c:        t1 = E->SX[E->mesh.levmax][m][1][i];
Maxwelltime:Global_operations.c:        f1 = E->SX[E->mesh.levmax][m][2][i];
Maxwelltime:Global_operations.c:    if (E->parallel.me_loc[3]==0) {
Maxwelltime:Global_operations.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:      for (j=1;j<=E->lmesh.nsf;j++)    {
Maxwelltime:Global_operations.c:        i = j*E->lmesh.noz;
Maxwelltime:Global_operations.c:        t1 = E->SX[E->mesh.levmax][m][1][i];
Maxwelltime:Global_operations.c:        f1 = E->SX[E->mesh.levmax][m][2][i];
Maxwelltime:Global_operations.c:    const int dims = E->mesh.nsd;
Maxwelltime:Global_operations.c:    const int lev = E->mesh.levmax;
Maxwelltime:Global_operations.c:        earth_mass =  4.0*M_PI / 3.0 * pow(E->sphere.dradius,3) 
Maxwelltime:Global_operations.c:                     *(   pow(E->sphere.ri,3) * E->data.density_below
Maxwelltime:Global_operations.c:                        + pow(E->sphere.ro,3) * E->data.density      
Maxwelltime:Global_operations.c:                        - pow(E->sphere.ri,3) * E->data.density   );
Maxwelltime:Global_operations.c:        earth_mass = earth_mass/(E->data.density*pow(E->sphere.dradius,3));
Maxwelltime:Global_operations.c:        E->ve_data_cont.CM[0] = 0.0 ;
Maxwelltime:Global_operations.c:        E->ve_data_cont.CM[1] = 0.0 ;
Maxwelltime:Global_operations.c:        E->ve_data_cont.CM[2] = 0.0 ;
Maxwelltime:Global_operations.c:    cm[0] = -E->ve_data_cont.CM_pot[1]*sqrt(12.0*M_PI)/earth_mass;
Maxwelltime:Global_operations.c:    cm[1] = -E->ve_data_cont.CM_pot[2]*sqrt(12.0*M_PI)/earth_mass;
Maxwelltime:Global_operations.c:    cm[2] =  E->ve_data_cont.CM_pot[0]*sqrt(12.0*M_PI)/earth_mass;
Maxwelltime:Global_operations.c:       fprintf(E->fp_out,"CM %g %g %g %d %d %d\n",cm[0],cm[1],cm[2],E->parallel.me,E->monitor.solution_cycles,add_incr_CM);
Maxwelltime:Global_operations.c:       fflush(E->fp_out);
Maxwelltime:Global_operations.c:        for (i=0;i<3;i++) E->ve_data_cont.CM_incr[i] = cm[i] ;
Maxwelltime:Global_operations.c:        for (i=0;i<3;i++) E->ve_data_cont.CM_incr[i] += cm[i] ;
Maxwelltime:Global_operations.c:    load_height_surf = r0 * E->ve_data_cont.surf_scaling  ;
Maxwelltime:Global_operations.c:    load_height_cmb  = r0 * E->ve_data_cont.botm_scaling  ;
Maxwelltime:Global_operations.c:    if (E->parallel.me_loc[3]==E->parallel.nprocz-1) {
Maxwelltime:Global_operations.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:      for (j=1;j<=E->lmesh.nsf;j++)    {
Maxwelltime:Global_operations.c:        i = j*E->lmesh.noz;
Maxwelltime:Global_operations.c:        t1 = E->SX[E->mesh.levmax][m][1][i];
Maxwelltime:Global_operations.c:        f1 = E->SX[E->mesh.levmax][m][2][i];
Maxwelltime:Global_operations.c:    if (E->parallel.me_loc[3]==0) {
Maxwelltime:Global_operations.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:      for (j=1;j<=E->lmesh.nsf;j++)    {
Maxwelltime:Global_operations.c:        i = j*E->lmesh.noz;
Maxwelltime:Global_operations.c:        t1 = E->SX[E->mesh.levmax][m][1][i];
Maxwelltime:Global_operations.c:        f1 = E->SX[E->mesh.levmax][m][2][i];
Maxwelltime:Global_operations.c: * doesn't change the surface arrays or E->data.CM*.
Maxwelltime:Global_operations.c:    const int dims = E->mesh.nsd;
Maxwelltime:Global_operations.c:    const int lev = E->mesh.levmax;
Maxwelltime:Global_operations.c:        earth_mass =  4.0*M_PI / 3.0 * pow(E->sphere.dradius,3) 
Maxwelltime:Global_operations.c:                     *(   pow(E->sphere.ri,3) * E->data.density_below
Maxwelltime:Global_operations.c:                        + pow(E->sphere.ro,3) * E->data.density      
Maxwelltime:Global_operations.c:                        - pow(E->sphere.ri,3) * E->data.density   );
Maxwelltime:Global_operations.c:        c_surf  = 1.0/ E->ve_data_cont.surf_scaling ; // nondim stress -> nondim height
Maxwelltime:Global_operations.c:        c_surf *= E->sphere.dradius ;    // -> dim'ful height 
Maxwelltime:Global_operations.c:        c_surf *= E->data.density ;      // -> dim'ful mass/area
Maxwelltime:Global_operations.c:        c_surf *= ( E->sphere.dradius*E->sphere.dradius ) / earth_mass; 
Maxwelltime:Global_operations.c:        c_surf *= E->sphere.ro ;
Maxwelltime:Global_operations.c:        c_cmb   = E->ve_data_cont.shear_mod ;   // rho.g.h
Maxwelltime:Global_operations.c:        c_cmb  *= 1.0/E->data.grav_acc ;
Maxwelltime:Global_operations.c:        c_cmb  *= ( E->sphere.dradius*E->sphere.dradius ) / earth_mass; 
Maxwelltime:Global_operations.c:        c_cmb  *= E->sphere.ri ;
Maxwelltime:Global_operations.c:        E->ve_data_cont.CM[0] = 0.0 ;
Maxwelltime:Global_operations.c:        E->ve_data_cont.CM[1] = 0.0 ;
Maxwelltime:Global_operations.c:        E->ve_data_cont.CM[2] = 0.0 ;
Maxwelltime:Global_operations.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Global_operations.c:    for (k=1; k<=E->lmesh.ely; k++)
Maxwelltime:Global_operations.c:    for (j=1; j<=E->lmesh.elx; j++) {
Maxwelltime:Global_operations.c:        el = j + (k-1)*E->lmesh.elx;
Maxwelltime:Global_operations.c:        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Maxwelltime:Global_operations.c:            lnode[d] = E->sien[m][el].node[d];
Maxwelltime:Global_operations.c:        for(d =1; d <=onedvpoints[E->mesh.nsd]; d++) 
Maxwelltime:Global_operations.c:        for(d1=1; d1<=onedvpoints[E->mesh.nsd]; d1++) {
Maxwelltime:Global_operations.c:            i = lnode[d1]*E->lmesh.noz;
Maxwelltime:Global_operations.c:            t1 = E->SX[E->mesh.levmax][m][1][i];
Maxwelltime:Global_operations.c:            f1 = E->SX[E->mesh.levmax][m][2][i];
Maxwelltime:Global_operations.c:                      * E->gDA1[m][el].vpt[d] * E->M.vpt[GMVINDEX(d1,d)] ;
Maxwelltime:Global_operations.c:                      * E->gDA0[m][el].vpt[d] * E->M.vpt[GMVINDEX(d1,d)] ;
Maxwelltime:Global_operations.c:   MPI_Allreduce(temp,cm,3,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Maxwelltime:Global_operations.c:    for (i=0;i<3;i++) E->ve_data_cont.CM_incr[i] = cm[i] ;
Maxwelltime:Global_operations.c:    if (E->parallel.me==0)
Maxwelltime:Global_operations.c:        fp = (i==0)? stderr : E->fp ;
Maxwelltime:Global_operations.c:                    E->monitor.solution_cycles,
Maxwelltime:Global_operations.c:                    E->monitor.solution_cycles,
Maxwelltime:Global_operations.c:                    E->ve_data_cont.CM[0], E->ve_data_cont.CM[1], E->ve_data_cont.CM[2] );
Maxwelltime:Global_operations.c: * mass location (stored in E->data.CM_incr).  This keeps the field X in a
Maxwelltime:Global_operations.c:    xy_mag = sqrt(  E->ve_data_cont.CM_incr[0]*E->ve_data_cont.CM_incr[0] 
Maxwelltime:Global_operations.c:                  + E->ve_data_cont.CM_incr[1]*E->ve_data_cont.CM_incr[1] );
Maxwelltime:Global_operations.c:    r0 = sqrt( E->ve_data_cont.CM_incr[2]*E->ve_data_cont.CM_incr[2] + xy_mag*xy_mag );
Maxwelltime:Global_operations.c:        t0 = acos( E->ve_data_cont.CM_incr[2]/r0 );
Maxwelltime:Global_operations.c:        f0 = acos( E->ve_data_cont.CM_incr[0]/xy_mag );
Maxwelltime:Global_operations.c:        if ( E->ve_data_cont.CM_incr[1]<0 ) f0 = 2.0*M_PI - f0 ;
Maxwelltime:Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:    for (j=1;j<=E->lmesh.nsf;j++)    {
Maxwelltime:Global_operations.c:       i = j*E->lmesh.noz;
Maxwelltime:Global_operations.c:       t1 = E->SX[E->mesh.levmax][m][1][i];
Maxwelltime:Global_operations.c:       f1 = E->SX[E->mesh.levmax][m][2][i];
Maxwelltime:Global_operations.c:    xy_mag = sqrt(  E->ve_data_cont.CM_incr[0]*E->ve_data_cont.CM_incr[0] 
Maxwelltime:Global_operations.c:                  + E->ve_data_cont.CM_incr[1]*E->ve_data_cont.CM_incr[1] );
Maxwelltime:Global_operations.c:    r0 = sqrt( E->ve_data_cont.CM_incr[2]*E->ve_data_cont.CM_incr[2] + xy_mag*xy_mag );
Maxwelltime:Global_operations.c:        t0 = acos( E->ve_data_cont.CM_incr[2]/r0 );
Maxwelltime:Global_operations.c:        f0 = acos( E->ve_data_cont.CM_incr[0]/xy_mag );
Maxwelltime:Global_operations.c:        if ( E->ve_data_cont.CM_incr[1]<0 ) f0 = 2.0*M_PI - f0 ;
Maxwelltime:Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:    for (j=1;j<=E->lmesh.nsf;j++)    
Maxwelltime:Global_operations.c:    for (k=1;k<=E->lmesh.noz;k++)    {
Maxwelltime:Global_operations.c:       i = k+(j-1)*E->lmesh.noz;
Maxwelltime:Global_operations.c:       t1 = E->SX[E->mesh.levmax][m][1][i];
Maxwelltime:Global_operations.c:       f1 = E->SX[E->mesh.levmax][m][2][i];
Maxwelltime:Global_operations.c:       u1 = E->sphere.cap[m].V[1][i] - r0 * rel_cos ;
Maxwelltime:Global_operations.c:       u2 = E->sphere.cap[m].V[2][i] - r0 * rel_cos ;
Maxwelltime:Global_operations.c:       u3 = E->sphere.cap[m].V[3][i] - r0 * rel_cos ;
Maxwelltime:Global_operations.c:    if ( k==E->lmesh.noz && E->parallel.me_loc[3]==E->parallel.nprocz-1) {
Maxwelltime:Global_operations.c:       E->sphere.cap[m].total_VS[1][j] += E->sphere.cap[m].V[1][i];
Maxwelltime:Global_operations.c:       E->sphere.cap[m].total_VS[2][j] += E->sphere.cap[m].V[2][i];
Maxwelltime:Global_operations.c:       E->sphere.cap[m].total_VS[3][j] += E->sphere.cap[m].V[3][i];  
Maxwelltime:Global_operations.c:    if ( k==E->lmesh.noz && E->parallel.me_loc[3]==E->parallel.nprocz-1) {
Maxwelltime:Global_operations.c:       E->sphere.cap[m].total_VS[1][j] += u1;
Maxwelltime:Global_operations.c:       E->sphere.cap[m].total_VS[2][j] += u2;
Maxwelltime:Global_operations.c:       E->sphere.cap[m].total_VS[3][j] += u3;
Maxwelltime:Global_operations.c:/*       if ( k==E->lmesh.noz && E->parallel.me_loc[3]==E->parallel.nprocz-1) {
Maxwelltime:Global_operations.c:          v1 = E->sphere.cap[m].V[1][i];
Maxwelltime:Global_operations.c:          v2 = E->sphere.cap[m].V[2][i];
Maxwelltime:Global_operations.c:          v3 = E->sphere.cap[m].V[3][i];
Maxwelltime:Global_operations.c:          E->sphere.cap[m].total_VC[1][j] += sin(t1)*cos(f1)*v3 + cos(t1)*cos(f1)*v1 - sin(f1)*v2;
Maxwelltime:Global_operations.c:          E->sphere.cap[m].total_VC[2][j] += sin(t1)*sin(f1)*v3 + cos(t1)*sin(f1)*v1 + cos(f1)*v2;
Maxwelltime:Global_operations.c:          E->sphere.cap[m].total_VC[3][j] += cos(t1)*v3         - sin(t1)*v1;
Maxwelltime:Global_operations.c:          v1 = E->sphere.cap[m].total_VC[1][j];
Maxwelltime:Global_operations.c:          v2 = E->sphere.cap[m].total_VC[2][j];
Maxwelltime:Global_operations.c:          v3 = E->sphere.cap[m].total_VC[3][j];
Maxwelltime:Global_operations.c:          E->sphere.cap[m].total_VS[3][j] = sin(t1)*cos(f1)*v1 + sin(t1)*sin(f1)*v2 + cos(t1)*v3;
Maxwelltime:Global_operations.c:          E->sphere.cap[m].total_VS[1][j] = cos(t1)*cos(f1)*v1 + cos(t1)*sin(f1)*v2 - sin(t1)*v3;
Maxwelltime:Global_operations.c:          E->sphere.cap[m].total_VS[2][j] = -sin(f1)*v1         + cos(f1)*v2;  
Maxwelltime:Global_operations.c:       E->sphere.cap[m].V[1][i] = u1;
Maxwelltime:Global_operations.c:       E->sphere.cap[m].V[2][i] = u2; 
Maxwelltime:Global_operations.c:       E->sphere.cap[m].V[3][i] = u3;
Maxwelltime:Global_operations.c:       if ( k==E->lmesh.noz && E->parallel.me_loc[3]==E->parallel.nprocz-1) {
Maxwelltime:Global_operations.c:       if ( k==1 && E->parallel.me_loc[3]==0)  {
Maxwelltime:Global_operations.c:    const int dims = E->mesh.nsd;
Maxwelltime:Global_operations.c:    const int lev = E->mesh.levmax;
Maxwelltime:Global_operations.c:    nox = E->lmesh.nox;
Maxwelltime:Global_operations.c:    noy = E->lmesh.noy;
Maxwelltime:Global_operations.c:    elx = E->lmesh.elx;
Maxwelltime:Global_operations.c:    ely = E->lmesh.ely;
Maxwelltime:Global_operations.c:    elz = E->lmesh.elz;
Maxwelltime:Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:                for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Maxwelltime:Global_operations.c:                    lnode[d] = E->sien[m][el].node[d];
Maxwelltime:Global_operations.c:                    for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)
Maxwelltime:Global_operations.c:                        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Maxwelltime:Global_operations.c:                            temp[1] += X3[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)] 
Maxwelltime:Global_operations.c:                                * E->gDA0[m][el].vpt[nint];
Maxwelltime:Global_operations.c:                    temp[2] += E->gDA0[m][el].vpt[5];
Maxwelltime:Global_operations.c:                    for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)
Maxwelltime:Global_operations.c:                        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Maxwelltime:Global_operations.c:                            temp[1] += X3[m][lnode[d]] * E->M.vpt[GMVINDEX(d,nint)] 
Maxwelltime:Global_operations.c:                                * E->gDA1[m][el].vpt[nint];
Maxwelltime:Global_operations.c:                    temp[2] += E->gDA1[m][el].vpt[5];
Maxwelltime:Global_operations.c:   MPI_Allreduce(temp,Have,3,MPI_DOUBLE,MPI_SUM,E->parallel.horizontal_comm);
Maxwelltime:Global_operations.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:        // To dimensionalize a nondim'l potential (such as E->potential or
Maxwelltime:Global_operations.c:        // E->incr_potential), multiply by 4.pi.G.rho.R^2 (where rho is the
Maxwelltime:Global_operations.c:        scale_pot = 1.0/( 4.0*M_PI * E->data.grav_const * E->data.density );
Maxwelltime:Global_operations.c:        c_cmb = c_surf * E->sphere.ri*E->sphere.ri/(E->sphere.ro*E->sphere.ro);
Maxwelltime:Global_operations.c:        E->ve_data_cont.PW_incr[0] = 0.0;
Maxwelltime:Global_operations.c:        E->ve_data_cont.PW_incr[1] = 0.0;
Maxwelltime:Global_operations.c:       for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Global_operations.c:          oldpotl_surf[m] =(double*)malloc((E->lmesh.nsf+2)*sizeof(double));
Maxwelltime:Global_operations.c:          oldpotl_cmb[m] = (double*)malloc((E->lmesh.nsf+2)*sizeof(double));
Maxwelltime:Global_operations.c:          for (n=1;n<=E->lmesh.nsf;n++)  { 
Maxwelltime:Global_operations.c:    M0 = E->viscosity.beta*M[0] + (1.0-E->viscosity.beta)*E->ve_data_cont.PW_incr[0]; 
Maxwelltime:Global_operations.c:    M1 = E->viscosity.beta*M[1] + (1.0-E->viscosity.beta)*E->ve_data_cont.PW_incr[1]; 
Maxwelltime:Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:    for (n=1;n<=E->lmesh.nsf;n++)   {
Maxwelltime:Global_operations.c:        t = E->SX[E->mesh.levmax][m][1][n*E->lmesh.NOZ[E->mesh.levmax]];
Maxwelltime:Global_operations.c:        f = E->SX[E->mesh.levmax][m][2][n*E->lmesh.NOZ[E->mesh.levmax]];
Maxwelltime:Global_operations.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Maxwelltime:Global_operations.c:        if (E->parallel.me_loc[3]==0)   {
Maxwelltime:Global_operations.c:   MPI_Allreduce(potential,prod,3,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:   E->ve_data_cont.potential_vary_PW = sqrt(prod[1]/prod[0]);
Maxwelltime:Global_operations.c: if (E->parallel.me==0) fprintf(E->fp_out,"pw step=%d %g %g %g %g %g\n",E->monitor.solution_cycles,E->viscosity.beta,M[0],M[1],E->ve_data_cont.PW_incr[0],E->ve_data_cont.PW_incr[1]);
Maxwelltime:Global_operations.c:   E->ve_data_cont.PW_incr[0] = M[0];
Maxwelltime:Global_operations.c:   E->ve_data_cont.PW_incr[1] = M[1];
Maxwelltime:Global_operations.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Global_operations.c:    for (n=1;n<=E->lmesh.nsf;n++)   {
Maxwelltime:Global_operations.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Maxwelltime:Global_operations.c:        if (E->parallel.me_loc[3]==0)   
Maxwelltime:Global_operations.c:        M_conv = (3.0*E->data.grav_const*E->data.density) /
Maxwelltime:Global_operations.c:          (omega*omega*E->ve_data_cont.kf)*5.0*sqrt(4.0*M_PI/15.0);
Maxwelltime:Global_operations.c:    M[0] = M_conv*E->ve_data_cont.PW_pot[0];
Maxwelltime:Global_operations.c:    M[1] = M_conv*E->ve_data_cont.PW_pot[1];
Maxwelltime:Global_operations.c:        //                    * E->control.CApert ); // non-hydrostatic effect
Maxwelltime:Global_operations.c:    	density_cmb = (E->data.density_below-E->data.density)/E->data.density;
Maxwelltime:Global_operations.c:        I_to_M_conv = ( 3.0 * E->data.grav_const * E->data.density) /
Maxwelltime:Global_operations.c:                      (omega*omega*E->ve_data_cont.kf);
Maxwelltime:Global_operations.c:        c_surf  = c_surf/E->ve_data_cont.surf_scaling*density_surf;    //turn load to surface mass density, sigma
Maxwelltime:Global_operations.c:        c_cmb   = -E->sphere.ri*E->sphere.ri/(E->sphere.ro*E->sphere.ro);  
Maxwelltime:Global_operations.c:        c_cmb  = c_cmb/E->ve_data_cont.botm_scaling*density_cmb;      //turn load to surface mass density, sigma
Maxwelltime:Global_operations.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Global_operations.c:    for (k=1; k<=E->lmesh.ely; k++)
Maxwelltime:Global_operations.c:    for (j=1; j<=E->lmesh.elx; j++) {
Maxwelltime:Global_operations.c:        el = j + (k-1)*E->lmesh.elx;
Maxwelltime:Global_operations.c:        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Maxwelltime:Global_operations.c:            lnode[d] = E->sien[m][el].node[d];
Maxwelltime:Global_operations.c:        for(d =1; d <=onedvpoints[E->mesh.nsd]; d++) 
Maxwelltime:Global_operations.c:        for(d1=1; d1<=onedvpoints[E->mesh.nsd]; d1++) {
Maxwelltime:Global_operations.c:            i = lnode[d1]*E->lmesh.noz;
Maxwelltime:Global_operations.c:            t1 = E->SX[E->mesh.levmax][m][1][i];
Maxwelltime:Global_operations.c:            f1 = E->SX[E->mesh.levmax][m][2][i];
Maxwelltime:Global_operations.c:            if (E->parallel.me_loc[3]==E->parallel.nprocz-1) 
Maxwelltime:Global_operations.c:                      * E->gDA1[m][el].vpt[d] * E->M.vpt[GMVINDEX(d1,d)] ;
Maxwelltime:Global_operations.c:            if (E->parallel.me_loc[3]==0) 
Maxwelltime:Global_operations.c:                      * E->gDA0[m][el].vpt[d] * E->M.vpt[GMVINDEX(d1,d)] ;
Maxwelltime:Global_operations.c:    MPI_Allreduce(temp,I,3,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c:        //                    * E->control.CApert ); // non-hydrostatic effect
Maxwelltime:Global_operations.c:        I_to_M_conv = ( 3.0 * E->data.grav_const ) /
Maxwelltime:Global_operations.c:                      (omega*omega * pow(E->sphere.dradius,5) * E->ve_data_cont.kf);
Maxwelltime:Global_operations.c:        c_surf  = -E->sphere.dradius ;    // -> dim'ful height 
Maxwelltime:Global_operations.c:        c_surf *= E->data.density ;       // -> dim'ful mass/area
Maxwelltime:Global_operations.c:        c_surf *= (E->sphere.dradius*E->sphere.dradius) ; // nondim area
Maxwelltime:Global_operations.c:        c_surf *= (E->sphere.dradius*E->sphere.dradius) ; // dim'ful radius^2
Maxwelltime:Global_operations.c:        c_cmb   = -E->sphere.dradius ;  
Maxwelltime:Global_operations.c:        c_cmb  *= (E->data.density_below - E->data.density) ;
Maxwelltime:Global_operations.c:        c_cmb  *= ( E->sphere.dradius*E->sphere.dradius ) ;
Maxwelltime:Global_operations.c:        c_cmb  *= ( E->sphere.dradius*E->sphere.dradius ) * pow(E->sphere.ri,2);
Maxwelltime:Global_operations.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Global_operations.c:    for (k=1; k<=E->lmesh.ely; k++)
Maxwelltime:Global_operations.c:    for (j=1; j<=E->lmesh.elx; j++) {
Maxwelltime:Global_operations.c:        el = j + (k-1)*E->lmesh.elx;
Maxwelltime:Global_operations.c:        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)
Maxwelltime:Global_operations.c:            lnode[d] = E->sien[m][el].node[d];
Maxwelltime:Global_operations.c:        for(d =1; d <=onedvpoints[E->mesh.nsd]; d++) 
Maxwelltime:Global_operations.c:        for(d1=1; d1<=onedvpoints[E->mesh.nsd]; d1++) {
Maxwelltime:Global_operations.c:            i = lnode[d1]*E->lmesh.noz;
Maxwelltime:Global_operations.c:            t1 = E->SX[E->mesh.levmax][m][1][i];
Maxwelltime:Global_operations.c:            f1 = E->SX[E->mesh.levmax][m][2][i];
Maxwelltime:Global_operations.c:            if (E->parallel.me_loc[3]==E->parallel.nprocz-1) 
Maxwelltime:Global_operations.c:                      * E->gDA1[m][el].vpt[d] * E->M.vpt[GMVINDEX(d1,d)] ;
Maxwelltime:Global_operations.c:            if (E->parallel.me_loc[3]==0) 
Maxwelltime:Global_operations.c:                      * E->gDA0[m][el].vpt[d] * E->M.vpt[GMVINDEX(d1,d)] ;
Maxwelltime:Global_operations.c:    MPI_Allreduce(temp,I,3,MPI_DOUBLE,MPI_SUM,E->parallel.world);
Maxwelltime:Global_operations.c: MPI_Allreduce(data,temp,total,MPI_FLOAT,MPI_SUM,E->parallel.horizontal_comm);
Maxwelltime:Initial_temperature.c:  int m = E->parallel.me;
Maxwelltime:Initial_temperature.c:  int noz = E->lmesh.noz;
Maxwelltime:Initial_temperature.c:  input_int("tic_method", &(E->convection.tic_method), "0,0,2", m);
Maxwelltime:Initial_temperature.c:    E->convection.tic_method = 4; /*  */
Maxwelltime:Initial_temperature.c:    E->control.ggrd.use_temp = 1;
Maxwelltime:Initial_temperature.c:     (E->control.mantle_temp).
Maxwelltime:Initial_temperature.c:      E->convection.number_of_perturbations = n;
Maxwelltime:Initial_temperature.c:      if (! input_float_vector("perturbmag", n, E->convection.perturb_mag, m) ) {
Maxwelltime:Initial_temperature.c:      if (! input_int_vector("perturbm", n, E->convection.perturb_mm, m) ) {
Maxwelltime:Initial_temperature.c:      if (! input_int_vector("perturbl", n, E->convection.perturb_ll, m) ) {
Maxwelltime:Initial_temperature.c:      if (! input_int_vector("perturblayer", n, E->convection.load_depth, m) ) {
Maxwelltime:Initial_temperature.c:      E->convection.number_of_perturbations = 1;
Maxwelltime:Initial_temperature.c:      E->convection.perturb_mag[0] = 1;
Maxwelltime:Initial_temperature.c:      E->convection.perturb_mm[0] = 2;
Maxwelltime:Initial_temperature.c:      E->convection.perturb_ll[0] = 2;
Maxwelltime:Initial_temperature.c:      E->convection.load_depth[0] = (noz+1)/2;
Maxwelltime:Initial_temperature.c:    input_float("half_space_age", &(E->convection.half_space_age), "40.0,1e-3,nomax", m);
Maxwelltime:Initial_temperature.c:    input_float("mantle_temp",&(E->control.mantle_temp),"1.0",m);
Maxwelltime:Initial_temperature.c:    switch(E->convection.tic_method){
Maxwelltime:Initial_temperature.c:      if( ! input_float_vector("blob_center", 3, E->convection.blob_center, m)) {
Maxwelltime:Initial_temperature.c:	assert( E->sphere.caps == 12 || E->sphere.caps == 1 );
Maxwelltime:Initial_temperature.c:	if(E->sphere.caps == 12) { /* Full version: just quit here */
Maxwelltime:Initial_temperature.c:	else if(E->sphere.caps == 1) { /* Regional version: put the blob at the center */
Maxwelltime:Initial_temperature.c:	  E->convection.blob_center[0] = 0.5*(E->control.theta_min+E->control.theta_max);
Maxwelltime:Initial_temperature.c:	  E->convection.blob_center[1] = 0.5*(E->control.fi_min+E->control.fi_max);
Maxwelltime:Initial_temperature.c:	  E->convection.blob_center[2] = 0.5*(E->sphere.ri+E->sphere.ro);
Maxwelltime:Initial_temperature.c:      input_float("blob_radius", &(E->convection.blob_radius), "0.063,0.0,1.0", m);
Maxwelltime:Initial_temperature.c:      input_float("blob_dT", &(E->convection.blob_dT), "0.18,nomin,nomax", m);
Maxwelltime:Initial_temperature.c:      input_boolean("blob_bc_persist",&(E->convection.blob_bc_persist),"off",m);
Maxwelltime:Initial_temperature.c:      input_boolean("ggrd_tinit_scale_with_prem",&(E->control.ggrd.temp.scale_with_prem),"off",E->parallel.me);
Maxwelltime:Initial_temperature.c:      input_boolean("ggrd_tinit_limit_trange",&(E->control.ggrd.temp.limit_trange),"on",E->parallel.me);
Maxwelltime:Initial_temperature.c:      input_double("ggrd_tinit_scale",&(E->control.ggrd.temp.scale),"1.0",E->parallel.me); /* scale */
Maxwelltime:Initial_temperature.c:      input_double("ggrd_tinit_offset",&(E->control.ggrd.temp.offset),"0.0",E->parallel.me); /* offset */
Maxwelltime:Initial_temperature.c:      input_string("ggrd_tinit_gfile",E->control.ggrd.temp.gfile,"",E->parallel.me); /* grids */
Maxwelltime:Initial_temperature.c:      input_string("ggrd_tinit_dfile",E->control.ggrd.temp.dfile,"",E->parallel.me); /* depth.dat layers of grids*/
Maxwelltime:Initial_temperature.c:      input_boolean("ggrd_tinit_override_tbc",&(E->control.ggrd.temp.override_tbc),"off",E->parallel.me);
Maxwelltime:Initial_temperature.c:      input_string("ggrd_tinit_prem_file",E->control.ggrd.temp.prem.model_filename,"hc/prem/prem.dat", E->parallel.me); /* PREM model filename */
Maxwelltime:Initial_temperature.c:  if (E->convection.tic_method == -1) {
Maxwelltime:Initial_temperature.c:      if(strcmp(E->output.format, "ascii-gz") == 0)
Maxwelltime:Initial_temperature.c:  else if (E->control.lith_age)
Maxwelltime:Initial_temperature.c:  if (E->control.verbose)
Maxwelltime:Initial_temperature.c:  fprintf(E->fp_out,"output_temperature\n");
Maxwelltime:Initial_temperature.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)        {
Maxwelltime:Initial_temperature.c:    fprintf(E->fp_out,"for cap %d\n",E->sphere.capid[m]);
Maxwelltime:Initial_temperature.c:    for (j=1;j<=E->lmesh.nno;j++)
Maxwelltime:Initial_temperature.c:      fprintf(E->fp_out,"X = %.6e Z = %.6e Y = %.6e T[%06d] = %.6e \n",E->sx[m][1][j],E->sx[m][2][j],E->sx[m][3][j],j,E->T[m][j]);
Maxwelltime:Initial_temperature.c:  fflush(E->fp_out);
Maxwelltime:Initial_temperature.c:  ii = E->monitor.solution_cycles_init;
Maxwelltime:Initial_temperature.c:  sprintf(output_file,"%s.velo.%d.%d",E->control.old_P_file,E->parallel.me,ii);
Maxwelltime:Initial_temperature.c:    fprintf(E->fp,"(Initial_temperature.c #1) Cannot open %s\n",output_file);
Maxwelltime:Initial_temperature.c:  if (E->parallel.me==0)
Maxwelltime:Initial_temperature.c:    fprintf(E->fp,"Reading %s for initial temperature\n",output_file);
Maxwelltime:Initial_temperature.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Initial_temperature.c:    for(i=1;i<=E->lmesh.nno;i++)  {
Maxwelltime:Initial_temperature.c:      E->T[m][i] = max(0.0,min(g,1.0));
Maxwelltime:Initial_temperature.c:    nox = E->lmesh.nox;
Maxwelltime:Initial_temperature.c:    noy = E->lmesh.noy;
Maxwelltime:Initial_temperature.c:    noz = E->lmesh.noz;
Maxwelltime:Initial_temperature.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Initial_temperature.c:                    r1 = E->sx[m][3][node];
Maxwelltime:Initial_temperature.c:                    E->T[m][node] = E->control.TBCbotval - (E->control.TBCtopval + E->control.TBCbotval)*(r1 - E->sphere.ri)/(E->sphere.ro - E->sphere.ri);
Maxwelltime:Initial_temperature.c:    nox = E->lmesh.nox;
Maxwelltime:Initial_temperature.c:    noy = E->lmesh.noy;
Maxwelltime:Initial_temperature.c:    noz = E->lmesh.noz;
Maxwelltime:Initial_temperature.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Initial_temperature.c:                    r1 = E->sx[m][3][node];
Maxwelltime:Initial_temperature.c:                    E->T[m][node] = (E->control.TBCtopval*E->sphere.ro
Maxwelltime:Initial_temperature.c:                                     - E->control.TBCbotval*E->sphere.ri)
Maxwelltime:Initial_temperature.c:                        / (E->sphere.ro - E->sphere.ri)
Maxwelltime:Initial_temperature.c:                        + (E->control.TBCbotval - E->control.TBCtopval)
Maxwelltime:Initial_temperature.c:                        * E->sphere.ro * E->sphere.ri / r1
Maxwelltime:Initial_temperature.c:                        / (E->sphere.ro - E->sphere.ri);
Maxwelltime:Initial_temperature.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Initial_temperature.c:        for(i=1; i<=E->lmesh.nno; i++)
Maxwelltime:Initial_temperature.c:            E->T[m][i] = mantle_temp;
Maxwelltime:Initial_temperature.c:    nox = E->lmesh.nox;
Maxwelltime:Initial_temperature.c:    noy = E->lmesh.noy;
Maxwelltime:Initial_temperature.c:    noz = E->lmesh.noz;
Maxwelltime:Initial_temperature.c:    dT = (mantle_temp - E->control.TBCtopval);
Maxwelltime:Initial_temperature.c:    tmp = 0.5 / sqrt(age_in_myrs / E->data.scalet);
Maxwelltime:Initial_temperature.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Initial_temperature.c:                    r1 = E->sx[m][3][node];
Maxwelltime:Initial_temperature.c:                    E->T[m][node] -= dT * erfc(tmp * (E->sphere.ro - r1));
Maxwelltime:Initial_temperature.c:    nox = E->lmesh.nox;
Maxwelltime:Initial_temperature.c:    noy = E->lmesh.noy;
Maxwelltime:Initial_temperature.c:    noz = E->lmesh.noz;
Maxwelltime:Initial_temperature.c:    dT = (E->control.TBCbotval - mantle_temp);
Maxwelltime:Initial_temperature.c:    tmp = 0.5 / sqrt(age_in_myrs / E->data.scalet);
Maxwelltime:Initial_temperature.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Initial_temperature.c:                    r1 = E->sx[m][3][node];
Maxwelltime:Initial_temperature.c:                    E->T[m][node] += dT * erfc(tmp * (r1 - E->sphere.ri));
Maxwelltime:Initial_temperature.c:    nox = E->lmesh.nox;
Maxwelltime:Initial_temperature.c:    noy = E->lmesh.noy;
Maxwelltime:Initial_temperature.c:    noz = E->lmesh.noz;
Maxwelltime:Initial_temperature.c:    gnoz = E->mesh.noz;
Maxwelltime:Initial_temperature.c:    for (p=0; p<E->convection.number_of_perturbations; p++) {
Maxwelltime:Initial_temperature.c:        ll = E->convection.perturb_ll[p];
Maxwelltime:Initial_temperature.c:        mm = E->convection.perturb_mm[p];
Maxwelltime:Initial_temperature.c:        kk = E->convection.load_depth[p];
Maxwelltime:Initial_temperature.c:        con = E->convection.perturb_mag[p];
Maxwelltime:Initial_temperature.c:        k = kk - E->lmesh.nzs + 1; /* convert global nz to local nz */
Maxwelltime:Initial_temperature.c:        if (E->parallel.me_loc[1] == 0 && E->parallel.me_loc[2] == 0
Maxwelltime:Initial_temperature.c:            && E->sphere.capid[1] == 1 )
Maxwelltime:Initial_temperature.c:        if(E->sphere.caps == 1) {
Maxwelltime:Initial_temperature.c:            tlen = M_PI / (E->control.theta_max - E->control.theta_min);
Maxwelltime:Initial_temperature.c:            flen = M_PI / (E->control.fi_max - E->control.fi_min);
Maxwelltime:Initial_temperature.c:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Initial_temperature.c:                        t1 = (E->sx[m][1][node] - E->control.theta_min) * tlen;
Maxwelltime:Initial_temperature.c:                        f1 = (E->sx[m][2][node] - E->control.fi_min) * flen;
Maxwelltime:Initial_temperature.c:                        E->T[m][node] += con * cos(ll*t1) * cos(mm*f1);
Maxwelltime:Initial_temperature.c:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Initial_temperature.c:                        t1 = E->sx[m][1][node];
Maxwelltime:Initial_temperature.c:                        f1 = E->sx[m][2][node];
Maxwelltime:Initial_temperature.c:                        E->T[m][node] += con * modified_plgndr_a(ll,mm,t1) * cos(mm*f1);
Maxwelltime:Initial_temperature.c:    nox = E->lmesh.nox;
Maxwelltime:Initial_temperature.c:    noy = E->lmesh.noy;
Maxwelltime:Initial_temperature.c:    noz = E->lmesh.noz;
Maxwelltime:Initial_temperature.c:    gnoz = E->mesh.noz;
Maxwelltime:Initial_temperature.c:    rlen = M_PI / (E->sphere.ro - E->sphere.ri);
Maxwelltime:Initial_temperature.c:    for (p=0; p<E->convection.number_of_perturbations; p++) {
Maxwelltime:Initial_temperature.c:        ll = E->convection.perturb_ll[p];
Maxwelltime:Initial_temperature.c:        mm = E->convection.perturb_mm[p];
Maxwelltime:Initial_temperature.c:        con = E->convection.perturb_mag[p];
Maxwelltime:Initial_temperature.c:        if (E->parallel.me_loc[1] == 0 && E->parallel.me_loc[2] == 0
Maxwelltime:Initial_temperature.c:            && E->sphere.capid[1] == 1 )
Maxwelltime:Initial_temperature.c:        if(E->sphere.caps == 1) {
Maxwelltime:Initial_temperature.c:            tlen = M_PI / (E->control.theta_max - E->control.theta_min);
Maxwelltime:Initial_temperature.c:            flen = M_PI / (E->control.fi_max - E->control.fi_min);
Maxwelltime:Initial_temperature.c:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Initial_temperature.c:                            t1 = (E->sx[m][1][node] - E->control.theta_min) * tlen;
Maxwelltime:Initial_temperature.c:                            f1 = (E->sx[m][2][node] - E->control.fi_min) * flen;
Maxwelltime:Initial_temperature.c:                            r1 = E->sx[m][3][node];
Maxwelltime:Initial_temperature.c:                            E->T[m][node] += con * cos(ll*t1) * cos(mm*f1)
Maxwelltime:Initial_temperature.c:                                * sin((r1-E->sphere.ri) * rlen);
Maxwelltime:Initial_temperature.c:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Initial_temperature.c:                            t1 = E->sx[m][1][node];
Maxwelltime:Initial_temperature.c:                            f1 = E->sx[m][2][node];
Maxwelltime:Initial_temperature.c:                            r1 = E->sx[m][3][node];
Maxwelltime:Initial_temperature.c:                            E->T[m][node] += con * modified_plgndr_a(ll,mm,t1)
Maxwelltime:Initial_temperature.c:                                * sin((r1-E->sphere.ri) * rlen);
Maxwelltime:Initial_temperature.c:    noy = E->lmesh.noy;
Maxwelltime:Initial_temperature.c:    nox = E->lmesh.nox;
Maxwelltime:Initial_temperature.c:    noz = E->lmesh.noz;
Maxwelltime:Initial_temperature.c:    rout = E->sphere.ro;
Maxwelltime:Initial_temperature.c:    rin = E->sphere.ri;
Maxwelltime:Initial_temperature.c:    theta_center = E->convection.blob_center[0];
Maxwelltime:Initial_temperature.c:    fi_center    = E->convection.blob_center[1];
Maxwelltime:Initial_temperature.c:    r_center     = E->convection.blob_center[2];
Maxwelltime:Initial_temperature.c:    radius       = E->convection.blob_radius;
Maxwelltime:Initial_temperature.c:    amp          = E->convection.blob_dT;
Maxwelltime:Initial_temperature.c:    if(E->parallel.me == 0)
Maxwelltime:Initial_temperature.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Initial_temperature.c:		    dx[1] = E->x[m][1][node] - x_center[1];
Maxwelltime:Initial_temperature.c:		    dx[2] = E->x[m][2][node] - x_center[2];
Maxwelltime:Initial_temperature.c:		    dx[3] = E->x[m][3][node] - x_center[3];
Maxwelltime:Initial_temperature.c:		      E->T[m][node] += amp * exp(-1.0*distance/radius);
Maxwelltime:Initial_temperature.c:		      if(E->convection.blob_bc_persist){
Maxwelltime:Initial_temperature.c:			r1 = E->sx[m][3][node];
Maxwelltime:Initial_temperature.c:			  E->sphere.cap[m].TB[1][node]=E->T[m][node];
Maxwelltime:Initial_temperature.c:			  E->sphere.cap[m].TB[2][node]=E->T[m][node];
Maxwelltime:Initial_temperature.c:			  E->sphere.cap[m].TB[3][node]=E->T[m][node];
Maxwelltime:Initial_temperature.c:    switch (E->convection.tic_method){
Maxwelltime:Initial_temperature.c:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Maxwelltime:Initial_temperature.c:        mantle_temperature = E->control.mantle_temp;
Maxwelltime:Initial_temperature.c:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Maxwelltime:Initial_temperature.c:        if (E->sphere.caps == 1)
Maxwelltime:Initial_temperature.c:        mantle_temperature = E->control.mantle_temp;
Maxwelltime:Initial_temperature.c:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Maxwelltime:Initial_temperature.c:        mantle_temperature = E->control.mantle_temp;
Maxwelltime:Initial_temperature.c:        add_bottom_tbl(E, E->convection.half_space_age, mantle_temperature);
Maxwelltime:Initial_temperature.c:        mantle_temperature = E->control.mantle_temp;
Maxwelltime:Initial_temperature.c:        add_top_tbl(E, E->convection.half_space_age, mantle_temperature);
Maxwelltime:Initial_temperature.c:        add_bottom_tbl(E, E->convection.half_space_age, mantle_temperature);
Maxwelltime:Initial_temperature.c:        if((E->parallel.nprocz % 2) == 0) {
Maxwelltime:Initial_temperature.c:            if(E->parallel.me==0)
Maxwelltime:Initial_temperature.c:                        E->convection.tic_method);
Maxwelltime:Initial_temperature.c:            E->convection.number_of_perturbations = 1;
Maxwelltime:Initial_temperature.c:            mid = (E->mesh.noz+1) / 2;
Maxwelltime:Initial_temperature.c:            E->convection.load_depth[0] = mid;
Maxwelltime:Initial_temperature.c:            k = mid - E->lmesh.nzs + 1; /* convert to local nz */
Maxwelltime:Initial_temperature.c:            E->convection.perturb_mag[0] = 0;
Maxwelltime:Initial_temperature.c:            if ( (k > 1) && (k < E->lmesh.noz) ) {
Maxwelltime:Initial_temperature.c:                E->convection.perturb_mag[0] = 2 / (E->sx[1][3][k+1] - E->sx[1][3][k-1]);
Maxwelltime:Initial_temperature.c:                E->convection.tic_method);
Maxwelltime:Initial_temperature.c:        fprintf(stderr,"Invalid value: 'tic_method=%d'\n", E->convection.tic_method);
Maxwelltime:Instructions.c:  //chatty = ((E->parallel.me == 0)&&(E->control.verbose))?(1):(0);
Maxwelltime:Instructions.c:  chatty = E->parallel.me == 0;
Maxwelltime:Instructions.c:    E->monitor.cpu_time_at_last_cycle =
Maxwelltime:Instructions.c:        E->monitor.cpu_time_at_start = CPU_time0();
Maxwelltime:Instructions.c:    (E->problem_derived_values)(E);   /* call this before global_derived_  */
Maxwelltime:Instructions.c:    (E->solver.parallel_processor_setup)(E);   /* get # of proc in x,y,z */
Maxwelltime:Instructions.c:    (E->solver.parallel_domain_decomp0)(E);  /* get local nel, nno, elx, nox et al */
Maxwelltime:Instructions.c:    (E->problem_allocate_vars)(E);
Maxwelltime:Instructions.c:    (E->solver_allocate_vars)(E);
Maxwelltime:Instructions.c:    (E->solver.construct_boundary)(E);
Maxwelltime:Instructions.c:    (E->solver.parallel_domain_boundary_nodes)(E);
Maxwelltime:Instructions.c:    (E->solver.node_locations)(E);
Maxwelltime:Instructions.c:    if(E->output.write_q_files)
Maxwelltime:Instructions.c:      E->output.fpqt = E->output.fpqb = NULL;
Maxwelltime:Instructions.c:    if(E->control.lith_age)
Maxwelltime:Instructions.c:    (E->problem_boundary_conds)(E);
Maxwelltime:Instructions.c:    (E->solver.parallel_communication_routs_v)(E);
Maxwelltime:Instructions.c:    if(E->control.use_cbf_topo){
Maxwelltime:Instructions.c:      (E->solver.parallel_communication_routs_s)(E); 
Maxwelltime:Instructions.c:    if(E->control.inv_gruneisen != 0)
Maxwelltime:Instructions.c:    if(E->control.tracer) {
Maxwelltime:Instructions.c:	(E->problem_tracer_setup)(E);
Maxwelltime:Instructions.c:    if(E->control.ggrd.ray_control)
Maxwelltime:Instructions.c:    (E->next_buoyancy_field_init)(E);
Maxwelltime:Instructions.c:    if(E->control.mat_control)
Maxwelltime:Instructions.c:    if (E->control.tracer==1) {
Maxwelltime:Instructions.c:        if (E->composition.on)
Maxwelltime:Instructions.c:    (E->problem_initial_fields)(E);   /* temperature/chemistry/melting etc */
Maxwelltime:Instructions.c:  int m=E->parallel.me;
Maxwelltime:Instructions.c:  input_string("Problem",E->control.PROBLEM_TYPE,"convection",m);
Maxwelltime:Instructions.c:  if ( strcmp(E->control.PROBLEM_TYPE,"convection") == 0)
Maxwelltime:Instructions.c:  else if ( strcmp(E->control.PROBLEM_TYPE,"convection-chemical") == 0)
Maxwelltime:Instructions.c:    fprintf(E->fp,"Unable to determine problem type, assuming convection ... \n");
Maxwelltime:Instructions.c:  input_string("Geometry",E->control.GEOMETRY,"sphere",m);
Maxwelltime:Instructions.c:  if ( strcmp(E->control.GEOMETRY,"sphere") == 0)
Maxwelltime:Instructions.c:      (E->solver.set_3dsphere_defaults)(E);
Maxwelltime:Instructions.c:    fprintf(E->fp,"Unable to determine geometry, assuming sphere 3d ... \n");
Maxwelltime:Instructions.c:    (E->solver.set_3dsphere_defaults)(E);
Maxwelltime:Instructions.c:  input_string("Solver",E->control.SOLVER_TYPE,"cgrad",m);
Maxwelltime:Instructions.c:  if ( strcmp(E->control.SOLVER_TYPE,"cgrad") == 0)
Maxwelltime:Instructions.c:  else if ( strcmp(E->control.SOLVER_TYPE,"multigrid") == 0)
Maxwelltime:Instructions.c:    if (E->parallel.me==0) fprintf(stderr,"Unable to determine how to solve, specify Solver=VALID_OPTION \n");
Maxwelltime:Instructions.c:  input_string("datadir",E->control.data_dir,".",m);
Maxwelltime:Instructions.c:  input_string("datafile",E->control.data_prefix,"initialize",m);
Maxwelltime:Instructions.c:  input_string("datadir_old",E->control.data_dir_old,".",m);
Maxwelltime:Instructions.c:  input_string("datafile_old",E->control.data_prefix_old,"initialize",m);
Maxwelltime:Instructions.c:  input_string("te_datafile",E->ve_data_cont.te_file,"initialize",m);
Maxwelltime:Instructions.c:  input_string("platemargins_datafile",E->ve_data_cont.platemargins_file,"initialize",m);
Maxwelltime:Instructions.c:  input_string("ice_datafile",E->ve_data_cont.ice_file,"initialize",m);
Maxwelltime:Instructions.c:  input_string("ocean_datafile",E->ve_data_cont.ocean_file,"initialize",m);
Maxwelltime:Instructions.c:  E->ve_data_cont.variable_te=0;
Maxwelltime:Instructions.c:  input_int("variable_te",&(E->ve_data_cont.variable_te),"off",m);
Maxwelltime:Instructions.c:  E->ve_data_cont.Heaviside=0;
Maxwelltime:Instructions.c:  input_int("Heaviside",&(E->ve_data_cont.Heaviside),"0",m);
Maxwelltime:Instructions.c:  E->ve_data_cont.apply_potential=0;
Maxwelltime:Instructions.c:  input_int("apply_potential",&(E->ve_data_cont.apply_potential),"0",m);
Maxwelltime:Instructions.c:  E->ve_data_cont.plate_margins=0;
Maxwelltime:Instructions.c:  input_int("platemargins",&(E->ve_data_cont.plate_margins),"off",m);
Maxwelltime:Instructions.c:  input_int("update_K_steps",&(E->ve_data_cont.KERNEL),"0",m);
Maxwelltime:Instructions.c:  input_int("iteration",&(E->ve_data_cont.iteration),"0",m);
Maxwelltime:Instructions.c:  input_double("damping",&(E->ve_data_cont.damping),"1",m);
Maxwelltime:Instructions.c:  input_double("tole_compressibility",&(E->control.tole_comp),"1e-7",m);
Maxwelltime:Instructions.c:  input_int("self_gravitation",&(E->ve_data_cont.SELFG),"0",m);
Maxwelltime:Instructions.c:  input_int("apply_SLE",&(E->ve_data_cont.SLE),"0",m);
Maxwelltime:Instructions.c:  input_int("polar_wander",&(E->ve_data_cont.polar_wander),"0",m);
Maxwelltime:Instructions.c:  input_double("polar_wander_kf",&(E->ve_data_cont.kf),"1",m);
Maxwelltime:Instructions.c:  input_int("SLE_lmax",&(E->ve_data_cont.SLE_lmax),"0",m);
Maxwelltime:Instructions.c:  input_int("pure_visc",&(E->ve_data_cont.pure_visc),"0",m);
Maxwelltime:Instructions.c:  input_int("nproc_surf",&(E->parallel.nprocxy),"1",m);
Maxwelltime:Instructions.c:  input_int("nprocx",&(E->parallel.nprocx),"1",m);
Maxwelltime:Instructions.c:  input_int("nprocy",&(E->parallel.nprocy),"1",m);
Maxwelltime:Instructions.c:  input_int("nprocz",&(E->parallel.nprocz),"1",m);
Maxwelltime:Instructions.c:  if (E->control.CONJ_GRAD) {
Maxwelltime:Instructions.c:      input_int("nodex",&(E->mesh.nox),"essential",m);
Maxwelltime:Instructions.c:      input_int("nodez",&(E->mesh.noz),"essential",m);
Maxwelltime:Instructions.c:      input_int("nodey",&(E->mesh.noy),"essential",m);
Maxwelltime:Instructions.c:      E->mesh.mgunitx = (E->mesh.nox - 1) / E->parallel.nprocx;
Maxwelltime:Instructions.c:      E->mesh.mgunity = (E->mesh.noy - 1) / E->parallel.nprocy;
Maxwelltime:Instructions.c:      E->mesh.mgunitz = (E->mesh.noz - 1) / E->parallel.nprocz;
Maxwelltime:Instructions.c:      E->mesh.levels = 1;
Maxwelltime:Instructions.c:      input_int("mgunitx",&(E->mesh.mgunitx),"1",m);
Maxwelltime:Instructions.c:      input_int("mgunitz",&(E->mesh.mgunitz),"1",m);
Maxwelltime:Instructions.c:      input_int("mgunity",&(E->mesh.mgunity),"1",m);
Maxwelltime:Instructions.c:      input_int("levels",&(E->mesh.levels),"1",m);
Maxwelltime:Instructions.c:      levmax = E->mesh.levels - 1;
Maxwelltime:Instructions.c:      E->mesh.nox = E->mesh.mgunitx * (int) pow(2.0,levmax) * E->parallel.nprocx + 1;
Maxwelltime:Instructions.c:      E->mesh.noy = E->mesh.mgunity * (int) pow(2.0,levmax) * E->parallel.nprocy + 1;
Maxwelltime:Instructions.c:      E->mesh.noz = E->mesh.mgunitz * (int) pow(2.0,levmax) * E->parallel.nprocz + 1;
Maxwelltime:Instructions.c:  input_float("radius",&E->sphere.dradius,"6371e3.0",m);
Maxwelltime:Instructions.c:  E->data.radius_km = E->sphere.dradius / 1e3;
Maxwelltime:Instructions.c:  input_double("radius_outer",&(E->sphere.ro),"1",m);
Maxwelltime:Instructions.c:  input_double("radius_inner",&(E->sphere.ri),"0.55",m);
Maxwelltime:Instructions.c:  if(E->sphere.caps == 1) {
Maxwelltime:Instructions.c:      input_double("theta_min",&(E->control.theta_min),"essential",m);
Maxwelltime:Instructions.c:      input_double("theta_max",&(E->control.theta_max),"essential",m);
Maxwelltime:Instructions.c:      input_double("fi_min",&(E->control.fi_min),"essential",m);
Maxwelltime:Instructions.c:      input_double("fi_max",&(E->control.fi_max),"essential",m);
Maxwelltime:Instructions.c:  input_int("coor",&(E->control.coor),"0",m);
Maxwelltime:Instructions.c:  if(E->control.coor == 2){
Maxwelltime:Instructions.c:    E->control.coor_refine[0] = 0.10; /* bottom 10% */
Maxwelltime:Instructions.c:    E->control.coor_refine[1] = 0.15; /* get 15% of the nodes */
Maxwelltime:Instructions.c:    E->control.coor_refine[2] = 0.10; /* top 10% */
Maxwelltime:Instructions.c:    E->control.coor_refine[3] = 0.20; /* get 20% of the nodes */
Maxwelltime:Instructions.c:    input_float_vector("coor_refine",4,E->control.coor_refine,m);
Maxwelltime:Instructions.c:  }else if(E->control.coor == 3){
Maxwelltime:Instructions.c:    input_int("r_grid_layers", &(E->control.rlayers), "1",m);
Maxwelltime:Instructions.c:    if(E->control.rlayers > 20)
Maxwelltime:Instructions.c:    input_float_vector("rr", E->control.rlayers, (E->control.rrlayer),m);
Maxwelltime:Instructions.c:    input_int_vector("nr", E->control.rlayers, (E->control.nrlayer),m);
Maxwelltime:Instructions.c:  input_string("coor_file",E->control.coor_file,"",m);
Maxwelltime:Instructions.c:  input_boolean("node_assemble",&(E->control.NASSEMBLE),"off",m);
Maxwelltime:Instructions.c:  input_boolean("verbose",&(E->control.verbose),"off",m);
Maxwelltime:Instructions.c:  input_boolean("see_convergence",&(E->control.print_convergence),"off",m);
Maxwelltime:Instructions.c:  input_boolean("stokes_flow_only",&(E->control.stokes),"off",m);
Maxwelltime:Instructions.c:  //input_boolean("remove_hor_buoy_avg",&(E->control.remove_hor_buoy_avg),"on",m);
Maxwelltime:Instructions.c:  input_boolean("restart",&(E->control.restart),"off",m);
Maxwelltime:Instructions.c:  input_int("post_p",&(E->control.post_p),"0",m);
Maxwelltime:Instructions.c:  input_int("solution_cycles_init",&(E->monitor.solution_cycles_init),"0",m);
Maxwelltime:Instructions.c:  input_int("num_mat_layer",&(E->viscosity.rheol_layers),"1",m);   // number of rheology layers
Maxwelltime:Instructions.c:  input_int("num_mat",&(E->viscosity.num_mat),"1",m);            // number of material groups. 
Maxwelltime:Instructions.c:  if(E->viscosity.num_mat > CITCOM_MAX_VISC_LAYER)
Maxwelltime:Instructions.c:  input_float("z_cmb",&(E->viscosity.zcmb),"0.45",m); /* 0.45063569 */
Maxwelltime:Instructions.c:  input_float("z_lmantle",&(E->viscosity.zlm),"0.45",m); /*0.10359441  */
Maxwelltime:Instructions.c:  input_float("z_410",&(E->viscosity.z410),"0.225",m); /* 0.06434, more like it */
Maxwelltime:Instructions.c:  input_float("z_lith",&(E->viscosity.zlith),"0.225",m); /* 0.0157, more like it */
Maxwelltime:Instructions.c:  E->viscosity.zbase_layer[0] = E->viscosity.zbase_layer[1] = -999;
Maxwelltime:Instructions.c:  E->viscosity.nbase_layer[0] = 1;
Maxwelltime:Instructions.c:  input_int_vector("n_mat_layer",E->viscosity.rheol_layers,(E->viscosity.nbase_layer),m);
Maxwelltime:Instructions.c:  input_float("start_age",&(E->control.start_age),"0.0",m);
Maxwelltime:Instructions.c:  input_int("reset_startage",&(E->control.reset_startage),"0",m);
Maxwelltime:Instructions.c:  input_int("zero_elapsed_time",&(E->control.zero_elapsed_time),"0",m);
Maxwelltime:Instructions.c:  input_int("output_ll_max",&(E->output.llmax),"1",m);
Maxwelltime:Instructions.c:  input_int("nlong",&(E->sphere.noy),"1",m);
Maxwelltime:Instructions.c:  input_int("nlati",&(E->sphere.nox),"1",m);
Maxwelltime:Instructions.c:  input_int("topvbc",&(E->mesh.topvbc),"0",m);
Maxwelltime:Instructions.c:  input_int("botvbc",&(E->mesh.botvbc),"0",m);
Maxwelltime:Instructions.c:  input_float("topvbxval",&(E->control.VBXtopval),"0.0",m);
Maxwelltime:Instructions.c:  input_float("botvbxval",&(E->control.VBXbotval),"0.0",m);
Maxwelltime:Instructions.c:  input_float("topvbyval",&(E->control.VBYtopval),"0.0",m);
Maxwelltime:Instructions.c:  input_float("botvbyval",&(E->control.VBYbotval),"0.0",m);
Maxwelltime:Instructions.c:  input_float("T_interior_max_for_exit",&(E->monitor.T_interior_max_for_exit),"1.5",m);
Maxwelltime:Instructions.c:  input_int("pseudo_free_surf",&(E->control.pseudo_free_surf),"0",m);
Maxwelltime:Instructions.c:  input_int("toptbc",&(E->mesh.toptbc),"1",m);
Maxwelltime:Instructions.c:  input_int("bottbc",&(E->mesh.bottbc),"1",m);
Maxwelltime:Instructions.c:  input_float("toptbcval",&(E->control.TBCtopval),"0.0",m);
Maxwelltime:Instructions.c:  input_float("bottbcval",&(E->control.TBCbotval),"1.0",m);
Maxwelltime:Instructions.c:  input_boolean("side_sbcs",&(E->control.side_sbcs),"off",m);
Maxwelltime:Instructions.c:  input_int("file_vbcs",&(E->control.vbcs_file),"0",m);
Maxwelltime:Instructions.c:  input_string("vel_bound_file",E->control.velocity_boundary_file,"",m);
Maxwelltime:Instructions.c:  input_int("file_tbcs",&(E->control.tbcs_file),"0",m);
Maxwelltime:Instructions.c:  input_string("temp_bound_file",E->control.temperature_boundary_file,"",m);
Maxwelltime:Instructions.c:  input_int("reference_state",&(E->refstate.choice),"1",m);
Maxwelltime:Instructions.c:  if(E->refstate.choice == 0) {
Maxwelltime:Instructions.c:      input_string("refstate_file",E->refstate.filename,"refstate.dat",m);
Maxwelltime:Instructions.c:  input_int("mineral_physics_model",&(E->control.mineral_physics_model),"1",m);
Maxwelltime:Instructions.c:  input_int("mat_control",&(E->control.mat_control),"0",m);
Maxwelltime:Instructions.c:  input_string("mat_file",E->control.mat_file,"",m);
Maxwelltime:Instructions.c:  input_boolean("precise_strain_rate",&(E->control.precise_strain_rate),"off",m);
Maxwelltime:Instructions.c:     read in time-constant prefactors from weak.grd netcdf file that apply to top two E->mat layers
Maxwelltime:Instructions.c:  ggrd_init_master(&E->control.ggrd);
Maxwelltime:Instructions.c:	       E->control.ggrd.time_hist.file,"",m); 
Maxwelltime:Instructions.c:  /* if > 0, will use top  E->control.ggrd.mat_control layers and assign a prefactor for the viscosity */
Maxwelltime:Instructions.c:  input_int("ggrd_mat_control",&(E->control.ggrd.mat_control),"0",m); 
Maxwelltime:Instructions.c:  input_string("ggrd_mat_file",E->control.ggrd.mat_file,"",m); /* file to read prefactors from */
Maxwelltime:Instructions.c:  if(E->control.ggrd.mat_control) /* this will override mat_control setting */
Maxwelltime:Instructions.c:    E->control.mat_control = 1;
Maxwelltime:Instructions.c:	    &(E->control.ggrd.ray_control),"0",m); 
Maxwelltime:Instructions.c:	       E->control.ggrd.ray_file,"",m); /* file to read prefactors from */
Maxwelltime:Instructions.c:  input_int("ggrd_vtop_control",&(E->control.ggrd.vtop_control),"0",m); 
Maxwelltime:Instructions.c:  input_string("ggrd_vtop_dir",E->control.ggrd.vtop_dir,"",m); /* file to read prefactors from */
Maxwelltime:Instructions.c:  E->control.ggrd_vtop_omega[0] = 0;
Maxwelltime:Instructions.c:  input_float_vector("ggrd_vtop_omega",4,E->control.ggrd_vtop_omega,m);
Maxwelltime:Instructions.c:  if(E->control.ggrd_vtop_omega[0] > 0)
Maxwelltime:Instructions.c:    E->control.ggrd.vtop_control = 1;
Maxwelltime:Instructions.c:  if(E->control.ggrd.vtop_control) /* this will override mat_control setting */
Maxwelltime:Instructions.c:    E->control.vbcs_file = 1;
Maxwelltime:Instructions.c:  input_boolean("allow_mixed_vbcs",&(E->control.ggrd_allow_mixed_vbcs),"off",m);
Maxwelltime:Instructions.c:  input_boolean("aug_lagr",&(E->control.augmented_Lagr),"off",m);
Maxwelltime:Instructions.c:  input_double("aug_number",&(E->control.augmented),"0.0",m);
Maxwelltime:Instructions.c:  input_boolean("remove_rigid_rotation",&(E->control.remove_rigid_rotation),"on",m);
Maxwelltime:Instructions.c:  input_boolean("remove_angular_momentum",&(E->control.remove_angular_momentum),"on",m);
Maxwelltime:Instructions.c:  input_boolean("self_gravitation",&(E->control.self_gravitation),"off",m);
Maxwelltime:Instructions.c:  input_boolean("use_cbf_topo",&(E->control.use_cbf_topo),"off",m); /* make default on later XXX TWB */
Maxwelltime:Instructions.c:  input_int("storage_spacing",&(E->control.record_every),"10",m);
Maxwelltime:Instructions.c:  input_int("checkpointFrequency",&(E->control.checkpoint_frequency),"100",m);
Maxwelltime:Instructions.c:  input_int("cpu_limits_in_seconds",&(E->control.record_all_until),"5",m);
Maxwelltime:Instructions.c:  input_int("write_q_files",&(E->output.write_q_files),"0",m);/* write additional
Maxwelltime:Instructions.c:  if(E->output.write_q_files){	/* make sure those get written at
Maxwelltime:Instructions.c:    E->output.write_q_files = min(E->output.write_q_files,E->control.record_every);
Maxwelltime:Instructions.c:  input_boolean("precond",&(E->control.precondition),"off",m);
Maxwelltime:Instructions.c:  input_int("mg_cycle",&(E->control.mg_cycle),"2,0,nomax",m);
Maxwelltime:Instructions.c:  input_int("down_heavy",&(E->control.down_heavy),"1,0,nomax",m);
Maxwelltime:Instructions.c:  input_int("up_heavy",&(E->control.up_heavy),"1,0,nomax",m);
Maxwelltime:Instructions.c:  input_double("accuracy",&(E->control.accuracy),"1.0e-4,0.0,1.0",m);
Maxwelltime:Instructions.c:  input_boolean("only_check_vel_convergence",&(E->control.only_check_vel_convergence),"off",m);
Maxwelltime:Instructions.c:  input_int("vhighstep",&(E->control.v_steps_high),"1,0,nomax",m);
Maxwelltime:Instructions.c:  input_int("vlowstep",&(E->control.v_steps_low),"250,0,nomax",m);
Maxwelltime:Instructions.c:  input_int("max_mg_cycles",&(E->control.max_mg_cycles),"100,0,nomax",m);
Maxwelltime:Instructions.c:  input_int("piterations",&(E->control.p_iterations),"100,0,nomax",m);
Maxwelltime:Instructions.c:  input_float("rayleigh",&(E->control.Atemp),"essential",m);
Maxwelltime:Instructions.c:  input_float("dissipation_number",&(E->control.disptn_number),"0.0",m);
Maxwelltime:Instructions.c:      E->control.inv_gruneisen = 1/tmp;
Maxwelltime:Instructions.c:      E->control.inv_gruneisen = 0;
Maxwelltime:Instructions.c:  if(E->control.inv_gruneisen != 0) {
Maxwelltime:Instructions.c:      input_string("uzawa",E->control.uzawa,"cg",m);
Maxwelltime:Instructions.c:      if(strcmp(E->control.uzawa, "cg") == 0) {
Maxwelltime:Instructions.c:          input_int("compress_iter_maxstep",&(E->control.compress_iter_maxstep),"100",m);
Maxwelltime:Instructions.c:      else if(strcmp(E->control.uzawa, "bicg") == 0) {
Maxwelltime:Instructions.c:  input_float("surfaceT",&(E->control.surface_temp),"0.1",m);
Maxwelltime:Instructions.c:  /*input_float("adiabaticT0",&(E->control.adiabaticT0),"0.4",m);*/
Maxwelltime:Instructions.c:  input_float("Q0",&(E->control.Q0),"0.0",m);
Maxwelltime:Instructions.c:  input_float("gravacc",&(E->data.grav_acc),"9.81",m);
Maxwelltime:Instructions.c:  input_float("thermexp",&(E->data.therm_exp),"3.0e-5",m);
Maxwelltime:Instructions.c:  input_float("cp",&(E->data.Cp),"1200.0",m);
Maxwelltime:Instructions.c:  input_float("thermdiff",&(E->data.therm_diff),"1.0e-6",m);
Maxwelltime:Instructions.c:  input_float("density",&(E->data.density),"3340.0",m);
Maxwelltime:Instructions.c:  input_float("density_above",&(E->data.density_above),"1030.0",m);
Maxwelltime:Instructions.c:  input_float("density_below",&(E->data.density_below),"6600.0",m);
Maxwelltime:Instructions.c:  input_double("shearmodulus",&(E->ve_data_cont.shear_mod),"1e11",m);
Maxwelltime:Instructions.c:  input_float("refvisc",&(E->data.ref_viscosity),"1.0e21",m);
Maxwelltime:Instructions.c:  E->control.sob_tolerance = 1.0;
Maxwelltime:Instructions.c:  input_float("additional_acc",&(E->control.sob_tolerance),"1.0",m);
Maxwelltime:Instructions.c:  E->ve_data_cont.tau = E->data.ref_viscosity/(E->ve_data_cont.shear_mod*365.25*24*3600);
Maxwelltime:Instructions.c:/*  if (E->ve_data_cont.Heaviside==1)  {   
Maxwelltime:Instructions.c:        input_int("stages",&(E->ve_data_cont.stages),"0",m);
Maxwelltime:Instructions.c:        input_int_vector("step",E->ve_data_cont.stages,(E->ve_data_cont.stages_step),m);
Maxwelltime:Instructions.c:        input_double_vector("timestep",E->ve_data_cont.stages,(E->ve_data_cont.stages_time),m);
Maxwelltime:Instructions.c:        input_int("maxstep",&(E->advection.max_timesteps),"1000",m);
Maxwelltime:Instructions.c:        input_int("maxtotstep",&(E->advection.max_total_timesteps),"1000000",m);
Maxwelltime:Instructions.c:  else if (E->ve_data_cont.Heaviside==2)  {   
Maxwelltime:Instructions.c:       input_string("load_stages_time_file",E->ve_data_cont.timestage_file,"initialize",m);
Maxwelltime:Instructions.c:       if ( (fp=fopen(E->ve_data_cont.timestage_file,"r"))==NULL) {
Maxwelltime:Instructions.c:          fprintf(stderr,"ERROR: cannot find file %s\n",E->ve_data_cont.timestage_file);
Maxwelltime:Instructions.c:       sscanf(input_s,"%d %d",&E->ve_data_cont.stages,&j);
Maxwelltime:Instructions.c:       for (i=0;i<=E->ve_data_cont.stages;i++)  {
Maxwelltime:Instructions.c:         E->ve_data_cont.stages_time[i]=temp1+temp0;
Maxwelltime:Instructions.c:         E->ve_data_cont.stages_step[i]=temp2;
Maxwelltime:Instructions.c://if (E->parallel.me==0) fprintf(stderr,"bbb %d %d %g %g %d\n",i,j,temp0,temp1,temp2);
Maxwelltime:Instructions.c:       for (i=0;i<E->ve_data_cont.stages;i++)  {
Maxwelltime:Instructions.c:          E->ve_data_cont.stages_time[i]=E->ve_data_cont.stages_time[i+1]-E->ve_data_cont.stages_time[i];
Maxwelltime:Instructions.c:          if(i>0) E->ve_data_cont.stages_step[i]+=temp2;
Maxwelltime:Instructions.c:          temp2 =E->ve_data_cont.stages_step[i];
Maxwelltime:Instructions.c://if (E->parallel.me==0) fprintf(stderr,"aaa %d %g %d\n",i,E->ve_data_cont.stages_time[i],E->ve_data_cont.stages_step[i]);
Maxwelltime:Instructions.c:       E->advection.max_timesteps = temp2;
Maxwelltime:Instructions.c:       E->advection.max_total_timesteps = temp2;
Maxwelltime:Instructions.c:  E->data.ellipticity = ell_tmp;
Maxwelltime:Instructions.c:  if(fabs(E->data.ellipticity) > 5e-7){
Maxwelltime:Instructions.c:    E->data.ra = pow((1.-E->data.ellipticity),-1./3.); /* non dim long axis */
Maxwelltime:Instructions.c:    E->data.rc = 1./(E->data.ra * E->data.ra); /* non dim short axis */
Maxwelltime:Instructions.c:    E->data.efac = (1.-E->data.ellipticity)*(1.-E->data.ellipticity);
Maxwelltime:Instructions.c:    if(E->parallel.me == 0){
Maxwelltime:Instructions.c:	      E->data.ellipticity,E->data.ra,E->data.rc);
Maxwelltime:Instructions.c:    E->data.use_ellipse = 1;
Maxwelltime:Instructions.c:    E->data.ra = E->data.rc = E->data.efac=1.0;
Maxwelltime:Instructions.c:    E->data.use_ellipse = 0;
Maxwelltime:Instructions.c:  input_double("rotation_m",&E->data.rotm,"0.0",m);
Maxwelltime:Instructions.c:  if(fabs(E->data.rotm) > 5e-7){
Maxwelltime:Instructions.c:    E->data.j2 = 2./3.*E->data.ellipticity*(1.-E->data.ellipticity/2.)-
Maxwelltime:Instructions.c:      E->data.rotm/3.*(1.-3./2.*E->data.rotm-2./7.*E->data.ellipticity);
Maxwelltime:Instructions.c:    E->data.ge = 1/(E->data.ra*E->data.ra)*(1+3./2.*E->data.j2-E->data.rotm);
Maxwelltime:Instructions.c:    if(E->parallel.me==0)
Maxwelltime:Instructions.c:	      E->data.rotm,E->data.j2,E->data.ge);
Maxwelltime:Instructions.c:    E->data.use_rotation_g = 1;
Maxwelltime:Instructions.c:    E->data.use_rotation_g = 0;
Maxwelltime:Instructions.c:  E->data.therm_cond = E->data.therm_diff * E->data.density * E->data.Cp;
Maxwelltime:Instructions.c:  E->data.ref_temperature = E->control.Atemp * E->data.therm_diff
Maxwelltime:Instructions.c:    * E->data.ref_viscosity
Maxwelltime:Instructions.c:    / (E->data.density * E->data.grav_acc * E->data.therm_exp)
Maxwelltime:Instructions.c:    / (E->data.radius_km * E->data.radius_km * E->data.radius_km * 1e9);
Maxwelltime:Instructions.c:  (E->problem_settings)(E);
Maxwelltime:Instructions.c:    if (E->control.CONJ_GRAD) {
Maxwelltime:Instructions.c:        if(E->mesh.levels != 1)
Maxwelltime:Instructions.c:        if(E->mesh.levels < 2)
Maxwelltime:Instructions.c:        if(E->mesh.levels > MAX_LEVELS)
Maxwelltime:Instructions.c:    if((E->parallel.me == 0) && (E->control.only_check_vel_convergence)) {
Maxwelltime:Instructions.c:    if(E->sphere.caps == 12 &&
Maxwelltime:Instructions.c:       (E->control.remove_angular_momentum || E->control.remove_rigid_rotation) &&
Maxwelltime:Instructions.c:       (E->mesh.topvbc || E->mesh.botvbc || E->control.side_sbcs)) {
Maxwelltime:Instructions.c:   E->mesh.levmax = E->mesh.levels-1;
Maxwelltime:Instructions.c:   E->mesh.gridmax = E->mesh.levmax;
Maxwelltime:Instructions.c:   E->mesh.elx = E->mesh.nox-1;
Maxwelltime:Instructions.c:   E->mesh.ely = E->mesh.noy-1;
Maxwelltime:Instructions.c:   E->mesh.elz = E->mesh.noz-1;
Maxwelltime:Instructions.c:   if(E->sphere.caps == 1) {
Maxwelltime:Instructions.c:       E->mesh.nno = E->sphere.caps * E->mesh.nox * E->mesh.noy * E->mesh.noz;
Maxwelltime:Instructions.c:       E->mesh.nno = E->sphere.caps * (E->mesh.nox-1) * (E->mesh.noy-1) * E->mesh.noz
Maxwelltime:Instructions.c:           + 2*E->mesh.noz;
Maxwelltime:Instructions.c:   E->mesh.nel = E->sphere.caps*E->mesh.elx*E->mesh.elz*E->mesh.ely;
Maxwelltime:Instructions.c:   E->mesh.nnov = E->mesh.nno;
Maxwelltime:Instructions.c:   E->mesh.neq = E->mesh.nnov*E->mesh.nsd;
Maxwelltime:Instructions.c:if (E->parallel.me==0) fprintf(E->fp,"neqneq %d %d\n",E->mesh.neq, E->mesh.nnov);
Maxwelltime:Instructions.c:   E->mesh.npno = E->mesh.nel;
Maxwelltime:Instructions.c:   E->mesh.nsf = E->mesh.nox*E->mesh.noy;
Maxwelltime:Instructions.c:   for(i=E->mesh.levmax;i>=E->mesh.levmin;i--) {
Maxwelltime:Instructions.c:      nox = E->mesh.mgunitx * (int) pow(2.0,(double)i)*E->parallel.nprocx + 1;
Maxwelltime:Instructions.c:      noy = E->mesh.mgunity * (int) pow(2.0,(double)i)*E->parallel.nprocy + 1;
Maxwelltime:Instructions.c:      noz = E->mesh.mgunitz * (int) pow(2.0,(double)i)*E->parallel.nprocz + 1;
Maxwelltime:Instructions.c:      E->mesh.ELX[i] = nox-1;
Maxwelltime:Instructions.c:      E->mesh.ELY[i] = noy-1;
Maxwelltime:Instructions.c:      E->mesh.ELZ[i] = noz-1;
Maxwelltime:Instructions.c:      if(E->sphere.caps == 1) {
Maxwelltime:Instructions.c:          E->mesh.NNO[i] = nox * noz * noy;
Maxwelltime:Instructions.c:          E->mesh.NNO[i] = E->sphere.caps * (nox-1) * (noy-1) * noz + 2 * noz;
Maxwelltime:Instructions.c:      E->mesh.NEL[i] = E->sphere.caps * (nox-1) * (noz-1) * (noy-1);
Maxwelltime:Instructions.c:      E->mesh.NPNO[i] = E->mesh.NEL[i] ;
Maxwelltime:Instructions.c:      E->mesh.NOX[i] = nox;
Maxwelltime:Instructions.c:      E->mesh.NOZ[i] = noz;
Maxwelltime:Instructions.c:      E->mesh.NOY[i] = noy;
Maxwelltime:Instructions.c:      E->mesh.NNOV[i] = E->mesh.NNO[i];
Maxwelltime:Instructions.c:      E->mesh.NEQ[i] = E->mesh.nsd * E->mesh.NNOV[i] ;
Maxwelltime:Instructions.c:  E->sphere.elx = E->sphere.nox-1;
Maxwelltime:Instructions.c:  E->sphere.ely = E->sphere.noy-1;
Maxwelltime:Instructions.c:  E->sphere.snel = E->sphere.elx*E->sphere.ely;
Maxwelltime:Instructions.c:  E->sphere.nsf = E->sphere.nox*E->sphere.noy;
Maxwelltime:Instructions.c:    E->data.scalet = (E->data.radius_km*1e3*E->data.radius_km*1e3/E->data.therm_diff)/(1.e6*365.25*24*3600);
Maxwelltime:Instructions.c:    E->data.scalev = (E->data.radius_km*1e3/E->data.therm_diff)/(100*365.25*24*3600);
Maxwelltime:Instructions.c:    E->data.timedir = E->control.Atemp / fabs(E->control.Atemp);
Maxwelltime:Instructions.c:    if(E->control.print_convergence && E->parallel.me==0) {
Maxwelltime:Instructions.c:                E->mesh.nox, E->mesh.noz, E->mesh.noy, E->mesh.nno, E->mesh.nel);
Maxwelltime:Instructions.c:	fprintf(E->fp,"Problem has %d x %d x %d nodes per cap, %d nodes and %d elements in total\n",
Maxwelltime:Instructions.c:                E->mesh.nox, E->mesh.noz, E->mesh.noy, E->mesh.nno, E->mesh.nel);
Maxwelltime:Instructions.c:    const int vpts = vpoints[E->mesh.nsd];
Maxwelltime:Instructions.c: for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Instructions.c:  npno = E->lmesh.npno;
Maxwelltime:Instructions.c:  nel  = E->lmesh.nel;
Maxwelltime:Instructions.c:  nno  = E->lmesh.nno;
Maxwelltime:Instructions.c:  nsf  = E->lmesh.nsf;
Maxwelltime:Instructions.c:  noz  = E->lmesh.noz;
Maxwelltime:Instructions.c:  nox  = E->lmesh.nox;
Maxwelltime:Instructions.c:  noy  = E->lmesh.noy;
Maxwelltime:Instructions.c:  elx  = E->lmesh.elx;
Maxwelltime:Instructions.c:  ely  = E->lmesh.ely;
Maxwelltime:Instructions.c:  snel = E->lmesh.elx*E->lmesh.ely;
Maxwelltime:Instructions.c:  E->P[j]        = (double *) malloc((npno+1)*sizeof(double));
Maxwelltime:Instructions.c:  E->T[j]        = (double *) malloc((nno+1)*sizeof(double));
Maxwelltime:Instructions.c:  E->NP[j]       = (float *) malloc((nno+1)*sizeof(float));
Maxwelltime:Instructions.c:  E->buoyancy[j] = (double *) malloc((nno+1)*sizeof(double));
Maxwelltime:Instructions.c:  E->gstress[j] = (float *) malloc((6*nno+1)*sizeof(float));
Maxwelltime:Instructions.c:  //E->stress[j]   = (float *) malloc((12*nsf+1)*sizeof(float));
Maxwelltime:Instructions.c:  for(i=1;i<=E->mesh.nsd;i++)
Maxwelltime:Instructions.c:      E->sphere.cap[j].TB[i] = (float *)  malloc((nno+1)*sizeof(float));
Maxwelltime:Instructions.c:   E->gDA0[j] = (struct Shape_function_dA *)malloc((snel+1)*sizeof(struct Shape_function_dA));
Maxwelltime:Instructions.c:   E->gDA1[j] = (struct Shape_function_dA *)malloc((snel+1)*sizeof(struct Shape_function_dA));
Maxwelltime:Instructions.c:  E->slice.tpg[j]      = (float *)malloc((nsf+2)*sizeof(float));
Maxwelltime:Instructions.c:  E->slice.tpgb[j]     = (float *)malloc((nsf+2)*sizeof(float));
Maxwelltime:Instructions.c:  E->slice.divg[j]     = (float *)malloc((nsf+2)*sizeof(float));
Maxwelltime:Instructions.c:  E->slice.vort[j]     = (float *)malloc((nsf+2)*sizeof(float));
Maxwelltime:Instructions.c:  E->slice.shflux[j]    = (float *)malloc((nsf+2)*sizeof(float));
Maxwelltime:Instructions.c:  E->slice.bhflux[j]    = (float *)malloc((nsf+2)*sizeof(float));
Maxwelltime:Instructions.c:  /*  if(E->mesh.topvbc==2 && E->control.pseudo_free_surf) */
Maxwelltime:Instructions.c:  E->slice.freesurf[j]    = (float *)malloc((nsf+2)*sizeof(float));
Maxwelltime:Instructions.c:  E->all_load[j]      = (double *)malloc((nno+2)*sizeof(double));
Maxwelltime:Instructions.c:  E->total_load[j]      = (double *)malloc((nno+2)*sizeof(double));
Maxwelltime:Instructions.c:  E->all_potential[j]      = (double *)malloc((nno+2)*sizeof(double));
Maxwelltime:Instructions.c:  E->all_load_potential[j]      = (double *)malloc((nno+2)*sizeof(double));
Maxwelltime:Instructions.c:  E->total_potential[j]      = (double *)malloc((nno+2)*sizeof(double));
Maxwelltime:Instructions.c:  E->potential[0][j]      = (double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:  E->potential[1][j]      = (double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:  E->init_potential[0][j]      = (double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:  E->init_potential[1][j]      = (double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:  E->incr_potential[0][j]      = (double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:  E->incr_potential[1][j]      = (double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:  E->incr_potential[2][j]      = (double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:  E->incr_potential[3][j]      = (double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:  E->slice_ve.elast_thick[j]=(double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:  E->slice_ve.plate_margins[j]=(double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:     E->all_load[j][i] = 0.0;
Maxwelltime:Instructions.c:     E->total_load[j][i] = 0.0;
Maxwelltime:Instructions.c:     E->total_potential[j][i] = 0.0;
Maxwelltime:Instructions.c:     E->all_potential[j][i] = 0.0;
Maxwelltime:Instructions.c:     E->all_load_potential[j][i] = 0.0;
Maxwelltime:Instructions.c:     E->init_total_potential[j][i] = 0.0;
Maxwelltime:Instructions.c:     E->slice_ve.load[i][j]      = (double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:       E->slice_ve.load[i][j][k] = 0.0;
Maxwelltime:Instructions.c:  for (i=1;i<=E->mesh.nsd;i++)   {
Maxwelltime:Instructions.c:     E->slice_ve.surf[i][j]      = (double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:     E->slice_ve.botm[i][j]      = (double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:     E->Xsurf[i][j]      = (double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:       E->slice_ve.surf[i][j][k] = 0.0;
Maxwelltime:Instructions.c:       E->slice_ve.botm[i][j][k] = 0.0;
Maxwelltime:Instructions.c:   E->slice_ve.dynamic_oceanload[j]=(double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:   E->slice_ve.static_oceanload[j]=(double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:   E->slice_ve.iceload[0][j]=(double *)malloc((nsf+2)*sizeof(double));
Maxwelltime:Instructions.c:       E->slice_ve.dynamic_oceanload[j][k] = 0.0;
Maxwelltime:Instructions.c:       E->slice_ve.static_oceanload[j][k] = 0.0;
Maxwelltime:Instructions.c:       E->slice_ve.iceload[0][j][k] = 0.0;
Maxwelltime:Instructions.c:  E->Maxwelltime[j] = (double *)malloc((nel+1)*sizeof(double));
Maxwelltime:Instructions.c:  E->Sxx[j] = (double *)malloc((nel*vpts+1)*sizeof(double));
Maxwelltime:Instructions.c:  E->Syy[j] = (double *)malloc((nel*vpts+1)*sizeof(double));
Maxwelltime:Instructions.c:  E->Szz[j] = (double *)malloc((nel*vpts+1)*sizeof(double));
Maxwelltime:Instructions.c:  E->Sxy[j] = (double *)malloc((nel*vpts+1)*sizeof(double));
Maxwelltime:Instructions.c:  E->Sxz[j] = (double *)malloc((nel*vpts+1)*sizeof(double));
Maxwelltime:Instructions.c:  E->Szy[j] = (double *)malloc((nel*vpts+1)*sizeof(double));
Maxwelltime:Instructions.c:    E->S2xx[j] = (double *)malloc((nel+1)*sizeof(double));
Maxwelltime:Instructions.c:    E->S2yy[j] = (double *)malloc((nel+1)*sizeof(double));
Maxwelltime:Instructions.c:    E->S2zz[j] = (double *)malloc((nel+1)*sizeof(double));
Maxwelltime:Instructions.c:    E->S2xy[j] = (double *)malloc((nel+1)*sizeof(double));
Maxwelltime:Instructions.c:    E->S2xz[j] = (double *)malloc((nel+1)*sizeof(double));
Maxwelltime:Instructions.c:    E->S2zy[j] = (double *)malloc((nel+1)*sizeof(double));
Maxwelltime:Instructions.c:    E->EVold[j] = (float *) malloc((nel+2)*sizeof(float));
Maxwelltime:Instructions.c:    E->EVolder[j] = (float *) malloc((nel+2)*sizeof(float));
Maxwelltime:Instructions.c:    E->S2inv[j] = (float *) malloc((nel+2)*sizeof(float));
Maxwelltime:Instructions.c:    E->E2inv[j] = (float *) malloc((nel+2)*sizeof(float));
Maxwelltime:Instructions.c:  E->mat[j] = (int *) malloc((nel+2)*sizeof(int));
Maxwelltime:Instructions.c:  E->VIP[j] = (float *) malloc((nel+2)*sizeof(float));
Maxwelltime:Instructions.c:  E->heating_adi[j]    = (double *) malloc((nel+1)*sizeof(double));
Maxwelltime:Instructions.c:  E->heating_visc[j]   = (double *) malloc((nel+1)*sizeof(double));
Maxwelltime:Instructions.c:  E->heating_latent[j] = (double *) malloc((nel+1)*sizeof(double));
Maxwelltime:Instructions.c:  E->TMass[j] = (double *) malloc((nno+1)*sizeof(double));
Maxwelltime:Instructions.c:  E->NMass[j] = (double *) malloc((nno+1)*sizeof(double));
Maxwelltime:Instructions.c:  E->sien[j]         = (struct SIEN *) malloc((nxyz+2)*sizeof(struct SIEN));
Maxwelltime:Instructions.c:  E->surf_element[j] = (int *) malloc((nxyz+2)*sizeof(int));
Maxwelltime:Instructions.c:  E->surf_node[j]    = (int *) malloc((nsf+2)*sizeof(int));
Maxwelltime:Instructions.c:  E->rho      = (double *) malloc((nno+1)*sizeof(double));
Maxwelltime:Instructions.c:  E->Have.T         = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Maxwelltime:Instructions.c:  E->Have.V[1]      = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Maxwelltime:Instructions.c:  E->Have.V[2]      = (float *)malloc((E->lmesh.noz+2)*sizeof(float));
Maxwelltime:Instructions.c: for(i=E->mesh.levmin;i<=E->mesh.levmax;i++) {
Maxwelltime:Instructions.c:  E->sphere.R[i] = (double *)  malloc((E->lmesh.NOZ[i]+1)*sizeof(double));
Maxwelltime:Instructions.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Instructions.c:    nno  = E->lmesh.NNO[i];
Maxwelltime:Instructions.c:    npno = E->lmesh.NPNO[i];
Maxwelltime:Instructions.c:    nel  = E->lmesh.NEL[i];
Maxwelltime:Instructions.c:    nox = E->lmesh.NOX[i];
Maxwelltime:Instructions.c:    noz = E->lmesh.NOZ[i];
Maxwelltime:Instructions.c:    noy = E->lmesh.NOY[i];
Maxwelltime:Instructions.c:    elx = E->lmesh.ELX[i];
Maxwelltime:Instructions.c:    ely = E->lmesh.ELY[i];
Maxwelltime:Instructions.c:    snel=E->lmesh.SNEL[i];
Maxwelltime:Instructions.c:    for(d=1;d<=E->mesh.nsd;d++)   {
Maxwelltime:Instructions.c:      E->X[i][j][d]  = (double *)  malloc((nno+1)*sizeof(double));
Maxwelltime:Instructions.c:      E->SX[i][j][d]  = (double *)  malloc((nno+1)*sizeof(double));
Maxwelltime:Instructions.c:      E->SinCos[i][j][d]  = (double *)  malloc((nno+1)*sizeof(double));
Maxwelltime:Instructions.c:    E->IEN[i][j] = (struct IEN *)   malloc((nel+2)*sizeof(struct IEN));
Maxwelltime:Instructions.c:    E->EL[i][j]  = (struct SUBEL *) malloc((nel+2)*sizeof(struct SUBEL));
Maxwelltime:Instructions.c:    E->sphere.area1[i][j] = (double *) malloc((snel+1)*sizeof(double));
Maxwelltime:Instructions.c:      E->sphere.angle1[i][j][k] = (double *) malloc((snel+1)*sizeof(double));
Maxwelltime:Instructions.c:    E->GNX[i][j] = (struct Shape_function_dx *)malloc((nel+1)*sizeof(struct Shape_function_dx));
Maxwelltime:Instructions.c:    E->GDA[i][j] = (struct Shape_function_dA *)malloc((nel+1)*sizeof(struct Shape_function_dA));
Maxwelltime:Instructions.c:    E->MASS[i][j]     = (double *) malloc((nno+1)*sizeof(double));
Maxwelltime:Instructions.c:    E->ECO[i][j] = (struct COORD *) malloc((nno+2)*sizeof(struct COORD));
Maxwelltime:Instructions.c:    E->TWW[i][j] = (struct FNODE *)   malloc((nel+2)*sizeof(struct FNODE));
Maxwelltime:Instructions.c:    for(d=1;d<=E->mesh.nsd;d++)
Maxwelltime:Instructions.c:      for(l=1;l<=E->lmesh.NNO[i];l++)  {
Maxwelltime:Instructions.c:        E->SX[i][j][d][l] = 0.0;
Maxwelltime:Instructions.c:        E->X[i][j][d][l] = 0.0;
Maxwelltime:Instructions.c: for(i=0;i<=E->output.llmax;i++)
Maxwelltime:Instructions.c:  E->sphere.hindex[i] = (int *) malloc((E->output.llmax+3)
Maxwelltime:Instructions.c: for(i=E->mesh.gridmin;i<=E->mesh.gridmax;i++)
Maxwelltime:Instructions.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Instructions.c:    nno  = E->lmesh.NNO[i];
Maxwelltime:Instructions.c:    npno = E->lmesh.NPNO[i];
Maxwelltime:Instructions.c:    nel  = E->lmesh.NEL[i];
Maxwelltime:Instructions.c:    nox = E->lmesh.NOX[i];
Maxwelltime:Instructions.c:    noz = E->lmesh.NOZ[i];
Maxwelltime:Instructions.c:    noy = E->lmesh.NOY[i];
Maxwelltime:Instructions.c:    elx = E->lmesh.ELX[i];
Maxwelltime:Instructions.c:    ely = E->lmesh.ELY[i];
Maxwelltime:Instructions.c:    E->CC[i][j] =(struct CC *)  malloc((1)*sizeof(struct CC));
Maxwelltime:Instructions.c:    E->CCX[i][j]=(struct CCX *)  malloc((1)*sizeof(struct CCX));
Maxwelltime:Instructions.c:    E->ELEMENT[i][j] = (unsigned int *) malloc((nel+2)*sizeof(unsigned int));
Maxwelltime:Instructions.c:    E->elt_del[i][j] = (struct EG *) malloc((nel+1)*sizeof(struct EG));
Maxwelltime:Instructions.c:    if(E->control.inv_gruneisen != 0)
Maxwelltime:Instructions.c:        E->elt_c[i][j] = (struct EC *) malloc((nel+1)*sizeof(struct EC));
Maxwelltime:Instructions.c:    E->EVI[i][j] = (float *) malloc((nel+1)*vpoints[E->mesh.nsd]*sizeof(float));
Maxwelltime:Instructions.c:    E->erho[i][j]    = (float *) malloc((nel+1)*sizeof(float));
Maxwelltime:Instructions.c:    E->elambda[i][j] = (float *) malloc((nel+1)*sizeof(float));
Maxwelltime:Instructions.c:    E->esmu[i][j]    = (float *) malloc((nel+1)*sizeof(float));
Maxwelltime:Instructions.c:    E->egrav[i][j]    = (float *) malloc((nel+1)*sizeof(float));
Maxwelltime:Instructions.c:    E->BPI[i][j] = (double *) malloc((npno+1)*sizeof(double));
Maxwelltime:Instructions.c:    E->ID[i][j]  = (struct ID *)    malloc((nno+1)*sizeof(struct ID));
Maxwelltime:Instructions.c:    E->VI[i][j]  = (float *)        malloc((nno+1)*sizeof(float));
Maxwelltime:Instructions.c:    E->NODE[i][j] = (unsigned int *)malloc((nno+1)*sizeof(unsigned int));
Maxwelltime:Instructions.c:    E->parallel.EXCHANGE_sNODE[i][j] = (struct PASS *) malloc((nozl+2)*sizeof(struct PASS));
Maxwelltime:Instructions.c:    E->parallel.NODE[i][j]   = (struct BOUND *) malloc((nxyz+2)*sizeof(struct BOUND));
Maxwelltime:Instructions.c:    E->parallel.EXCHANGE_NODE[i][j]= (struct PASS *) malloc((nxyz+2)*sizeof(struct PASS));
Maxwelltime:Instructions.c:    E->parallel.EXCHANGE_ID[i][j] = (struct PASS *) malloc((nxyz*E->mesh.nsd+3)*sizeof(struct PASS));
Maxwelltime:Instructions.c:    for(l=1;l<=E->lmesh.NNO[i];l++)  {
Maxwelltime:Instructions.c:      E->NODE[i][j][l] = (INTX | INTY | INTZ);  /* and any others ... */
Maxwelltime:Instructions.c:      E->VI[i][j][l] = 1.0;
Maxwelltime:Instructions.c:      E->ELEMENT[i][j][l]=0;
Maxwelltime:Instructions.c: for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Instructions.c:  for(k=1;k<=E->mesh.nsd;k++)
Maxwelltime:Instructions.c:    for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Instructions.c:      E->sphere.cap[j].TB[k][i] = 0.0;
Maxwelltime:Instructions.c:  for(i=1;i<=E->lmesh.nno;i++)  {
Maxwelltime:Instructions.c:     E->T[j][i] = 0.0;
Maxwelltime:Instructions.c:     E->buoyancy[j][i] = 0.0;
Maxwelltime:Instructions.c:  for(i=1;i<=E->lmesh.nel;i++)   {
Maxwelltime:Instructions.c:      E->mat[j][i]=1;
Maxwelltime:Instructions.c:      E->Maxwelltime[j][i]=1;
Maxwelltime:Instructions.c:      E->VIP[j][i]=1.0;
Maxwelltime:Instructions.c:      E->heating_adi[j][i] = 0;
Maxwelltime:Instructions.c:      E->heating_visc[j][i] = 0;
Maxwelltime:Instructions.c:      E->heating_latent[j][i] = 1.0;
Maxwelltime:Instructions.c:  for(i=1;i<=E->lmesh.npno;i++)
Maxwelltime:Instructions.c:      E->P[j][i] = 0.0;
Maxwelltime:Instructions.c:  if (strcmp(E->output.format, "hdf5") == 0)
Maxwelltime:Instructions.c:    E->monitor.incompressibility = 0;
Maxwelltime:Instructions.c:    E->monitor.fdotf = 0;
Maxwelltime:Instructions.c:    E->monitor.vdotv = 0;
Maxwelltime:Instructions.c:    E->monitor.pdotp = 0;
Maxwelltime:Instructions.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Maxwelltime:Instructions.c:    E->lmesh.nnov = E->lmesh.nno;
Maxwelltime:Instructions.c:    E->lmesh.neq = E->lmesh.nnov * E->mesh.nsd;
Maxwelltime:Instructions.c:    E->temp[j] = (double *) malloc((E->lmesh.neq+1)*sizeof(double));
Maxwelltime:Instructions.c:    E->temp1[j] = (double *) malloc(E->lmesh.neq*sizeof(double));
Maxwelltime:Instructions.c:    E->F[j] = (double *) malloc(E->lmesh.neq*sizeof(double));
Maxwelltime:Instructions.c:    E->U[j] = (double *) malloc((E->lmesh.neq+1)*sizeof(double));
Maxwelltime:Instructions.c:    E->u1[j] = (double *) malloc((E->lmesh.neq+1)*sizeof(double));
Maxwelltime:Instructions.c:    for(i=1;i<=E->mesh.nsd;i++) {
Maxwelltime:Instructions.c:      E->sphere.cap[j].V[i] = (double *) malloc((E->lmesh.nnov+1)*sizeof(double));
Maxwelltime:Instructions.c:      E->sphere.cap[j].total_VS[i] = (double *) malloc((E->lmesh.nnov+1)*sizeof(double));
Maxwelltime:Instructions.c:      E->sphere.cap[j].total_VC[i] = (double *) malloc((E->lmesh.nnov+1)*sizeof(double));
Maxwelltime:Instructions.c:      E->sphere.cap[j].VB[i] = (float *)malloc((E->lmesh.nnov+1)*sizeof(float));
Maxwelltime:Instructions.c:      E->sphere.cap[j].Vprev[i] = (float *) malloc((E->lmesh.nnov+1)*sizeof(float));
Maxwelltime:Instructions.c:    for(i=0;i<E->lmesh.neq;i++)
Maxwelltime:Instructions.c:      E->U[j][i] = E->temp[j][i] = E->temp1[j][i] = 0.0;
Maxwelltime:Instructions.c:    for(k=1;k<=E->mesh.nsd;k++)
Maxwelltime:Instructions.c:      for(i=1;i<=E->lmesh.nnov;i++)  {
Maxwelltime:Instructions.c:        E->sphere.cap[j].VB[k][i] = 0.0;
Maxwelltime:Instructions.c:    for(k=1;k<=E->mesh.nsd;k++)
Maxwelltime:Instructions.c:      for(i=1;i<=E->lmesh.nsf;i++)  {
Maxwelltime:Instructions.c:        E->sphere.cap[j].total_VS[k][i] = 0.0;
Maxwelltime:Instructions.c:        E->sphere.cap[j].total_VC[k][i] = 0.0;
Maxwelltime:Instructions.c:  for(l=E->mesh.gridmin;l<=E->mesh.gridmax;l++)
Maxwelltime:Instructions.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Maxwelltime:Instructions.c:      E->lmesh.NEQ[l] = E->lmesh.NNOV[l] * E->mesh.nsd;
Maxwelltime:Instructions.c:      for (i=1;i<=enodes[E->mesh.nsd];i++)  {
Maxwelltime:Instructions.c:         E->B_R[l][j][i] = (double *)malloc((E->lmesh.SNEL[l]*onedvpoints[E->mesh.nsd]+2)*sizeof(double));
Maxwelltime:Instructions.c:         for (n=1;n<=E->lmesh.SNEL[l]*onedvpoints[E->mesh.nsd]+1;n++)
Maxwelltime:Instructions.c:             E->B_R[l][j][i][n] = 0.0;
Maxwelltime:Instructions.c:      E->BI[l][j] = (double *) malloc((E->lmesh.NEQ[l])*sizeof(double));
Maxwelltime:Instructions.c:      k = (E->lmesh.NOX[l]*E->lmesh.NOZ[l]+E->lmesh.NOX[l]*E->lmesh.NOY[l]+
Maxwelltime:Instructions.c:          E->lmesh.NOY[l]*E->lmesh.NOZ[l])*6;
Maxwelltime:Instructions.c:      E->zero_resid[l][j] = (int *) malloc((k+2)*sizeof(int));
Maxwelltime:Instructions.c:      E->parallel.Skip_id[l][j] = (int *) malloc((k+2)*sizeof(int));
Maxwelltime:Instructions.c:      for(i=0;i<E->lmesh.NEQ[l];i++) {
Maxwelltime:Instructions.c:         E->BI[l][j][i]=0.0;
Maxwelltime:Instructions.c:  E->control.v_steps_low = 10;
Maxwelltime:Instructions.c:  E->control.v_steps_upper = 1;
Maxwelltime:Instructions.c:  E->control.accuracy = 1.0e-4;
Maxwelltime:Instructions.c:  E->control.verbose=0; /* debugging/profiles */
Maxwelltime:Instructions.c:    E->control.stokes=0;
Maxwelltime:Instructions.c:    E->control.restart=0;
Maxwelltime:Instructions.c:    E->control.CONVECTION = 0;
Maxwelltime:Instructions.c:    E->control.CART2D = 0;
Maxwelltime:Instructions.c:    E->control.CART3D = 0;
Maxwelltime:Instructions.c:    E->control.CART2pt5D = 0;
Maxwelltime:Instructions.c:    E->control.AXI = 0;
Maxwelltime:Instructions.c:    E->control.CONJ_GRAD = 0;
Maxwelltime:Instructions.c:    E->control.NMULTIGRID = 0;
Maxwelltime:Instructions.c:    E->control.augmented_Lagr = 0;
Maxwelltime:Instructions.c:    E->control.augmented = 0.0;
Maxwelltime:Instructions.c:    E->trace.fpt = NULL;
Maxwelltime:Instructions.c:    E->control.tracer = 0;
Maxwelltime:Instructions.c:    E->composition.on = 0;
Maxwelltime:Instructions.c:  E->parallel.nprocx=1; E->parallel.nprocz=1; E->parallel.nprocy=1;
Maxwelltime:Instructions.c:  E->mesh.levmax=0;
Maxwelltime:Instructions.c:  E->mesh.levmin=0;
Maxwelltime:Instructions.c:  E->mesh.gridmax=0;
Maxwelltime:Instructions.c:  E->mesh.gridmin=0;
Maxwelltime:Instructions.c:  E->mesh.noz = 1;    E->mesh.nzs = 1;  E->lmesh.noz = 1;    E->lmesh.nzs = 1;
Maxwelltime:Instructions.c:  E->mesh.noy = 1;    E->mesh.nys = 1;  E->lmesh.noy = 1;    E->lmesh.nys = 1;
Maxwelltime:Instructions.c:  E->mesh.nox = 1;    E->mesh.nxs = 1;  E->lmesh.nox = 1;    E->lmesh.nxs = 1;
Maxwelltime:Instructions.c:  E->sphere.ro = 1.0;
Maxwelltime:Instructions.c:  E->sphere.ri = 0.5;
Maxwelltime:Instructions.c:  E->control.precondition = 0;  /* for larger visc contrasts turn this back on  */
Maxwelltime:Instructions.c:  E->mesh.toptbc = 1; /* fixed t */
Maxwelltime:Instructions.c:  E->mesh.bottbc = 1;
Maxwelltime:Instructions.c:  E->mesh.topvbc = 0; /* stress */
Maxwelltime:Instructions.c:  E->mesh.botvbc = 0;
Maxwelltime:Instructions.c:  E->control.VBXtopval=0.0;
Maxwelltime:Instructions.c:  E->control.VBYtopval=0.0;
Maxwelltime:Instructions.c:  E->control.VBXbotval=0.0;
Maxwelltime:Instructions.c:  E->control.VBYbotval=0.0;
Maxwelltime:Instructions.c:  E->data.radius_km = 6370.0; /* Earth, whole mantle defaults */
Maxwelltime:Instructions.c:  E->data.grav_acc = 9.81;
Maxwelltime:Instructions.c:  E->data.therm_diff = 1.0e-6;
Maxwelltime:Instructions.c:  E->data.therm_exp = 3.e-5;
Maxwelltime:Instructions.c:  E->data.density = 3300.0;
Maxwelltime:Instructions.c:  E->data.ref_viscosity=1.e21;
Maxwelltime:Instructions.c:  E->data.density_above = 1000.0;    /* sea water */
Maxwelltime:Instructions.c:  E->data.density_below = 6600.0;    /* sea water */
Maxwelltime:Instructions.c:  E->data.Cp = 1200.0;
Maxwelltime:Instructions.c:  E->data.therm_cond = 3.168;
Maxwelltime:Instructions.c:  E->data.res_density = 3300.0;  /* density when X = ... */
Maxwelltime:Instructions.c:  E->data.res_density_X = 0.3;
Maxwelltime:Instructions.c:  E->data.melt_density = 2800.0;
Maxwelltime:Instructions.c:  E->data.permeability = 3.0e-10;
Maxwelltime:Instructions.c:  E->data.gas_const = 8.3;
Maxwelltime:Instructions.c:  E->data.surf_heat_flux = 4.4e-2;
Maxwelltime:Instructions.c:  E->data.grav_const = 6.6742e-11;
Maxwelltime:Instructions.c:  E->data.youngs_mod = 1.0e11;
Maxwelltime:Instructions.c:  E->data.Te = 0.0;
Maxwelltime:Instructions.c:  E->data.T_sol0 = 1373.0;      /* Dave's values 1991 (for the earth) */
Maxwelltime:Instructions.c:  E->data.Tsurf = 273.0;
Maxwelltime:Instructions.c:  E->data.dTsol_dz = 3.4e-3 ;
Maxwelltime:Instructions.c:  E->data.dTsol_dF = 440.0;
Maxwelltime:Instructions.c:  E->data.dT_dz = 0.48e-3;
Maxwelltime:Instructions.c:  E->data.delta_S = 250.0;
Maxwelltime:Instructions.c:  E->data.ref_temperature = 2 * 1350.0; /* fixed temperature ... delta T */
Maxwelltime:Instructions.c:    sprintf(E->control.data_prefix,"citcom.tmp.%d",getpid());
Maxwelltime:Instructions.c:    E->control.NASSEMBLE = 0;
Maxwelltime:Instructions.c:    E->monitor.elapsed_time=0.0;
Maxwelltime:Instructions.c:    E->control.record_all_until = 10000000;
Maxwelltime:Instructions.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Instructions.c:    for(i=1;i<=E->lmesh.nno;i++)    {
Maxwelltime:Instructions.c:      if ((E->node[j][i] & VBX) && (E->node[j][i] & SBX))
Maxwelltime:Instructions.c:      if ((E->node[j][i] & VBZ) && (E->node[j][i] & SBZ))
Maxwelltime:Instructions.c:      if ((E->node[j][i] & VBY) && (E->node[j][i] & SBY))
Maxwelltime:Instructions.c:      if ((E->node[j][i] & TBX) && (E->node[j][i] & FBX))
Maxwelltime:Instructions.c:      if ((E->node[j][i] & TBZ) && (E->node[j][i] & FBZ))
Maxwelltime:Instructions.c:      if ((E->node[j][i] & TBY) && (E->node[j][i] & FBY))
Maxwelltime:Instructions.c:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Maxwelltime:Instructions.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Instructions.c:      for(i=1;i<=E->lmesh.NNO[lev];i++)        {
Maxwelltime:Instructions.c:        if ((E->NODE[lev][j][i] & VBX) && (E->NODE[lev][j][i]  & SBX))
Maxwelltime:Instructions.c:        if ((E->NODE[lev][j][i] & VBZ) && (E->NODE[lev][j][i]  & SBZ))
Maxwelltime:Instructions.c:        if ((E->NODE[lev][j][i] & VBY) && (E->NODE[lev][j][i]  & SBY))
Maxwelltime:Instructions.c:  E->eco[j] = E->ECO[E->mesh.levmax][j];
Maxwelltime:Instructions.c:  E->ien[j] = E->IEN[E->mesh.levmax][j];
Maxwelltime:Instructions.c:  E->id[j] = E->ID[E->mesh.levmax][j];
Maxwelltime:Instructions.c:  E->Vi[j] = E->VI[E->mesh.levmax][j];
Maxwelltime:Instructions.c:  E->EVi[j] = E->EVI[E->mesh.levmax][j];
Maxwelltime:Instructions.c:  E->node[j] = E->NODE[E->mesh.levmax][j];
Maxwelltime:Instructions.c:  E->cc[j] = E->CC[E->mesh.levmax][j];
Maxwelltime:Instructions.c:  E->ccx[j] = E->CCX[E->mesh.levmax][j];
Maxwelltime:Instructions.c:  E->Mass[j] = E->MASS[E->mesh.levmax][j];
Maxwelltime:Instructions.c:  E->gDA[j] = E->GDA[E->mesh.levmax][j];
Maxwelltime:Instructions.c:  E->gNX[j] = E->GNX[E->mesh.levmax][j];
Maxwelltime:Instructions.c:  for (i=1;i<=E->mesh.nsd;i++)    {
Maxwelltime:Instructions.c:    E->x[j][i] = E->X[E->mesh.levmax][j][i];
Maxwelltime:Instructions.c:    E->sx[j][i] = E->SX[E->mesh.levmax][j][i];
Maxwelltime:Instructions.c:{ if(E->control.verbose && E->parallel.me==0)
Maxwelltime:Instructions.c:{ if(E->control.verbose && E->fp)
Maxwelltime:Instructions.c:    { fprintf(E->fp,"%s\n",string);
Maxwelltime:Instructions.c:      fflush(E->fp);
Maxwelltime:Instructions.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Instructions.c:    for(i=1;i<=E->lmesh.npno;i++)
Maxwelltime:Instructions.c:      E->P[m][i]=0.0;
Maxwelltime:Instructions.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Instructions.c:    for(i=1;i<=E->lmesh.nnov;i++)   {
Maxwelltime:Instructions.c:        E->sphere.cap[m].V[1][i]=0.0;
Maxwelltime:Instructions.c:        E->sphere.cap[m].V[2][i]=0.0;
Maxwelltime:Instructions.c:        E->sphere.cap[m].V[3][i]=0.0;
Maxwelltime:Instructions.c:  E->fp = NULL;
Maxwelltime:Instructions.c:  if (strcmp(E->output.format, "ascii-gz") == 0)
Maxwelltime:Instructions.c:    sprintf(logfile,"%s/log", E->control.data_dir);
Maxwelltime:Instructions.c:    sprintf(logfile,"%s.log", E->control.data_file);
Maxwelltime:Instructions.c:  if (E->control.restart || E->control.post_p)
Maxwelltime:Instructions.c:      E->fp = output_open(logfile, "a");
Maxwelltime:Instructions.c:      E->fp = output_open(logfile, "w");
Maxwelltime:Instructions.c:  sprintf(logfile,"%s.Love_numbers", E->control.data_file);
Maxwelltime:Instructions.c:  E->fp_LN = output_open(logfile, "w");
Maxwelltime:Instructions.c:  E->fptime = NULL;
Maxwelltime:Instructions.c:  if (E->parallel.me == 0) {
Maxwelltime:Instructions.c:  if (strcmp(E->output.format, "ascii-gz") == 0)
Maxwelltime:Instructions.c:    sprintf(timeoutput,"%s/time", E->control.data_dir);
Maxwelltime:Instructions.c:    sprintf(timeoutput,"%s.time", E->control.data_file);
Maxwelltime:Instructions.c:  if (E->control.restart || E->control.post_p)
Maxwelltime:Instructions.c:      E->fptime = output_open(timeoutput, "a");
Maxwelltime:Instructions.c:      E->fptime = output_open(timeoutput, "w");
Maxwelltime:Instructions.c:  E->fp_out = NULL;
Maxwelltime:Instructions.c:  if (strcmp(E->output.format, "ascii-gz") == 0)
Maxwelltime:Instructions.c:    sprintf(output_file,"%s/info.%d", E->control.data_dir, E->parallel.me);
Maxwelltime:Instructions.c:    sprintf(output_file,"%s.info.%d", E->control.data_file, E->parallel.me);
Maxwelltime:Instructions.c:  E->fp_out = output_open(output_file, "w");
Maxwelltime:Instructions.c:  if (E->control.verbose) {
Maxwelltime:Instructions.c:  if((E->parallel.me_loc[3] == E->parallel.nprocz-1) &&
Maxwelltime:Instructions.c:     (E->parallel.me==E->parallel.nprocz-1)){
Maxwelltime:Instructions.c:    if (strcmp(E->output.format, "ascii-gz") == 0)
Maxwelltime:Instructions.c:      sprintf(output_file,"%s/qt.dat", E->control.data_dir);
Maxwelltime:Instructions.c:      sprintf(output_file,"%s.qt.dat", E->control.data_file);
Maxwelltime:Instructions.c:    if(E->control.restart)
Maxwelltime:Instructions.c:      E->output.fpqt = output_open(output_file, "a"); /* append for restart */
Maxwelltime:Instructions.c:      E->output.fpqt = output_open(output_file, "w");
Maxwelltime:Instructions.c:    E->output.fpqt = NULL;
Maxwelltime:Instructions.c:  if (E->parallel.me_loc[3] == 0)    {
Maxwelltime:Instructions.c:    if (strcmp(E->output.format, "ascii-gz") == 0)
Maxwelltime:Instructions.c:      sprintf(output_file,"%s/qb.dat", E->control.data_dir);
Maxwelltime:Instructions.c:      sprintf(output_file,"%s.qb.dat", E->control.data_file);
Maxwelltime:Instructions.c:    if(E->control.restart)
Maxwelltime:Instructions.c:      E->output.fpqb = output_open(output_file, "a"); /* append */
Maxwelltime:Instructions.c:      E->output.fpqb = output_open(output_file, "w");
Maxwelltime:Instructions.c:    E->output.fpqb = NULL;
Maxwelltime:Instructions.c:    len = strlen(E->output.optional);
Maxwelltime:Instructions.c:    next = E->output.optional;
Maxwelltime:Instructions.c:    E->output.connectivity = 0;
Maxwelltime:Instructions.c:    E->output.stress = 0;
Maxwelltime:Instructions.c:    E->output.pressure = 0;
Maxwelltime:Instructions.c:    E->output.surf = 0;
Maxwelltime:Instructions.c:    E->output.botm = 0;
Maxwelltime:Instructions.c:    E->output.geoid = 0;
Maxwelltime:Instructions.c:    E->output.horiz_avg = 0;
Maxwelltime:Instructions.c:    E->output.seismic = 0;
Maxwelltime:Instructions.c:    E->output.coord_bin = 0;
Maxwelltime:Instructions.c:    E->output.tracer = 0;
Maxwelltime:Instructions.c:    E->output.comp_el = 0;
Maxwelltime:Instructions.c:    E->output.comp_nd = 0;
Maxwelltime:Instructions.c:    E->output.heating = 0;
Maxwelltime:Instructions.c:            E->output.connectivity = 1;
Maxwelltime:Instructions.c:            E->output.stress = 1;
Maxwelltime:Instructions.c:            E->output.pressure = 1;
Maxwelltime:Instructions.c:            E->output.surf = 1;
Maxwelltime:Instructions.c:            E->output.botm = 1;
Maxwelltime:Instructions.c:	    if (E->parallel.nprocxy != 12) {
Maxwelltime:Instructions.c:		E->output.geoid  = 1;
Maxwelltime:Instructions.c:            E->output.horiz_avg = 1;
Maxwelltime:Instructions.c:            E->output.seismic = E->output.coord_bin = 1;
Maxwelltime:Instructions.c:            if(E->parallel.me==0) {
Maxwelltime:Instructions.c:                fprintf(stderr, "Total temperature contrast = %f K\n", E->data.ref_temperature);
Maxwelltime:Instructions.c:                fprintf(E->fp, "Total temperature contrast = %f K\n", E->data.ref_temperature);
Maxwelltime:Instructions.c:            E->output.tracer = 1;
Maxwelltime:Instructions.c:            E->output.comp_el = 1;
Maxwelltime:Instructions.c:            E->output.comp_nd = 1;
Maxwelltime:Instructions.c:            E->output.heating = 1;
Maxwelltime:Instructions.c:            if(E->parallel.me == 0)
Maxwelltime:Instructions.c:/* check whether E->control.data_file contains a path seperator */
Maxwelltime:Instructions.c:  found = strchr(E->control.data_prefix, '/');
Maxwelltime:Instructions.c:      fprintf(stderr, "error in input parameter: datafile='%s' contains '/'\n", E->control.data_file);
Maxwelltime:Instructions.c:  if (E->control.restart || E->control.post_p ||
Maxwelltime:Instructions.c:      (E->convection.tic_method == -1) ||
Maxwelltime:Instructions.c:      (E->control.tracer && (E->trace.ic_method == 2))) {
Maxwelltime:Instructions.c:      found = strchr(E->control.data_prefix_old, '/');
Maxwelltime:Instructions.c:	  fprintf(stderr, "error in input parameter: datafile_old='%s' contains '/'\n", E->control.data_file);
Maxwelltime:Instructions.c:	sprintf(tmp, "%d", E->parallel.me);
Maxwelltime:Instructions.c:    expand_datadir(E, E->control.data_dir);
Maxwelltime:Instructions.c:    mkdatadir(E->control.data_dir);
Maxwelltime:Instructions.c:    snprintf(E->control.data_file, 200, "%s/%s", E->control.data_dir,
Maxwelltime:Instructions.c:	     E->control.data_prefix);
Maxwelltime:Instructions.c:    if (E->control.restart || E->control.post_p ||
Maxwelltime:Instructions.c:        (E->convection.tic_method == -1) ||
Maxwelltime:Instructions.c:        (E->control.tracer && (E->trace.ic_method == 2))) {
Maxwelltime:Instructions.c:	expand_datadir(E, E->control.data_dir_old);
Maxwelltime:Instructions.c:	snprintf(E->control.old_P_file, 200, "%s/%s", E->control.data_dir_old,
Maxwelltime:Instructions.c:		 E->control.data_prefix_old);
Maxwelltime:Instructions.c:    if (strcmp(E->output.format, "ascii") == 0) {
Maxwelltime:Instructions.c:        E->problem_output = output;
Maxwelltime:Instructions.c:    else if (strcmp(E->output.format, "hdf5") == 0)
Maxwelltime:Instructions.c:        E->problem_output = h5output;
Maxwelltime:Instructions.c:    else if (strcmp(E->output.format, "vtk") == 0)
Maxwelltime:Instructions.c:        E->problem_output = vtk_output;
Maxwelltime:Instructions.c:    else if (strcmp(E->output.format, "ascii-gz") == 0)
Maxwelltime:Instructions.c:        E->problem_output = gzdir_output;
Maxwelltime:Instructions.c:        if (E->parallel.me == 0) {
Maxwelltime:Instructions.c:            fprintf(E->fp, "wrong output_format, must be  'ascii', 'hdf5' 'ascii-gz', or 'vtk'\n");
Maxwelltime:Instructions.c:        if (E->parallel.me == 0) {
Maxwelltime:Instructions.c:            fprintf(E->fp, "wrong output_format, must be 'ascii', 'hdf5', or 'vtk' (USE_GZDIR undefined)\n");
Maxwelltime:Instructions.c:  if (E->fp)
Maxwelltime:Instructions.c:    fclose(E->fp);
Maxwelltime:Instructions.c:  if (E->fptime)
Maxwelltime:Instructions.c:    fclose(E->fptime);
Maxwelltime:Instructions.c:  if (E->fp_out)
Maxwelltime:Instructions.c:    fclose(E->fp_out);
Maxwelltime:Instructions.c:  if (E->trace.fpt)
Maxwelltime:Instructions.c:    fclose(E->trace.fpt);
Maxwelltime:Instructions.c:  if(E->output.fpqt)
Maxwelltime:Instructions.c:    fclose(E->output.fpqt);
Maxwelltime:Instructions.c:  if(E->output.fpqb)
Maxwelltime:Instructions.c:    fclose(E->output.fpqb);
Maxwelltime:Instructions.c:  if (E->fp_LN)
Maxwelltime:Instructions.c:    fclose(E->fp_LN);
Maxwelltime:Instructions.c:  if((E->output.gzdir.vtk_io != 0) &&
Maxwelltime:Instructions.c:     (strcmp(E->output.format, "ascii-gz") == 0)){
Maxwelltime:Instructions.c:    if((E->output.gzdir.vtk_io == 3)||(E->parallel.me == 0)){
Maxwelltime:Instructions.c:      if(E->parallel.me == 0){
Maxwelltime:Instructions.c:	if(E->output.gzdir.vtk_fp)
Maxwelltime:Instructions.c:	  fclose(E->output.gzdir.vtk_fp);
Maxwelltime:Lith_age.c:  int m = E->parallel.me;
Maxwelltime:Lith_age.c:  E->control.lith_age = 0;
Maxwelltime:Lith_age.c:  E->control.lith_age_time = 0;
Maxwelltime:Lith_age.c:  E->control.temperature_bound_adj = 0;
Maxwelltime:Lith_age.c:  input_int("lith_age",&(E->control.lith_age),"0",m);
Maxwelltime:Lith_age.c:  input_int("ggrd_age_control",&(E->control.ggrd.age_control),"0",m); /* if > 0, will use top  E->control.ggrd.mat_control layers and assign a prefactor for the viscosity */
Maxwelltime:Lith_age.c:  if(E->control.ggrd.age_control){
Maxwelltime:Lith_age.c:    E->control.lith_age = 1;	
Maxwelltime:Lith_age.c:  if (E->control.lith_age) {
Maxwelltime:Lith_age.c:    input_int("lith_age_time",&(E->control.lith_age_time),"0",m);
Maxwelltime:Lith_age.c:    input_string("lith_age_file",E->control.lith_age_file,"",m);
Maxwelltime:Lith_age.c:    input_float("lith_age_depth",&(E->control.lith_age_depth),"0.0471",m);
Maxwelltime:Lith_age.c:    input_int("temperature_bound_adj",&(E->control.temperature_bound_adj),"0",m);
Maxwelltime:Lith_age.c:    if (E->control.temperature_bound_adj) {
Maxwelltime:Lith_age.c:      input_float("depth_bound_adj",&(E->control.depth_bound_adj),"0.1570",m);
Maxwelltime:Lith_age.c:      input_float("width_bound_adj",&(E->control.width_bound_adj),"0.08727",m);
Maxwelltime:Lith_age.c:  gnox=E->mesh.nox;
Maxwelltime:Lith_age.c:  gnoy=E->mesh.noy;
Maxwelltime:Lith_age.c:  if (E->parallel.me == 0 ) fprintf(stderr,"INSIDE lith_age_init\n");
Maxwelltime:Lith_age.c:  E->age_t=(float*) malloc((gnox*gnoy+1)*sizeof(float));
Maxwelltime:Lith_age.c:  if(E->control.lith_age_time==1)   {
Maxwelltime:Lith_age.c:    E->control.lith_age_old_cycles = E->monitor.solution_cycles;
Maxwelltime:Lith_age.c:    (E->solver.lith_age_read_files)(E,output);
Maxwelltime:Lith_age.c:    sprintf(output_file,"%s",E->control.lith_age_file);
Maxwelltime:Lith_age.c:      fprintf(E->fp,"(Boundary_conditions #1) Can't open %s\n",output_file);
Maxwelltime:Lith_age.c:	if(fscanf(fp1,"%f",&(E->age_t[node])) != 1) {
Maxwelltime:Lith_age.c:	E->age_t[node]=E->age_t[node]*E->data.scalet;
Maxwelltime:Lith_age.c:  } /* end E->control.lith_age_time == false */
Maxwelltime:Lith_age.c:  noy=E->lmesh.noy;
Maxwelltime:Lith_age.c:  nox=E->lmesh.nox;
Maxwelltime:Lith_age.c:  noz=E->lmesh.noz;
Maxwelltime:Lith_age.c:  gnox=E->mesh.nox;
Maxwelltime:Lith_age.c:  gnoy=E->mesh.noy;
Maxwelltime:Lith_age.c:  gnoz=E->mesh.noz;
Maxwelltime:Lith_age.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Lith_age.c:	  nodeg=E->lmesh.nxs-1+j+(E->lmesh.nys+i-2)*gnox;
Maxwelltime:Lith_age.c:	  r1=E->sx[m][3][node];
Maxwelltime:Lith_age.c:	  E->T[m][node] = E->control.mantle_temp;
Maxwelltime:Lith_age.c:	  if( r1 >= E->sphere.ro-E->control.lith_age_depth )
Maxwelltime:Lith_age.c:	      temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Maxwelltime:Lith_age.c:	      E->T[m][node] = E->control.mantle_temp * erf(temp);
Maxwelltime:Lith_age.c:  noy = E->lmesh.noy;
Maxwelltime:Lith_age.c:  nox = E->lmesh.nox;
Maxwelltime:Lith_age.c:  noz = E->lmesh.noz;
Maxwelltime:Lith_age.c:  rout = E->sphere.ro;
Maxwelltime:Lith_age.c:  rin = E->sphere.ri;
Maxwelltime:Lith_age.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Lith_age.c:	  r1=E->sx[m][3][node];
Maxwelltime:Lith_age.c:	    E->sphere.cap[m].TB[1][node]=E->T[m][node];
Maxwelltime:Lith_age.c:	    E->sphere.cap[m].TB[2][node]=E->T[m][node];
Maxwelltime:Lith_age.c:	    E->sphere.cap[m].TB[3][node]=E->T[m][node];
Maxwelltime:Lith_age.c:  nno=E->lmesh.nno;
Maxwelltime:Lith_age.c:  if (E->control.temperature_bound_adj) {
Maxwelltime:Lith_age.c:    ttt2=E->control.theta_min + E->control.width_bound_adj;
Maxwelltime:Lith_age.c:    ttt3=E->control.theta_max - E->control.width_bound_adj;
Maxwelltime:Lith_age.c:    fff2=E->control.fi_min + E->control.width_bound_adj;
Maxwelltime:Lith_age.c:    fff3=E->control.fi_max - E->control.width_bound_adj;
Maxwelltime:Lith_age.c:    if(lv==E->mesh.gridmax)
Maxwelltime:Lith_age.c:      for(j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Lith_age.c:	for(node=1;node<=E->lmesh.nno;node++)  {
Maxwelltime:Lith_age.c:	  if( ((E->sx[j][1][node]<=ttt2) && (E->sx[j][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) || ((E->sx[j][1][node]>=ttt3) && (E->sx[j][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) )
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBX;
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBX);
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBY;
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBY);
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBZ;
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBZ);
Maxwelltime:Lith_age.c:	  if( ((E->sx[j][2][node]<=fff2) && (E->sx[j][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) )
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBX;
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBX);
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBY;
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBY);
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBZ;
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBZ);
Maxwelltime:Lith_age.c:	  if( ((E->sx[j][2][node]>=fff3) && (E->sx[j][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) )
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBX;
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBX);
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBY;
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBY);
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBZ;
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBZ);
Maxwelltime:Lith_age.c:  } /* end E->control.temperature_bound_adj */
Maxwelltime:Lith_age.c:  if (E->control.lith_age_time) {
Maxwelltime:Lith_age.c:    if(lv==E->mesh.gridmax)
Maxwelltime:Lith_age.c:      for(j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Lith_age.c:	for(node=1;node<=E->lmesh.nno;node++)  {
Maxwelltime:Lith_age.c:	  if(E->sx[j][3][node]>=E->sphere.ro-E->control.lith_age_depth)
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBX;
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBX);
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBY;
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBY);
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] | TBZ;
Maxwelltime:Lith_age.c:	      E->node[j][node]=E->node[j][node] & (~FBZ);
Maxwelltime:Lith_age.c:  } /* end E->control.lith_age_time */
Maxwelltime:Lith_age.c:  gnox=E->mesh.nox;
Maxwelltime:Lith_age.c:  gnoy=E->mesh.noy;
Maxwelltime:Lith_age.c:  gnoz=E->mesh.noz;
Maxwelltime:Lith_age.c:  nox=E->lmesh.nox;
Maxwelltime:Lith_age.c:  noy=E->lmesh.noy;
Maxwelltime:Lith_age.c:  noz=E->lmesh.noz;
Maxwelltime:Lith_age.c:  if(E->control.lith_age_time==1)   {
Maxwelltime:Lith_age.c:    if (E->control.lith_age_old_cycles != E->monitor.solution_cycles) {
Maxwelltime:Lith_age.c:      E->control.lith_age_old_cycles = E->monitor.solution_cycles;
Maxwelltime:Lith_age.c:    if (E->parallel.me == 0) fprintf(stderr,"INSIDE lith_age_conform_tbc\n");
Maxwelltime:Lith_age.c:    (E->solver.lith_age_read_files)(E,output);
Maxwelltime:Lith_age.c:  if(E->monitor.solution_cycles>1 && E->control.temperature_bound_adj) {
Maxwelltime:Lith_age.c:    ttt2=E->control.theta_min + E->control.width_bound_adj;
Maxwelltime:Lith_age.c:    ttt3=E->control.theta_max - E->control.width_bound_adj;
Maxwelltime:Lith_age.c:    fff2=E->control.fi_min + E->control.width_bound_adj;
Maxwelltime:Lith_age.c:    fff3=E->control.fi_max - E->control.width_bound_adj;
Maxwelltime:Lith_age.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Lith_age.c:	    nodeg=E->lmesh.nxs-1+j+(E->lmesh.nys+i-2)*gnox;
Maxwelltime:Lith_age.c:	    t1=E->sx[m][1][node];
Maxwelltime:Lith_age.c:	    f1=E->sx[m][2][node];
Maxwelltime:Lith_age.c:	    r1=E->sx[m][3][node];
Maxwelltime:Lith_age.c:	    if(fabs(r1-E->sphere.ro)>=e_4 && fabs(r1-E->sphere.ri)>=e_4)  { /* if NOT right on the boundary */
Maxwelltime:Lith_age.c:	      if( ((E->sx[m][1][node]<=ttt2) && (E->sx[m][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) || ((E->sx[m][1][node]>=ttt3) && (E->sx[m][3][node]>=E->sphere.ro-E->control.depth_bound_adj)) ) {
Maxwelltime:Lith_age.c:		temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Maxwelltime:Lith_age.c:		t0 = E->control.mantle_temp * erf(temp);
Maxwelltime:Lith_age.c:		E->sphere.cap[m].TB[1][node]=t0;
Maxwelltime:Lith_age.c:		E->sphere.cap[m].TB[2][node]=t0;
Maxwelltime:Lith_age.c:		E->sphere.cap[m].TB[3][node]=t0;
Maxwelltime:Lith_age.c:	      if( ((E->sx[m][2][node]<=fff2) || (E->sx[m][2][node]>=fff3)) && (E->sx[m][3][node]>=E->sphere.ro-E->control.depth_bound_adj) ) {
Maxwelltime:Lith_age.c:		temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Maxwelltime:Lith_age.c:		t0 = E->control.mantle_temp * erf(temp);
Maxwelltime:Lith_age.c:		E->sphere.cap[m].TB[1][node]=t0;
Maxwelltime:Lith_age.c:		E->sphere.cap[m].TB[2][node]=t0;
Maxwelltime:Lith_age.c:		E->sphere.cap[m].TB[3][node]=t0;
Maxwelltime:Lith_age.c:  if(E->monitor.solution_cycles>0 && E->control.lith_age_time)   {
Maxwelltime:Lith_age.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Lith_age.c:	    nodeg=E->lmesh.nxs-1+j+(E->lmesh.nys+i-2)*gnox;
Maxwelltime:Lith_age.c:	    t1=E->sx[m][1][node];
Maxwelltime:Lith_age.c:	    f1=E->sx[m][2][node];
Maxwelltime:Lith_age.c:	    r1=E->sx[m][3][node];
Maxwelltime:Lith_age.c:	    if(fabs(r1-E->sphere.ro)>=e_4 && fabs(r1-E->sphere.ri)>=e_4)  { /* if NOT right on the boundary */
Maxwelltime:Lith_age.c:	      if(  E->sx[m][3][node]>=E->sphere.ro-E->control.lith_age_depth ) {
Maxwelltime:Lith_age.c:                depth=E->sphere.ro - E->sx[m][3][node];
Maxwelltime:Lith_age.c:		temp = (E->sphere.ro-r1) *0.5 /sqrt(E->age_t[nodeg]);
Maxwelltime:Lith_age.c:		t0 = E->control.mantle_temp * erf(temp);
Maxwelltime:Lith_age.c:		E->sphere.cap[m].TB[1][node]=t0;
Maxwelltime:Lith_age.c:		E->sphere.cap[m].TB[2][node]=t0;
Maxwelltime:Lith_age.c:		E->sphere.cap[m].TB[3][node]=t0;
Maxwelltime:Lith_age.c:  nno=E->lmesh.nno;
Maxwelltime:Lith_age.c:  gnox=E->mesh.nox;
Maxwelltime:Lith_age.c:  gnoy=E->mesh.noy;
Maxwelltime:Lith_age.c:  gnoz=E->mesh.noz;
Maxwelltime:Lith_age.c:  nox=E->lmesh.nox;
Maxwelltime:Lith_age.c:  noy=E->lmesh.noy;
Maxwelltime:Lith_age.c:  noz=E->lmesh.noz;
Maxwelltime:Lith_age.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Lith_age.c:    for(node=1;node<=E->lmesh.nno;node++)  {
Maxwelltime:Lith_age.c:        type = (E->node[j][node] & (TBX | TBZ | TBY));
Maxwelltime:Lith_age.c:            assimilate_new_temp = E->sphere.cap[j].TB[1][node];
Maxwelltime:Lith_age.c:            assimilate_new_temp = E->sphere.cap[j].TB[3][node];
Maxwelltime:Lith_age.c:            assimilate_new_temp = E->sphere.cap[j].TB[2][node];
Maxwelltime:Lith_age.c:            assimilate_new_temp = 0.5 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[3][node]);
Maxwelltime:Lith_age.c:            assimilate_new_temp = 0.5 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[2][node]);
Maxwelltime:Lith_age.c:            assimilate_new_temp = 0.5 * (E->sphere.cap[j].TB[3][node] + E->sphere.cap[j].TB[2][node]);
Maxwelltime:Lith_age.c:            assimilate_new_temp = 0.3333333 * (E->sphere.cap[j].TB[1][node] + E->sphere.cap[j].TB[2][node] + E->sphere.cap[j].TB[3][node]);
Maxwelltime:Lith_age.c:        depth = E->sphere.ro - E->sx[j][3][node];
Maxwelltime:Lith_age.c:            if(depth <= E->control.lith_age_depth) {
Maxwelltime:Lith_age.c:                daf = 0.5*depth/E->control.lith_age_depth;
Maxwelltime:Lith_age.c:                E->T[j][node] = daf*E->T[j][node] + (1.0-daf)*assimilate_new_temp;
Maxwelltime:Lith_age.c:                E->T[j][node] = assimilate_new_temp;
Maxwelltime:Material_properties.c:    int noz = E->lmesh.noz;
Maxwelltime:Material_properties.c:    int nno = E->lmesh.nno;
Maxwelltime:Material_properties.c:    int nel = E->lmesh.nel;
Maxwelltime:Material_properties.c:    E->refstate.rho = (double *) malloc((noz+1)*sizeof(double));
Maxwelltime:Material_properties.c:    E->refstate.gravity = (double *) malloc((noz+1)*sizeof(double));
Maxwelltime:Material_properties.c:    E->refstate.thermal_expansivity = (double *) malloc((noz+1)*sizeof(double));
Maxwelltime:Material_properties.c:    E->refstate.heat_capacity = (double *) malloc((noz+1)*sizeof(double));
Maxwelltime:Material_properties.c:    /*E->refstate.thermal_conductivity = (double *) malloc((noz+1)*sizeof(double));*/
Maxwelltime:Material_properties.c:    /*E->refstate.Tadi = (double *) malloc((noz+1)*sizeof(double));*/
Maxwelltime:Material_properties.c:for(i=0;i<E->viscosity.rheol_layers;i++)
Maxwelltime:Material_properties.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Material_properties.c:      E->viscosity.zbase_layer[i] = E->sphere.ro-E->sx[m][3][E->viscosity.nbase_layer[i] - E->lmesh.nzs +1];
Maxwelltime:Material_properties.c:    switch(E->refstate.choice) {
Maxwelltime:Material_properties.c:        if (E->parallel.me) {
Maxwelltime:Material_properties.c:            fprintf(E->fp, "Unknown option for reference state\n");
Maxwelltime:Material_properties.c:            fflush(E->fp);
Maxwelltime:Material_properties.c:    if(E->parallel.me == 0) {
Maxwelltime:Material_properties.c:    if(E->parallel.me < E->parallel.nprocz)
Maxwelltime:Material_properties.c:        for(i=1; i<=E->lmesh.noz; i++) {
Maxwelltime:Material_properties.c:                    i+E->lmesh.nzs-1, E->sx[1][3][i], 1-E->sx[1][3][i],
Maxwelltime:Material_properties.c:                    E->refstate.rho[i],layers_r(E,E->sx[1][3][i]));
Maxwelltime:Material_properties.c:    fp = fopen(E->refstate.filename, "r");
Maxwelltime:Material_properties.c:                E->refstate.filename);
Maxwelltime:Material_properties.c:    for(i=1; i<E->lmesh.nzs; i++) {
Maxwelltime:Material_properties.c:    for(i=1; i<=E->lmesh.noz; i++) {
Maxwelltime:Material_properties.c:                  &(E->refstate.rho[i]),
Maxwelltime:Material_properties.c:                  &(E->refstate.gravity[i]),
Maxwelltime:Material_properties.c:                  &(E->refstate.thermal_expansivity[i]),
Maxwelltime:Material_properties.c:                  &(E->refstate.heat_capacity[i]),
Maxwelltime:Material_properties.c:            fprintf(stderr,"Error while reading file '%s'\n", E->refstate.filename);
Maxwelltime:Material_properties.c:                E->refstate.rho[i],
Maxwelltime:Material_properties.c:                E->refstate.gravity[i],
Maxwelltime:Material_properties.c:                E->refstate.thermal_expansivity[i],
Maxwelltime:Material_properties.c:                E->refstate.heat_capacity[i]);
Maxwelltime:Material_properties.c:    beta = E->control.disptn_number * E->control.inv_gruneisen;
Maxwelltime:Material_properties.c:    for(i=1; i<=E->lmesh.noz; i++) {
Maxwelltime:Material_properties.c:	r = E->sx[1][3][i];
Maxwelltime:Material_properties.c:	E->refstate.rho[i] = exp(beta*z);
Maxwelltime:Material_properties.c:	E->refstate.gravity[i] = 1;
Maxwelltime:Material_properties.c:	E->refstate.thermal_expansivity[i] = 1;
Maxwelltime:Material_properties.c:	E->refstate.heat_capacity[i] = 1;
Maxwelltime:Material_properties.c:	/*E->refstate.thermal_conductivity[i] = 1;*/
Maxwelltime:Material_properties.c:	/*E->refstate.Tadi[i] = (E->control.adiabaticT0 + E->control.surface_temp) * exp(E->control.disptn_number * z) - E->control.surface_temp;*/
Maxwelltime:Mineral_physics_models.c:    if(!E->output.horiz_avg)
Maxwelltime:Mineral_physics_models.c:    rhor = malloc((E->lmesh.noz+1) * sizeof(double));
Maxwelltime:Mineral_physics_models.c:    vpr = malloc((E->lmesh.noz+1) * sizeof(double));
Maxwelltime:Mineral_physics_models.c:    vsr = malloc((E->lmesh.noz+1) * sizeof(double));
Maxwelltime:Mineral_physics_models.c:    depthkm = malloc((E->lmesh.noz+1) * sizeof(double));
Maxwelltime:Mineral_physics_models.c:    for(nz=1; nz<=E->lmesh.noz; nz++) {
Maxwelltime:Mineral_physics_models.c:        get_prem(E->sx[m][3][nz], &vpr[nz], &vsr[nz], &rhor[nz]);
Maxwelltime:Mineral_physics_models.c:        depthkm[nz] = (1.0 - E->sx[m][3][nz]) * E->data.radius_km;
Maxwelltime:Mineral_physics_models.c:    for(i=0; i<E->lmesh.nno; i++) {
Maxwelltime:Mineral_physics_models.c:        nz = (i % E->lmesh.noz) + 1;
Maxwelltime:Mineral_physics_models.c:        dT = (E->T[m][i+1] - E->Have.T[nz]) * E->data.ref_temperature;
Maxwelltime:Mineral_physics_models.c:        drho = -dT * E->refstate.thermal_expansivity[nz] * E->data.therm_exp;
Maxwelltime:Mineral_physics_models.c:        if(E->control.tracer && E->composition.on && E->composition.ichemical_buoyancy)
Maxwelltime:Mineral_physics_models.c:            for(j=0; j<E->composition.ncomp; j++) {
Maxwelltime:Mineral_physics_models.c:                dC = E->composition.comp_node[m][j][i+1] - E->Have.C[j][nz];
Maxwelltime:Mineral_physics_models.c:                drho += dC * E->composition.buoyancy_ratio[j]
Maxwelltime:Mineral_physics_models.c:                    * E->data.ref_temperature * E->data.therm_exp / E->refstate.rho[nz];
Maxwelltime:Mineral_physics_models.c:    switch(E->control.mineral_physics_model) {
Maxwelltime:Mineral_physics_models.c:                E->control.mineral_physics_model);
Maxwelltime:Mineral_physics_models.c:                E->control.mineral_physics_model);
Maxwelltime:Mineral_physics_models.c:                E->control.mineral_physics_model);
Maxwelltime:Mineral_physics_models.c:                E->control.mineral_physics_model);
Maxwelltime:Mineral_physics_models.c:                E->control.mineral_physics_model);
Maxwelltime:Nodal_mesh.c:    const int nno = E->lmesh.nno;
Maxwelltime:Nodal_mesh.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Nodal_mesh.c:            E->sphere.cap[m].V[1][node] = E->U[m][E->id[m][node].doff[1]];
Maxwelltime:Nodal_mesh.c:            E->sphere.cap[m].V[2][node] = E->U[m][E->id[m][node].doff[2]];
Maxwelltime:Nodal_mesh.c:            E->sphere.cap[m].V[3][node] = E->U[m][E->id[m][node].doff[3]];
Maxwelltime:Nodal_mesh.c:            if (E->node[m][node] & VBX)
Maxwelltime:Nodal_mesh.c:                E->sphere.cap[m].V[1][node] = E->sphere.cap[m].VB[1][node];
Maxwelltime:Nodal_mesh.c:            if (E->node[m][node] & VBY)
Maxwelltime:Nodal_mesh.c:                E->sphere.cap[m].V[2][node] = E->sphere.cap[m].VB[2][node];
Maxwelltime:Nodal_mesh.c:            if (E->node[m][node] & VBZ)
Maxwelltime:Nodal_mesh.c:                E->sphere.cap[m].V[3][node] = E->sphere.cap[m].VB[3][node];
Maxwelltime:Nodal_mesh.c:    const int nno = E->lmesh.nno;
Maxwelltime:Nodal_mesh.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Nodal_mesh.c:            E->sphere.cap[m].Vprev[1][node] = E->sphere.cap[m].V[1][node];
Maxwelltime:Nodal_mesh.c:            E->sphere.cap[m].Vprev[2][node] = E->sphere.cap[m].V[2][node];
Maxwelltime:Nodal_mesh.c:            E->sphere.cap[m].Vprev[3][node] = E->sphere.cap[m].V[3][node];
Maxwelltime:Nodal_mesh.c:            E->sphere.cap[m].V[1][node] = E->U[m][E->id[m][node].doff[1]];
Maxwelltime:Nodal_mesh.c:            E->sphere.cap[m].V[2][node] = E->U[m][E->id[m][node].doff[2]];
Maxwelltime:Nodal_mesh.c:            E->sphere.cap[m].V[3][node] = E->U[m][E->id[m][node].doff[3]];
Maxwelltime:Nodal_mesh.c:            if (E->node[m][node] & VBX)
Maxwelltime:Nodal_mesh.c:                E->sphere.cap[m].V[1][node] = E->sphere.cap[m].VB[1][node];
Maxwelltime:Nodal_mesh.c:            if (E->node[m][node] & VBY)
Maxwelltime:Nodal_mesh.c:                E->sphere.cap[m].V[2][node] = E->sphere.cap[m].VB[2][node];
Maxwelltime:Nodal_mesh.c:            if (E->node[m][node] & VBZ)
Maxwelltime:Nodal_mesh.c:                E->sphere.cap[m].V[3][node] = E->sphere.cap[m].VB[3][node];
Maxwelltime:Nodal_mesh.c:            sum_dV += (E->sphere.cap[m].V[1][node] - E->sphere.cap[m].Vprev[1][node])*(E->sphere.cap[m].V[1][node] - E->sphere.cap[m].Vprev[1][node])
Maxwelltime:Nodal_mesh.c:                + (E->sphere.cap[m].V[2][node] - E->sphere.cap[m].Vprev[2][node])*(E->sphere.cap[m].V[2][node] - E->sphere.cap[m].Vprev[2][node])
Maxwelltime:Nodal_mesh.c:                + (E->sphere.cap[m].V[3][node] - E->sphere.cap[m].Vprev[3][node])*(E->sphere.cap[m].V[3][node] - E->sphere.cap[m].Vprev[3][node]);
Maxwelltime:Nodal_mesh.c:            sum_V += E->sphere.cap[m].V[1][node]*E->sphere.cap[m].V[1][node]
Maxwelltime:Nodal_mesh.c:                + E->sphere.cap[m].V[2][node]*E->sphere.cap[m].V[2][node]
Maxwelltime:Nodal_mesh.c:                + E->sphere.cap[m].V[3][node]*E->sphere.cap[m].V[3][node];
Maxwelltime:Nodal_mesh.c:        MPI_Allreduce(&rel_error,&global_max_error,1,MPI_DOUBLE,MPI_MAX,E->parallel.world);
Maxwelltime:Nodal_mesh.c:        if(global_max_error <= tol_error) E->monitor.stop_topo_loop = 1;
Maxwelltime:Nodal_mesh.c:        if(E->parallel.me==0)
Maxwelltime:Nodal_mesh.c:            fprintf(stderr,"global_max_error=%e stop_topo_loop=%d\n",global_max_error,E->monitor.stop_topo_loop);
Maxwelltime:Nodal_mesh.c:    const int ends=enodes[E->mesh.nsd];
Maxwelltime:Nodal_mesh.c:    const int lev=E->mesh.levmax;
Maxwelltime:Nodal_mesh.c:            node = E->ien[m][el].node[a];
Maxwelltime:Nodal_mesh.c:            VV[1][a] = E->sphere.cap[m].V[1][node];
Maxwelltime:Nodal_mesh.c:            VV[2][a] = E->sphere.cap[m].V[2][node];
Maxwelltime:Nodal_mesh.c:            VV[3][a] = E->sphere.cap[m].V[3][node];
Maxwelltime:Nodal_mesh.c:            node = E->ien[m][el].node[a];
Maxwelltime:Nodal_mesh.c:            sint = E->SinCos[lev][m][0][node]; 
Maxwelltime:Nodal_mesh.c:            sinf = E->SinCos[lev][m][1][node];
Maxwelltime:Nodal_mesh.c:            cost = E->SinCos[lev][m][2][node];
Maxwelltime:Nodal_mesh.c:            cosf = E->SinCos[lev][m][3][node];
Maxwelltime:Nodal_mesh.c:            VV[1][a] = E->sphere.cap[m].V[1][node]*cost*cosf
Maxwelltime:Nodal_mesh.c:                - E->sphere.cap[m].V[2][node]*sinf
Maxwelltime:Nodal_mesh.c:                + E->sphere.cap[m].V[3][node]*sint*cosf;
Maxwelltime:Nodal_mesh.c:            VV[2][a] = E->sphere.cap[m].V[1][node]*cost*sinf
Maxwelltime:Nodal_mesh.c:                + E->sphere.cap[m].V[2][node]*cosf
Maxwelltime:Nodal_mesh.c:                + E->sphere.cap[m].V[3][node]*sint*sinf;
Maxwelltime:Nodal_mesh.c:            VV[3][a] = -E->sphere.cap[m].V[1][node]*sint
Maxwelltime:Nodal_mesh.c:                + E->sphere.cap[m].V[3][node]*cost;
Maxwelltime:Nodal_mesh.c:    const int dims=E->mesh.nsd;
Maxwelltime:Nodal_mesh.c:    const int ends=enodes[E->mesh.nsd];
Maxwelltime:Nodal_mesh.c:    const int nno=E->lmesh.nno;
Maxwelltime:Nodal_mesh.c:    const int lev=E->mesh.levmax;
Maxwelltime:Nodal_mesh.c:            node = E->ien[m][el].node[a];
Maxwelltime:Nodal_mesh.c:/*            VV[1][a] = E->U[m][E->id[m][node].doff[1]];
Maxwelltime:Nodal_mesh.c:            VV[2][a] = E->U[m][E->id[m][node].doff[2]];
Maxwelltime:Nodal_mesh.c:            VV[3][a] = E->U[m][E->id[m][node].doff[3]]; */
Maxwelltime:Nodal_mesh.c:            VV[1][a] = E->sphere.cap[m].V[1][node];
Maxwelltime:Nodal_mesh.c:            VV[2][a] = E->sphere.cap[m].V[2][node];
Maxwelltime:Nodal_mesh.c:            VV[3][a] = E->sphere.cap[m].V[3][node];  
Maxwelltime:Nodal_mesh.c:            node = E->ien[m][el].node[a];
Maxwelltime:Nodal_mesh.c:            sint = E->SinCos[lev][m][0][node];
Maxwelltime:Nodal_mesh.c:            sinf = E->SinCos[lev][m][1][node];
Maxwelltime:Nodal_mesh.c:            cost = E->SinCos[lev][m][2][node];
Maxwelltime:Nodal_mesh.c:            cosf = E->SinCos[lev][m][3][node];
Maxwelltime:Nodal_mesh.c:            VV[1][a] = E->U[m][E->id[m][node].doff[1]]*cost*cosf
Maxwelltime:Nodal_mesh.c:                - E->U[m][E->id[m][node].doff[2]]*sinf
Maxwelltime:Nodal_mesh.c:                + E->U[m][E->id[m][node].doff[3]]*sint*cosf;
Maxwelltime:Nodal_mesh.c:            VV[2][a] = E->U[m][E->id[m][node].doff[1]]*cost*sinf
Maxwelltime:Nodal_mesh.c:                + E->U[m][E->id[m][node].doff[2]]*cosf
Maxwelltime:Nodal_mesh.c:                + E->U[m][E->id[m][node].doff[3]]*sint*sinf;
Maxwelltime:Nodal_mesh.c:            VV[3][a] = -E->U[m][E->id[m][node].doff[1]]*sint
Maxwelltime:Nodal_mesh.c:                + E->U[m][E->id[m][node].doff[3]]*cost;
Maxwelltime:Nodal_mesh.c:/*            VV[1][a] = E->sphere.cap[m].V[1][node]*cost*cosf
Maxwelltime:Nodal_mesh.c:                - E->sphere.cap[m].V[2][node]*sinf
Maxwelltime:Nodal_mesh.c:                + E->sphere.cap[m].V[3][node]*sint*cosf;
Maxwelltime:Nodal_mesh.c:            VV[2][a] = E->sphere.cap[m].V[1][node]*cost*sinf
Maxwelltime:Nodal_mesh.c:                + E->sphere.cap[m].V[2][node]*cosf
Maxwelltime:Nodal_mesh.c:                + E->sphere.cap[m].V[3][node]*sint*sinf;
Maxwelltime:Nodal_mesh.c:            VV[3][a] = -E->sphere.cap[m].V[1][node]*sint
Maxwelltime:Nodal_mesh.c:                + E->sphere.cap[m].V[3][node]*cost;
Maxwelltime:Nodal_mesh.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Nodal_mesh.c:    for(node=1;node<=E->lmesh.NNO[lev];node++)
Maxwelltime:Nodal_mesh.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Nodal_mesh.c:    for(element=1;element<=E->lmesh.NEL[lev];element++)
Maxwelltime:Nodal_mesh.c:       for(j=1;j<=enodes[E->mesh.nsd];j++)  {
Maxwelltime:Nodal_mesh.c:     	  node = E->IEN[lev][m][element].node[j];
Maxwelltime:Nodal_mesh.c:    	  PN[m][node] += P[m][element] * E->TWW[lev][m][element].node[j] ;
Maxwelltime:Nodal_mesh.c:   (E->exchange_node_f)(E,PN,lev);
Maxwelltime:Nodal_mesh.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Nodal_mesh.c:     for(node=1;node<=E->lmesh.NNO[lev];node++)
Maxwelltime:Nodal_mesh.c:        PN[m][node] *= E->MASS[lev][m][node];
Maxwelltime:Nodal_mesh.c:  const int nsd=E->mesh.nsd;
Maxwelltime:Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Nodal_mesh.c:   for(i=1;i<=E->lmesh.NNO[lev];i++)
Maxwelltime:Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Nodal_mesh.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)   {
Maxwelltime:Nodal_mesh.c:       n = E->IEN[lev][m][e].node[j];
Maxwelltime:Nodal_mesh.c:       VN[m][n] += E->TWW[lev][m][e].node[j] * VE[m][e];
Maxwelltime:Nodal_mesh.c:   (E->exchange_node_f)(E,VN,lev);
Maxwelltime:Nodal_mesh.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Nodal_mesh.c:     for(n=1;n<=E->lmesh.NNO[lev];n++)
Maxwelltime:Nodal_mesh.c:        VN[m][n] *= E->MASS[lev][m][n];
Maxwelltime:Nodal_mesh.c:  const int nsd=E->mesh.nsd;
Maxwelltime:Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Nodal_mesh.c:   for(i=1;i<=E->lmesh.NNO[lev];i++)
Maxwelltime:Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Nodal_mesh.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)   {
Maxwelltime:Nodal_mesh.c:       n = E->IEN[lev][m][e].node[j];
Maxwelltime:Nodal_mesh.c:       VN[m][n] += E->TWW[lev][m][e].node[j] * temp_visc;
Maxwelltime:Nodal_mesh.c:   (E->exchange_node_f)(E,VN,lev);
Maxwelltime:Nodal_mesh.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Nodal_mesh.c:     for(n=1;n<=E->lmesh.NNO[lev];n++)
Maxwelltime:Nodal_mesh.c:        VN[m][n] *= E->MASS[lev][m][n];
Maxwelltime:Nodal_mesh.c:  const int nsd=E->mesh.nsd;
Maxwelltime:Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Nodal_mesh.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Maxwelltime:Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Nodal_mesh.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Maxwelltime:Nodal_mesh.c:	 temp_visc += E->N.vpt[GNVINDEX(j,i)]*VN[m][E->IEN[lev][m][e].node[j]];
Maxwelltime:Nodal_mesh.c:  const int nsd=E->mesh.nsd;
Maxwelltime:Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Nodal_mesh.c:   for(i=1;i<=E->lmesh.NEL[lev];i++)
Maxwelltime:Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Nodal_mesh.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)   {
Maxwelltime:Nodal_mesh.c:  const int nsd=E->mesh.nsd;
Maxwelltime:Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Nodal_mesh.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Maxwelltime:Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Nodal_mesh.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Maxwelltime:Obsolete.c:  const int dims=E->mesh.nsd;
Maxwelltime:Obsolete.c:          x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]*
Maxwelltime:Obsolete.c:                E->N.vpt[GNVINDEX(i,k)];
Maxwelltime:Obsolete.c:            dxda[d][e] += E->X[lev][m][e][E->IEN[lev][m][el].node[i]]
Maxwelltime:Obsolete.c:               * E->Nx.vpt[GNVXINDEX(d-1,i,k)];
Maxwelltime:Obsolete.c:      jacobian = determinant(dxda,E->mesh.nsd);
Maxwelltime:Obsolete.c:                 E->Nx.vpt[GNVXINDEX(e-1,j,k)] *cof[e][d];
Maxwelltime:Obsolete.c:                 E->Nx.vpt[GNVXINDEX(e-1,j,k)] *cof[e][d];
Maxwelltime:Obsolete.c:          x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]
Maxwelltime:Obsolete.c:                 *E->N.ppt[GNPINDEX(i,k)];
Maxwelltime:Obsolete.c:            dxda[d][e] += E->X[lev][m][e][E->IEN[lev][m][el].node[i]]
Maxwelltime:Obsolete.c:                     * E->Nx.ppt[GNPXINDEX(d-1,i,k)];
Maxwelltime:Obsolete.c:      jacobian = determinant(dxda,E->mesh.nsd);
Maxwelltime:Obsolete.c:          cof[d][e]=cofactor(dxda,d,e,E->mesh.nsd);
Maxwelltime:Obsolete.c:                E->Nx.ppt[GNPXINDEX(e-1,j,k)]*cof[e][d];
Maxwelltime:Obsolete.c:                E->Nx.ppt[GNPXINDEX(e-1,j,k)]*cof[e][d];
Maxwelltime:Obsolete.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Obsolete.c:   for(k=1;k<=vpoints[E->mesh.nsd];k++)  {
Maxwelltime:Obsolete.c:            dxda[d][e] += E->NMx.vpt[GNVXINDEX(d-1,i,k)]
Maxwelltime:Obsolete.c:                * E->x[m][e][E->ien[m][el].node[i]];
Maxwelltime:Obsolete.c:        jacobian = sqrt(fabs(determinant(cof,E->mesh.nsd)))/cof[3][3];
Maxwelltime:Obsolete.c:  const int oned = onedvpoints[E->mesh.nsd];
Maxwelltime:Obsolete.c:  const int vpts = vpoints[E->mesh.nsd-1];
Maxwelltime:Obsolete.c:  const int ppts = ppoints[E->mesh.nsd-1];
Maxwelltime:Obsolete.c:  const int ends = enodes[E->mesh.nsd-1];
Maxwelltime:Obsolete.c:  to = E->eco[m][el].centre[1];
Maxwelltime:Obsolete.c:  fo = E->eco[m][el].centre[2];
Maxwelltime:Obsolete.c:  ro = E->eco[m][el].centre[3];
Maxwelltime:Obsolete.c:    node=E->ien[m][el].node[a];
Maxwelltime:Obsolete.c:    xx[1][i] = E->x[m][1][node]*dxdy[1][1]
Maxwelltime:Obsolete.c:      + E->x[m][2][node]*dxdy[1][2]
Maxwelltime:Obsolete.c:      + E->x[m][3][node]*dxdy[1][3];
Maxwelltime:Obsolete.c:    xx[2][i] = E->x[m][1][node]*dxdy[2][1]
Maxwelltime:Obsolete.c:      + E->x[m][2][node]*dxdy[2][2]
Maxwelltime:Obsolete.c:      + E->x[m][3][node]*dxdy[2][3];
Maxwelltime:Obsolete.c:    xx[3][i] = E->x[m][1][node]*dxdy[3][1]
Maxwelltime:Obsolete.c:      + E->x[m][2][node]*dxdy[3][2]
Maxwelltime:Obsolete.c:      + E->x[m][3][node]*dxdy[3][3];
Maxwelltime:Obsolete.c:    for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Obsolete.c:      for(e=1;e<=E->mesh.nsd-1;e++)
Maxwelltime:Obsolete.c:	for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Obsolete.c:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Maxwelltime:Obsolete.c:	    dxda[d][e] += xx[dims[NS][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Maxwelltime:Obsolete.c:	for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Obsolete.c:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Maxwelltime:Obsolete.c:	    dxda[d][e] += xx[dims[NS][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Maxwelltime:Obsolete.c:	for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Obsolete.c:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Maxwelltime:Obsolete.c:	    dxda[d][e] += xx[dims[NS][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Maxwelltime:Obsolete.c:    jacobian = determinant(dxda,E->mesh.nsd-1);
Maxwelltime:Obsolete.c:    for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Obsolete.c:      for(e=1;e<=E->mesh.nsd-1;e++)
Maxwelltime:Obsolete.c:	for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Obsolete.c:	  for(e=1;e<=E->mesh.nsd-1;e++)
Maxwelltime:Obsolete.c:	    dxda[d][e] += xx[dims[NS][e]][k]*E->Mx.ppt[GMPXINDEX(d-1,k,i)];
Maxwelltime:Obsolete.c:	for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Obsolete.c:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Maxwelltime:Obsolete.c:	    node=E->ien[m][el].node[a];
Maxwelltime:Obsolete.c:	    dxda[d][e] += xx[dims[NS][e]][k]*E->Mx.ppt[GMPXINDEX(d-1,k,i)];
Maxwelltime:Obsolete.c:	for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Obsolete.c:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Maxwelltime:Obsolete.c:	    node=E->ien[m][el].node[a];
Maxwelltime:Obsolete.c:	    dxda[d][e] += xx[dims[NS][e]][k]*E->Mx.ppt[GMPXINDEX(d-1,k,i)];
Maxwelltime:Obsolete.c:    jacobian = determinant(dxda,E->mesh.nsd-1);
Maxwelltime:Obsolete.c:  for(i=1;i<=E->mesh.nsd;i++)
Maxwelltime:Obsolete.c:    { for(a=1;a<=enodes[E->mesh.nsd];a++)
Maxwelltime:Obsolete.c:	{ if (E->node[m][E->ien[m][el].node[a]] & type)
Maxwelltime:Obsolete.c:		{  get_elt_g(E,el,elt_g,E->mesh.levmax,m);
Maxwelltime:Obsolete.c:	      p=E->mesh.nsd*(a-1) + i - 1;
Maxwelltime:Obsolete.c:	      for(b=1;b<=pnodes[E->mesh.nsd];b++)
Maxwelltime:Obsolete.c:		  elt_h[q] -= elt_g[p][q] * E->sphere.cap[m].VB[i][E->ien[m][el].node[a]];
Maxwelltime:Obsolete.c:  const int nel=E->lmesh.nel;
Maxwelltime:Obsolete.c:  const int vpts=vpoints[E->mesh.nsd];
Maxwelltime:Obsolete.c:  lev = E->mesh.levmax;
Maxwelltime:Obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Obsolete.c:        EV[el] +=  E->EVI[lev][m][(el-1)*vpts+j];
Maxwelltime:Obsolete.c:    E->sphere.con = (double *)malloc(E->sphere.hindice*sizeof(double));
Maxwelltime:Obsolete.c:    for (ll=0;ll<=E->output.llmax;ll++)
Maxwelltime:Obsolete.c:	    E->sphere.con[E->sphere.hindex[ll][mm]] =
Maxwelltime:Obsolete.c:    E->sphere.tablenplm   = (double **) malloc((E->sphere.nox+1)
Maxwelltime:Obsolete.c:    for (i=1;i<=E->sphere.nox;i++)
Maxwelltime:Obsolete.c:	E->sphere.tablenplm[i]= (double *)malloc(E->sphere.hindice
Maxwelltime:Obsolete.c:    E->sphere.tablencosf  = (double **) malloc((E->sphere.noy+1)
Maxwelltime:Obsolete.c:    E->sphere.tablensinf  = (double **) malloc((E->sphere.noy+1)
Maxwelltime:Obsolete.c:    for (i=1;i<=E->sphere.noy;i++)   {
Maxwelltime:Obsolete.c:	E->sphere.tablencosf[i]= (double *)malloc((E->output.llmax+3)
Maxwelltime:Obsolete.c:	E->sphere.tablensinf[i]= (double *)malloc((E->output.llmax+3)
Maxwelltime:Obsolete.c:    E->sphere.sx[1] = (double *) malloc((E->sphere.nsf+1)*sizeof(double));
Maxwelltime:Obsolete.c:    E->sphere.sx[2] = (double *) malloc((E->sphere.nsf+1)*sizeof(double));
Maxwelltime:Obsolete.c:    dth = M_PI/E->sphere.elx;
Maxwelltime:Obsolete.c:    dfi = 2.0*M_PI/E->sphere.ely;
Maxwelltime:Obsolete.c:    for (j=1;j<=E->sphere.noy;j++)
Maxwelltime:Obsolete.c:	for (i=1;i<=E->sphere.nox;i++) {
Maxwelltime:Obsolete.c:	    node = i+(j-1)*E->sphere.nox;
Maxwelltime:Obsolete.c:	    E->sphere.sx[1][node] = dth*(i-1);
Maxwelltime:Obsolete.c:	    E->sphere.sx[2][node] = dfi*(j-1);
Maxwelltime:Obsolete.c:    for (j=1;j<=E->sphere.nox;j++)  {
Maxwelltime:Obsolete.c:	t=E->sphere.sx[1][j];
Maxwelltime:Obsolete.c:	for (ll=0;ll<=E->output.llmax;ll++)
Maxwelltime:Obsolete.c:		p = E->sphere.hindex[ll][mm];
Maxwelltime:Obsolete.c:		E->sphere.tablenplm[j][p] = modified_plgndr_a(ll,mm,t) ;
Maxwelltime:Obsolete.c:    for (j=1;j<=E->sphere.noy;j++)  {
Maxwelltime:Obsolete.c:	node = 1+(j-1)*E->sphere.nox;
Maxwelltime:Obsolete.c:	f=E->sphere.sx[2][node];
Maxwelltime:Obsolete.c:	for (mm=0;mm<=E->output.llmax;mm++)   {
Maxwelltime:Obsolete.c:	    E->sphere.tablencosf[j][mm] = cos( (double)(mm)*f );
Maxwelltime:Obsolete.c:	    E->sphere.tablensinf[j][mm] = sin( (double)(mm)*f );
Maxwelltime:Obsolete.c:    for (i=1;i<=E->sphere.nox;i++)
Maxwelltime:Obsolete.c:	for (j=1;j<=E->sphere.noy;j++)   {
Maxwelltime:Obsolete.c:	    node = i+(j-1)*E->sphere.nox;
Maxwelltime:Obsolete.c:	    E->sphere.int_cap[node]=0;
Maxwelltime:Obsolete.c:	    E->sphere.int_ele[node]=0;
Maxwelltime:Obsolete.c:    for (i=1;i<=E->sphere.nox;i++)
Maxwelltime:Obsolete.c:	for (j=1;j<=E->sphere.noy;j++)   {
Maxwelltime:Obsolete.c:	    node = i+(j-1)*E->sphere.nox;
Maxwelltime:Obsolete.c:	    t = E->sphere.sx[1][node];
Maxwelltime:Obsolete.c:	    f = E->sphere.sx[2][node];
Maxwelltime:Obsolete.c:	    fprintf(E->fp,"mmm0=%d\n",node);
Maxwelltime:Obsolete.c:	    fprintf(E->fp,"mmm=%d\n",m);
Maxwelltime:Obsolete.c:		    fprintf(stderr,"!!! Processor %d cannot find the right element in cap %d\n",E->parallel.me,m);
Maxwelltime:Obsolete.c:		E->sphere.int_cap[node]=m;
Maxwelltime:Obsolete.c:		E->sphere.int_ele[node]=el;
Maxwelltime:Obsolete.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Obsolete.c:	ia[2] = E->lmesh.noz*E->lmesh.nox-E->lmesh.noz+1;
Maxwelltime:Obsolete.c:	ia[3] = E->lmesh.nno-E->lmesh.noz+1;
Maxwelltime:Obsolete.c:	ia[4] = ia[3]-E->lmesh.noz*(E->lmesh.nox-1);
Maxwelltime:Obsolete.c:	    xx[1] = E->x[m][1][ia[i]]/E->sx[m][3][ia[1]];
Maxwelltime:Obsolete.c:	    xx[2] = E->x[m][2][ia[i]]/E->sx[m][3][ia[1]];
Maxwelltime:Obsolete.c:	    xx[3] = E->x[m][3][ia[i]]/E->sx[m][3][ia[1]];
Maxwelltime:Obsolete.c:	    angle1[i]=E->sphere.angle[m][i];
Maxwelltime:Obsolete.c:	if ( fabs ((area1-E->sphere.area[m])/E->sphere.area[m]) <e_7 ) {
Maxwelltime:Obsolete.c:    level=E->mesh.levmin;
Maxwelltime:Obsolete.c:    for (es=1;es<=E->lmesh.SNEL[level];es++)              {
Maxwelltime:Obsolete.c:	el = (es-1)*E->lmesh.ELZ[level]+1;
Maxwelltime:Obsolete.c:	area = E->sphere.area1[level][m][es];
Maxwelltime:Obsolete.c:	    for (lev=E->mesh.levmin;lev<E->mesh.levmax;lev++)  {
Maxwelltime:Obsolete.c:		    el_plus = E->EL[lev][m][el].sub[j];
Maxwelltime:Obsolete.c:		    es_plus = (el_plus-1)/E->lmesh.ELZ[lev_plus]+1;
Maxwelltime:Obsolete.c:		    area = E->sphere.area1[lev_plus][m][es_plus];
Maxwelltime:Obsolete.c:    es = (el-1)/E->lmesh.elz+1;
Maxwelltime:Obsolete.c:    to = E->eco[m][el].centre[1];
Maxwelltime:Obsolete.c:    fo = E->eco[m][el].centre[2];
Maxwelltime:Obsolete.c:	node = E->ien[m][el].node[i];
Maxwelltime:Obsolete.c:	snode = E->sien[m][es].node[i];
Maxwelltime:Obsolete.c:	for (j=1;j<=E->mesh.nsd;j++)
Maxwelltime:Obsolete.c:	    yy[j][i] = E->x[m][1][node]*dxdy[j][1]
Maxwelltime:Obsolete.c:                + E->x[m][2][node]*dxdy[j][2]
Maxwelltime:Obsolete.c:                + E->x[m][3][node]*dxdy[j][3];
Maxwelltime:Obsolete.c:    for (j=1;j<=E->mesh.nsd;j++)
Maxwelltime:Obsolete.c:    /*if(fabs(xx1)>1.5 || fabs(yy1)>1.5)fprintf(E->fp_out,"ME= %d %d %d %g %g %g %g %g %g %g\n",ne,m,es,t[1],t[2],t[3],t[4],ta,xx1,yy1);
Maxwelltime:Obsolete.c:    for (i=1;i<=E->sphere.nox;i++)
Maxwelltime:Obsolete.c:	for (j=1;j<=E->sphere.noy;j++)   {
Maxwelltime:Obsolete.c:	    node = i+(j-1)*E->sphere.nox;
Maxwelltime:Obsolete.c:	    m = E->sphere.int_cap[node];
Maxwelltime:Obsolete.c:	    el = E->sphere.int_ele[node];
Maxwelltime:Obsolete.c:		t = E->sphere.sx[1][node];
Maxwelltime:Obsolete.c:		f = E->sphere.sx[2][node];
Maxwelltime:Obsolete.c:		x[1] = E->sx[1][3][1]*sin(t)*cos(f);
Maxwelltime:Obsolete.c:		x[2] = E->sx[1][3][1]*sin(t)*sin(f);
Maxwelltime:Obsolete.c:		x[3] = E->sx[1][3][1]*cos(t);
Maxwelltime:Obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Maxwelltime:Obsolete.c:    for(i=1;i<=E->lmesh.nno;i++)  {
Maxwelltime:Obsolete.c:      e_pressure = (E->sphere.ro-E->sx[m][3][i])-E->viscosity.z410-
Maxwelltime:Obsolete.c:            E->control.clapeyron410*(E->T[m][i]-E->control.transT410);
Maxwelltime:Obsolete.c:      B[m][i] = pt5*(one+tanh(E->control.width410*e_pressure));
Maxwelltime:Obsolete.c:    for (k=1;k<=E->lmesh.noy;k++)
Maxwelltime:Obsolete.c:      for (j=1;j<=E->lmesh.nox;j++)  {
Maxwelltime:Obsolete.c:        for (i=1;i<E->lmesh.noz;i++)   {
Maxwelltime:Obsolete.c:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Maxwelltime:Obsolete.c:            B_b[m][ns]=(E->sx[m][3][n+1]-E->sx[m][3][n])*(pt5-B[m][n])/(B[m][n+1]-B[m][n])+E->sx[m][3][n];
Maxwelltime:Obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Maxwelltime:Obsolete.c:    for(i=1;i<=E->lmesh.nno;i++)  {
Maxwelltime:Obsolete.c:      e_pressure = (E->sphere.ro-E->sx[m][3][i])-E->viscosity.zlm-
Maxwelltime:Obsolete.c:            E->control.clapeyron670*(E->T[m][i]-E->control.transT670);
Maxwelltime:Obsolete.c:      B[m][i] = pt5*(one+tanh(E->control.width670*e_pressure));
Maxwelltime:Obsolete.c:    for (k=1;k<=E->lmesh.noy;k++)
Maxwelltime:Obsolete.c:      for (j=1;j<=E->lmesh.nox;j++)  {
Maxwelltime:Obsolete.c:        for (i=1;i<E->lmesh.noz;i++)   {
Maxwelltime:Obsolete.c:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Maxwelltime:Obsolete.c:            B_b[m][ns]=(E->sx[m][3][n+1]-E->sx[m][3][n])*(pt5-B[m][n])/(B[m][n+1]-B[m][n])+E->sx[m][3][n];
Maxwelltime:Obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Maxwelltime:Obsolete.c:    for(i=1;i<=E->lmesh.nno;i++)  {
Maxwelltime:Obsolete.c:      e_pressure = (E->sphere.ro-E->sx[m][3][i])-E->viscosity.zcmb-
Maxwelltime:Obsolete.c:            E->control.clapeyroncmb*(E->T[m][i]-E->control.transTcmb);
Maxwelltime:Obsolete.c:      B[m][i] = pt5*(one+tanh(E->control.widthcmb*e_pressure));
Maxwelltime:Obsolete.c:    for (k=1;k<=E->lmesh.noy;k++)
Maxwelltime:Obsolete.c:      for (j=1;j<=E->lmesh.nox;j++)  {
Maxwelltime:Obsolete.c:        for (i=1;i<E->lmesh.noz;i++)   {
Maxwelltime:Obsolete.c:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Maxwelltime:Obsolete.c:            B_b[m][ns]=(E->sx[m][3][n+1]-E->sx[m][3][n])*(pt5-B[m][n])/(B[m][n+1]-B[m][n])+E->sx[m][3][n];
Maxwelltime:Obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Obsolete.c:    for(p=1;p<=E->lmesh.NEL[lev];p++)
Maxwelltime:Obsolete.c:   weight=1.0/((double)enodes[E->mesh.nsd]) ;
Maxwelltime:Obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Obsolete.c:    for(p=1;p<=E->lmesh.NEL[lev];p++)
Maxwelltime:Obsolete.c:      for(j=1;j<=enodes[E->mesh.nsd];j++)
Maxwelltime:Obsolete.c:        P[m][p] += PN[m][E->IEN[lev][m][p].node[j]] * weight;
Maxwelltime:Obsolete.c:   const int nsd=E->mesh.nsd;
Maxwelltime:Obsolete.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Obsolete.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Maxwelltime:Obsolete.c:          VE[m][(e-1)*vpts + i] += VN[m][E->IEN[lev][m][e].node[j]]*E->N.vpt[GNVINDEX(j,i)];
Maxwelltime:Obsolete.c:   const int nsd=E->mesh.nsd;
Maxwelltime:Obsolete.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Obsolete.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Maxwelltime:Obsolete.c:          VE[m][(e-1)*vpts + i] += log(VN[m][E->IEN[lev][m][e].node[j]]) *  E->N.vpt[GNVINDEX(j,i)];
Maxwelltime:Obsolete.c:    if(!input_string(input_token,filename,"initialize",E->parallel.me)) {
Maxwelltime:Obsolete.c:	fprintf(E->fp,"No previous %s information found in input file\n",name);fflush(E->fp);
Maxwelltime:Obsolete.c:    fprintf(E->fp,"Previous %s information is in file %s\n",name,filename);fflush(E->fp);
Maxwelltime:Obsolete.c:	fprintf(E->fp,"Unable to open the required file `%s' (this is fatal)",filename);
Maxwelltime:Obsolete.c:	fflush(E->fp);
Maxwelltime:Obsolete.c:	fprintf(E->fp,"File %s is not in the correct format\n",filename);fflush(E->fp);
Maxwelltime:Obsolete.c:	fprintf(E->fp,"Unable to deciphre the columns in the input file");fflush(E->fp);
Maxwelltime:Obsolete.c:	fprintf(E->fp,"\t%s (%s) found in column %d\n",name,abbr,column);fflush(E->fp);
Maxwelltime:Obsolete.c:	fprintf(E->fp,"\t%s (%s) not found in file: %s\n",name,abbr,filename);fflush(E->fp);
Maxwelltime:Obsolete.c:    if(((3!= E->mesh.nsd) && (fnodesy !=1)) || ((3==E->mesh.nsd) && (1==fnodesy))) {
Maxwelltime:Obsolete.c:	fprintf(E->fp,"Input data for file `%s'  is of inappropriate dimension (not %dD)\n",filename,E->mesh.nsd);fflush(E->fp);
Maxwelltime:Obsolete.c:    if(fnodesx != E->lmesh.nox || fnodesz != E->lmesh.noz || fnodesy != E->lmesh.noy) {
Maxwelltime:Obsolete.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Obsolete.c:  n = loc_mat_size[E->mesh.nsd];
Maxwelltime:Obsolete.c:    const int dims=E->mesh.nsd;
Maxwelltime:Obsolete.c:    const int n=loc_mat_size[E->mesh.nsd];
Maxwelltime:Obsolete.c:    const int neq=E->lmesh.NEQ[level];
Maxwelltime:Obsolete.c:    const int num_nodes=E->lmesh.NNO[level];
Maxwelltime:Obsolete.c:    const int nox=E->lmesh.NOX[level];
Maxwelltime:Obsolete.c:    const int noz=E->lmesh.NOY[level];
Maxwelltime:Obsolete.c:    const int noy=E->lmesh.NOZ[level];
Maxwelltime:Obsolete.c:    gneq = E->mesh.NEQ[level];
Maxwelltime:Obsolete.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Obsolete.c:      r1[m] = (double *)malloc(E->lmesh.neq*sizeof(double));
Maxwelltime:Obsolete.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Obsolete.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Obsolete.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Obsolete.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Obsolete.c: 	for(i=1;i<=E->lmesh.NNO[level];i++)  {
Maxwelltime:Obsolete.c:	    eqn1=E->ID[level][m][i].doff[1];
Maxwelltime:Obsolete.c:	    eqn2=E->ID[level][m][i].doff[2];
Maxwelltime:Obsolete.c:	    eqn3=E->ID[level][m][i].doff[3];
Maxwelltime:Obsolete.c:            d0[m][eqn1] += r1[m][eqn1]*E->BI[level][m][eqn1];
Maxwelltime:Obsolete.c:            d0[m][eqn2] += r1[m][eqn2]*E->BI[level][m][eqn2];
Maxwelltime:Obsolete.c:            d0[m][eqn3] += r1[m][eqn3]*E->BI[level][m][eqn3];
Maxwelltime:Obsolete.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Obsolete.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Obsolete.c: 	for(i=1;i<=E->lmesh.NNO[level];i++)  {
Maxwelltime:Obsolete.c:	    eqn1=E->ID[level][m][i].doff[1];
Maxwelltime:Obsolete.c:	    eqn2=E->ID[level][m][i].doff[2];
Maxwelltime:Obsolete.c:	    eqn3=E->ID[level][m][i].doff[3];
Maxwelltime:Obsolete.c:            C=E->Node_map[level][m]+(i-1)*max_eqn;
Maxwelltime:Obsolete.c:	    B1=E->Eqn_k1[level][m]+(i-1)*max_eqn;
Maxwelltime:Obsolete.c:	    B2=E->Eqn_k2[level][m]+(i-1)*max_eqn;
Maxwelltime:Obsolete.c: 	    B3=E->Eqn_k3[level][m]+(i-1)*max_eqn;
Maxwelltime:Obsolete.c:      (E->solver.exchange_id_d)(E, Ad, level);
Maxwelltime:Obsolete.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Obsolete.c:   if(E->parallel.me==0)fprintf(stderr,"residuall =%.5e for %d\n",residual,count);
Maxwelltime:Obsolete.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Output.c:    int m = E->parallel.me;
Maxwelltime:Output.c:    input_string("output_format", E->output.format, "ascii",m);
Maxwelltime:Output.c:    input_string("output_optional", E->output.optional, "surf,botm,tracer",m);
Maxwelltime:Output.c:    E->output.gzdir.vtk_io = 0;
Maxwelltime:Output.c:    E->output.gzdir.rnr = 0;
Maxwelltime:Output.c:    if(strcmp(E->output.format, "ascii-gz") == 0){
Maxwelltime:Output.c:      input_int("gzdir_vtkio",&(E->output.gzdir.vtk_io),"0",m);
Maxwelltime:Output.c:      input_boolean("gzdir_rnr",&(E->output.gzdir.rnr),"off",m);
Maxwelltime:Output.c:      E->output.gzdir.vtk_base_init = 0;
Maxwelltime:Output.c:      E->output.gzdir.vtk_base_save = 1; /* should we save the basis vectors? (memory!) */
Maxwelltime:Output.c:      //      E->output.gzdir.vtk_io,E->output.gzdir.vtk_base_save);
Maxwelltime:Output.c:    if (E->output.coord_bin)
Maxwelltime:Output.c:  if (E->output.geoid)		/* this needs to be called after the
Maxwelltime:Output.c:  if (E->output.stress){
Maxwelltime:Output.c:  if (E->output.pressure)
Maxwelltime:Output.c:  if (E->output.horiz_avg)
Maxwelltime:Output.c:  if (E->output.seismic)
Maxwelltime:Output.c:  if(E->output.tracer && E->control.tracer)
Maxwelltime:Output.c:  if (E->output.comp_nd && E->composition.on)
Maxwelltime:Output.c:  if (E->output.comp_el && E->composition.on)
Maxwelltime:Output.c:  if(E->output.heating && E->control.disptn_number != 0)
Maxwelltime:Output.c:  sprintf(output_file,"%s.coord.%d",E->control.data_file,E->parallel.me);
Maxwelltime:Output.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Maxwelltime:Output.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Maxwelltime:Output.c:    for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Output.c:      fprintf(fp1,"%.6e %.6e %.6e\n",E->sx[j][1][i],E->sx[j][2][i],E->sx[j][3][i]);
Maxwelltime:Output.c:    const int nox = E->lmesh.nox;
Maxwelltime:Output.c:    const int noy = E->lmesh.noy;
Maxwelltime:Output.c:    const int noz = E->lmesh.noz;
Maxwelltime:Output.c:    buffer[0] = E->sx[j][3][1];
Maxwelltime:Output.c:    buffer[1] = E->sx[j][3][noz];
Maxwelltime:Output.c:    buffer[2] = E->sx[j][1][corner_nodes[0]];
Maxwelltime:Output.c:    buffer[3] = E->sx[j][2][corner_nodes[0]];
Maxwelltime:Output.c:    buffer[4] = E->sx[j][1][corner_nodes[1]];
Maxwelltime:Output.c:    buffer[5] = E->sx[j][2][corner_nodes[1]];
Maxwelltime:Output.c:    buffer[6] = E->sx[j][1][corner_nodes[2]];
Maxwelltime:Output.c:    buffer[7] = E->sx[j][2][corner_nodes[2]];
Maxwelltime:Output.c:    buffer[8] = E->sx[j][1][corner_nodes[3]];
Maxwelltime:Output.c:    buffer[9] = E->sx[j][2][corner_nodes[3]];
Maxwelltime:Output.c:    if(E->parallel.me == 0) {
Maxwelltime:Output.c:        sprintf(output_file,"%s.domain",E->control.data_file);
Maxwelltime:Output.c:        header[0] = E->parallel.nproc;
Maxwelltime:Output.c:        for(rank=1; rank<E->parallel.nproc; rank++) {
Maxwelltime:Output.c:            MPI_Recv(buffer, ncolumns, MPI_DOUBLE, rank, tag, E->parallel.world, &status);
Maxwelltime:Output.c:        MPI_Send(buffer, ncolumns, MPI_DOUBLE, receiver, tag, E->parallel.world);
Maxwelltime:Output.c:  sprintf(output_file,"%s.coord_bin.%d",E->control.data_file,E->parallel.me);
Maxwelltime:Output.c:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Output.c:      header[0] = E->lmesh.nox;
Maxwelltime:Output.c:      header[1] = E->lmesh.noy;
Maxwelltime:Output.c:      header[2] = E->lmesh.noz;
Maxwelltime:Output.c:      fwrite(&(E->x[j][1][1]), sizeof(double), E->lmesh.nno, fp1);
Maxwelltime:Output.c:      fwrite(&(E->x[j][2][1]), sizeof(double), E->lmesh.nno, fp1);
Maxwelltime:Output.c:      fwrite(&(E->x[j][3][1]), sizeof(double), E->lmesh.nno, fp1);
Maxwelltime:Output.c:  int lev = E->mesh.levmax;
Maxwelltime:Output.c:  sprintf(output_file,"%s.visc.%d.%d", E->control.data_file,
Maxwelltime:Output.c:          E->parallel.me, cycles);
Maxwelltime:Output.c:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Output.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Maxwelltime:Output.c:    for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Output.c:      fprintf(fp1,"%.4e\n",E->VI[lev][j][i]);
Maxwelltime:Output.c:  sprintf(output_file,"%s.velo.%d.%d", E->control.data_file,
Maxwelltime:Output.c:          E->parallel.me, cycles);
Maxwelltime:Output.c:  fprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Maxwelltime:Output.c:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Output.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Maxwelltime:Output.c:    for(i=1;i<=E->lmesh.nno;i++) {
Maxwelltime:Output.c:        fprintf(fp1,"%.6e %.6e %.6e %.6e\n",E->sphere.cap[j].V[1][i],E->sphere.cap[j].V[2][i],E->sphere.cap[j].V[3][i],E->T[j][i]);
Maxwelltime:Output.c:  if((E->output.write_q_files == 0) || (cycles == 0) ||
Maxwelltime:Output.c:     (cycles % E->output.write_q_files)!=0)
Maxwelltime:Output.c:  if(E->control.use_cbf_topo){
Maxwelltime:Output.c:    get_CBF_topo(E,E->slice.tpg,E->slice.tpgb);
Maxwelltime:Output.c:    get_STD_topo(E,E->slice.tpg,E->slice.tpgb,E->slice.divg,E->slice.vort,cycles);
Maxwelltime:Output.c:  if (E->output.surf && (E->parallel.me_loc[3]==E->parallel.nprocz-1)) {
Maxwelltime:Output.c:    sprintf(output_file,"%s.surf.%d.%d", E->control.data_file,
Maxwelltime:Output.c:            E->parallel.me, cycles);
Maxwelltime:Output.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Output.c:        if(E->control.pseudo_free_surf)
Maxwelltime:Output.c:            topo = E->slice.freesurf[j];
Maxwelltime:Output.c:            topo = E->slice.tpg[j];
Maxwelltime:Output.c:        fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Maxwelltime:Output.c:        for(i=1;i<=E->lmesh.nsf;i++)   {
Maxwelltime:Output.c:            s = i*E->lmesh.noz;
Maxwelltime:Output.c:		    topo[i],E->slice.shflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Maxwelltime:Output.c:  if (E->output.botm && (E->parallel.me_loc[3]==0)) {
Maxwelltime:Output.c:    sprintf(output_file,"%s.botm.%d.%d", E->control.data_file,
Maxwelltime:Output.c:            E->parallel.me, cycles);
Maxwelltime:Output.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Output.c:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Maxwelltime:Output.c:      for(i=1;i<=E->lmesh.nsf;i++)  {
Maxwelltime:Output.c:        s = (i-1)*E->lmesh.noz + 1;
Maxwelltime:Output.c:		E->slice.tpgb[j][i],E->slice.bhflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Maxwelltime:Output.c:    if (E->parallel.me == (E->parallel.nprocz-1))  {
Maxwelltime:Output.c:        sprintf(output_file, "%s.geoid.%d.%d", E->control.data_file,
Maxwelltime:Output.c:                E->parallel.me, cycles);
Maxwelltime:Output.c:        fprintf(fp1, "%d %d %.5e\n", cycles, E->output.llmax,
Maxwelltime:Output.c:                E->monitor.elapsed_time);
Maxwelltime:Output.c:        for (ll=0; ll<=E->output.llmax; ll++)
Maxwelltime:Output.c:                p = E->sphere.hindex[ll][mm];
Maxwelltime:Output.c:                        E->sphere.harm_geoid[0][p],
Maxwelltime:Output.c:                        E->sphere.harm_geoid[1][p],
Maxwelltime:Output.c:                        E->sphere.harm_geoid_from_tpgt[0][p],
Maxwelltime:Output.c:                        E->sphere.harm_geoid_from_tpgt[1][p],
Maxwelltime:Output.c:                        E->sphere.harm_geoid_from_bncy[0][p],
Maxwelltime:Output.c:                        E->sphere.harm_geoid_from_bncy[1][p]);
Maxwelltime:Output.c:  if(E->control.use_cbf_topo)	{/* for CBF topo, stress will not have been computed */
Maxwelltime:Output.c:  sprintf(output_file,"%s.stress.%d.%d", E->control.data_file,
Maxwelltime:Output.c:          E->parallel.me, cycles);
Maxwelltime:Output.c:  fprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Maxwelltime:Output.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Output.c:    fprintf(fp1,"%3d %7d\n",m,E->lmesh.nno);
Maxwelltime:Output.c:    for (node=1;node<=E->lmesh.nno;node++)
Maxwelltime:Output.c:              E->gstress[m][(node-1)*6+1],
Maxwelltime:Output.c:              E->gstress[m][(node-1)*6+2],
Maxwelltime:Output.c:              E->gstress[m][(node-1)*6+3],
Maxwelltime:Output.c:              E->gstress[m][(node-1)*6+4],
Maxwelltime:Output.c:              E->gstress[m][(node-1)*6+5],
Maxwelltime:Output.c:              E->gstress[m][(node-1)*6+6]);
Maxwelltime:Output.c:  if (E->parallel.me<E->parallel.nprocz)  {
Maxwelltime:Output.c:    sprintf(output_file,"%s.horiz_avg.%d.%d", E->control.data_file,
Maxwelltime:Output.c:            E->parallel.me, cycles);
Maxwelltime:Output.c:    for(j=1;j<=E->lmesh.noz;j++)  {
Maxwelltime:Output.c:        fprintf(fp1,"%.4e %.4e %.4e %.4e",E->sx[1][3][j],
Maxwelltime:Output.c:		E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j]);
Maxwelltime:Output.c:        if (E->composition.on) {
Maxwelltime:Output.c:            for(n=0; n<E->composition.ncomp; n++)
Maxwelltime:Output.c:                fprintf(fp1," %.4e", E->Have.C[n][j]);
Maxwelltime:Output.c:    const int len = E->lmesh.nno;
Maxwelltime:Output.c:    sprintf(output_file,"%s.seismic.%d.%d", E->control.data_file, E->parallel.me, cycles);
Maxwelltime:Output.c:    fwrite(rho, sizeof(double), E->lmesh.nno, fp);
Maxwelltime:Output.c:    fwrite(vp, sizeof(double), E->lmesh.nno, fp);
Maxwelltime:Output.c:    fwrite(vs, sizeof(double), E->lmesh.nno, fp);
Maxwelltime:Output.c:    sprintf(output_file,"%s.dv.%d.%d", E->control.data_file, E->parallel.me, cycles);
Maxwelltime:Output.c:    fprintf(fp, "%d %d %.5e\n", cycles, E->lmesh.nno, E->monitor.elapsed_time);
Maxwelltime:Output.c:    for(i=0; i<E->lmesh.nno; i++) {
Maxwelltime:Output.c:        int nz = (i % E->lmesh.noz) + 1;
Maxwelltime:Output.c:        get_prem(E->sx[1][3][nz], &vpr, &vsr, &rhor);
Maxwelltime:Output.c:  sprintf(output_file,"%s.mat.%d", E->control.data_file,E->parallel.me);
Maxwelltime:Output.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Output.c:    for(el=1;el<=E->lmesh.nel;el++)
Maxwelltime:Output.c:      fprintf(fp,"%d %d %f\n", el,E->mat[m][el],E->VIP[m][el]);
Maxwelltime:Output.c:  sprintf(output_file,"%s.pressure.%d.%d", E->control.data_file,
Maxwelltime:Output.c:          E->parallel.me, cycles);
Maxwelltime:Output.c:  fprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Maxwelltime:Output.c:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Output.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Maxwelltime:Output.c:    for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Output.c:      fprintf(fp1,"%.6e\n",E->NP[j][i]);
Maxwelltime:Output.c:  sprintf(output_file,"%s.tracer.%d.%d", E->control.data_file,
Maxwelltime:Output.c:          E->parallel.me, cycles);
Maxwelltime:Output.c:  ncolumns = 3 + E->trace.number_of_extra_quantities;
Maxwelltime:Output.c:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Output.c:      fprintf(fp1,"%d %d %d %.5e\n", cycles, E->trace.ntracers[j],
Maxwelltime:Output.c:              ncolumns, E->monitor.elapsed_time);
Maxwelltime:Output.c:      for(n=1;n<=E->trace.ntracers[j];n++) {
Maxwelltime:Output.c:                  E->trace.basicq[j][0][n],
Maxwelltime:Output.c:                  E->trace.basicq[j][1][n],
Maxwelltime:Output.c:                  E->trace.basicq[j][2][n]);
Maxwelltime:Output.c:          for (i=0; i<E->trace.number_of_extra_quantities; i++) {
Maxwelltime:Output.c:              fprintf(fp1," %.12e", E->trace.extraq[j][i][n]);
Maxwelltime:Output.c:    sprintf(output_file,"%s.comp_nd.%d.%d", E->control.data_file,
Maxwelltime:Output.c:            E->parallel.me, cycles);
Maxwelltime:Output.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Output.c:                j, E->lmesh.nel,
Maxwelltime:Output.c:                E->monitor.elapsed_time, E->composition.ncomp);
Maxwelltime:Output.c:        for(i=0;i<E->composition.ncomp;i++) {
Maxwelltime:Output.c:                    E->composition.initial_bulk_composition[i],
Maxwelltime:Output.c:                    E->composition.bulk_composition[i]);
Maxwelltime:Output.c:        for(i=1;i<=E->lmesh.nno;i++) {
Maxwelltime:Output.c:            for(k=0;k<E->composition.ncomp;k++) {
Maxwelltime:Output.c:                fprintf(fp1,"%.6e ",E->composition.comp_node[j][k][i]);
Maxwelltime:Output.c:    sprintf(output_file,"%s.comp_el.%d.%d", E->control.data_file,
Maxwelltime:Output.c:            E->parallel.me, cycles);
Maxwelltime:Output.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Output.c:                j, E->lmesh.nel,
Maxwelltime:Output.c:                E->monitor.elapsed_time, E->composition.ncomp);
Maxwelltime:Output.c:        for(i=0;i<E->composition.ncomp;i++) {
Maxwelltime:Output.c:                    E->composition.initial_bulk_composition[i],
Maxwelltime:Output.c:                    E->composition.bulk_composition[i]);
Maxwelltime:Output.c:        for(i=1;i<=E->lmesh.nel;i++) {
Maxwelltime:Output.c:            for(k=0;k<E->composition.ncomp;k++) {
Maxwelltime:Output.c:			E->composition.comp_el[j][k][i]);
Maxwelltime:Output.c:    sprintf(output_file,"%s.heating.%d.%d", E->control.data_file,
Maxwelltime:Output.c:            E->parallel.me, cycles);
Maxwelltime:Output.c:    fprintf(fp1,"%.5e\n",E->monitor.elapsed_time);
Maxwelltime:Output.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Output.c:        fprintf(fp1,"%3d %7d\n", j, E->lmesh.nel);
Maxwelltime:Output.c:        for(e=1; e<=E->lmesh.nel; e++)
Maxwelltime:Output.c:            fprintf(fp1, "%.4e %.4e %.4e\n", E->heating_adi[j][e],
Maxwelltime:Output.c:                    E->heating_visc[j][e], E->heating_latent[j][e]);
Maxwelltime:Output.c:  if (E->parallel.me == 0) {
Maxwelltime:Output.c:    fprintf(E->fptime,"%d %.4e %.4e %.4e %.4e\n",
Maxwelltime:Output.c:            E->monitor.elapsed_time,
Maxwelltime:Output.c:            E->advection.timestep,
Maxwelltime:Output.c:            current_time - E->monitor.cpu_time_at_start,
Maxwelltime:Output.c:            current_time - E->monitor.cpu_time_at_last_cycle);
Maxwelltime:Output.c:    fflush(E->fptime);
Maxwelltime:Output.c:  E->monitor.cpu_time_at_last_cycle = current_time;
Maxwelltime:Output.c: if (E->parallel.me==proc_loc)  {
Maxwelltime:Output.c:     sprintf(output_file,"%s.%s_sharm.%d",E->control.data_file,filen,ii);
Maxwelltime:Output.c:     fprintf(fp1,"%d %.5e %s\n",ii,E->monitor.elapsed_time,filen);
Maxwelltime:Output.c:     for (ll=0;ll<=E->output.llmax;ll++)
Maxwelltime:Output.c:        i = E->sphere.hindex[ll][mm];
Maxwelltime:Output_gzdir.c:    if (E->output.coord_bin)
Maxwelltime:Output_gzdir.c:  snprintf(output_dir,255,"%s/%d",E->control.data_dir,out_cycles);
Maxwelltime:Output_gzdir.c:  if (E->output.geoid)
Maxwelltime:Output_gzdir.c:  if (E->output.stress){
Maxwelltime:Output_gzdir.c:  if (E->output.pressure)
Maxwelltime:Output_gzdir.c:  if (E->output.horiz_avg)
Maxwelltime:Output_gzdir.c:  if(E->control.tracer){
Maxwelltime:Output_gzdir.c:    if(E->output.tracer ||
Maxwelltime:Output_gzdir.c:       (out_cycles == E->advection.max_timesteps))
Maxwelltime:Output_gzdir.c:  if (E->output.comp_nd && E->composition.on)
Maxwelltime:Output_gzdir.c:  if (E->output.comp_el && E->composition.on)
Maxwelltime:Output_gzdir.c:  if(E->output.heating && E->control.disptn_number != 0)
Maxwelltime:Output_gzdir.c:  if((E->output.gzdir.vtk_io == 2)||(E->output.gzdir.vtk_io == 3)){
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2) /* serial */
Maxwelltime:Output_gzdir.c:    E->output.gzdir.vtk_ocount = -1;
Maxwelltime:Output_gzdir.c:    if(E->parallel.me == 0){
Maxwelltime:Output_gzdir.c:      snprintf(message,255,"%s/vtk_time.log",E->control.data_dir);
Maxwelltime:Output_gzdir.c:      E->output.gzdir.vtk_fp = output_open(message,"w");
Maxwelltime:Output_gzdir.c:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Maxwelltime:Output_gzdir.c:      if(E->output.gzdir.vtk_io == 2) /* serial */
Maxwelltime:Output_gzdir.c:		E->lmesh.nno * E->parallel.nproc *
Maxwelltime:Output_gzdir.c:		E->sphere.caps_per_proc);
Maxwelltime:Output_gzdir.c:		E->lmesh.nno * E->sphere.caps_per_proc);
Maxwelltime:Output_gzdir.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Maxwelltime:Output_gzdir.c:    for(j=1;j <= E->sphere.caps_per_proc;j++)     {
Maxwelltime:Output_gzdir.c:      for(i=1;i <= E->lmesh.nno;i++) {
Maxwelltime:Output_gzdir.c:	x[0]=E->x[j][1][i];x[1]=E->x[j][2][i];x[2]=E->x[j][3][i];
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2){ /* serial output, close and have
Maxwelltime:Output_gzdir.c:      if(E->parallel.me <  E->parallel.nproc-1){/* send to next if not last*/
Maxwelltime:Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Maxwelltime:Output_gzdir.c:    if((E->output.gzdir.vtk_io == 3) || (E->parallel.me == 0)){ /* in first CPU, or parallel output */
Maxwelltime:Output_gzdir.c:      if(E->output.gzdir.vtk_io == 2){ /* need to reopen, serial */
Maxwelltime:Output_gzdir.c:	j = E->parallel.nproc * E->lmesh.nel *
Maxwelltime:Output_gzdir.c:	  E->sphere.caps_per_proc; /* total number of elements */
Maxwelltime:Output_gzdir.c:	j = E->lmesh.nel * E->sphere.caps_per_proc;
Maxwelltime:Output_gzdir.c:	      j,j*(enodes[E->mesh.nsd]+1));
Maxwelltime:Output_gzdir.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Maxwelltime:Output_gzdir.c:    if(enodes[E->mesh.nsd] != 8)
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2){ /* serial, global node numbers */
Maxwelltime:Output_gzdir.c:      offset = E->lmesh.nno * E->parallel.me - 1;
Maxwelltime:Output_gzdir.c:    ix[0] = enodes[E->mesh.nsd];
Maxwelltime:Output_gzdir.c:    for(j=1;j <= E->sphere.caps_per_proc;j++)     {
Maxwelltime:Output_gzdir.c:      for(i=1;i <= E->lmesh.nel;i++) {
Maxwelltime:Output_gzdir.c:	ix[1]= E->ien[j][i].node[1]+offset;ix[2] = E->ien[j][i].node[2]+offset;
Maxwelltime:Output_gzdir.c:	ix[3]= E->ien[j][i].node[3]+offset;ix[4] = E->ien[j][i].node[4]+offset;
Maxwelltime:Output_gzdir.c:	ix[5]= E->ien[j][i].node[5]+offset;ix[6] = E->ien[j][i].node[6]+offset;
Maxwelltime:Output_gzdir.c:	ix[7]= E->ien[j][i].node[7]+offset;ix[8] = E->ien[j][i].node[8]+offset;
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2){ /* serial IO */
Maxwelltime:Output_gzdir.c:      if(E->parallel.me <  E->parallel.nproc-1)
Maxwelltime:Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Maxwelltime:Output_gzdir.c:    if((E->output.gzdir.vtk_io==3) || (E->parallel.me == 0) ){
Maxwelltime:Output_gzdir.c:      if(E->output.gzdir.vtk_io == 2){ /* serial */
Maxwelltime:Output_gzdir.c:	j=E->parallel.nproc*E->lmesh.nel*E->sphere.caps_per_proc;
Maxwelltime:Output_gzdir.c:	j = E->lmesh.nel*E->sphere.caps_per_proc;
Maxwelltime:Output_gzdir.c:      if(E->parallel.me == 0)
Maxwelltime:Output_gzdir.c:	   E->control.data_dir,E->parallel.me);
Maxwelltime:Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Maxwelltime:Output_gzdir.c:      gzprintf(gz1,"%3d %7d\n",j,E->lmesh.nno);
Maxwelltime:Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Output_gzdir.c:		 E->sx[j][1][i],E->sx[j][2][i],E->sx[j][3][i]);
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io == 1){
Maxwelltime:Output_gzdir.c:	       E->control.data_dir,E->parallel.me);
Maxwelltime:Output_gzdir.c:      for(j=1;j <= E->sphere.caps_per_proc;j++)     {
Maxwelltime:Output_gzdir.c:	for(i=1;i <= E->lmesh.nno;i++) {
Maxwelltime:Output_gzdir.c:		   E->x[j][1][i],E->x[j][2][i],E->x[j][3][i]);
Maxwelltime:Output_gzdir.c:      offset = E->lmesh.nno * E->parallel.me - 1;
Maxwelltime:Output_gzdir.c:	       E->control.data_dir,E->parallel.me);
Maxwelltime:Output_gzdir.c:      for(j=1;j <= E->sphere.caps_per_proc;j++)     {
Maxwelltime:Output_gzdir.c:	for(i=1;i <= E->lmesh.nel;i++) {
Maxwelltime:Output_gzdir.c:	  gzprintf(gz1,"%2i\t",enodes[E->mesh.nsd]);
Maxwelltime:Output_gzdir.c:	  if(enodes[E->mesh.nsd] != 8){
Maxwelltime:Output_gzdir.c:		   E->ien[j][i].node[1]+offset,E->ien[j][i].node[2]+offset,
Maxwelltime:Output_gzdir.c:		   E->ien[j][i].node[3]+offset,E->ien[j][i].node[4]+offset,
Maxwelltime:Output_gzdir.c:		   E->ien[j][i].node[5]+offset,E->ien[j][i].node[6]+offset,
Maxwelltime:Output_gzdir.c:		   E->ien[j][i].node[7]+offset,E->ien[j][i].node[8]+offset);
Maxwelltime:Output_gzdir.c:  if(E->output.gzdir.vtk_io){	/* all VTK modes need basis vectors */
Maxwelltime:Output_gzdir.c:    os = E->lmesh.nno*9;
Maxwelltime:Output_gzdir.c:    if((!E->output.gzdir.vtk_base_init) ||(!E->output.gzdir.vtk_base_save)){
Maxwelltime:Output_gzdir.c:      if(!E->output.gzdir.vtk_base_init) /* init space */
Maxwelltime:Output_gzdir.c:	E->output.gzdir.vtk_base = (float *)safe_malloc(sizeof(float)*os*E->sphere.caps_per_proc);
Maxwelltime:Output_gzdir.c:      for(k=0,j=1;j <= E->sphere.caps_per_proc;j++,k += os)     {
Maxwelltime:Output_gzdir.c:	for(i=1;i <= E->lmesh.nno;i++,k += 9){
Maxwelltime:Output_gzdir.c:	  calc_cbase_at_node(j,i,(E->output.gzdir.vtk_base+k),E);
Maxwelltime:Output_gzdir.c:      E->output.gzdir.vtk_base_init = 1;
Maxwelltime:Output_gzdir.c:  if(E->output.gzdir.rnr){	/* remove the whole model net rotation */
Maxwelltime:Output_gzdir.c:    if((E->control.remove_rigid_rotation || E->control.remove_angular_momentum) &&
Maxwelltime:Output_gzdir.c:       (E->parallel.me == 0))	/* that's not too terrible but wastes time */
Maxwelltime:Output_gzdir.c:    if(E->parallel.me == 0)
Maxwelltime:Output_gzdir.c:  if((E->output.gzdir.vtk_io == 2) || (E->output.gzdir.vtk_io == 3)){
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2)
Maxwelltime:Output_gzdir.c:    E->output.gzdir.vtk_ocount++; /* regular output file name */
Maxwelltime:Output_gzdir.c:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Maxwelltime:Output_gzdir.c:      if(E->parallel.me == 0){
Maxwelltime:Output_gzdir.c:	fprintf(E->output.gzdir.vtk_fp,"%12i %12i %12.6e %s\n",
Maxwelltime:Output_gzdir.c:		E->output.gzdir.vtk_ocount,cycles,E->monitor.elapsed_time,output_file);
Maxwelltime:Output_gzdir.c:      if(E->output.gzdir.vtk_io == 2) /* serial */
Maxwelltime:Output_gzdir.c:	sprintf(message,"POINT_DATA %i\n",E->lmesh.nno*E->parallel.nproc*E->sphere.caps_per_proc);
Maxwelltime:Output_gzdir.c:	sprintf(message,"POINT_DATA %i\n",E->lmesh.nno*E->sphere.caps_per_proc);
Maxwelltime:Output_gzdir.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 7, E->parallel.world, &mpi_stat);
Maxwelltime:Output_gzdir.c:    for(j=1; j<= E->sphere.caps_per_proc;j++) /* print the temperatures */
Maxwelltime:Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++){
Maxwelltime:Output_gzdir.c:	cvec[0] = E->T[j][i];
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2){
Maxwelltime:Output_gzdir.c:      if(E->parallel.me <  E->parallel.nproc-1){
Maxwelltime:Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 7, E->parallel.world);
Maxwelltime:Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, 0, 6, E->parallel.world); /* tell m=0 to go ahead */
Maxwelltime:Output_gzdir.c:    if((E->output.gzdir.vtk_io == 3) || (E->parallel.me == 0)){
Maxwelltime:Output_gzdir.c:      if(E->output.gzdir.vtk_io == 2){
Maxwelltime:Output_gzdir.c:	mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, E->parallel.nproc-1 , 6, E->parallel.world, &mpi_stat);
Maxwelltime:Output_gzdir.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 5, E->parallel.world, &mpi_stat);
Maxwelltime:Output_gzdir.c:    for(k=0,j=1;j <= E->sphere.caps_per_proc;j++,k += os)     {
Maxwelltime:Output_gzdir.c:      if(E->output.gzdir.rnr){
Maxwelltime:Output_gzdir.c:	for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Maxwelltime:Output_gzdir.c:	  vcorr[0] = E->sphere.cap[j].V[1][i]; /* vtheta */
Maxwelltime:Output_gzdir.c:	  vcorr[1] = E->sphere.cap[j].V[2][i]; /* vphi */
Maxwelltime:Output_gzdir.c:	  sub_netr(E->sx[j][3][i],E->sx[j][1][i],E->sx[j][2][i],(vcorr+0),(vcorr+1),omega);
Maxwelltime:Output_gzdir.c:	  convert_pvec_to_cvec(E->sphere.cap[j].V[3][i],vcorr[0],vcorr[1],
Maxwelltime:Output_gzdir.c:			       (E->output.gzdir.vtk_base+k),cvec);
Maxwelltime:Output_gzdir.c:	for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Maxwelltime:Output_gzdir.c:	  convert_pvec_to_cvec(E->sphere.cap[j].V[3][i],E->sphere.cap[j].V[1][i],E->sphere.cap[j].V[2][i],
Maxwelltime:Output_gzdir.c:			       (E->output.gzdir.vtk_base+k),cvec);
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2){
Maxwelltime:Output_gzdir.c:      if(E->parallel.me <  E->parallel.nproc-1){
Maxwelltime:Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 5, E->parallel.world);
Maxwelltime:Output_gzdir.c:      if(E->parallel.me == 0)
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io == 1) {
Maxwelltime:Output_gzdir.c:	       E->control.data_dir,
Maxwelltime:Output_gzdir.c:	       cycles,E->parallel.me,cycles);
Maxwelltime:Output_gzdir.c:	       E->control.data_dir,cycles,
Maxwelltime:Output_gzdir.c:	       E->parallel.me,cycles);
Maxwelltime:Output_gzdir.c:	     cycles,E->lmesh.nno,E->monitor.elapsed_time);
Maxwelltime:Output_gzdir.c:    for(j=1; j<= E->sphere.caps_per_proc;j++)     {
Maxwelltime:Output_gzdir.c:      gzprintf(gzout,"%3d %7d\n",j,E->lmesh.nno);
Maxwelltime:Output_gzdir.c:      if(E->output.gzdir.vtk_io){
Maxwelltime:Output_gzdir.c:	for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Output_gzdir.c:	  gzprintf(gzout,"%.6e\n",E->T[j][i]);
Maxwelltime:Output_gzdir.c:	if(E->output.gzdir.rnr){
Maxwelltime:Output_gzdir.c:	  for(i=1;i<=E->lmesh.nno;i++){
Maxwelltime:Output_gzdir.c:	    vcorr[0] = E->sphere.cap[j].V[1][i]; /* vt */
Maxwelltime:Output_gzdir.c:	    vcorr[1] = E->sphere.cap[j].V[2][i]; /* vphi */
Maxwelltime:Output_gzdir.c:	    sub_netr(E->sx[j][3][i],E->sx[j][1][i],E->sx[j][2][i],(vcorr+0),(vcorr+1),omega);
Maxwelltime:Output_gzdir.c:		     E->sphere.cap[j].V[3][i],E->T[j][i]);
Maxwelltime:Output_gzdir.c:	  for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Output_gzdir.c:		     E->sphere.cap[j].V[1][i],
Maxwelltime:Output_gzdir.c:		     E->sphere.cap[j].V[2][i],
Maxwelltime:Output_gzdir.c:		     E->sphere.cap[j].V[3][i],E->T[j][i]);
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io){
Maxwelltime:Output_gzdir.c:	       E->control.data_dir,cycles,E->parallel.me,cycles);
Maxwelltime:Output_gzdir.c:      for(k=0,j=1;j <= E->sphere.caps_per_proc;j++,k += os)     {
Maxwelltime:Output_gzdir.c:	if(E->output.gzdir.rnr){
Maxwelltime:Output_gzdir.c:	  for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Maxwelltime:Output_gzdir.c:	    vcorr[0] = E->sphere.cap[j].V[1][i];
Maxwelltime:Output_gzdir.c:	    vcorr[1] = E->sphere.cap[j].V[2][i];
Maxwelltime:Output_gzdir.c:	    sub_netr(E->sx[j][3][i],E->sx[j][1][i],E->sx[j][2][i],(vcorr+0),(vcorr+1),omega);
Maxwelltime:Output_gzdir.c:	    convert_pvec_to_cvec(E->sphere.cap[j].V[3][i],vcorr[0],vcorr[1],
Maxwelltime:Output_gzdir.c:				 (E->output.gzdir.vtk_base+k),cvec);
Maxwelltime:Output_gzdir.c:	  for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Maxwelltime:Output_gzdir.c:	    convert_pvec_to_cvec(E->sphere.cap[j].V[3][i],
Maxwelltime:Output_gzdir.c:				 E->sphere.cap[j].V[1][i],
Maxwelltime:Output_gzdir.c:				 E->sphere.cap[j].V[2][i],
Maxwelltime:Output_gzdir.c:				 (E->output.gzdir.vtk_base+k),cvec);
Maxwelltime:Output_gzdir.c:  if(E->output.gzdir.vtk_io){	/* all VTK modes */
Maxwelltime:Output_gzdir.c:    if(!E->output.gzdir.vtk_base_save)
Maxwelltime:Output_gzdir.c:      free(E->output.gzdir.vtk_base);
Maxwelltime:Output_gzdir.c:  int lev = E->mesh.levmax;
Maxwelltime:Output_gzdir.c:  if(E->output.gzdir.vtk_io < 2){
Maxwelltime:Output_gzdir.c:	     "%s/%d/visc.%d.%d.gz", E->control.data_dir,
Maxwelltime:Output_gzdir.c:	     cycles,E->parallel.me, cycles);
Maxwelltime:Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Output_gzdir.c:      gzprintf(gz1,"%3d %7d\n",j,E->lmesh.nno);
Maxwelltime:Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Output_gzdir.c:	gzprintf(gz1,"%.4e\n",E->VI[lev][j][i]);
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2)
Maxwelltime:Output_gzdir.c:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Maxwelltime:Output_gzdir.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Maxwelltime:Output_gzdir.c:    for(j=1; j<= E->sphere.caps_per_proc;j++)
Maxwelltime:Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++){
Maxwelltime:Output_gzdir.c:	ftmp = log10(E->VI[lev][j][i]);
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2)
Maxwelltime:Output_gzdir.c:      if(E->parallel.me <  E->parallel.nproc-1){
Maxwelltime:Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Maxwelltime:Output_gzdir.c:  if((E->output.write_q_files == 0) || (cycles == 0) ||
Maxwelltime:Output_gzdir.c:     (cycles % E->output.write_q_files)!=0)
Maxwelltime:Output_gzdir.c:  if(E->control.use_cbf_topo){
Maxwelltime:Output_gzdir.c:    get_CBF_topo(E,E->slice.tpg,E->slice.tpgb);
Maxwelltime:Output_gzdir.c:    get_STD_topo(E,E->slice.tpg,E->slice.tpgb,E->slice.divg,E->slice.vort,cycles);
Maxwelltime:Output_gzdir.c:  if (E->output.surf && (E->parallel.me_loc[3]==E->parallel.nprocz-1)) {
Maxwelltime:Output_gzdir.c:    snprintf(output_file,255,"%s/%d/surf.%d.%d.gz", E->control.data_dir,
Maxwelltime:Output_gzdir.c:	    cycles,E->parallel.me, cycles);
Maxwelltime:Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Output_gzdir.c:        if(E->control.pseudo_free_surf)
Maxwelltime:Output_gzdir.c:            topo = E->slice.freesurf[j];
Maxwelltime:Output_gzdir.c:            topo = E->slice.tpg[j];
Maxwelltime:Output_gzdir.c:        gzprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Maxwelltime:Output_gzdir.c:        for(i=1;i<=E->lmesh.nsf;i++)   {
Maxwelltime:Output_gzdir.c:            s = i*E->lmesh.noz;
Maxwelltime:Output_gzdir.c:		     topo[i],E->slice.shflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Maxwelltime:Output_gzdir.c:  if (E->output.botm && (E->parallel.me_loc[3]==0)) {
Maxwelltime:Output_gzdir.c:    snprintf(output_file,255,"%s/%d/botm.%d.%d.gz", E->control.data_dir,
Maxwelltime:Output_gzdir.c:	    cycles,E->parallel.me, cycles);
Maxwelltime:Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Output_gzdir.c:      gzprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Maxwelltime:Output_gzdir.c:      for(i=1;i<=E->lmesh.nsf;i++)  {
Maxwelltime:Output_gzdir.c:        s = (i-1)*E->lmesh.noz + 1;
Maxwelltime:Output_gzdir.c:		 E->slice.tpgb[j][i],E->slice.bhflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Maxwelltime:Output_gzdir.c:    if (E->parallel.me == (E->parallel.nprocz-1))  {
Maxwelltime:Output_gzdir.c:		 "%s/%d/geoid.%d.%d.gz", E->control.data_dir,
Maxwelltime:Output_gzdir.c:		cycles,E->parallel.me, cycles);
Maxwelltime:Output_gzdir.c:        gzprintf(fp1, "%d %d %.5e\n", cycles, E->output.llmax,
Maxwelltime:Output_gzdir.c:                E->monitor.elapsed_time);
Maxwelltime:Output_gzdir.c:        for (ll=0; ll<=E->output.llmax; ll++)
Maxwelltime:Output_gzdir.c:                p = E->sphere.hindex[ll][mm];
Maxwelltime:Output_gzdir.c:                        E->sphere.harm_geoid[0][p],
Maxwelltime:Output_gzdir.c:                        E->sphere.harm_geoid[1][p],
Maxwelltime:Output_gzdir.c:                        E->sphere.harm_geoid_from_tpgt[0][p],
Maxwelltime:Output_gzdir.c:                        E->sphere.harm_geoid_from_tpgt[1][p],
Maxwelltime:Output_gzdir.c:                        E->sphere.harm_geoid_from_bncy[0][p],
Maxwelltime:Output_gzdir.c:                        E->sphere.harm_geoid_from_bncy[1][p]);
Maxwelltime:Output_gzdir.c:  if(E->control.use_cbf_topo)	{/* for CBF topo, stress will not have been computed */
Maxwelltime:Output_gzdir.c:  snprintf(output_file,255,"%s/%d/stress.%d.%d.gz", E->control.data_dir,
Maxwelltime:Output_gzdir.c:	  cycles,E->parallel.me, cycles);
Maxwelltime:Output_gzdir.c:  gzprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Maxwelltime:Output_gzdir.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Output_gzdir.c:    gzprintf(fp1,"%3d %7d\n",m,E->lmesh.nno);
Maxwelltime:Output_gzdir.c:    for (node=1;node<=E->lmesh.nno;node++)
Maxwelltime:Output_gzdir.c:              E->gstress[m][(node-1)*6+1], /*  stt */
Maxwelltime:Output_gzdir.c:              E->gstress[m][(node-1)*6+2], /*  spp */
Maxwelltime:Output_gzdir.c:              E->gstress[m][(node-1)*6+3], /*  srr */
Maxwelltime:Output_gzdir.c:              E->gstress[m][(node-1)*6+4], /*  stp */
Maxwelltime:Output_gzdir.c:              E->gstress[m][(node-1)*6+5], /*  str */
Maxwelltime:Output_gzdir.c:              E->gstress[m][(node-1)*6+6]); /* srp */
Maxwelltime:Output_gzdir.c:  if (E->parallel.me<E->parallel.nprocz)  {
Maxwelltime:Output_gzdir.c:    snprintf(output_file,255,"%s/%d/horiz_avg.%d.%d.gz", E->control.data_dir,
Maxwelltime:Output_gzdir.c:	    cycles,E->parallel.me, cycles);
Maxwelltime:Output_gzdir.c:    for(j=1;j<=E->lmesh.noz;j++)  {
Maxwelltime:Output_gzdir.c:        gzprintf(fp1,"%.4e %.4e %.4e %.4e",E->sx[1][3][j],E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j]);
Maxwelltime:Output_gzdir.c:        if (E->composition.on) {
Maxwelltime:Output_gzdir.c:            for(n=0; n<E->composition.ncomp; n++)
Maxwelltime:Output_gzdir.c:                gzprintf(fp1," %.4e", E->Have.C[n][j]);
Maxwelltime:Output_gzdir.c:  snprintf(output_file,255,"%s/mat.%d.gz", E->control.data_dir,E->parallel.me);
Maxwelltime:Output_gzdir.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Output_gzdir.c:    for(el=1;el<=E->lmesh.nel;el++)
Maxwelltime:Output_gzdir.c:      gzprintf(fp,"%d %d %f\n", el,E->mat[m][el],E->VIP[m][el]);
Maxwelltime:Output_gzdir.c:  if(E->output.gzdir.vtk_io < 2){ /* old */
Maxwelltime:Output_gzdir.c:    snprintf(output_file,255,"%s/%d/pressure.%d.%d.gz", E->control.data_dir,cycles,
Maxwelltime:Output_gzdir.c:	     E->parallel.me, cycles);
Maxwelltime:Output_gzdir.c:    gzprintf(gz1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Maxwelltime:Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Output_gzdir.c:      gzprintf(gz1,"%3d %7d\n",j,E->lmesh.nno);
Maxwelltime:Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Output_gzdir.c:	gzprintf(gz1,"%.6e\n",E->NP[j][i]);
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2)
Maxwelltime:Output_gzdir.c:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Maxwelltime:Output_gzdir.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Maxwelltime:Output_gzdir.c:    for(j=1; j<= E->sphere.caps_per_proc;j++)
Maxwelltime:Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++){
Maxwelltime:Output_gzdir.c:	ftmp = E->NP[j][i];
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2)
Maxwelltime:Output_gzdir.c:      if(E->parallel.me <  E->parallel.nproc-1){
Maxwelltime:Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Maxwelltime:Output_gzdir.c:	   E->control.data_dir,cycles,
Maxwelltime:Output_gzdir.c:	   E->parallel.me, cycles);
Maxwelltime:Output_gzdir.c:  ncolumns = 3 + E->trace.number_of_extra_quantities;
Maxwelltime:Output_gzdir.c:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Output_gzdir.c:      gzprintf(fp1,"%d %d %d %.5e\n", cycles, E->trace.ntracers[j],
Maxwelltime:Output_gzdir.c:              ncolumns, E->monitor.elapsed_time);
Maxwelltime:Output_gzdir.c:      for(n=1;n<=E->trace.ntracers[j];n++) {
Maxwelltime:Output_gzdir.c:                  E->trace.basicq[j][0][n],
Maxwelltime:Output_gzdir.c:                  E->trace.basicq[j][1][n],
Maxwelltime:Output_gzdir.c:                  E->trace.basicq[j][2][n]);
Maxwelltime:Output_gzdir.c:          for (i=0; i<E->trace.number_of_extra_quantities; i++) {
Maxwelltime:Output_gzdir.c:              gzprintf(fp1," %9.5e", E->trace.extraq[j][i][n]);
Maxwelltime:Output_gzdir.c:  if(E->output.gzdir.vtk_io < 2){
Maxwelltime:Output_gzdir.c:	     E->control.data_dir,cycles,
Maxwelltime:Output_gzdir.c:	     E->parallel.me, cycles);
Maxwelltime:Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Output_gzdir.c:	       j, E->lmesh.nel,
Maxwelltime:Output_gzdir.c:	       E->monitor.elapsed_time,
Maxwelltime:Output_gzdir.c:	       E->composition.initial_bulk_composition,
Maxwelltime:Output_gzdir.c:	       E->composition.bulk_composition);
Maxwelltime:Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++) {
Maxwelltime:Output_gzdir.c:	for(k=0;k<E->composition.ncomp;k++)
Maxwelltime:Output_gzdir.c:	  gzprintf(gz1,"%.6e ",E->composition.comp_node[j][k][i]);
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2)
Maxwelltime:Output_gzdir.c:    if((E->output.gzdir.vtk_io==3) || (E->parallel.me == 0)){
Maxwelltime:Output_gzdir.c:      if(E->composition.ncomp > 4)
Maxwelltime:Output_gzdir.c:      sprintf(message,"SCALARS composition float %d\n",E->composition.ncomp);
Maxwelltime:Output_gzdir.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Maxwelltime:Output_gzdir.c:    for(j=1; j<= E->sphere.caps_per_proc;j++)
Maxwelltime:Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++){
Maxwelltime:Output_gzdir.c:	for(k=0;k<E->composition.ncomp;k++){
Maxwelltime:Output_gzdir.c:	  ftmp = E->composition.comp_node[j][k][i];
Maxwelltime:Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2) /* serial */
Maxwelltime:Output_gzdir.c:      if(E->parallel.me <  E->parallel.nproc-1){
Maxwelltime:Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Maxwelltime:Output_gzdir.c:    snprintf(output_file,255,"%s/%d/comp_el.%d.%d.gz", E->control.data_dir,
Maxwelltime:Output_gzdir.c:	    cycles,E->parallel.me, cycles);
Maxwelltime:Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Output_gzdir.c:                j, E->lmesh.nel,
Maxwelltime:Output_gzdir.c:                E->monitor.elapsed_time,
Maxwelltime:Output_gzdir.c:                E->composition.initial_bulk_composition,
Maxwelltime:Output_gzdir.c:                E->composition.bulk_composition);
Maxwelltime:Output_gzdir.c:        for(i=1;i<=E->lmesh.nel;i++) {
Maxwelltime:Output_gzdir.c:	  for(k=0;k<E->composition.ncomp;k++)
Maxwelltime:Output_gzdir.c:            gzprintf(fp1,"%.6e ",E->composition.comp_el[j][k][i]);
Maxwelltime:Output_gzdir.c:    snprintf(output_file,255,"%s/%d/heating.%d.%d.gz", E->control.data_dir,
Maxwelltime:Output_gzdir.c:	    cycles,E->parallel.me, cycles);
Maxwelltime:Output_gzdir.c:    gzprintf(fp1,"%.5e\n",E->monitor.elapsed_time);
Maxwelltime:Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Output_gzdir.c:        gzprintf(fp1,"%3d %7d\n", j, E->lmesh.nel);
Maxwelltime:Output_gzdir.c:        for(e=1; e<=E->lmesh.nel; e++)
Maxwelltime:Output_gzdir.c:            gzprintf(fp1, "%.4e %.4e %.4e\n", E->heating_adi[j][e],
Maxwelltime:Output_gzdir.c:                      E->heating_visc[j][e], E->heating_latent[j][e]);
Maxwelltime:Output_gzdir.c:  ii = E->monitor.solution_cycles_init;
Maxwelltime:Output_gzdir.c:  switch(E->output.gzdir.vtk_io){
Maxwelltime:Output_gzdir.c:	     E->control.data_dir_old,
Maxwelltime:Output_gzdir.c:	     ii,E->parallel.me,ii);
Maxwelltime:Output_gzdir.c:	     E->control.data_dir_old,ii,
Maxwelltime:Output_gzdir.c:	     E->parallel.me,ii);
Maxwelltime:Output_gzdir.c:  if (E->parallel.me==0){
Maxwelltime:Output_gzdir.c:    fprintf(E->fp,"restart_tic_from_gzdir_file: using  %s for restarted temperature\n",
Maxwelltime:Output_gzdir.c:  if(mm != E->lmesh.nno){
Maxwelltime:Output_gzdir.c:    fprintf(stderr,"%i %i\n",mm, E->lmesh.nno);
Maxwelltime:Output_gzdir.c:  switch(E->output.gzdir.vtk_io) {
Maxwelltime:Output_gzdir.c:    for(m=1;m <= E->sphere.caps_per_proc;m++) {
Maxwelltime:Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++){
Maxwelltime:Output_gzdir.c:	E->T[m][i] = g;
Maxwelltime:Output_gzdir.c:    for(m=1;m <= E->sphere.caps_per_proc;m++) {
Maxwelltime:Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++)  {
Maxwelltime:Output_gzdir.c:	/*  E->sphere.cap[m].V[1][i] = v1;
Maxwelltime:Output_gzdir.c:	    E->sphere.cap[m].V[1][i] = v2;
Maxwelltime:Output_gzdir.c:	    E->sphere.cap[m].V[1][i] = v3;  */
Maxwelltime:Output_gzdir.c:	//E->T[m][i] = max(0.0,min(g,1.0));
Maxwelltime:Output_gzdir.c:	E->T[m][i] = g;
Maxwelltime:Output_gzdir.c:  if(E->output.gzdir.vtk_io == 2){ /* serial */
Maxwelltime:Output_gzdir.c:	       E->control.data_dir);
Maxwelltime:Output_gzdir.c:	       E->control.data_dir, E->output.gzdir.vtk_ocount);
Maxwelltime:Output_gzdir.c:	       E->control.data_dir,E->parallel.me);
Maxwelltime:Output_gzdir.c:	       E->control.data_dir,cycles,
Maxwelltime:Output_gzdir.c:	       E->output.gzdir.vtk_ocount,
Maxwelltime:Output_gzdir.c:	       E->parallel.me);
Maxwelltime:Output_h5.c:    int nprocx = E->parallel.nprocx;
Maxwelltime:Output_h5.c:    int nprocy = E->parallel.nprocy;
Maxwelltime:Output_h5.c:    int nprocz = E->parallel.nprocz;
Maxwelltime:Output_h5.c:    E->hdf5.cap = (E->parallel.me) / (nprocx * nprocy * nprocz);
Maxwelltime:Output_h5.c:    if (E->output.stress == 1)
Maxwelltime:Output_h5.c:        E->hdf5.data = (float *)malloc((tensor3d->n) * sizeof(float));
Maxwelltime:Output_h5.c:        E->hdf5.data = (float *)malloc((vector3d->n) * sizeof(float));
Maxwelltime:Output_h5.c:    tensor3d->data = E->hdf5.data;
Maxwelltime:Output_h5.c:    vector3d->data = E->hdf5.data;
Maxwelltime:Output_h5.c:    vector2d->data = E->hdf5.data;
Maxwelltime:Output_h5.c:    scalar3d->data = E->hdf5.data;
Maxwelltime:Output_h5.c:    scalar2d->data = E->hdf5.data;
Maxwelltime:Output_h5.c:    scalar1d->data = E->hdf5.data;
Maxwelltime:Output_h5.c:    E->hdf5.tensor3d = tensor3d;
Maxwelltime:Output_h5.c:    E->hdf5.vector3d = vector3d;
Maxwelltime:Output_h5.c:    E->hdf5.vector2d = vector2d;
Maxwelltime:Output_h5.c:    E->hdf5.scalar3d = scalar3d;
Maxwelltime:Output_h5.c:    E->hdf5.scalar2d = scalar2d;
Maxwelltime:Output_h5.c:    E->hdf5.scalar1d = scalar1d;
Maxwelltime:Output_h5.c: * These represent possible choices for (E->output) function pointer.       *
Maxwelltime:Output_h5.c:    if(E->parallel.me == 0)
Maxwelltime:Output_h5.c:        if (E->output.coord_bin)
Maxwelltime:Output_h5.c:    int m = E->parallel.me;
Maxwelltime:Output_h5.c:    input_int("cb_block_size", &(E->output.cb_block_size), "1048576", m);
Maxwelltime:Output_h5.c:    input_int("cb_buffer_size", &(E->output.cb_buffer_size), "4194304", m);
Maxwelltime:Output_h5.c:    input_int("sieve_buf_size", &(E->output.sieve_buf_size), "1048576", m);
Maxwelltime:Output_h5.c:    input_int("output_alignment", &(E->output.alignment), "262144", m);
Maxwelltime:Output_h5.c:    input_int("output_alignment_threshold", &(E->output.alignment_threshold), "524288", m);
Maxwelltime:Output_h5.c:    input_int("cache_mdc_nelmts", &(E->output.cache_mdc_nelmts), "10330", m);
Maxwelltime:Output_h5.c:    input_int("cache_rdcc_nelmts", &(E->output.cache_rdcc_nelmts), "521", m);
Maxwelltime:Output_h5.c:    input_int("cache_rdcc_nbytes", &(E->output.cache_rdcc_nbytes), "1048576", m);
Maxwelltime:Output_h5.c:    snprintf(filename, (size_t)100, "%s.h5", E->control.data_file);
Maxwelltime:Output_h5.c:             E->control.data_file, cycles);
Maxwelltime:Output_h5.c:    if(E->control.tracer == 1)
Maxwelltime:Output_h5.c:    if(E->output.geoid == 1)
Maxwelltime:Output_h5.c:    if(E->output.stress == 1){
Maxwelltime:Output_h5.c:    if(E->output.pressure == 1)
Maxwelltime:Output_h5.c:    if (E->output.horiz_avg == 1)
Maxwelltime:Output_h5.c:    MPI_Comm comm = E->parallel.world;
Maxwelltime:Output_h5.c:    snprintf(tmp, (size_t)100, "%d", E->output.cb_block_size);
Maxwelltime:Output_h5.c:    snprintf(tmp, (size_t)100, "%d", E->output.cb_buffer_size);
Maxwelltime:Output_h5.c:    status = H5Pset_sieve_buf_size(fapl_id, (size_t)(E->output.sieve_buf_size));
Maxwelltime:Output_h5.c:    status = H5Pset_alignment(fapl_id, (hsize_t)(E->output.alignment_threshold),
Maxwelltime:Output_h5.c:                                       (hsize_t)(E->output.alignment));
Maxwelltime:Output_h5.c:    status = H5Pset_cache(fapl_id, E->output.cache_mdc_nelmts,
Maxwelltime:Output_h5.c:                                   (size_t)(E->output.cache_rdcc_nelmts),
Maxwelltime:Output_h5.c:                                   (size_t)(E->output.cache_rdcc_nbytes),
Maxwelltime:Output_h5.c:    E->hdf5.file_id = file_id;
Maxwelltime:Output_h5.c:    status = H5Fclose(E->hdf5.file_id);
Maxwelltime:Output_h5.c:    field = E->hdf5.vector3d;
Maxwelltime:Output_h5.c:    nx = E->lmesh.nox;
Maxwelltime:Output_h5.c:    ny = E->lmesh.noy;
Maxwelltime:Output_h5.c:    nz = E->lmesh.noz;
Maxwelltime:Output_h5.c:                field->data[3*m+0] = E->sx[1][1][n+1];
Maxwelltime:Output_h5.c:                field->data[3*m+1] = E->sx[1][2][n+1];
Maxwelltime:Output_h5.c:                field->data[3*m+2] = E->sx[1][3][n+1];
Maxwelltime:Output_h5.c:    h5create_field(E->hdf5.file_id, field, "coord", "coordinates of nodes");
Maxwelltime:Output_h5.c:    dataset = H5Dopen(E->hdf5.file_id, "/coord");
Maxwelltime:Output_h5.c:    field = E->hdf5.vector3d;
Maxwelltime:Output_h5.c:    nx = E->lmesh.nox;
Maxwelltime:Output_h5.c:    ny = E->lmesh.noy;
Maxwelltime:Output_h5.c:    nz = E->lmesh.noz;
Maxwelltime:Output_h5.c:                field->data[3*m+0] = E->sphere.cap[1].V[1][n+1];
Maxwelltime:Output_h5.c:                field->data[3*m+1] = E->sphere.cap[1].V[2][n+1];
Maxwelltime:Output_h5.c:                field->data[3*m+2] = E->sphere.cap[1].V[3][n+1];
Maxwelltime:Output_h5.c:    h5create_field(E->hdf5.file_id, field, "velocity", "velocity values on nodes");
Maxwelltime:Output_h5.c:    dataset = H5Dopen(E->hdf5.file_id, "/velocity");
Maxwelltime:Output_h5.c:    field = E->hdf5.scalar3d;
Maxwelltime:Output_h5.c:    nx = E->lmesh.nox;
Maxwelltime:Output_h5.c:    ny = E->lmesh.noy;
Maxwelltime:Output_h5.c:    nz = E->lmesh.noz;
Maxwelltime:Output_h5.c:                field->data[m] = E->T[1][n+1];
Maxwelltime:Output_h5.c:    h5create_field(E->hdf5.file_id, field, "temperature", "temperature values on nodes");
Maxwelltime:Output_h5.c:    dataset = H5Dopen(E->hdf5.file_id, "/temperature");
Maxwelltime:Output_h5.c:    field = E->hdf5.scalar3d;
Maxwelltime:Output_h5.c:    lev = E->mesh.levmax;
Maxwelltime:Output_h5.c:    nx = E->lmesh.nox;
Maxwelltime:Output_h5.c:    ny = E->lmesh.noy;
Maxwelltime:Output_h5.c:    nz = E->lmesh.noz;
Maxwelltime:Output_h5.c:                field->data[m] = E->VI[lev][1][n+1];
Maxwelltime:Output_h5.c:    h5create_field(E->hdf5.file_id, field, "viscosity", "viscosity values on nodes");
Maxwelltime:Output_h5.c:    dataset = H5Dopen(E->hdf5.file_id, "/viscosity");
Maxwelltime:Output_h5.c:    field = E->hdf5.scalar3d;
Maxwelltime:Output_h5.c:    nx = E->lmesh.nox;
Maxwelltime:Output_h5.c:    ny = E->lmesh.noy;
Maxwelltime:Output_h5.c:    nz = E->lmesh.noz;
Maxwelltime:Output_h5.c:                field->data[m] = E->NP[1][n+1];
Maxwelltime:Output_h5.c:    h5create_field(E->hdf5.file_id, field, "pressure", "pressure values on nodes");
Maxwelltime:Output_h5.c:    dataset = H5Dopen(E->hdf5.file_id, "/pressure");
Maxwelltime:Output_h5.c:    if(E->control.use_cbf_topo)	{/* for CBF topo, stress will not have been computed */
Maxwelltime:Output_h5.c:    field = E->hdf5.tensor3d;
Maxwelltime:Output_h5.c:    nx = E->lmesh.nox;
Maxwelltime:Output_h5.c:    ny = E->lmesh.noy;
Maxwelltime:Output_h5.c:    nz = E->lmesh.noz;
Maxwelltime:Output_h5.c:                field->data[6*m+0] = E->gstress[1][6*n+1];
Maxwelltime:Output_h5.c:                field->data[6*m+1] = E->gstress[1][6*n+2];
Maxwelltime:Output_h5.c:                field->data[6*m+2] = E->gstress[1][6*n+3];
Maxwelltime:Output_h5.c:                field->data[6*m+3] = E->gstress[1][6*n+4];
Maxwelltime:Output_h5.c:                field->data[6*m+4] = E->gstress[1][6*n+5];
Maxwelltime:Output_h5.c:                field->data[6*m+5] = E->gstress[1][6*n+6];
Maxwelltime:Output_h5.c:    h5create_field(E->hdf5.file_id, field, "stress", "stress values on nodes");
Maxwelltime:Output_h5.c:    dataset = H5Dopen(E->hdf5.file_id, "/stress");
Maxwelltime:Output_h5.c:    int pz = E->parallel.me_loc[3];
Maxwelltime:Output_h5.c:    int nprocz = E->parallel.nprocz;
Maxwelltime:Output_h5.c:    field = E->hdf5.vector2d;
Maxwelltime:Output_h5.c:    nx = E->lmesh.nox;
Maxwelltime:Output_h5.c:    ny = E->lmesh.noy;
Maxwelltime:Output_h5.c:    nz = E->lmesh.noz;
Maxwelltime:Output_h5.c:    if (E->output.surf == 1)
Maxwelltime:Output_h5.c:                field->data[2*m+0] = E->sx[1][1][n+1];
Maxwelltime:Output_h5.c:                field->data[2*m+1] = E->sx[1][2][n+1];
Maxwelltime:Output_h5.c:        dataset = H5Dopen(E->hdf5.file_id, "/surf/coord");
Maxwelltime:Output_h5.c:    if (E->output.botm == 1)
Maxwelltime:Output_h5.c:                field->data[2*m+0] = E->sx[1][1][n+1];
Maxwelltime:Output_h5.c:                field->data[2*m+1] = E->sx[1][2][n+1];
Maxwelltime:Output_h5.c:        dataset = H5Dopen(E->hdf5.file_id, "/botm/coord");
Maxwelltime:Output_h5.c:    int pz = E->parallel.me_loc[3];
Maxwelltime:Output_h5.c:    int nprocz = E->parallel.nprocz;
Maxwelltime:Output_h5.c:    file_id = E->hdf5.file_id;
Maxwelltime:Output_h5.c:    scalar = E->hdf5.scalar2d;
Maxwelltime:Output_h5.c:    vector = E->hdf5.vector2d;
Maxwelltime:Output_h5.c:    nx = E->lmesh.nox;
Maxwelltime:Output_h5.c:    ny = E->lmesh.noy;
Maxwelltime:Output_h5.c:    nz = E->lmesh.noz;
Maxwelltime:Output_h5.c:    if((E->output.write_q_files == 0) || (cycles == 0) ||
Maxwelltime:Output_h5.c:       (cycles % E->output.write_q_files)!=0)
Maxwelltime:Output_h5.c:    if(E->control.use_cbf_topo){
Maxwelltime:Output_h5.c:      get_CBF_topo(E, E->slice.tpg, E->slice.tpgb);
Maxwelltime:Output_h5.c:      get_STD_topo(E, E->slice.tpg, E->slice.tpgb, E->slice.divg, E->slice.vort, cycles);
Maxwelltime:Output_h5.c:    if (E->output.surf == 1)
Maxwelltime:Output_h5.c:        h5create_field(surf_group, E->hdf5.vector2d, "velocity",
Maxwelltime:Output_h5.c:        h5create_field(surf_group, E->hdf5.scalar2d, "heatflux",
Maxwelltime:Output_h5.c:        h5create_field(surf_group, E->hdf5.scalar2d, "topography",
Maxwelltime:Output_h5.c:                vector->data[2*m+0] = E->sphere.cap[1].V[1][n+1];
Maxwelltime:Output_h5.c:                vector->data[2*m+1] = E->sphere.cap[1].V[2][n+1];
Maxwelltime:Output_h5.c:                scalar->data[m] = E->slice.shflux[1][n+1];
Maxwelltime:Output_h5.c:        if (E->control.pseudo_free_surf)
Maxwelltime:Output_h5.c:            topo = E->slice.freesurf[1];
Maxwelltime:Output_h5.c:            topo = E->slice.tpg[1];
Maxwelltime:Output_h5.c:    if (E->output.botm == 1)
Maxwelltime:Output_h5.c:        h5create_field(botm_group, E->hdf5.vector2d, "velocity",
Maxwelltime:Output_h5.c:        h5create_field(botm_group, E->hdf5.scalar2d, "heatflux",
Maxwelltime:Output_h5.c:        h5create_field(botm_group, E->hdf5.scalar2d, "topography",
Maxwelltime:Output_h5.c:                vector->data[2*m+0] = E->sphere.cap[1].V[1][n+1];
Maxwelltime:Output_h5.c:                vector->data[2*m+1] = E->sphere.cap[1].V[2][n+1];
Maxwelltime:Output_h5.c:                scalar->data[m] = E->slice.bhflux[1][n+1];
Maxwelltime:Output_h5.c:        topo = E->slice.tpg[1];
Maxwelltime:Output_h5.c:    int px = E->parallel.me_loc[1];
Maxwelltime:Output_h5.c:    int py = E->parallel.me_loc[2];
Maxwelltime:Output_h5.c:    field = E->hdf5.scalar1d;
Maxwelltime:Output_h5.c:    if (E->output.horiz_avg == 1)
Maxwelltime:Output_h5.c:            field->data[k] = E->sx[1][3][k+1];
Maxwelltime:Output_h5.c:        dataset = H5Dopen(E->hdf5.file_id, "/horiz_avg/coord");
Maxwelltime:Output_h5.c:    int px = E->parallel.me_loc[1];
Maxwelltime:Output_h5.c:    int py = E->parallel.me_loc[2];
Maxwelltime:Output_h5.c:    file_id = E->hdf5.file_id;
Maxwelltime:Output_h5.c:    field = E->hdf5.scalar1d;
Maxwelltime:Output_h5.c:    h5create_field(avg_group, E->hdf5.scalar1d, "temperature",
Maxwelltime:Output_h5.c:    h5create_field(avg_group, E->hdf5.scalar1d, "velocity_xy",
Maxwelltime:Output_h5.c:    h5create_field(avg_group, E->hdf5.scalar1d, "velocity_z",
Maxwelltime:Output_h5.c:        field->data[k] = E->Have.T[k+1];
Maxwelltime:Output_h5.c:        field->data[k] = E->Have.V[1][k+1];
Maxwelltime:Output_h5.c:        field->data[k] = E->Have.V[2][k+1];
Maxwelltime:Output_h5.c:    hsize_t dim = E->sphere.hindice;
Maxwelltime:Output_h5.c:    dataset = H5Dcreate(E->hdf5.file_id, "geoid", datatype,
Maxwelltime:Output_h5.c:    if (E->parallel.me == 0) {
Maxwelltime:Output_h5.c:        row = (struct HDF5_GEOID *) malloc((E->sphere.hindice)
Maxwelltime:Output_h5.c:        for(ll = 0; ll <= E->output.llmax; ll++)
Maxwelltime:Output_h5.c:                row[i].total_sin = E->sphere.harm_geoid[0][i];
Maxwelltime:Output_h5.c:                row[i].total_cos = E->sphere.harm_geoid[1][i];
Maxwelltime:Output_h5.c:                row[i].tpgt_sin = E->sphere.harm_geoid_from_tpgt[0][i];
Maxwelltime:Output_h5.c:                row[i].tpgt_cos = E->sphere.harm_geoid_from_tpgt[1][i];
Maxwelltime:Output_h5.c:                row[i].bncy_sin = E->sphere.harm_geoid_from_bncy[0][i];
Maxwelltime:Output_h5.c:                row[i].bncy_cos = E->sphere.harm_geoid_from_bncy[1][i];
Maxwelltime:Output_h5.c:    int px = E->parallel.me_loc[1];
Maxwelltime:Output_h5.c:    int py = E->parallel.me_loc[2];
Maxwelltime:Output_h5.c:    int pz = E->parallel.me_loc[3];
Maxwelltime:Output_h5.c:    int nprocx = E->parallel.nprocx;
Maxwelltime:Output_h5.c:    int nprocy = E->parallel.nprocy;
Maxwelltime:Output_h5.c:    int nprocz = E->parallel.nprocz;
Maxwelltime:Output_h5.c:    int nel = E->lmesh.nel;
Maxwelltime:Output_h5.c:    if (E->output.connectivity == 1)
Maxwelltime:Output_h5.c:            ien = E->ien[1][e+1].node;
Maxwelltime:Output_h5.c:        h5create_connectivity(E->hdf5.file_id, E->lmesh.nel * procs_per_cap);
Maxwelltime:Output_h5.c:        dataset = H5Dopen(E->hdf5.file_id, "/connectivity");
Maxwelltime:Output_h5.c:                                 0, (E->hdf5.cap == 0));
Maxwelltime:Output_h5.c:    root = H5Gopen(E->hdf5.file_id, "/");
Maxwelltime:Output_h5.c:    status = set_attribute_float(root, "time", E->monitor.elapsed_time);
Maxwelltime:Output_h5.c:    input = h5create_group(E->hdf5.file_id, "input", (size_t)0);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "PID", E->control.PID);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "ADV", E->advection.ADVECTION);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "filter_temp", E->advection.filter_temperature);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "finetunedt", E->advection.fine_tune_dt);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "fixed_timestep", E->advection.fixed_timestep);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "inputdiffusivity", E->control.inputdiff);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "adv_sub_iterations", E->advection.temp_iterations);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "side_sbcs", E->control.side_sbcs);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "pseudo_free_surf", E->control.pseudo_free_surf);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "topvbc", E->mesh.topvbc);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "topvbxval", E->control.VBXtopval);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "topvbyval", E->control.VBYtopval);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "botvbc", E->mesh.botvbc);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "botvbxval", E->control.VBXbotval);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "botvbyval", E->control.VBYbotval);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "toptbc", E->mesh.toptbc);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "toptbcval", E->control.TBCtopval);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "bottbc", E->mesh.bottbc);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "bottbcval", E->control.TBCbotval);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "temperature_bound_adj", E->control.temperature_bound_adj);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "depth_bound_adj", E->control.depth_bound_adj);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "width_bound_adj", E->control.width_bound_adj);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "density", E->data.density);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "thermdiff", E->data.therm_diff);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "gravacc", E->data.grav_acc);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "thermexp", E->data.therm_exp);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "refvisc", E->data.ref_viscosity);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "cp", E->data.Cp);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "density_above", E->data.density_above);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "density_below", E->data.density_below);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "z_lith", E->viscosity.zlith);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "z_410", E->viscosity.z410);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "z_lmantle", E->viscosity.zlm);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "z_cmb", E->viscosity.zcmb);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "radius_km", E->data.radius_km);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "scalev", E->data.scalev);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "scalet", E->data.scalet);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "restart", E->control.restart);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "post_p", E->control.post_p);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "solution_cycles_init", E->monitor.solution_cycles_init);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "zero_elapsed_time", E->control.zero_elapsed_time);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "tic_method", E->convection.tic_method);
Maxwelltime:Output_h5.c:    n = E->convection.number_of_perturbations;
Maxwelltime:Output_h5.c:    status = set_attribute_int_vector(input, "perturbl", n, E->convection.perturb_ll);
Maxwelltime:Output_h5.c:    status = set_attribute_int_vector(input, "perturbm", n, E->convection.perturb_mm);
Maxwelltime:Output_h5.c:    status = set_attribute_int_vector(input, "perturblayer", n, E->convection.load_depth);
Maxwelltime:Output_h5.c:    status = set_attribute_float_vector(input, "perturbmag", n, E->convection.perturb_mag);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "half_space_age", E->convection.half_space_age);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "mantle_temp", E->control.mantle_temp);
Maxwelltime:Output_h5.c:    if (E->convection.tic_method == 2)
Maxwelltime:Output_h5.c:        status = set_attribute_float_vector(input, "blob_center", 3, E->convection.blob_center);
Maxwelltime:Output_h5.c:        status = set_attribute_float(input, "blob_radius", E->convection.blob_radius);
Maxwelltime:Output_h5.c:        status = set_attribute_float(input, "blob_dT", E->convection.blob_dT);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "file_vbcs", E->control.vbcs_file);
Maxwelltime:Output_h5.c:    status = set_attribute_string(input, "vel_bound_file", E->control.velocity_boundary_file);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "file_tbcs", E->control.tbcs_file);
Maxwelltime:Output_h5.c:    status = set_attribute_string(input, "temp_bound_file", E->control.temperature_boundary_file);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "mat_control", E->control.mat_control);
Maxwelltime:Output_h5.c:    status = set_attribute_string(input, "mat_file", E->control.mat_file);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "lith_age", E->control.lith_age);
Maxwelltime:Output_h5.c:    status = set_attribute_string(input, "lith_age_file", E->control.lith_age_file);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "lith_age_time", E->control.lith_age_time);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "lith_age_depth", E->control.lith_age_depth);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "start_age", E->control.start_age);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "reset_startage", E->control.reset_startage);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "Ra_410", E->control.Ra_410);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "clapeyron410", E->control.clapeyron410);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "transT410", E->control.transT410);
Maxwelltime:Output_h5.c:                                 (E->control.inv_width410 == 0)?
Maxwelltime:Output_h5.c:                                 E->control.inv_width410 :
Maxwelltime:Output_h5.c:				 1.0/E->control.inv_width410);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "Ra_670", E->control.Ra_670);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "clapeyron670", E->control.clapeyron670);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "transT670", E->control.transT670);
Maxwelltime:Output_h5.c:                                 (E->control.inv_width670 == 0)?
Maxwelltime:Output_h5.c:                                 E->control.inv_width670 :
Maxwelltime:Output_h5.c:				 1.0/E->control.inv_width670);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "Ra_cmb", E->control.Ra_cmb);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "clapeyroncmb", E->control.clapeyroncmb);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "transTcmb", E->control.transTcmb);
Maxwelltime:Output_h5.c:                                 (E->control.inv_widthcmb == 0)?
Maxwelltime:Output_h5.c:                                 E->control.inv_widthcmb :
Maxwelltime:Output_h5.c:				 1.0/E->control.inv_widthcmb);
Maxwelltime:Output_h5.c:    status = set_attribute_string(input, "datadir", E->control.data_dir);
Maxwelltime:Output_h5.c:    status = set_attribute_string(input, "datafile", E->control.data_file);
Maxwelltime:Output_h5.c:    status = set_attribute_string(input, "datadir_old", E->control.data_dir_old);
Maxwelltime:Output_h5.c:    status = set_attribute_string(input, "datafile_old", E->control.old_P_file);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "rayleigh", E->control.Atemp);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "dissipation_number", E->control.disptn_number);
Maxwelltime:Output_h5.c:                                 (E->control.inv_gruneisen == 0)?
Maxwelltime:Output_h5.c:                                  1.0/E->control.inv_gruneisen :
Maxwelltime:Output_h5.c:				 E->control.inv_gruneisen);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "surfaceT", E->control.surface_temp);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "Q0", E->control.Q0);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "stokes_flow_only", E->control.stokes);
Maxwelltime:Output_h5.c:    status = set_attribute_string(input, "output_format", E->output.format);
Maxwelltime:Output_h5.c:    status = set_attribute_string(input, "output_optional", E->output.optional);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "output_ll_max", E->output.llmax);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "verbose", E->control.verbose);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "see_convergence", E->control.print_convergence);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "nproc_surf", E->parallel.nprocxy);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "nprocx", E->parallel.nprocx);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "nprocy", E->parallel.nprocy);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "nprocz", E->parallel.nprocz);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "coor", E->control.coor);
Maxwelltime:Output_h5.c:    status = set_attribute_string(input, "coor_file", E->control.coor_file);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "nodex", E->mesh.nox);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "nodey", E->mesh.noy);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "nodez", E->mesh.noz);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "levels", E->mesh.levels);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "mgunitx", E->mesh.mgunitx);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "mgunity", E->mesh.mgunity);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "mgunitz", E->mesh.mgunitz);
Maxwelltime:Output_h5.c:    status = set_attribute_double(input, "radius_outer", E->sphere.ro);
Maxwelltime:Output_h5.c:    status = set_attribute_double(input, "radius_inner", E->sphere.ri);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "caps", E->sphere.caps);
Maxwelltime:Output_h5.c:    dims[0] = E->sphere.caps;
Maxwelltime:Output_h5.c:    for(n = 1; n <= E->sphere.caps; n++)
Maxwelltime:Output_h5.c:        data[4*(n-1) + 0] = E->sphere.cap[n].theta[1];
Maxwelltime:Output_h5.c:        data[4*(n-1) + 1] = E->sphere.cap[n].theta[2];
Maxwelltime:Output_h5.c:        data[4*(n-1) + 2] = E->sphere.cap[n].theta[3];
Maxwelltime:Output_h5.c:        data[4*(n-1) + 3] = E->sphere.cap[n].theta[4];
Maxwelltime:Output_h5.c:    for(n = 1; n <= E->sphere.caps; n++)
Maxwelltime:Output_h5.c:        data[4*(n-1) + 0] = E->sphere.cap[n].fi[1];
Maxwelltime:Output_h5.c:        data[4*(n-1) + 1] = E->sphere.cap[n].fi[2];
Maxwelltime:Output_h5.c:        data[4*(n-1) + 2] = E->sphere.cap[n].fi[3];
Maxwelltime:Output_h5.c:        data[4*(n-1) + 3] = E->sphere.cap[n].fi[4];
Maxwelltime:Output_h5.c:    if (E->sphere.caps == 1)
Maxwelltime:Output_h5.c:        status = set_attribute_double(input, "theta_min", E->control.theta_min);
Maxwelltime:Output_h5.c:        status = set_attribute_double(input, "theta_max", E->control.theta_max);
Maxwelltime:Output_h5.c:        status = set_attribute_double(input, "fi_min", E->control.fi_min);
Maxwelltime:Output_h5.c:        status = set_attribute_double(input, "fi_max", E->control.fi_max);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "tracer", E->control.tracer);
Maxwelltime:Output_h5.c:    status = set_attribute_string(input, "tracer_file", E->trace.tracer_file);
Maxwelltime:Output_h5.c:    status = set_attribute_string(input, "Viscosity", E->viscosity.STRUCTURE);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "visc_smooth_method", E->viscosity.smooth_cycles);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "VISC_UPDATE", E->viscosity.update_allowed);
Maxwelltime:Output_h5.c:    n = E->viscosity.num_mat;
Maxwelltime:Output_h5.c:    status = set_attribute_float_vector(input, "visc0", n, E->viscosity.N0);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "TDEPV", E->viscosity.TDEPV);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "rheol", E->viscosity.RHEOL);
Maxwelltime:Output_h5.c:    status = set_attribute_float_vector(input, "viscE", n, E->viscosity.E);
Maxwelltime:Output_h5.c:    status = set_attribute_float_vector(input, "viscT", n, E->viscosity.T);
Maxwelltime:Output_h5.c:    status = set_attribute_float_vector(input, "viscZ", n, E->viscosity.Z);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "SDEPV", E->viscosity.SDEPV);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "sdepv_misfit", E->viscosity.sdepv_misfit);
Maxwelltime:Output_h5.c:    status = set_attribute_float_vector(input, "sdepv_expt", n, E->viscosity.sdepv_expt);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "VMIN", E->viscosity.MIN);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "visc_min", E->viscosity.min_value);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "VMAX", E->viscosity.MAX);
Maxwelltime:Output_h5.c:    status = set_attribute_float(input, "visc_max", E->viscosity.max_value);
Maxwelltime:Output_h5.c:    status = set_attribute_string(input, "Solver", E->control.SOLVER_TYPE);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "node_assemble", E->control.NASSEMBLE);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "precond", E->control.precondition);
Maxwelltime:Output_h5.c:    status = set_attribute_double(input, "accuracy", E->control.accuracy);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "mg_cycle", E->control.mg_cycle);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "down_heavy", E->control.down_heavy);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "up_heavy", E->control.up_heavy);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "vlowstep", E->control.v_steps_low);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "vhighstep", E->control.v_steps_high);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "piterations", E->control.p_iterations);
Maxwelltime:Output_h5.c:    status = set_attribute_int(input, "aug_lagr", E->control.augmented_Lagr);
Maxwelltime:Output_h5.c:    status = set_attribute_double(input, "aug_number", E->control.augmented);
Maxwelltime:Output_h5.c:    /* status = set_attribute(input, "", H5T_NATIVE_, &(E->)); */
Maxwelltime:Output_h5.c:    px = E->parallel.me_loc[1];
Maxwelltime:Output_h5.c:    py = E->parallel.me_loc[2];
Maxwelltime:Output_h5.c:    pz = E->parallel.me_loc[3];
Maxwelltime:Output_h5.c:    nprocx = E->parallel.nprocx;
Maxwelltime:Output_h5.c:    nprocy = E->parallel.nprocy;
Maxwelltime:Output_h5.c:    nprocz = E->parallel.nprocz;
Maxwelltime:Output_h5.c:    nodex = E->mesh.nox;
Maxwelltime:Output_h5.c:    nodey = E->mesh.noy;
Maxwelltime:Output_h5.c:    nodez = E->mesh.noz;
Maxwelltime:Output_h5.c:    nx = E->lmesh.nox;
Maxwelltime:Output_h5.c:    ny = E->lmesh.noy;
Maxwelltime:Output_h5.c:    nz = E->lmesh.noz;
Maxwelltime:Output_h5.c:            (*field)->dims[s] = E->sphere.caps;
Maxwelltime:Output_h5.c:            (*field)->maxdims[s] = E->sphere.caps;
Maxwelltime:Output_h5.c:            (*field)->offset[s] = E->hdf5.cap;
Maxwelltime:Output_h5.c:        if(E->control.verbose) {
Maxwelltime:Output_h5.c:            fprintf(E->fp_out, "creating dataset: rank=%d  size=%d\n",
Maxwelltime:Output_h5.c:            fprintf(E->fp_out, "  s=%d  x=%d  y=%d  z=%d  c=%d\n",
Maxwelltime:Output_h5.c:            fprintf(E->fp_out, "\tdim\tmaxdim\toffset\tstride\tcount\tblock\n");
Maxwelltime:Output_h5.c:                fprintf(E->fp_out, "\t%d\t%d\t%d\t%d\t%d\t%d\n",
Maxwelltime:Output_vtk.c:             E->lmesh.exs, E->lmesh.exs + E->lmesh.elx,
Maxwelltime:Output_vtk.c:             E->lmesh.eys, E->lmesh.eys + E->lmesh.ely,
Maxwelltime:Output_vtk.c:             E->lmesh.ezs, E->lmesh.ezs + E->lmesh.elz);
Maxwelltime:Output_vtk.c:    for(j=1; j<=E->sphere.caps_per_proc; j++) {
Maxwelltime:Output_vtk.c:        for(i=1; i<=E->lmesh.nno; i++) {
Maxwelltime:Output_vtk.c:            fprintf(fp, "%.6e\n", E->T[j][i]);
Maxwelltime:Output_vtk.c:    const int lev = E->mesh.levmax;
Maxwelltime:Output_vtk.c:    for(j=1; j<=E->sphere.caps_per_proc; j++) {
Maxwelltime:Output_vtk.c:        V[1] = E->sphere.cap[j].V[1];
Maxwelltime:Output_vtk.c:        V[2] = E->sphere.cap[j].V[2];
Maxwelltime:Output_vtk.c:        V[3] = E->sphere.cap[j].V[3];
Maxwelltime:Output_vtk.c:        for(i=1; i<=E->lmesh.nno; i++) {
Maxwelltime:Output_vtk.c:            sint = E->SinCos[lev][j][0][i];
Maxwelltime:Output_vtk.c:            sinf = E->SinCos[lev][j][1][i];
Maxwelltime:Output_vtk.c:            cost = E->SinCos[lev][j][2][i];
Maxwelltime:Output_vtk.c:            cosf = E->SinCos[lev][j][3][i];
Maxwelltime:Output_vtk.c:    int lev = E->mesh.levmax;
Maxwelltime:Output_vtk.c:    for(j=1; j<=E->sphere.caps_per_proc; j++) {
Maxwelltime:Output_vtk.c:        for(i=1; i<=E->lmesh.nno; i++)
Maxwelltime:Output_vtk.c:            fprintf(fp, "%.4e\n", E->VI[lev][j][i]);
Maxwelltime:Output_vtk.c:    for(j=1; j<=E->sphere.caps_per_proc; j++) {
Maxwelltime:Output_vtk.c:        for(i=1; i<=E->lmesh.nno; i++)
Maxwelltime:Output_vtk.c:                    E->x[j][1][i],
Maxwelltime:Output_vtk.c:                    E->x[j][2][i],
Maxwelltime:Output_vtk.c:                    E->x[j][3][i]);
Maxwelltime:Output_vtk.c:             E->control.data_file, E->parallel.me, cycles);
Maxwelltime:Pan_problem_misc_functions.c:   if (E->parallel.me==0) {
Maxwelltime:Pan_problem_misc_functions.c:    sprintf(unique_name,"%06d.%s-%s",E->control.PID,comment,name);
Maxwelltime:Pan_problem_misc_functions.c:  /* This function is called only when E->control.side_sbcs is true.
Maxwelltime:Pan_problem_misc_functions.c:  if(E->parallel.total_surf_proc==12) {
Maxwelltime:Pan_problem_misc_functions.c:  for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Pan_problem_misc_functions.c:    E->sbc.node[m] = (int* ) malloc((E->lmesh.nno+1)*sizeof(int));
Maxwelltime:Pan_problem_misc_functions.c:    for(i=1; i<=E->lmesh.nno; i++) {
Maxwelltime:Pan_problem_misc_functions.c:      if(E->node[m][i] & sbc_flags) {
Maxwelltime:Pan_problem_misc_functions.c:	E->sbc.node[m][i] = n;
Maxwelltime:Pan_problem_misc_functions.c:	E->sbc.node[m][i] = 0;
Maxwelltime:Pan_problem_misc_functions.c:      for(d=1; d<=E->mesh.nsd; d++) {
Maxwelltime:Pan_problem_misc_functions.c:	E->sbc.SB[m][side][d] = (double *) malloc(n*sizeof(double));
Maxwelltime:Pan_problem_misc_functions.c:	  E->sbc.SB[m][side][d][i] = 0;
Maxwelltime:Pan_problem_misc_functions.c:    for(d=1; d<=E->mesh.nsd; d++)
Maxwelltime:Pan_problem_misc_functions.c:      for(i=1; i<=E->lmesh.nno; i++)
Maxwelltime:Pan_problem_misc_functions.c:	if(E->node[m][i] & sbc_flag[d] && E->sphere.cap[m].VB[d][i] != 0) {
Maxwelltime:Pan_problem_misc_functions.c:	  j = E->sbc.node[m][i];
Maxwelltime:Pan_problem_misc_functions.c:	    E->sbc.SB[m][side][d][j] = E->sphere.cap[m].VB[d][i];
Maxwelltime:Pan_problem_misc_functions.c:    int lev = E->mesh.levmax;
Maxwelltime:Pan_problem_misc_functions.c:    nxny = E->lmesh.nox*E->lmesh.noy;
Maxwelltime:Pan_problem_misc_functions.c:    temp = E->control.Atemp;
Maxwelltime:Pan_problem_misc_functions.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Pan_problem_misc_functions.c:      for(i=1;i<=E->lmesh.nno;i++) {
Maxwelltime:Pan_problem_misc_functions.c:	nz = ((i-1) % E->lmesh.noz) + 1;
Maxwelltime:Pan_problem_misc_functions.c:        buoy[m][i] =  temp * E->refstate.rho[nz]
Maxwelltime:Pan_problem_misc_functions.c:	  * E->refstate.thermal_expansivity[nz] * E->T[m][i];
Maxwelltime:Pan_problem_misc_functions.c:    if(E->control.tracer &&
Maxwelltime:Pan_problem_misc_functions.c:       (E->composition.ichemical_buoyancy)) {
Maxwelltime:Pan_problem_misc_functions.c:      for(j=0;j<E->composition.ncomp;j++) {
Maxwelltime:Pan_problem_misc_functions.c:	temp2 = E->composition.buoyancy_ratio[j] * temp;
Maxwelltime:Pan_problem_misc_functions.c:            for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Pan_problem_misc_functions.c:	      for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Pan_problem_misc_functions.c:		buoy[m][i] -= temp2 * E->composition.comp_node[m][j][i];
Maxwelltime:Pan_problem_misc_functions.c:    if(E->control.ggrd.ray_control)
Maxwelltime:Pan_problem_misc_functions.c:    if(E->data.use_rotation_g){
Maxwelltime:Pan_problem_misc_functions.c:      rfac = E->data.ge*(5./2.*E->data.rotm-E->data.ellipticity);
Maxwelltime:Pan_problem_misc_functions.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Pan_problem_misc_functions.c:	  for(i=1;i<=E->lmesh.noz;i++)
Maxwelltime:Pan_problem_misc_functions.c:	    n = j*E->lmesh.noz + i; /* this could be improved by only
Maxwelltime:Pan_problem_misc_functions.c:	    cost2 = cos(E->sx[m][1][n]);cost2 = cost2*cost2;	    /* cos^2(theta) */
Maxwelltime:Pan_problem_misc_functions.c:	    buoy[m][n] *= E->refstate.gravity[i] * (E->data.ge+rfac*cost2);
Maxwelltime:Pan_problem_misc_functions.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Pan_problem_misc_functions.c:	  for(i=1;i<=E->lmesh.noz;i++){
Maxwelltime:Pan_problem_misc_functions.c:	    n = j*E->lmesh.noz + i;
Maxwelltime:Pan_problem_misc_functions.c:	    buoy[m][n] *= E->refstate.gravity[i];
Maxwelltime:Pan_problem_misc_functions.c:  lev = E->mesh.levmax;
Maxwelltime:Pan_problem_misc_functions.c:  st = E->SinCos[lev][cap][0][node]; /* for elliptical, sincos would be  corrected */
Maxwelltime:Pan_problem_misc_functions.c:  sp = E->SinCos[lev][cap][1][node];
Maxwelltime:Pan_problem_misc_functions.c:  ct = E->SinCos[lev][cap][2][node];
Maxwelltime:Pan_problem_misc_functions.c:  cp = E->SinCos[lev][cap][3][node];
Maxwelltime:Pan_problem_misc_functions.c:  E->control.verbose = 1;
Maxwelltime:Pan_problem_misc_functions.c:	  E->parallel.me,message);
Maxwelltime:Pan_problem_misc_functions.c:  brange = (double)E->control.coor_refine[0];
Maxwelltime:Pan_problem_misc_functions.c:  bfrac =  (double)E->control.coor_refine[1];
Maxwelltime:Pan_problem_misc_functions.c:  trange = (double)E->control.coor_refine[2];
Maxwelltime:Pan_problem_misc_functions.c:  tfrac = (double)E->control.coor_refine[3];
Maxwelltime:Pan_problem_misc_functions.c:  range = (double) E->sphere.ro - E->sphere.ri;		/* original range */
Maxwelltime:Pan_problem_misc_functions.c:  nb = E->mesh.noz * bfrac;
Maxwelltime:Pan_problem_misc_functions.c:  nt = E->mesh.noz * tfrac;
Maxwelltime:Pan_problem_misc_functions.c:  nm = E->mesh.noz - nb - nt;
Maxwelltime:Pan_problem_misc_functions.c:  for(r=E->sphere.ri,k=1;k<=nb;k++,r+=drb){
Maxwelltime:Pan_problem_misc_functions.c:  klim = E->mesh.noz - nt + 1;
Maxwelltime:Pan_problem_misc_functions.c:  for(;k <= E->mesh.noz;k++,r+=drt){
Maxwelltime:Pan_problem_misc_functions.c:rr[1...E->mesh.noz]
Maxwelltime:Pan_problem_misc_functions.c:  if(E->control.nrlayer[0] != 1)
Maxwelltime:Pan_problem_misc_functions.c:  if(E->control.nrlayer[E->control.rlayers-1] != E->mesh.noz)
Maxwelltime:Pan_problem_misc_functions.c:  if(fabs(E->control.rrlayer[0] -E->sphere.ri) > 1e-5)
Maxwelltime:Pan_problem_misc_functions.c:  if(fabs(E->control.rrlayer[ E->control.rlayers-1] - E->sphere.ro)>1e-6)
Maxwelltime:Pan_problem_misc_functions.c:  if(E->control.rlayers < 2)
Maxwelltime:Pan_problem_misc_functions.c:  rr[1] =  E->control.rrlayer[0];
Maxwelltime:Pan_problem_misc_functions.c:  for(j = 1; j < E->control.rlayers; j++){
Maxwelltime:Pan_problem_misc_functions.c:    ddr = (E->control.rrlayer[j] - E->control.rrlayer[j - 1]) /
Maxwelltime:Pan_problem_misc_functions.c:      (E->control.nrlayer[j] - E->control.nrlayer[j - 1]);
Maxwelltime:Pan_problem_misc_functions.c:    for(k = E->control.nrlayer[j-1]+1;k <= E->control.nrlayer[j];k++)
Maxwelltime:Pan_problem_misc_functions.c:  if(E->data.use_ellipse){
Maxwelltime:Pan_problem_misc_functions.c:    return M_PI_2 - atan2(tan(tmp),E->data.efac);
Maxwelltime:Parallel_util.c:  MPI_Barrier(E->parallel.world);
Maxwelltime:Parsing.c:    int m=E->parallel.me;
Maxwelltime:Phase_change.c:  int nno  = E->lmesh.nno;
Maxwelltime:Phase_change.c:  int nsf  = E->lmesh.nsf;
Maxwelltime:Phase_change.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Phase_change.c:    E->Fas410[j]   = (float *) malloc((nno+1)*sizeof(float));
Maxwelltime:Phase_change.c:    E->Fas410_b[j] = (float *) malloc((nsf+1)*sizeof(float));
Maxwelltime:Phase_change.c:    E->Fas670[j]   = (float *) malloc((nno+1)*sizeof(float));
Maxwelltime:Phase_change.c:    E->Fas670_b[j] = (float *) malloc((nsf+1)*sizeof(float));
Maxwelltime:Phase_change.c:    E->Fascmb[j]   = (float *) malloc((nno+1)*sizeof(float));
Maxwelltime:Phase_change.c:    E->Fascmb_b[j] = (float *) malloc((nsf+1)*sizeof(float));
Maxwelltime:Phase_change.c:  int m = E->parallel.me;
Maxwelltime:Phase_change.c:  input_float("Ra_410",&(E->control.Ra_410),"0.0",m);
Maxwelltime:Phase_change.c:  input_float("clapeyron410",&(E->control.clapeyron410),"0.0",m);
Maxwelltime:Phase_change.c:  input_float("transT410",&(E->control.transT410),"0.0",m);
Maxwelltime:Phase_change.c:    E->control.inv_width410 = 1.0/width;
Maxwelltime:Phase_change.c:  input_float("Ra_670",&(E->control.Ra_670),"0.0",m);
Maxwelltime:Phase_change.c:  input_float("clapeyron670",&(E->control.clapeyron670),"0.0",m);
Maxwelltime:Phase_change.c:  input_float("transT670",&(E->control.transT670),"0.0",m);
Maxwelltime:Phase_change.c:    E->control.inv_width670 = 1.0/width;
Maxwelltime:Phase_change.c:  input_float("Ra_cmb",&(E->control.Ra_cmb),"0.0",m);
Maxwelltime:Phase_change.c:  input_float("clapeyroncmb",&(E->control.clapeyroncmb),"0.0",m);
Maxwelltime:Phase_change.c:  input_float("transTcmb",&(E->control.transTcmb),"0.0",m);
Maxwelltime:Phase_change.c:    E->control.inv_widthcmb = 1.0/width;
Maxwelltime:Phase_change.c:  if (E->control.Ra_410 != 0.0)
Maxwelltime:Phase_change.c:    phase_change_apply(E, buoy, E->Fas410, E->Fas410_b, E->control.Ra_410,
Maxwelltime:Phase_change.c:		       E->control.clapeyron410, E->viscosity.z410,
Maxwelltime:Phase_change.c:		       E->control.transT410, E->control.inv_width410);
Maxwelltime:Phase_change.c:  if (E->control.Ra_670 != 0.0)
Maxwelltime:Phase_change.c:    phase_change_apply(E, buoy, E->Fas670, E->Fas670_b, E->control.Ra_670,
Maxwelltime:Phase_change.c:		       E->control.clapeyron670, E->viscosity.zlm,
Maxwelltime:Phase_change.c:		       E->control.transT670, E->control.inv_width670);
Maxwelltime:Phase_change.c:  if (E->control.Ra_cmb != 0.0)
Maxwelltime:Phase_change.c:    phase_change_apply(E, buoy, E->Fascmb, E->Fascmb_b, E->control.Ra_cmb,
Maxwelltime:Phase_change.c:		       E->control.clapeyroncmb, E->viscosity.zcmb,
Maxwelltime:Phase_change.c:		       E->control.transTcmb, E->control.inv_widthcmb);
Maxwelltime:Phase_change.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Phase_change.c:    for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Phase_change.c:  if (E->control.verbose) {
Maxwelltime:Phase_change.c:    fprintf(E->fp_out, "Ra=%f, clapeyron=%f, depth=%f, transT=%f, inv_width=%f\n",
Maxwelltime:Phase_change.c:    fflush(E->fp_out);
Maxwelltime:Phase_change.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Maxwelltime:Phase_change.c:    for(i=1;i<=E->lmesh.nno;i++)  {
Maxwelltime:Phase_change.c:        nz = ((i-1) % E->lmesh.noz) + 1;
Maxwelltime:Phase_change.c:        dz = (E->sphere.ro-E->sx[m][3][i]) - depth;
Maxwelltime:Phase_change.c:        e_pressure = dz * E->refstate.rho[nz] * E->refstate.gravity[nz]
Maxwelltime:Phase_change.c:            - clapeyron * (E->T[m][i] - transT);
Maxwelltime:Phase_change.c:    for (k=1;k<=E->lmesh.noy;k++)
Maxwelltime:Phase_change.c:      for (j=1;j<=E->lmesh.nox;j++)  {
Maxwelltime:Phase_change.c:        for (i=1;i<E->lmesh.noz;i++)   {
Maxwelltime:Phase_change.c:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Maxwelltime:Phase_change.c:            B_b[m][ns]=(E->sx[m][3][n+1]-E->sx[m][3][n])*(pt5-B[m][n])/(B[m][n+1]-B[m][n])+E->sx[m][3][n];
Maxwelltime:Phase_change.c:  fprintf(E->fp_out,"output_phase_change_buoyancy\n");
Maxwelltime:Phase_change.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)        {
Maxwelltime:Phase_change.c:    fprintf(E->fp_out,"for cap %d\n",E->sphere.capid[m]);
Maxwelltime:Phase_change.c:    for (j=1;j<=E->lmesh.nno;j++)
Maxwelltime:Phase_change.c:      fprintf(E->fp_out,"Z = %.6e T = %.6e B[%06d] = %.6e \n",E->sx[m][3][j],E->T[m][j],j,B[m][j]);
Maxwelltime:Phase_change.c:  fflush(E->fp_out);
Maxwelltime:Problem_related.c:    (E->solver.read_input_files_for_timesteps)(E,1,1); /* read velocity(1) and output(1) */
Maxwelltime:Problem_related.c:  (E->solver.read_input_files_for_timesteps)(E,4,1); /* read Rayleigh number for top layers */
Maxwelltime:Problem_related.c:    (E->solver.read_input_files_for_timesteps)(E,3,1); /* read element material(3) and output(1) */
Maxwelltime:Problem_related.c:    (E->solver.read_input_files_for_timesteps)(E,5,1); /* read temperature(5) and output(1) */
Maxwelltime:Problem_related.c:    E->monitor.elapsed_time = 0.0;
Maxwelltime:Problem_related.c:    if (E->convection.tic_method == -1) {
Maxwelltime:Problem_related.c:      if(strcmp(E->output.format, "ascii-gz") == 0){
Maxwelltime:Problem_related.c:	if(E->output.gzdir.vtk_io)
Maxwelltime:Problem_related.c:		  E->control.data_dir_old,E->monitor.solution_cycles_init,E->parallel.me,E->monitor.solution_cycles_init);
Maxwelltime:Problem_related.c:		  E->control.data_dir_old,E->monitor.solution_cycles_init,E->parallel.me,E->monitor.solution_cycles_init);
Maxwelltime:Problem_related.c:	sprintf(output_file, "%s.velo.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Maxwelltime:Problem_related.c:      sprintf(output_file, "%s.velo.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Maxwelltime:Problem_related.c:	fprintf(E->fp,"(Problem_related #8) Cannot open %s\n",output_file);
Maxwelltime:Problem_related.c:      if(sscanf(input_s,"%d %d %f",&ll,&mm,&E->monitor.elapsed_time) != 3) {
Maxwelltime:Problem_related.c:    if (E->control.zero_elapsed_time) /* set elapsed_time to zero */
Maxwelltime:Problem_related.c:	E->monitor.elapsed_time = 0.0;
Maxwelltime:Problem_related.c:    if (E->control.reset_startage)
Maxwelltime:Problem_related.c:	E->control.start_age = E->monitor.elapsed_time*E->data.scalet;
Maxwelltime:Problem_related.c:   if (E->data.timedir >= 0) { /* forward convection */
Maxwelltime:Problem_related.c:      age_in_MY = E->control.start_age - E->monitor.elapsed_time*E->data.scalet;
Maxwelltime:Problem_related.c:      age_in_MY = E->control.start_age + E->monitor.elapsed_time*E->data.scalet;
Maxwelltime:Problem_related.c:      if (((age_in_MY+e_4) < 0.0) && (E->monitor.solution_cycles < 1)) {
Maxwelltime:Problem_related.c:        if (E->parallel.me == 0) fprintf(stderr,"Age = %g Ma, Initial age should not be negative!\n",age_in_MY);
Maxwelltime:Process_buoyancy.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Process_buoyancy.c:    TG[m] = (float *)malloc((E->lmesh.nsf+2)*sizeof(float));
Maxwelltime:Process_buoyancy.c:  temp_c = (float *)malloc((E->sphere.hindice+2)*sizeof(float));
Maxwelltime:Process_buoyancy.c:  temp_s = (float *)malloc((E->sphere.hindice+2)*sizeof(float));
Maxwelltime:Process_buoyancy.c:  for (p=0;p<E->sphere.hindice;p++) {
Maxwelltime:Process_buoyancy.c:  if (E->parallel.me<E->parallel.nprocz)  { 
Maxwelltime:Process_buoyancy.c:    sprintf(output_file,"%s.temp_sph.%d%d",E->control.data_file,E->parallel.me,E->monitor.solution_cycles);
Maxwelltime:Process_buoyancy.c:    fprintf(fp1,"%d %d %.5e\n",E->monitor.solution_cycles,E->output.llmax,E->monitor.elapsed_time);
Maxwelltime:Process_buoyancy.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Process_buoyancy.c:    for (k=1;k<=E->lmesh.noz;k++)  {
Maxwelltime:Process_buoyancy.c:      for (i=1;i<=E->lmesh.noy;i++)
Maxwelltime:Process_buoyancy.c:        for (j=1;j<=E->lmesh.nox;j++)  {
Maxwelltime:Process_buoyancy.c:           node = k+(j-1)*E->lmesh.noz+(i-1)*E->lmesh.nox*E->lmesh.noz; 
Maxwelltime:Process_buoyancy.c:           snode = j+(i-1)*E->lmesh.nox; 
Maxwelltime:Process_buoyancy.c:           TG[m][snode] = E->T[m][node];
Maxwelltime:Process_buoyancy.c:      if (E->parallel.me<E->parallel.nprocz)  { 
Maxwelltime:Process_buoyancy.c:        fprintf(fp1,"%d %.4e \n",k,E->sx[m][3][k]);
Maxwelltime:Process_buoyancy.c:        for (ll=0;ll<=E->output.llmax;ll++)
Maxwelltime:Process_buoyancy.c:             p=E->sphere.hindex[ll][mm]; 
Maxwelltime:Process_buoyancy.c:  if (E->parallel.me<E->parallel.nprocz) 
Maxwelltime:Process_buoyancy.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Process_buoyancy.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Process_buoyancy.c:    const int nno=E->lmesh.nno;
Maxwelltime:Process_buoyancy.c:    const int lev = E->mesh.levmax;
Maxwelltime:Process_buoyancy.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Process_buoyancy.c:    for(e=1;e<=E->lmesh.nel;e++) {
Maxwelltime:Process_buoyancy.c:          u[i] += VV[3][j]*E->N.vpt[GNVINDEX(j,i)];
Maxwelltime:Process_buoyancy.c:          T[i] += E->T[m][E->ien[m][e].node[j]]*E->N.vpt[GNVINDEX(j,i)];
Maxwelltime:Process_buoyancy.c:          dTdz[i] += -E->T[m][E->ien[m][e].node[j]]*E->gNX[m][e].vpt[GNVXINDEX(2,j,i)];
Maxwelltime:Process_buoyancy.c:        uT += u[i]*T[i]*E->gDA[m][e].vpt[i] + dTdz[i]*E->gDA[m][e].vpt[i];
Maxwelltime:Process_buoyancy.c:      uT /= E->eco[m][e].area;
Maxwelltime:Process_buoyancy.c:        flux[m][E->ien[m][e].node[j]] += uT*E->TWW[lev][m][e].node[j];
Maxwelltime:Process_buoyancy.c:  (E->exchange_node_f)(E,flux,lev);
Maxwelltime:Process_buoyancy.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Process_buoyancy.c:       flux[m][i] *= E->MASS[lev][m][i];
Maxwelltime:Process_buoyancy.c:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Maxwelltime:Process_buoyancy.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Process_buoyancy.c:      for(i=1;i<=E->lmesh.nsf;i++)
Maxwelltime:Process_buoyancy.c:        E->slice.shflux[m][i]=2*flux[m][E->surf_node[m][i]]-flux[m][E->surf_node[m][i]-1];
Maxwelltime:Process_buoyancy.c:  if (E->parallel.me_loc[3]==0)
Maxwelltime:Process_buoyancy.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Process_buoyancy.c:      for(i=1;i<=E->lmesh.nsf;i++)
Maxwelltime:Process_buoyancy.c:        E->slice.bhflux[m][i] = 2*flux[m][E->surf_node[m][i]-E->lmesh.noz+1]
Maxwelltime:Process_buoyancy.c:                                - flux[m][E->surf_node[m][i]-E->lmesh.noz+2];
Maxwelltime:Process_buoyancy.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Process_buoyancy.c:    for(e=1;e<=E->lmesh.snel;e++) {
Maxwelltime:Process_buoyancy.c:         uT =(E->slice.shflux[m][E->sien[m][e].node[1]] +
Maxwelltime:Process_buoyancy.c:              E->slice.shflux[m][E->sien[m][e].node[2]] +
Maxwelltime:Process_buoyancy.c:              E->slice.shflux[m][E->sien[m][e].node[3]] +
Maxwelltime:Process_buoyancy.c:              E->slice.shflux[m][E->sien[m][e].node[4]])*0.25;
Maxwelltime:Process_buoyancy.c:         el = e*E->lmesh.elz;
Maxwelltime:Process_buoyancy.c:         sum_h[0] += uT*E->eco[m][el].area;
Maxwelltime:Process_buoyancy.c:         sum_h[1] += E->eco[m][el].area;
Maxwelltime:Process_buoyancy.c:         uT =(E->slice.bhflux[m][E->sien[m][e].node[1]] +
Maxwelltime:Process_buoyancy.c:              E->slice.bhflux[m][E->sien[m][e].node[2]] +
Maxwelltime:Process_buoyancy.c:              E->slice.bhflux[m][E->sien[m][e].node[3]] +
Maxwelltime:Process_buoyancy.c:              E->slice.bhflux[m][E->sien[m][e].node[4]])*0.25;
Maxwelltime:Process_buoyancy.c:         el = (e-1)*E->lmesh.elz+1;
Maxwelltime:Process_buoyancy.c:         sum_h[2] += uT*E->eco[m][el].area;
Maxwelltime:Process_buoyancy.c:         sum_h[3] += E->eco[m][el].area;
Maxwelltime:Process_buoyancy.c:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Maxwelltime:Process_buoyancy.c:    /*     if (E->control.verbose && E->parallel.me==E->parallel.nprocz-1) {
Maxwelltime:Process_buoyancy.c:	     fprintf(E->fp_out,"surface heat flux= %f %f\n",sum_h[0],E->monitor.elapsed_time);
Maxwelltime:Process_buoyancy.c:             fflush(E->fp_out);
Maxwelltime:Process_buoyancy.c:    if (E->parallel.me==E->parallel.nprocz-1) {
Maxwelltime:Process_buoyancy.c:      //fprintf(E->fp,"surface heat flux= %f\n",sum_h[0]); //commented out because E->fp is only on CPU 0 
Maxwelltime:Process_buoyancy.c:      if(E->output.write_q_files > 0){
Maxwelltime:Process_buoyancy.c:	fprintf(E->output.fpqt,"%13.5e %13.5e %13.5e\n",E->monitor.elapsed_time,sum_h[0],sqrt(E->monitor.vdotv));
Maxwelltime:Process_buoyancy.c:	fflush(E->output.fpqt);
Maxwelltime:Process_buoyancy.c:  if (E->parallel.me_loc[3]==0)    {
Maxwelltime:Process_buoyancy.c:/*     if (E->control.verbose && E->parallel.me==0) fprintf(E->fp_out,"bottom heat flux= %f %f\n",sum_h[2],E->monitor.elapsed_time); */
Maxwelltime:Process_buoyancy.c:    if (E->parallel.me==0) {
Maxwelltime:Process_buoyancy.c:      fprintf(E->fp,"bottom heat flux= %f\n",sum_h[2]);
Maxwelltime:Process_buoyancy.c:      if(E->output.write_q_files > 0){
Maxwelltime:Process_buoyancy.c:	fprintf(E->output.fpqb,"%13.5e %13.5e %13.5e\n",
Maxwelltime:Process_buoyancy.c:		E->monitor.elapsed_time,sum_h[2],sqrt(E->monitor.vdotv));
Maxwelltime:Process_buoyancy.c:	fflush(E->output.fpqb);
Maxwelltime:Process_buoyancy.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Process_buoyancy.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)      {
Maxwelltime:Process_buoyancy.c:	S1[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Maxwelltime:Process_buoyancy.c:	S2[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Maxwelltime:Process_buoyancy.c:	S3[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Maxwelltime:Process_buoyancy.c:    for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Process_buoyancy.c:	for(i=1;i<=E->lmesh.nno;i++) {
Maxwelltime:Process_buoyancy.c:	    S1[m][i] = E->T[m][i];
Maxwelltime:Process_buoyancy.c:	    S2[m][i] = E->sphere.cap[m].V[1][i]*E->sphere.cap[m].V[1][i]
Maxwelltime:Process_buoyancy.c:          	+ E->sphere.cap[m].V[2][i]*E->sphere.cap[m].V[2][i];
Maxwelltime:Process_buoyancy.c:	    S3[m][i] = E->sphere.cap[m].V[3][i]*E->sphere.cap[m].V[3][i];
Maxwelltime:Process_buoyancy.c:    return_horiz_ave_f(E,S1,E->Have.T);
Maxwelltime:Process_buoyancy.c:    return_horiz_ave_f(E,S2,E->Have.V[1]);
Maxwelltime:Process_buoyancy.c:    return_horiz_ave_f(E,S3,E->Have.V[2]);
Maxwelltime:Process_buoyancy.c:    if (E->composition.on) {
Maxwelltime:Process_buoyancy.c:        for(n=0; n<E->composition.ncomp; n++) {
Maxwelltime:Process_buoyancy.c:            for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Process_buoyancy.c:                for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Process_buoyancy.c:                    S1[m][i] = E->composition.comp_node[m][n][i];
Maxwelltime:Process_buoyancy.c:            return_horiz_ave_f(E,S1,E->Have.C[n]);
Maxwelltime:Process_buoyancy.c:    for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Process_buoyancy.c:    for (i=1;i<=E->lmesh.noz;i++) {
Maxwelltime:Process_buoyancy.c:	E->Have.V[1][i] = sqrt(E->Have.V[1][i]);
Maxwelltime:Process_buoyancy.c:	E->Have.V[2][i] = sqrt(E->Have.V[2][i]);
Maxwelltime:Regional_boundary_conditions.c:  for(lv=E->mesh.gridmax;lv>=E->mesh.gridmin;lv--)
Maxwelltime:Regional_boundary_conditions.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)     {
Maxwelltime:Regional_boundary_conditions.c:      noz = E->lmesh.NOZ[lv];
Maxwelltime:Regional_boundary_conditions.c:      if(E->mesh.topvbc == 0) {
Maxwelltime:Regional_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,1,0.0,VBX,0,lv,j);
Maxwelltime:Regional_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,VBZ,1,lv,j);
Maxwelltime:Regional_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,2,0.0,VBY,0,lv,j);
Maxwelltime:Regional_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,1,E->control.VBXtopval,SBX,1,lv,j);
Maxwelltime:Regional_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,SBZ,0,lv,j);
Maxwelltime:Regional_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,2,E->control.VBYtopval,SBY,1,lv,j);
Maxwelltime:Regional_boundary_conditions.c:      else if(E->mesh.topvbc == 1) {
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,E->control.VBXtopval,VBX,1,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,VBZ,1,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,E->control.VBYtopval,VBY,1,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,0.0,SBX,0,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,SBZ,0,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,0.0,SBY,0,lv,j);
Maxwelltime:Regional_boundary_conditions.c:	if(E->control.vbcs_file)   {
Maxwelltime:Regional_boundary_conditions.c:	  if((lv == E->mesh.gridmin) && (j == E->sphere.caps_per_proc))
Maxwelltime:Regional_boundary_conditions.c:      else if(E->mesh.topvbc == 2) {
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,0.0,VBX,0,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,VBZ,0,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,0.0,VBY,0,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,E->control.VBXtopval,SBX,1,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,SBZ,1,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,E->control.VBYtopval,SBY,1,lv,j);
Maxwelltime:Regional_boundary_conditions.c:      if(E->mesh.botvbc == 0) {
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,0.0,VBX,0,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,VBZ,1,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,0.0,VBY,0,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,E->control.VBXbotval,SBX,1,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,SBZ,0,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,E->control.VBYbotval,SBY,1,lv,j);
Maxwelltime:Regional_boundary_conditions.c:      else if(E->mesh.botvbc == 1) {
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,E->control.VBXbotval,VBX,1,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,VBZ,1,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,E->control.VBYbotval,VBY,1,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,0.0,SBX,0,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,SBZ,0,lv,j);
Maxwelltime:Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,0.0,SBY,0,lv,j);
Maxwelltime:Regional_boundary_conditions.c:      if(E->control.side_sbcs)
Maxwelltime:Regional_boundary_conditions.c:      if(E->control.verbose) {
Maxwelltime:Regional_boundary_conditions.c:	for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Regional_boundary_conditions.c:	  for (node=1;node<=E->lmesh.nno;node++)
Maxwelltime:Regional_boundary_conditions.c:	    fprintf(E->fp_out,"m=%d VB== %d %g %g %g flag %u %u %u\n",j,node,E->sphere.cap[j].VB[1][node],E->sphere.cap[j].VB[2][node],E->sphere.cap[j].VB[3][node],E->node[j][node]&VBX,E->node[j][node]&VBY,E->node[j][node]&VBZ);
Maxwelltime:Regional_boundary_conditions.c:	fflush(E->fp_out);
Maxwelltime:Regional_boundary_conditions.c:  lev = E->mesh.levmax;
Maxwelltime:Regional_boundary_conditions.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)    {
Maxwelltime:Regional_boundary_conditions.c:    noz = E->lmesh.noz;
Maxwelltime:Regional_boundary_conditions.c:    if(E->mesh.toptbc == 1)    {
Maxwelltime:Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,TBZ,1,lev,j);
Maxwelltime:Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,FBZ,0,lev,j);
Maxwelltime:Regional_boundary_conditions.c:      if(E->control.tbcs_file)   {
Maxwelltime:Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,TBZ,0,lev,j);
Maxwelltime:Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,FBZ,1,lev,j);
Maxwelltime:Regional_boundary_conditions.c:    if(E->mesh.bottbc == 1)    {
Maxwelltime:Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,TBZ,1,lev,j);
Maxwelltime:Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,FBZ,0,lev,j);
Maxwelltime:Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,TBZ,0,lev,j);
Maxwelltime:Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,FBZ,1,lev,j);
Maxwelltime:Regional_boundary_conditions.c:    if((E->control.temperature_bound_adj==1) || (E->control.lith_age_time==1))  {
Maxwelltime:Regional_boundary_conditions.c:   E->temperatures_conform_bcs = temperatures_conform_bcs;
Maxwelltime:Regional_boundary_conditions.c:  const int dims=E->mesh.nsd;
Maxwelltime:Regional_boundary_conditions.c:  if (E->parallel.me_loc[1]==0 || E->parallel.me_loc[1]==E->parallel.nprocx-1)
Maxwelltime:Regional_boundary_conditions.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Regional_boundary_conditions.c:    for(j=1;j<=E->lmesh.noy;j++)
Maxwelltime:Regional_boundary_conditions.c:      for(i=1;i<=E->lmesh.noz;i++)  {
Maxwelltime:Regional_boundary_conditions.c:        node1 = i + (j-1)*E->lmesh.noz*E->lmesh.nox;
Maxwelltime:Regional_boundary_conditions.c:        node2 = node1 + (E->lmesh.nox-1)*E->lmesh.noz;
Maxwelltime:Regional_boundary_conditions.c:        ii = i + E->lmesh.nzs - 1;
Maxwelltime:Regional_boundary_conditions.c:        if (E->parallel.me_loc[1]==0 )  {
Maxwelltime:Regional_boundary_conditions.c:           E->sphere.cap[m].VB[1][node1] = 0.0;
Maxwelltime:Regional_boundary_conditions.c:           if((ii != 1) && (ii != E->mesh.noz))
Maxwelltime:Regional_boundary_conditions.c:              E->sphere.cap[m].VB[3][node1] = 0.0;
Maxwelltime:Regional_boundary_conditions.c:        if (E->parallel.me_loc[1]==E->parallel.nprocx-1)  {
Maxwelltime:Regional_boundary_conditions.c:           E->sphere.cap[m].VB[1][node2] = 0.0;
Maxwelltime:Regional_boundary_conditions.c:           if((ii != 1) && (ii != E->mesh.noz))
Maxwelltime:Regional_boundary_conditions.c:              E->sphere.cap[m].VB[3][node2] = 0.0;
Maxwelltime:Regional_boundary_conditions.c:    if (E->parallel.me_loc[2]==0)
Maxwelltime:Regional_boundary_conditions.c:     for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Regional_boundary_conditions.c:      for(j=1;j<=E->lmesh.nox;j++)
Maxwelltime:Regional_boundary_conditions.c:        for(i=1;i<=E->lmesh.noz;i++)       {
Maxwelltime:Regional_boundary_conditions.c:          node1 = i + (j-1)*E->lmesh.noz;
Maxwelltime:Regional_boundary_conditions.c:          ii = i + E->lmesh.nzs - 1;
Maxwelltime:Regional_boundary_conditions.c:          E->sphere.cap[m].VB[2][node1] = 0.0;
Maxwelltime:Regional_boundary_conditions.c:          if((ii != 1) && (ii != E->mesh.noz))
Maxwelltime:Regional_boundary_conditions.c:            E->sphere.cap[m].VB[3][node1] = 0.0;
Maxwelltime:Regional_boundary_conditions.c:    if (E->parallel.me_loc[2]==E->parallel.nprocy-1)
Maxwelltime:Regional_boundary_conditions.c:     for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Regional_boundary_conditions.c:      for(j=1;j<=E->lmesh.nox;j++)
Maxwelltime:Regional_boundary_conditions.c:        for(i=1;i<=E->lmesh.noz;i++)       {
Maxwelltime:Regional_boundary_conditions.c:          node2 = (E->lmesh.noy-1)*E->lmesh.noz*E->lmesh.nox + i + (j-1)*E->lmesh.noz;
Maxwelltime:Regional_boundary_conditions.c:          ii = i + E->lmesh.nzs - 1;
Maxwelltime:Regional_boundary_conditions.c:          E->sphere.cap[m].VB[2][node2] = 0.0;
Maxwelltime:Regional_boundary_conditions.c:          if((ii != 1) && (ii != E->mesh.noz))
Maxwelltime:Regional_boundary_conditions.c:            E->sphere.cap[m].VB[3][node2] = 0.0;
Maxwelltime:Regional_boundary_conditions.c:  for(level=E->mesh.levmax;level>=E->mesh.levmin;level--) {
Maxwelltime:Regional_boundary_conditions.c:    if ( (E->control.CONJ_GRAD && level==E->mesh.levmax) ||E->control.NMULTIGRID)  {
Maxwelltime:Regional_boundary_conditions.c:    noz = E->lmesh.NOZ[level] ;
Maxwelltime:Regional_boundary_conditions.c:    noy = E->lmesh.NOY[level] ;
Maxwelltime:Regional_boundary_conditions.c:    nox = E->lmesh.NOX[level] ;
Maxwelltime:Regional_boundary_conditions.c:     for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Regional_boundary_conditions.c:       if (E->parallel.me_loc[1]==0 || E->parallel.me_loc[1]==E->parallel.nprocx-1) {
Maxwelltime:Regional_boundary_conditions.c:          ii = i + E->lmesh.NZS[level] - 1;
Maxwelltime:Regional_boundary_conditions.c:          if (E->parallel.me_loc[1]==0 )  {
Maxwelltime:Regional_boundary_conditions.c:            E->NODE[level][m][node1] = E->NODE[level][m][node1] | VBX;
Maxwelltime:Regional_boundary_conditions.c:            E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~SBX);
Maxwelltime:Regional_boundary_conditions.c:            if((ii!=1) && (ii!=E->mesh.NOZ[level])) {
Maxwelltime:Regional_boundary_conditions.c:               E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~VBY);
Maxwelltime:Regional_boundary_conditions.c:               E->NODE[level][m][node1] = E->NODE[level][m][node1] | SBY;
Maxwelltime:Regional_boundary_conditions.c:               E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~VBZ);
Maxwelltime:Regional_boundary_conditions.c:               E->NODE[level][m][node1] = E->NODE[level][m][node1] | SBZ;
Maxwelltime:Regional_boundary_conditions.c:          if (E->parallel.me_loc[1]==E->parallel.nprocx-1)  {
Maxwelltime:Regional_boundary_conditions.c:            E->NODE[level][m][node2] = E->NODE[level][m][node2] | VBX;
Maxwelltime:Regional_boundary_conditions.c:            E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~SBX);
Maxwelltime:Regional_boundary_conditions.c:            if((ii!=1) && (ii!=E->mesh.NOZ[level])) {
Maxwelltime:Regional_boundary_conditions.c:              E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~VBY);
Maxwelltime:Regional_boundary_conditions.c:              E->NODE[level][m][node2] = E->NODE[level][m][node2] | SBY;
Maxwelltime:Regional_boundary_conditions.c:              E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~VBZ);
Maxwelltime:Regional_boundary_conditions.c:              E->NODE[level][m][node2] = E->NODE[level][m][node2] | SBZ;
Maxwelltime:Regional_boundary_conditions.c:      if (E->parallel.me_loc[2]==0)
Maxwelltime:Regional_boundary_conditions.c:            ii = i + E->lmesh.NZS[level] - 1;
Maxwelltime:Regional_boundary_conditions.c:            jj = j + E->lmesh.NXS[level] - 1;
Maxwelltime:Regional_boundary_conditions.c:            E->NODE[level][m][node1] = E->NODE[level][m][node1] | VBY;
Maxwelltime:Regional_boundary_conditions.c:            E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~SBY);
Maxwelltime:Regional_boundary_conditions.c:            if((ii!= 1) && (ii != E->mesh.NOZ[level]))  {
Maxwelltime:Regional_boundary_conditions.c:                E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~VBZ);
Maxwelltime:Regional_boundary_conditions.c:                E->NODE[level][m][node1] = E->NODE[level][m][node1] | SBZ;
Maxwelltime:Regional_boundary_conditions.c:            if((jj!=1) && (jj!=E->mesh.NOX[level]) && (ii!=1) && (ii!=E->mesh.NOZ[level])){
Maxwelltime:Regional_boundary_conditions.c:                E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~VBX);
Maxwelltime:Regional_boundary_conditions.c:                E->NODE[level][m][node1] = E->NODE[level][m][node1] | SBX;
Maxwelltime:Regional_boundary_conditions.c:      if (E->parallel.me_loc[2]==E->parallel.nprocy-1)
Maxwelltime:Regional_boundary_conditions.c:            ii = i + E->lmesh.NZS[level] - 1;
Maxwelltime:Regional_boundary_conditions.c:            jj = j + E->lmesh.NXS[level] - 1;
Maxwelltime:Regional_boundary_conditions.c:            E->NODE[level][m][node2] = E->NODE[level][m][node2] | VBY;
Maxwelltime:Regional_boundary_conditions.c:            E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~SBY);
Maxwelltime:Regional_boundary_conditions.c:            if((ii!= 1) && (ii != E->mesh.NOZ[level]))  {
Maxwelltime:Regional_boundary_conditions.c:                E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~VBZ);
Maxwelltime:Regional_boundary_conditions.c:                E->NODE[level][m][node2] = E->NODE[level][m][node2] | SBZ;
Maxwelltime:Regional_boundary_conditions.c:            if((jj!=1) && (jj!=E->mesh.NOX[level]) && (ii!=1) && (ii!=E->mesh.NOZ[level])){
Maxwelltime:Regional_boundary_conditions.c:                E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~VBX);
Maxwelltime:Regional_boundary_conditions.c:                E->NODE[level][m][node2] = E->NODE[level][m][node2] | SBX;
Maxwelltime:Regional_boundary_conditions.c:  const int dims=E->mesh.nsd;
Maxwelltime:Regional_boundary_conditions.c:   if (E->parallel.me_loc[1]==0 || E->parallel.me_loc[1]==E->parallel.nprocx-1)
Maxwelltime:Regional_boundary_conditions.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Regional_boundary_conditions.c:    for(j=1;j<=E->lmesh.noy;j++)
Maxwelltime:Regional_boundary_conditions.c:      for(i=1;i<=E->lmesh.noz;i++) {
Maxwelltime:Regional_boundary_conditions.c:        node1 = i + (j-1)*E->lmesh.noz*E->lmesh.nox;
Maxwelltime:Regional_boundary_conditions.c:        node2 = node1 + (E->lmesh.nox-1)*E->lmesh.noz;
Maxwelltime:Regional_boundary_conditions.c:        if (E->parallel.me_loc[1]==0 )                   {
Maxwelltime:Regional_boundary_conditions.c:          E->node[m][node1] = E->node[m][node1] & (~TBX);
Maxwelltime:Regional_boundary_conditions.c:          E->node[m][node1] = E->node[m][node1] | FBX;
Maxwelltime:Regional_boundary_conditions.c:          E->sphere.cap[m].TB[1][node1] = 0.0;
Maxwelltime:Regional_boundary_conditions.c:        if (E->parallel.me_loc[1]==E->parallel.nprocx-1)   {
Maxwelltime:Regional_boundary_conditions.c:          E->node[m][node2] = E->node[m][node2] & (~TBX);
Maxwelltime:Regional_boundary_conditions.c:          E->node[m][node2] = E->node[m][node2] | FBX;
Maxwelltime:Regional_boundary_conditions.c:          E->sphere.cap[m].TB[1][node2] = 0.0;
Maxwelltime:Regional_boundary_conditions.c:    if (E->parallel.me_loc[2]==0)
Maxwelltime:Regional_boundary_conditions.c:     for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Regional_boundary_conditions.c:      for(j=1;j<=E->lmesh.nox;j++)
Maxwelltime:Regional_boundary_conditions.c:        for(i=1;i<=E->lmesh.noz;i++) {
Maxwelltime:Regional_boundary_conditions.c:          node1 = i + (j-1)*E->lmesh.noz;
Maxwelltime:Regional_boundary_conditions.c:          E->node[m][node1] = E->node[m][node1] & (~TBY);
Maxwelltime:Regional_boundary_conditions.c:              E->node[m][node1] = E->node[m][node1] | FBY;
Maxwelltime:Regional_boundary_conditions.c:              E->sphere.cap[m].TB[2][node1] = 0.0;
Maxwelltime:Regional_boundary_conditions.c:    if (E->parallel.me_loc[2]==E->parallel.nprocy-1)
Maxwelltime:Regional_boundary_conditions.c:     for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Regional_boundary_conditions.c:      for(j=1;j<=E->lmesh.nox;j++)
Maxwelltime:Regional_boundary_conditions.c:        for(i=1;i<=E->lmesh.noz;i++) {
Maxwelltime:Regional_boundary_conditions.c:          node2 = i +(j-1)*E->lmesh.noz + (E->lmesh.noy-1)*E->lmesh.noz*E->lmesh.nox;
Maxwelltime:Regional_boundary_conditions.c:          E->node[m][node2] = E->node[m][node2] & (~TBY);
Maxwelltime:Regional_boundary_conditions.c:          E->node[m][node2] = E->node[m][node2] | FBY;
Maxwelltime:Regional_boundary_conditions.c:          E->sphere.cap[m].TB[3][node2] = 0.0;
Maxwelltime:Regional_boundary_conditions.c:  if(dirn > E->mesh.nsd)
Maxwelltime:Regional_boundary_conditions.c:      rowl = E->lmesh.NOZ[level];
Maxwelltime:Regional_boundary_conditions.c:  if ( (ROW==1 && E->parallel.me_loc[3]==0) ||
Maxwelltime:Regional_boundary_conditions.c:       (ROW==E->lmesh.NOZ[level] && E->parallel.me_loc[3]==E->parallel.nprocz-1) ) {
Maxwelltime:Regional_boundary_conditions.c:      for(j=1;j<=E->lmesh.NOY[level];j++)
Maxwelltime:Regional_boundary_conditions.c:    	for(i=1;i<=E->lmesh.NOX[level];i++)     {
Maxwelltime:Regional_boundary_conditions.c:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+(j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Maxwelltime:Regional_boundary_conditions.c:    	  E->NODE[level][m][node] = E->NODE[level][m][node] & (~ mask);
Maxwelltime:Regional_boundary_conditions.c:      for(j=1;j<=E->lmesh.NOY[level];j++)
Maxwelltime:Regional_boundary_conditions.c:        for(i=1;i<=E->lmesh.NOX[level];i++)       {
Maxwelltime:Regional_boundary_conditions.c:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+(j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Maxwelltime:Regional_boundary_conditions.c:    	  E->NODE[level][m][node] = E->NODE[level][m][node] | (mask);
Maxwelltime:Regional_boundary_conditions.c:    	  if(level==E->mesh.levmax)   /* NB */
Maxwelltime:Regional_boundary_conditions.c:  const int dims=E->mesh.nsd;
Maxwelltime:Regional_boundary_conditions.c:  fprintf(E->fp,"Periodic boundary conditions\n");
Maxwelltime:Regional_boundary_conditions.c: const int dims=E->mesh.nsd;
Maxwelltime:Regional_boundary_conditions.c: fprintf(E->fp,"pERIodic temperature boundary conditions\n");
Maxwelltime:Regional_geometry_cartesian.c:  E->mesh.nsd = 2;
Maxwelltime:Regional_geometry_cartesian.c:  E->mesh.dof = 2;
Maxwelltime:Regional_geometry_cartesian.c:  E->mesh.nsd = 2;
Maxwelltime:Regional_geometry_cartesian.c:  E->mesh.dof = 3;
Maxwelltime:Regional_geometry_cartesian.c:  E->mesh.nsd = 3;
Maxwelltime:Regional_geometry_cartesian.c:  E->mesh.dof = 3;
Maxwelltime:Regional_geometry_cartesian.c:  E->mesh.nsd = 3;
Maxwelltime:Regional_geometry_cartesian.c:  E->mesh.dof = 3;
Maxwelltime:Regional_geometry_cartesian.c:  E->sphere.caps = 1;
Maxwelltime:Regional_geometry_cartesian.c:  E->sphere.max_connections = 6;
Maxwelltime:Regional_obsolete.c:  E->parallel.me = 0;
Maxwelltime:Regional_obsolete.c:  E->parallel.nproc = 1;
Maxwelltime:Regional_obsolete.c:  E->parallel.me_loc[1] = 0;
Maxwelltime:Regional_obsolete.c:  E->parallel.me_loc[2] = 0;
Maxwelltime:Regional_obsolete.c:  E->parallel.me_loc[3] = 0;
Maxwelltime:Regional_obsolete.c:  MPI_Comm_rank(E->parallel.world, &(E->parallel.me) );
Maxwelltime:Regional_obsolete.c:  MPI_Comm_size(E->parallel.world, &(E->parallel.nproc) );
Maxwelltime:Regional_obsolete.c:  const int dims = E->mesh.nsd;
Maxwelltime:Regional_obsolete.c:  if (E->parallel.nprocz==1)  {
Maxwelltime:Regional_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"scatter_to_nlayer should not be called\n");
Maxwelltime:Regional_obsolete.c:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Maxwelltime:Regional_obsolete.c:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Maxwelltime:Regional_obsolete.c:    SD = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Maxwelltime:Regional_obsolete.c:    rootid = E->parallel.me_sph*E->parallel.nprocz; /* which is the bottom cpu */
Maxwelltime:Regional_obsolete.c:    for (j=0;j<E->parallel.nprocz;j++) {
Maxwelltime:Regional_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Regional_obsolete.c:    if (E->parallel.me==rootid)
Maxwelltime:Regional_obsolete.c:      for (d=0;d<E->parallel.nprocz;d++)  {
Maxwelltime:Regional_obsolete.c:        for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Maxwelltime:Regional_obsolete.c:          k1 = k + d*E->lmesh.ELZ[lev];
Maxwelltime:Regional_obsolete.c:          for (j=1;j<=E->lmesh.NOY[lev];j++)
Maxwelltime:Regional_obsolete.c:            for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Maxwelltime:Regional_obsolete.c:              node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Maxwelltime:Regional_obsolete.c:              node1= k1+ (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Maxwelltime:Regional_obsolete.c:	  MPI_Send(SD,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],rootid,E->parallel.world);
Maxwelltime:Regional_obsolete.c:	  for (i=0;i<=E->lmesh.NEQ[lev];i++)
Maxwelltime:Regional_obsolete.c:      MPI_Recv(AUo[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,rootid,E->parallel.world,&status);
Maxwelltime:Regional_obsolete.c:  const int dims = E->mesh.nsd;
Maxwelltime:Regional_obsolete.c:  if (E->parallel.nprocz==1)  {
Maxwelltime:Regional_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Maxwelltime:Regional_obsolete.c:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Maxwelltime:Regional_obsolete.c:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Maxwelltime:Regional_obsolete.c:    RV = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Maxwelltime:Regional_obsolete.c:    rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Maxwelltime:Regional_obsolete.c:    for (j=0;j<E->parallel.nprocz;j++) {
Maxwelltime:Regional_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Regional_obsolete.c:    if (E->parallel.me!=rootid)
Maxwelltime:Regional_obsolete.c:      MPI_Send(AUi[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,E->parallel.me,E->parallel.world);
Maxwelltime:Regional_obsolete.c:      for (d=0;d<E->parallel.nprocz;d++) {
Maxwelltime:Regional_obsolete.c:	  MPI_Recv(RV,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],processors[d],E->parallel.world,&status);
Maxwelltime:Regional_obsolete.c:	  for (node=0;node<E->lmesh.NEQ[lev];node++)
Maxwelltime:Regional_obsolete.c:	for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Maxwelltime:Regional_obsolete.c:	  k1 = k + d*E->lmesh.ELZ[lev];
Maxwelltime:Regional_obsolete.c:	  for (j=1;j<=E->lmesh.NOY[lev];j++)
Maxwelltime:Regional_obsolete.c:	    for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Maxwelltime:Regional_obsolete.c:	      node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Maxwelltime:Regional_obsolete.c:	      node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Maxwelltime:Regional_obsolete.c:  if (E->parallel.nprocz==1)  {
Maxwelltime:Regional_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Maxwelltime:Regional_obsolete.c:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Maxwelltime:Regional_obsolete.c:    NNO = NOZ*E->lmesh.NOX[lev]*E->lmesh.NOY[lev];
Maxwelltime:Regional_obsolete.c:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Maxwelltime:Regional_obsolete.c:    RV = (float *)malloc((E->lmesh.NNO[lev]+2)*sizeof(float));
Maxwelltime:Regional_obsolete.c:    rootid = E->parallel.me_sph*E->parallel.nprocz; /* which is the bottom cpu */
Maxwelltime:Regional_obsolete.c:    for (j=0;j<E->parallel.nprocz;j++) {
Maxwelltime:Regional_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Regional_obsolete.c:    if (E->parallel.me!=rootid) {
Maxwelltime:Regional_obsolete.c:      MPI_Send(AUi[m],E->lmesh.NNO[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Maxwelltime:Regional_obsolete.c:      for (d=0;d<E->parallel.nprocz;d++) {
Maxwelltime:Regional_obsolete.c:	  MPI_Recv(RV,E->lmesh.NNO[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Maxwelltime:Regional_obsolete.c:	  for (node=1;node<=E->lmesh.NNO[lev];node++)
Maxwelltime:Regional_obsolete.c:	for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Maxwelltime:Regional_obsolete.c:	  k1 = k + d*E->lmesh.ELZ[lev];
Maxwelltime:Regional_obsolete.c:	  for (j=1;j<=E->lmesh.NOY[lev];j++)
Maxwelltime:Regional_obsolete.c:	    for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Maxwelltime:Regional_obsolete.c:	      node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Maxwelltime:Regional_obsolete.c:	      node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Maxwelltime:Regional_obsolete.c:  if (E->parallel.nprocz==1)  {
Maxwelltime:Regional_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Maxwelltime:Regional_obsolete.c:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz;
Maxwelltime:Regional_obsolete.c:    NNO = NOZ*E->lmesh.ELX[lev]*E->lmesh.ELY[lev];
Maxwelltime:Regional_obsolete.c:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Maxwelltime:Regional_obsolete.c:    RV = (float *)malloc((E->lmesh.NEL[lev]+2)*sizeof(float));
Maxwelltime:Regional_obsolete.c:    rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Maxwelltime:Regional_obsolete.c:    for (j=0;j<E->parallel.nprocz;j++) {
Maxwelltime:Regional_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Regional_obsolete.c:    if (E->parallel.me!=rootid) {
Maxwelltime:Regional_obsolete.c:      MPI_Send(AUi[m],E->lmesh.NEL[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Maxwelltime:Regional_obsolete.c:      for (d=0;d<E->parallel.nprocz;d++) {
Maxwelltime:Regional_obsolete.c:	  MPI_Recv(RV,E->lmesh.NEL[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Maxwelltime:Regional_obsolete.c:	  for (e=1;e<=E->lmesh.NEL[lev];e++)
Maxwelltime:Regional_obsolete.c:	for (k=1;k<=E->lmesh.ELZ[lev];k++)   {
Maxwelltime:Regional_obsolete.c:	  k1 = k + d*E->lmesh.ELZ[lev];
Maxwelltime:Regional_obsolete.c:	  for (j=1;j<=E->lmesh.ELY[lev];j++)
Maxwelltime:Regional_obsolete.c:	    for (i=1;i<=E->lmesh.ELX[lev];i++)   {
Maxwelltime:Regional_obsolete.c:	      e = k + (i-1)*E->lmesh.ELZ[lev] + (j-1)*E->lmesh.ELZ[lev]*E->lmesh.ELX[lev];
Maxwelltime:Regional_obsolete.c:	      e1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.ELX[lev];
Maxwelltime:Regional_obsolete.c:  if (E->parallel.nprocxy==1)   return;
Maxwelltime:Regional_obsolete.c:  nsl = E->sphere.nsf+1;
Maxwelltime:Regional_obsolete.c:  me = E->parallel.me;
Maxwelltime:Regional_obsolete.c:    for (i=1;i<E->parallel.nprocxy;i++)
Maxwelltime:Regional_obsolete.c:      RG[i] = ( float *)malloc((E->sphere.nsf+1)*sizeof(float));
Maxwelltime:Regional_obsolete.c:  for (i=1;i<=E->parallel.nprocxy;i++)  {
Maxwelltime:Regional_obsolete.c:    to_everyone = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Maxwelltime:Regional_obsolete.c:      MPI_Isend(TG,nsl,MPI_FLOAT,to_everyone,mst,E->parallel.world,&request[idb-1]);
Maxwelltime:Regional_obsolete.c:  for (i=1;i<=E->parallel.nprocxy;i++)  {
Maxwelltime:Regional_obsolete.c:    from_proc = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Maxwelltime:Regional_obsolete.c:      MPI_Irecv(RG[idb],nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&request[idb-1]);
Maxwelltime:Regional_obsolete.c:  for (i=1;i<E->parallel.nprocxy;i++)
Maxwelltime:Regional_obsolete.c:    for (j=1;j<=E->sphere.nsf; j++)  {
Maxwelltime:Regional_obsolete.c:  nox=E->lmesh.nox;
Maxwelltime:Regional_obsolete.c:  noz=E->lmesh.noz;
Maxwelltime:Regional_obsolete.c:  noy=E->lmesh.noy;
Maxwelltime:Regional_obsolete.c:  lev=E->mesh.levmax;
Maxwelltime:Regional_obsolete.c:  if(E->advection.timesteps>1)  {
Maxwelltime:Regional_obsolete.c:    fxx1=fxx1+E->advection.timestep*vxx1;
Maxwelltime:Regional_obsolete.c:    fxx2=fxx2+E->advection.timestep*vxx1;
Maxwelltime:Regional_obsolete.c:  if (E->parallel.me_loc[3] == E->parallel.nprocz-1 ) {
Maxwelltime:Regional_obsolete.c:	fyy=E->SX[lev][1][1][nodel];
Maxwelltime:Regional_obsolete.c:	  E->sphere.cap[1].VB[1][nodel]=0.0;
Maxwelltime:Regional_obsolete.c:	  E->sphere.cap[1].VB[2][nodel]=-vvc;
Maxwelltime:Regional_obsolete.c:	  E->sphere.cap[1].VB[3][nodel]=0.0;
Maxwelltime:Regional_obsolete.c:	  if (E->SX[lev][1][2][nodel]>=0.00 && E->SX[lev][1][2][nodel]<= fxx1) {
Maxwelltime:Regional_obsolete.c:	    E->sphere.cap[1].VB[1][nodel]=0.0;
Maxwelltime:Regional_obsolete.c:	    E->sphere.cap[1].VB[2][nodel]=vvo;
Maxwelltime:Regional_obsolete.c:	    E->sphere.cap[1].VB[3][nodel]=0.0;
Maxwelltime:Regional_obsolete.c:	  else if ( E->SX[lev][1][2][nodel]>fxx1 && E->SX[lev][1][2][nodel]<fxx2) {
Maxwelltime:Regional_obsolete.c:	    E->sphere.cap[1].VB[1][nodel]=0.0;
Maxwelltime:Regional_obsolete.c:	    E->sphere.cap[1].VB[2][nodel]=vxx1;
Maxwelltime:Regional_obsolete.c:	    E->sphere.cap[1].VB[3][nodel]=0.0;
Maxwelltime:Regional_obsolete.c:	  else if ( E->SX[lev][1][2][nodel]>=fxx2) {
Maxwelltime:Regional_obsolete.c:	    E->sphere.cap[1].VB[1][nodel]=0.0;
Maxwelltime:Regional_obsolete.c:	    E->sphere.cap[1].VB[2][nodel]=vvc;
Maxwelltime:Regional_obsolete.c:	    E->sphere.cap[1].VB[3][nodel]=0.0;
Maxwelltime:Regional_obsolete.c:  }    /* end of E->parallel.me_loc[3]   */
Maxwelltime:Regional_obsolete.c:  size2= (E->lmesh.nno+1)*sizeof(float);
Maxwelltime:Regional_obsolete.c:  sprintf(output_file,"%s.%05d.SZZ",E->control.data_file,file_number);
Maxwelltime:Regional_obsolete.c:  if (E->parallel.me==proc_loc)  {
Maxwelltime:Regional_obsolete.c:    sprintf(output_file,"%s.%s_intp",E->control.data_file,filen);
Maxwelltime:Regional_obsolete.c:      fprintf(E->fp,"(Output.c #7) Cannot open %s\n",output_file);
Maxwelltime:Regional_obsolete.c:    for (i=E->sphere.nox;i>=1;i--)
Maxwelltime:Regional_obsolete.c:      for (j=1;j<=E->sphere.noy;j++)  {
Maxwelltime:Regional_obsolete.c:        node = i + (j-1)*E->sphere.nox;
Maxwelltime:Regional_obsolete.c:        t = 90-E->sphere.sx[1][node]*rad;
Maxwelltime:Regional_obsolete.c:        f = E->sphere.sx[2][node]*rad;
Maxwelltime:Regional_obsolete.c:    fprintf(E->fp,"lmaxx=%.4e lminx=%.4e for %s\n",maxx,minx,filen);
Maxwelltime:Regional_obsolete.c:    sprintf(output_file,"%s.%s_sharm",E->control.data_file,filen);
Maxwelltime:Regional_obsolete.c:      fprintf(E->fp,"(Output.c #8) Cannot open %s\n",output_file);
Maxwelltime:Regional_obsolete.c:    for (ll=0;ll<=E->output.llmax;ll++)
Maxwelltime:Regional_obsolete.c:        i = E->sphere.hindex[ll][mm];
Maxwelltime:Regional_obsolete.c:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)      {
Maxwelltime:Regional_obsolete.c:    sprintf(output_file,"%s.surf.%d.%d",E->control.data_file,E->parallel.me,cycles);
Maxwelltime:Regional_obsolete.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Regional_obsolete.c:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Maxwelltime:Regional_obsolete.c:      for(i=1;i<=E->lmesh.nsf;i++)   {
Maxwelltime:Regional_obsolete.c:	s = i*E->lmesh.noz;
Maxwelltime:Regional_obsolete.c:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpg[j][i],E->slice.shflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Maxwelltime:Regional_obsolete.c:  if (E->parallel.me_loc[3]==0)      {
Maxwelltime:Regional_obsolete.c:    sprintf(output_file,"%s.botm.%d.%d",E->control.data_file,E->parallel.me,cycles);
Maxwelltime:Regional_obsolete.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Regional_obsolete.c:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Maxwelltime:Regional_obsolete.c:      for(i=1;i<=E->lmesh.nsf;i++)  {
Maxwelltime:Regional_obsolete.c:	s = (i-1)*E->lmesh.noz + 1;
Maxwelltime:Regional_obsolete.c:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpgb[j][i],E->slice.bhflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Maxwelltime:Regional_obsolete.c:/*    if (E->parallel.me<E->parallel.nprocz)  { */
Maxwelltime:Regional_obsolete.c:/*      sprintf(output_file,"%s.ave_r.%d.%d",E->control.data_file,E->parallel.me,cycles); */
Maxwelltime:Regional_obsolete.c:/*            fprintf(E->fp,"(Output.c #6) Cannot open %s\n",output_file); */
Maxwelltime:Regional_obsolete.c:/*      for(j=1;j<=E->lmesh.noz;j++)  { */
Maxwelltime:Regional_obsolete.c:/*          fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->sx[1][3][j],E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j]); */
Maxwelltime:Regional_obsolete.c:  const int lev = E->mesh.levmax;
Maxwelltime:Regional_obsolete.c:  const int nsd = E->mesh.nsd;
Maxwelltime:Regional_obsolete.c:  // E->sphere.caps_per_proc. Later, when elemental viscosity is written
Maxwelltime:Regional_obsolete.c:  int size2 = (E->lmesh.nel+1)*sizeof(float);
Maxwelltime:Regional_obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Regional_obsolete.c:    VN[m]=(float *)malloc((1+E->lmesh.nel*vpts)*sizeof(float));
Maxwelltime:Regional_obsolete.c:  for(i=1;i<=E->lmesh.nel;i++)
Maxwelltime:Regional_obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Regional_obsolete.c:  sprintf(output_file,"%s.visc.%d.%d",E->control.data_file,E->parallel.me,cycles);
Maxwelltime:Regional_obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Regional_obsolete.c:    VE[m]=(float *)malloc((1+E->lmesh.nno)*sizeof(float));
Maxwelltime:Regional_obsolete.c:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Regional_obsolete.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Maxwelltime:Regional_obsolete.c:    for(i=1;i<=E->lmesh.nno;i++)
Maxwelltime:Regional_obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Regional_obsolete.c:    record_h = E->control.record_every/10;  */
Maxwelltime:Regional_obsolete.c:    record_h = E->control.record_every;
Maxwelltime:Regional_obsolete.c:/*    if ( ((ii % record_h) == 0) || E->control.DIRECTII)    { */
Maxwelltime:Regional_obsolete.c:    if ( (ii == 0) || ((ii % record_h) == 0) || E->control.DIRECTII)    {
Maxwelltime:Regional_obsolete.c:/*    if ( ((ii % E->control.record_every) == 0) || E->control.DIRECTII)  { */
Maxwelltime:Regional_obsolete.c:    if ( ((ii == 0) || ((ii % E->control.record_every) == 0))
Maxwelltime:Regional_obsolete.c:		|| E->control.DIRECTII)     {
Maxwelltime:Regional_obsolete.c:    if ( (ii == 0) || ((ii % E->control.record_every) == 0)
Maxwelltime:Regional_obsolete.c:		|| E->control.DIRECTII)     {
Maxwelltime:Regional_obsolete.c:      get_STD_topo(E,E->slice.tpg,E->slice.tpgb,E->slice.divg,E->slice.vort,ii);
Maxwelltime:Regional_obsolete.c:  const int dims=E->mesh.nsd;
Maxwelltime:Regional_obsolete.c:  const int nno=E->lmesh.nno;
Maxwelltime:Regional_obsolete.c:  lev = E->mesh.levmax;
Maxwelltime:Regional_obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Regional_obsolete.c:      if (node%E->lmesh.noz==0)   {
Maxwelltime:Regional_obsolete.c:        i = node/E->lmesh.noz;
Maxwelltime:Regional_obsolete.c:        SV[(i-1)*2+1] = E->sphere.cap[m].V[1][node];
Maxwelltime:Regional_obsolete.c:        SV[(i-1)*2+2] = E->sphere.cap[m].V[2][node];
Maxwelltime:Regional_parallel_related.c:  me = E->parallel.me;
Maxwelltime:Regional_parallel_related.c:  surf_proc_per_cap = E->parallel.nprocx * E->parallel.nprocy;
Maxwelltime:Regional_parallel_related.c:  proc_per_cap = surf_proc_per_cap * E->parallel.nprocz;
Maxwelltime:Regional_parallel_related.c:  total_proc = E->sphere.caps * proc_per_cap;
Maxwelltime:Regional_parallel_related.c:  E->parallel.total_surf_proc = E->sphere.caps * surf_proc_per_cap;
Maxwelltime:Regional_parallel_related.c:  if ( total_proc != E->parallel.nproc ) {
Maxwelltime:Regional_parallel_related.c:    if (E->parallel.me==0) fprintf(stderr,"!!!! # of requested CPU is incorrect \n");
Maxwelltime:Regional_parallel_related.c:  j = me % E->parallel.nprocz;
Maxwelltime:Regional_parallel_related.c:  E->parallel.me_loc[3] = j;
Maxwelltime:Regional_parallel_related.c:  k = (me - j)/E->parallel.nprocz % E->parallel.nprocx;
Maxwelltime:Regional_parallel_related.c:  E->parallel.me_loc[1] = k;
Maxwelltime:Regional_parallel_related.c:  i = ((me - j)/E->parallel.nprocz - k)/E->parallel.nprocx % E->parallel.nprocy;
Maxwelltime:Regional_parallel_related.c:  E->parallel.me_loc[2] = i;
Maxwelltime:Regional_parallel_related.c:  E->sphere.caps_per_proc = 1;
Maxwelltime:Regional_parallel_related.c:  pid_surf = me/E->parallel.nprocz;
Maxwelltime:Regional_parallel_related.c:  i = cases[E->sphere.caps_per_proc];
Maxwelltime:Regional_parallel_related.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Regional_parallel_related.c:    E->sphere.capid[j] = 1;
Maxwelltime:Regional_parallel_related.c:  E->parallel.loc2proc_map = (int ****) malloc(E->sphere.caps*sizeof(int ***));
Maxwelltime:Regional_parallel_related.c:  for (m=0;m<E->sphere.caps;m++)  {
Maxwelltime:Regional_parallel_related.c:    E->parallel.loc2proc_map[m] = (int ***) malloc(E->parallel.nprocx*sizeof(int **));
Maxwelltime:Regional_parallel_related.c:    for (i=0;i<E->parallel.nprocx;i++) {
Maxwelltime:Regional_parallel_related.c:      E->parallel.loc2proc_map[m][i] = (int **) malloc(E->parallel.nprocy*sizeof(int *));
Maxwelltime:Regional_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++)
Maxwelltime:Regional_parallel_related.c:	E->parallel.loc2proc_map[m][i][j] = (int *) malloc(E->parallel.nprocz*sizeof(int));
Maxwelltime:Regional_parallel_related.c:  for (m=0;m<E->sphere.caps;m++)
Maxwelltime:Regional_parallel_related.c:    for (i=0;i<E->parallel.nprocx;i++)
Maxwelltime:Regional_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++)
Maxwelltime:Regional_parallel_related.c:	for (k=0;k<E->parallel.nprocz;k++) {
Maxwelltime:Regional_parallel_related.c:	    E->parallel.loc2proc_map[m][i][j][k] = m*proc_per_cap
Maxwelltime:Regional_parallel_related.c:	      + j*E->parallel.nprocx*E->parallel.nprocz
Maxwelltime:Regional_parallel_related.c:	      + i*E->parallel.nprocz + k;
Maxwelltime:Regional_parallel_related.c:  if (E->control.verbose) {
Maxwelltime:Regional_parallel_related.c:    fprintf(E->fp_out,"me=%d loc1=%d loc2=%d loc3=%d\n",me,E->parallel.me_loc[1],E->parallel.me_loc[2],E->parallel.me_loc[3]);
Maxwelltime:Regional_parallel_related.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Regional_parallel_related.c:      fprintf(E->fp_out,"capid[%d]=%d \n",j,E->sphere.capid[j]);
Maxwelltime:Regional_parallel_related.c:    for (m=0;m<E->sphere.caps;m++)
Maxwelltime:Regional_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++)
Maxwelltime:Regional_parallel_related.c:	for (i=0;i<E->parallel.nprocx;i++)
Maxwelltime:Regional_parallel_related.c:	  for (k=0;k<E->parallel.nprocz;k++)
Maxwelltime:Regional_parallel_related.c:	    fprintf(E->fp_out,"loc2proc_map[cap=%d][x=%d][y=%d][z=%d] = %d\n",
Maxwelltime:Regional_parallel_related.c:		    m,i,j,k,E->parallel.loc2proc_map[m][i][j][k]);
Maxwelltime:Regional_parallel_related.c:    fflush(E->fp_out);
Maxwelltime:Regional_parallel_related.c:  E->exchange_node_d = exchange_node_d;
Maxwelltime:Regional_parallel_related.c:  E->exchange_node_f = exchange_node_f;
Maxwelltime:Regional_parallel_related.c:  processors = (int *) malloc((E->parallel.total_surf_proc+1)*sizeof(int));
Maxwelltime:Regional_parallel_related.c:  k = E->parallel.me_loc[3];
Maxwelltime:Regional_parallel_related.c:  for (m=0;m<E->sphere.caps;m++)
Maxwelltime:Regional_parallel_related.c:    for (i=0;i<E->parallel.nprocx;i++)
Maxwelltime:Regional_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++) {
Maxwelltime:Regional_parallel_related.c:	processors[n] = E->parallel.loc2proc_map[m][i][j][k];
Maxwelltime:Regional_parallel_related.c:  if (E->control.verbose) {
Maxwelltime:Regional_parallel_related.c:    fprintf(E->fp_out,"horizontal group of me=%d loc3=%d\n",E->parallel.me,E->parallel.me_loc[3]);
Maxwelltime:Regional_parallel_related.c:    for (j=0;j<E->parallel.total_surf_proc;j++) {
Maxwelltime:Regional_parallel_related.c:      fprintf(E->fp_out,"%d proc=%d\n",j,processors[j]);
Maxwelltime:Regional_parallel_related.c:    fflush(E->fp_out);
Maxwelltime:Regional_parallel_related.c:  MPI_Comm_group(E->parallel.world, &world_g);
Maxwelltime:Regional_parallel_related.c:  MPI_Group_incl(world_g, E->parallel.total_surf_proc, processors, &horizon_g);
Maxwelltime:Regional_parallel_related.c:  MPI_Comm_create(E->parallel.world, horizon_g, &(E->parallel.horizontal_comm));
Maxwelltime:Regional_parallel_related.c:  processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Maxwelltime:Regional_parallel_related.c:  m = E->sphere.capid[1] - 1;  /* assume 1 cap per proc. */
Maxwelltime:Regional_parallel_related.c:  i = E->parallel.me_loc[1];
Maxwelltime:Regional_parallel_related.c:  j = E->parallel.me_loc[2];
Maxwelltime:Regional_parallel_related.c:  for (k=0;k<E->parallel.nprocz;k++) {
Maxwelltime:Regional_parallel_related.c:      processors[k] = E->parallel.loc2proc_map[m][i][j][k];
Maxwelltime:Regional_parallel_related.c:  if (E->control.verbose) {
Maxwelltime:Regional_parallel_related.c:    fprintf(E->fp_out,"vertical group of me=%d loc1=%d loc2=%d\n",E->parallel.me,E->parallel.me_loc[1],E->parallel.me_loc[2]);
Maxwelltime:Regional_parallel_related.c:    for (k=0;k<E->parallel.nprocz;k++) {
Maxwelltime:Regional_parallel_related.c:      fprintf(E->fp_out,"%d proc=%d\n",k,processors[k]);
Maxwelltime:Regional_parallel_related.c:    fflush(E->fp_out);
Maxwelltime:Regional_parallel_related.c:  MPI_Comm_group(E->parallel.world, &world_g);
Maxwelltime:Regional_parallel_related.c:  MPI_Group_incl(world_g, E->parallel.nprocz, processors, &vertical_g);
Maxwelltime:Regional_parallel_related.c:  MPI_Comm_create(E->parallel.world, vertical_g, &(E->parallel.vertical_comm));
Maxwelltime:Regional_parallel_related.c:  me = E->parallel.me;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.elx = E->mesh.elx/E->parallel.nprocx;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.elz = E->mesh.elz/E->parallel.nprocz;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.ely = E->mesh.ely/E->parallel.nprocy;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.nox = E->lmesh.elx + 1;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.noz = E->lmesh.elz + 1;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.noy = E->lmesh.ely + 1;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.exs = E->parallel.me_loc[1]*E->lmesh.elx;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.eys = E->parallel.me_loc[2]*E->lmesh.ely;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.ezs = E->parallel.me_loc[3]*E->lmesh.elz;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.nxs = E->parallel.me_loc[1]*E->lmesh.elx+1;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.nys = E->parallel.me_loc[2]*E->lmesh.ely+1;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.nzs = E->parallel.me_loc[3]*E->lmesh.elz+1;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.nno = E->lmesh.noz*E->lmesh.nox*E->lmesh.noy;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.nel = E->lmesh.ely*E->lmesh.elx*E->lmesh.elz;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.npno = E->lmesh.nel;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.nsf = E->lmesh.nno/E->lmesh.noz;
Maxwelltime:Regional_parallel_related.c:  E->lmesh.snel = E->lmesh.elx*E->lmesh.ely;
Maxwelltime:Regional_parallel_related.c:  for(i=E->mesh.levmax;i>=E->mesh.levmin;i--)   {
Maxwelltime:Regional_parallel_related.c:     if (E->control.NMULTIGRID)  {
Maxwelltime:Regional_parallel_related.c:        nox = E->mesh.mgunitx * (int) pow(2.0,(double)i) + 1;
Maxwelltime:Regional_parallel_related.c:        noy = E->mesh.mgunity * (int) pow(2.0,(double)i) + 1;
Maxwelltime:Regional_parallel_related.c:        noz = E->lmesh.elz/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Maxwelltime:Regional_parallel_related.c:        E->parallel.redundant[i]=0;
Maxwelltime:Regional_parallel_related.c:        { noz = E->lmesh.noz;
Maxwelltime:Regional_parallel_related.c:          noy = E->mesh.mgunity * (int) pow(2.0,(double)i) + 1;
Maxwelltime:Regional_parallel_related.c:          nox = E->mesh.mgunitx * (int) pow(2.0,(double)i) + 1;
Maxwelltime:Regional_parallel_related.c:          if(i<E->mesh.levmax) noz=2;
Maxwelltime:Regional_parallel_related.c:     E->lmesh.ELX[i] = nox-1;
Maxwelltime:Regional_parallel_related.c:     E->lmesh.ELY[i] = noy-1;
Maxwelltime:Regional_parallel_related.c:     E->lmesh.ELZ[i] = noz-1;
Maxwelltime:Regional_parallel_related.c:     E->lmesh.NOZ[i] = noz;
Maxwelltime:Regional_parallel_related.c:     E->lmesh.NOY[i] = noy;
Maxwelltime:Regional_parallel_related.c:     E->lmesh.NOX[i] = nox;
Maxwelltime:Regional_parallel_related.c:     E->lmesh.NNO[i] = nox * noz * noy;
Maxwelltime:Regional_parallel_related.c:     E->lmesh.NNOV[i] = E->lmesh.NNO[i];
Maxwelltime:Regional_parallel_related.c:     E->lmesh.SNEL[i] = E->lmesh.ELX[i]*E->lmesh.ELY[i];
Maxwelltime:Regional_parallel_related.c:     E->lmesh.NEL[i] = (nox-1) * (noz-1) * (noy-1);
Maxwelltime:Regional_parallel_related.c:     E->lmesh.NPNO[i] = E->lmesh.NEL[i] ;
Maxwelltime:Regional_parallel_related.c:     E->lmesh.NEQ[i] = E->mesh.nsd * E->lmesh.NNOV[i] ;
Maxwelltime:Regional_parallel_related.c:     E->lmesh.EXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i];
Maxwelltime:Regional_parallel_related.c:     E->lmesh.EYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i];
Maxwelltime:Regional_parallel_related.c:     E->lmesh.EZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i];
Maxwelltime:Regional_parallel_related.c:     E->lmesh.NXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i]+1;
Maxwelltime:Regional_parallel_related.c:     E->lmesh.NYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i]+1;
Maxwelltime:Regional_parallel_related.c:     E->lmesh.NZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i]+1;
Maxwelltime:Regional_parallel_related.c:fprintf(stderr,"b %d %d %d %d %d %d %d\n",E->parallel.me,E->parallel.me_loc[1],E->parallel.me_loc[2],E->parallel.me_loc[3],E->lmesh.nzs,E->lmesh.nys,E->lmesh.noy);
Maxwelltime:Regional_parallel_related.c:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)   {
Maxwelltime:Regional_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Regional_parallel_related.c:      nel = E->lmesh.NEL[lev];
Maxwelltime:Regional_parallel_related.c:      elx = E->lmesh.ELX[lev];
Maxwelltime:Regional_parallel_related.c:      elz = E->lmesh.ELZ[lev];
Maxwelltime:Regional_parallel_related.c:      ely = E->lmesh.ELY[lev];
Maxwelltime:Regional_parallel_related.c:      nox = E->lmesh.NOX[lev];
Maxwelltime:Regional_parallel_related.c:      noy = E->lmesh.NOY[lev];
Maxwelltime:Regional_parallel_related.c:      noz = E->lmesh.NOZ[lev];
Maxwelltime:Regional_parallel_related.c:      nno = E->lmesh.NNO[lev];
Maxwelltime:Regional_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] =  node;
Maxwelltime:Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Maxwelltime:Regional_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Maxwelltime:Regional_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] =  node;
Maxwelltime:Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Maxwelltime:Regional_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Maxwelltime:Regional_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Maxwelltime:Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Maxwelltime:Regional_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Maxwelltime:Regional_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Maxwelltime:Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Maxwelltime:Regional_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Maxwelltime:Regional_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Maxwelltime:Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Maxwelltime:Regional_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Maxwelltime:Regional_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Maxwelltime:Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Maxwelltime:Regional_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Maxwelltime:Regional_parallel_related.c:    if (E->parallel.me_loc[1]!=E->parallel.nprocx-1)
Maxwelltime:Regional_parallel_related.c:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[2];lnode++) {
Maxwelltime:Regional_parallel_related.c:        node = E->parallel.NODE[lev][m][lnode].bound[2];
Maxwelltime:Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Maxwelltime:Regional_parallel_related.c:    if (E->parallel.me_loc[2]!=E->parallel.nprocy-1)
Maxwelltime:Regional_parallel_related.c:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[4];lnode++) {
Maxwelltime:Regional_parallel_related.c:        node = E->parallel.NODE[lev][m][lnode].bound[4];
Maxwelltime:Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Maxwelltime:Regional_parallel_related.c:    if (E->parallel.me_loc[3]!=E->parallel.nprocz-1)
Maxwelltime:Regional_parallel_related.c:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[6];lnode++) {
Maxwelltime:Regional_parallel_related.c:        node = E->parallel.NODE[lev][m][lnode].bound[6];
Maxwelltime:Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Maxwelltime:Regional_parallel_related.c:if (E->control.verbose) {
Maxwelltime:Regional_parallel_related.c: fprintf(E->fp_out,"output_shared_nodes %d \n",E->parallel.me);
Maxwelltime:Regional_parallel_related.c: for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Maxwelltime:Regional_parallel_related.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)      {
Maxwelltime:Regional_parallel_related.c:    fprintf(E->fp_out,"lev=%d  me=%d capid=%d m=%d \n",lev,E->parallel.me,E->sphere.capid[m],m);
Maxwelltime:Regional_parallel_related.c:      for (i=1;i<=E->parallel.NUM_NNO[lev][m].bound[ii];i++)
Maxwelltime:Regional_parallel_related.c:        fprintf(E->fp_out,"ii=%d   %d %d \n",ii,i,E->parallel.NODE[lev][m][i].bound[ii]);
Maxwelltime:Regional_parallel_related.c:    for (node=1;node<=E->lmesh.NNO[lev];node++)
Maxwelltime:Regional_parallel_related.c:      if((E->NODE[lev][m][node] & SKIP)) {
Maxwelltime:Regional_parallel_related.c:        fprintf(E->fp_out,"skip %d %d \n",lnode,node);
Maxwelltime:Regional_parallel_related.c: fflush(E->fp_out);
Maxwelltime:Regional_parallel_related.c:  const int dims=E->mesh.nsd;
Maxwelltime:Regional_parallel_related.c:  me = E->parallel.me;
Maxwelltime:Regional_parallel_related.c:  nproczl = E->parallel.nprocz;
Maxwelltime:Regional_parallel_related.c:  nprocyl = E->parallel.nprocy;
Maxwelltime:Regional_parallel_related.c:  nprocxl = E->parallel.nprocx;
Maxwelltime:Regional_parallel_related.c:  lx = E->parallel.me_loc[1];
Maxwelltime:Regional_parallel_related.c:  ly = E->parallel.me_loc[2];
Maxwelltime:Regional_parallel_related.c:  lz = E->parallel.me_loc[3];
Maxwelltime:Regional_parallel_related.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Maxwelltime:Regional_parallel_related.c:    nox = E->lmesh.NOX[lev];
Maxwelltime:Regional_parallel_related.c:    noz = E->lmesh.NOZ[lev];
Maxwelltime:Regional_parallel_related.c:    noy = E->lmesh.NOY[lev];
Maxwelltime:Regional_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Regional_parallel_related.c:      cap = E->sphere.capid[m] - 1;  /* which cap I am in (0~11) */
Maxwelltime:Regional_parallel_related.c:        E->parallel.NUM_PASS[lev][m].bound[ii] = 1;
Maxwelltime:Regional_parallel_related.c:        if(E->parallel.me_loc[1]==0 && i==1)
Maxwelltime:Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Maxwelltime:Regional_parallel_related.c:        else if(E->parallel.me_loc[1]==nprocxl-1 && i==2)
Maxwelltime:Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Maxwelltime:Regional_parallel_related.c:        if (E->parallel.NUM_PASS[lev][m].bound[ii] == 1)  {
Maxwelltime:Regional_parallel_related.c:          /*E->parallel.PROCESSOR[lev][m].pass[kkk]=me-((i==1)?1:-1)*nproczl; */
Maxwelltime:Regional_parallel_related.c:          E->parallel.PROCESSOR[lev][m].pass[kkk]=E->parallel.loc2proc_map[cap][lx-dir][ly][lz];
Maxwelltime:Regional_parallel_related.c:              E->parallel.NUM_NODE[lev][m].pass[kkk] = E->parallel.NUM_NNO[lev][m].bound[ii];
Maxwelltime:Regional_parallel_related.c:          for (k=1;k<=E->parallel.NUM_NODE[lev][m].pass[kkk];k++)   {
Maxwelltime:Regional_parallel_related.c:            node = E->parallel.NODE[lev][m][lnode].bound[ii];
Maxwelltime:Regional_parallel_related.c:            E->parallel.EXCHANGE_NODE[lev][m][k].pass[kkk] = node;
Maxwelltime:Regional_parallel_related.c:                         E->parallel.EXCHANGE_ID[lev][m][++jj].pass[kkk] = E->ID[lev][m][node].doff[doff];
Maxwelltime:Regional_parallel_related.c:              E->parallel.NUM_NEQ[lev][m].pass[kkk] = jj;
Maxwelltime:Regional_parallel_related.c:        E->parallel.NUM_PASS[lev][m].bound[ii] = 1;
Maxwelltime:Regional_parallel_related.c:        if(E->parallel.me_loc[2]==0 && k==1)
Maxwelltime:Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Maxwelltime:Regional_parallel_related.c:        else if(E->parallel.me_loc[2]==nprocyl-1 && k==2)
Maxwelltime:Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Maxwelltime:Regional_parallel_related.c:        if(E->parallel.NUM_PASS[lev][m].bound[ii] == 1)  {
Maxwelltime:Regional_parallel_related.c:          /*E->parallel.PROCESSOR[lev][m].pass[kkk]=me-((k==1)?1:-1)*nprocxl*nproczl; */
Maxwelltime:Regional_parallel_related.c:          E->parallel.PROCESSOR[lev][m].pass[kkk]=E->parallel.loc2proc_map[cap][lx][ly-dir][lz];
Maxwelltime:Regional_parallel_related.c:          E->parallel.NUM_NODE[lev][m].pass[kkk] = E->parallel.NUM_NNO[lev][m].bound[ii];
Maxwelltime:Regional_parallel_related.c:          for (kk=1;kk<=E->parallel.NUM_NODE[lev][m].pass[kkk];kk++)   {
Maxwelltime:Regional_parallel_related.c:            node = E->parallel.NODE[lev][m][lnode].bound[ii];
Maxwelltime:Regional_parallel_related.c:            E->parallel.EXCHANGE_NODE[lev][m][kk].pass[kkk] = node;
Maxwelltime:Regional_parallel_related.c:                         E->parallel.EXCHANGE_ID[lev][m][++jj].pass[kkk] = E->ID[lev][m][node].doff[doff];
Maxwelltime:Regional_parallel_related.c:              E->parallel.NUM_NEQ[lev][m].pass[kkk] = jj;
Maxwelltime:Regional_parallel_related.c:        E->parallel.NUM_PASS[lev][m].bound[ii] = 1;
Maxwelltime:Regional_parallel_related.c:        if(E->parallel.me_loc[3]==0 && j==1)
Maxwelltime:Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Maxwelltime:Regional_parallel_related.c:        else if(E->parallel.me_loc[3]==nproczl-1 && j==2)
Maxwelltime:Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Maxwelltime:Regional_parallel_related.c:        if(E->parallel.NUM_PASS[lev][m].bound[ii] == 1)  {
Maxwelltime:Regional_parallel_related.c:          /*E->parallel.PROCESSOR[lev][m].pass[kkk]=me-((j==1)?1:-1);*/
Maxwelltime:Regional_parallel_related.c:          E->parallel.PROCESSOR[lev][m].pass[kkk]=E->parallel.loc2proc_map[cap][lx][ly][lz-dir];
Maxwelltime:Regional_parallel_related.c:          E->parallel.NUM_NODE[lev][m].pass[kkk] = E->parallel.NUM_NNO[lev][m].bound[ii];
Maxwelltime:Regional_parallel_related.c:          for (kk=1;kk<=E->parallel.NUM_NODE[lev][m].pass[kkk];kk++)   {
Maxwelltime:Regional_parallel_related.c:            node = E->parallel.NODE[lev][m][lnode].bound[ii];
Maxwelltime:Regional_parallel_related.c:            E->parallel.EXCHANGE_NODE[lev][m][kk].pass[kkk] = node;
Maxwelltime:Regional_parallel_related.c:                         E->parallel.EXCHANGE_ID[lev][m][++jj].pass[kkk] = E->ID[lev][m][node].doff[doff];
Maxwelltime:Regional_parallel_related.c:              E->parallel.NUM_NEQ[lev][m].pass[kkk] = jj;
Maxwelltime:Regional_parallel_related.c:      E->parallel.TNUM_PASS[lev][m] = kkk;
Maxwelltime:Regional_parallel_related.c:  if(E->control.verbose) {
Maxwelltime:Regional_parallel_related.c:    for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Maxwelltime:Regional_parallel_related.c:      fprintf(E->fp_out,"output_communication route surface for lev=%d \n",lev);
Maxwelltime:Regional_parallel_related.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Regional_parallel_related.c:    fprintf(E->fp_out,"  me= %d cap=%d pass  %d \n",E->parallel.me,E->sphere.capid[m],E->parallel.TNUM_PASS[lev][m]);
Maxwelltime:Regional_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Maxwelltime:Regional_parallel_related.c:      fprintf(E->fp_out,"proc %d and pass  %d to proc %d with %d eqn and %d node\n",E->parallel.me,k,E->parallel.PROCESSOR[lev][m].pass[k],E->parallel.NUM_NEQ[lev][m].pass[k],E->parallel.NUM_NODE[lev][m].pass[k]);
Maxwelltime:Regional_parallel_related.c:/*    fprintf(E->fp_out,"Eqn:\n");  */
Maxwelltime:Regional_parallel_related.c:/*    for (ii=1;ii<=E->parallel.NUM_NEQ[lev][m].pass[k];ii++)  */
Maxwelltime:Regional_parallel_related.c:/*      fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_ID[lev][m][ii].pass[k]);  */
Maxwelltime:Regional_parallel_related.c:/*    fprintf(E->fp_out,"Node:\n");  */
Maxwelltime:Regional_parallel_related.c:/*    for (ii=1;ii<=E->parallel.NUM_NODE[lev][m].pass[k];ii++)  */
Maxwelltime:Regional_parallel_related.c:/*      fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_NODE[lev][m][ii].pass[k]);  */
Maxwelltime:Regional_parallel_related.c:    fflush(E->fp_out);
Maxwelltime:Regional_parallel_related.c:  const int dims=E->mesh.nsd;
Maxwelltime:Regional_parallel_related.c:  me = E->parallel.me;
Maxwelltime:Regional_parallel_related.c:  nprocz = E->parallel.nprocz;
Maxwelltime:Regional_parallel_related.c:  nprocxl = E->parallel.nprocx;
Maxwelltime:Regional_parallel_related.c:  nprocyl = E->parallel.nprocy;
Maxwelltime:Regional_parallel_related.c:  nproczl = E->parallel.nprocz;
Maxwelltime:Regional_parallel_related.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Maxwelltime:Regional_parallel_related.c:    nox = E->lmesh.NOX[lev];
Maxwelltime:Regional_parallel_related.c:    noz = E->lmesh.NOZ[lev];
Maxwelltime:Regional_parallel_related.c:    noy = E->lmesh.NOY[lev];
Maxwelltime:Regional_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Regional_parallel_related.c:        E->parallel.NUM_PASS[lev][m].bound[ii] = 1;
Maxwelltime:Regional_parallel_related.c:        if(E->parallel.me_loc[1]==0 && i==1)
Maxwelltime:Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Maxwelltime:Regional_parallel_related.c:        else if(E->parallel.me_loc[1]==nprocxl-1 && i==2)
Maxwelltime:Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Maxwelltime:Regional_parallel_related.c:        for (p=1;p<=E->parallel.NUM_PASS[lev][m].bound[ii];p++)  {
Maxwelltime:Regional_parallel_related.c:          E->parallel.sPROCESSOR[lev][m].pass[kkk]=me-((i==1)?1:-1)*nproczl;
Maxwelltime:Regional_parallel_related.c:              E->parallel.NUM_sNODE[lev][m].pass[kkk] =
Maxwelltime:Regional_parallel_related.c:                          E->parallel.NUM_NNO[lev][m].bound[ii]/noz;
Maxwelltime:Regional_parallel_related.c:          for (k=1;k<=E->parallel.NUM_sNODE[lev][m].pass[kkk];k++)   {
Maxwelltime:Regional_parallel_related.c:            node = (E->parallel.NODE[lev][m][lnode].bound[ii]-1)/noz+1;
Maxwelltime:Regional_parallel_related.c:            E->parallel.EXCHANGE_sNODE[lev][m][k].pass[kkk] = node;
Maxwelltime:Regional_parallel_related.c:        E->parallel.NUM_PASS[lev][m].bound[ii] = 1;
Maxwelltime:Regional_parallel_related.c:        if(E->parallel.me_loc[2]==0 && k==1)
Maxwelltime:Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Maxwelltime:Regional_parallel_related.c:        else if(E->parallel.me_loc[2]==nprocyl-1 && k==2)
Maxwelltime:Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Maxwelltime:Regional_parallel_related.c:        for (p=1;p<=E->parallel.NUM_PASS[lev][m].bound[ii];p++)  {
Maxwelltime:Regional_parallel_related.c:          E->parallel.sPROCESSOR[lev][m].pass[kkk]=me-((k==1)?1:-1)*nprocxl*nproczl;
Maxwelltime:Regional_parallel_related.c:              E->parallel.NUM_sNODE[lev][m].pass[kkk] =
Maxwelltime:Regional_parallel_related.c:                          E->parallel.NUM_NNO[lev][m].bound[ii]/noz;
Maxwelltime:Regional_parallel_related.c:          for (kk=1;kk<=E->parallel.NUM_sNODE[lev][m].pass[kkk];kk++)   {
Maxwelltime:Regional_parallel_related.c:            node = (E->parallel.NODE[lev][m][lnode].bound[ii]-1)/noz+1;
Maxwelltime:Regional_parallel_related.c:            E->parallel.EXCHANGE_sNODE[lev][m][kk].pass[kkk] = node;
Maxwelltime:Regional_parallel_related.c:    E->parallel.sTNUM_PASS[lev][m] = kkk;
Maxwelltime:Regional_parallel_related.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Regional_parallel_related.c:     for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Maxwelltime:Regional_parallel_related.c:       sizeofk = (1+E->parallel.NUM_NEQ[lev][m].pass[k])*sizeof(double);
Maxwelltime:Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Regional_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Maxwelltime:Regional_parallel_related.c:     sizeofk = (1+E->parallel.NUM_NEQ[lev][m].pass[k])*sizeof(double);
Maxwelltime:Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Regional_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Maxwelltime:Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[k];j++)
Maxwelltime:Regional_parallel_related.c:       S[k][j-1] = U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[k] ];
Maxwelltime:Regional_parallel_related.c:     MPI_Sendrecv(S[k],E->parallel.NUM_NEQ[lev][m].pass[k],MPI_DOUBLE,
Maxwelltime:Regional_parallel_related.c:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Maxwelltime:Regional_parallel_related.c:		  R[k],E->parallel.NUM_NEQ[lev][m].pass[k],MPI_DOUBLE,
Maxwelltime:Regional_parallel_related.c:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Maxwelltime:Regional_parallel_related.c:		  E->parallel.world,&status);
Maxwelltime:Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[k];j++)
Maxwelltime:Regional_parallel_related.c:       U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[k] ] += R[k][j-1];
Maxwelltime:Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Regional_parallel_related.c: for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Maxwelltime:Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Regional_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Maxwelltime:Regional_parallel_related.c:     sizeofk = (1+E->parallel.NUM_NODE[lev][m].pass[k])*sizeof(double);
Maxwelltime:Regional_parallel_related.c: for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Maxwelltime:Regional_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Maxwelltime:Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Maxwelltime:Regional_parallel_related.c:       S[k][j-1] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ];
Maxwelltime:Regional_parallel_related.c:     MPI_Sendrecv(S[k],E->parallel.NUM_NODE[lev][m].pass[k],MPI_DOUBLE,
Maxwelltime:Regional_parallel_related.c:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Maxwelltime:Regional_parallel_related.c:		  R[k],E->parallel.NUM_NODE[lev][m].pass[k],MPI_DOUBLE,
Maxwelltime:Regional_parallel_related.c:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Maxwelltime:Regional_parallel_related.c:		  E->parallel.world,&status);
Maxwelltime:Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Maxwelltime:Regional_parallel_related.c:       U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += R[k][j-1];
Maxwelltime:Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Regional_parallel_related.c: for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Maxwelltime:Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Regional_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Maxwelltime:Regional_parallel_related.c:     sizeofk = (1+E->parallel.NUM_NODE[lev][m].pass[k])*sizeof(float);
Maxwelltime:Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)     {
Maxwelltime:Regional_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Maxwelltime:Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Maxwelltime:Regional_parallel_related.c:       S[k][j-1] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ];
Maxwelltime:Regional_parallel_related.c:     MPI_Sendrecv(S[k],E->parallel.NUM_NODE[lev][m].pass[k],MPI_FLOAT,
Maxwelltime:Regional_parallel_related.c:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Maxwelltime:Regional_parallel_related.c:		  R[k],E->parallel.NUM_NODE[lev][m].pass[k],MPI_FLOAT,
Maxwelltime:Regional_parallel_related.c:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Maxwelltime:Regional_parallel_related.c:		  E->parallel.world,&status);
Maxwelltime:Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Maxwelltime:Regional_parallel_related.c:       U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += R[k][j-1];
Maxwelltime:Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Regional_parallel_related.c: for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Maxwelltime:Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Maxwelltime:Regional_parallel_related.c:   for (k=1;k<=E->parallel.sTNUM_PASS[lev][m];k++)  {
Maxwelltime:Regional_parallel_related.c:     sizeofk = (1+2*E->parallel.NUM_sNODE[lev][m].pass[k])*sizeof(float);
Maxwelltime:Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Regional_parallel_related.c:   for (k=1;k<=E->parallel.sTNUM_PASS[lev][m];k++)  {
Maxwelltime:Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_sNODE[lev][m].pass[k];j++)  {
Maxwelltime:Regional_parallel_related.c:       S[k][j-1] = U1[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ];
Maxwelltime:Regional_parallel_related.c:       S[k][j-1+E->parallel.NUM_sNODE[lev][m].pass[k]]
Maxwelltime:Regional_parallel_related.c:	 = U2[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ];
Maxwelltime:Regional_parallel_related.c:     MPI_Sendrecv(S[k],2*E->parallel.NUM_sNODE[lev][m].pass[k],MPI_FLOAT,
Maxwelltime:Regional_parallel_related.c:		  E->parallel.sPROCESSOR[lev][m].pass[k],1,
Maxwelltime:Regional_parallel_related.c:		  R[k],2*E->parallel.NUM_sNODE[lev][m].pass[k],MPI_FLOAT,
Maxwelltime:Regional_parallel_related.c:		  E->parallel.sPROCESSOR[lev][m].pass[k],1,
Maxwelltime:Regional_parallel_related.c:		  E->parallel.world,&status);
Maxwelltime:Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_sNODE[lev][m].pass[k];j++)   {
Maxwelltime:Regional_parallel_related.c:       U1[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] += R[k][j-1];
Maxwelltime:Regional_parallel_related.c:       U2[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] +=
Maxwelltime:Regional_parallel_related.c:	 R[k][j-1+E->parallel.NUM_sNODE[lev][m].pass[k]];
Maxwelltime:Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Regional_parallel_related.c: for (k=1;k<=E->parallel.sTNUM_PASS[lev][m];k++)  {
Maxwelltime:Regional_read_input_from_files.c:    const int dims=E->mesh.nsd;
Maxwelltime:Regional_read_input_from_files.c:    /*if( E->parallel.me == 0)  
Maxwelltime:Regional_read_input_from_files.c:    nox=E->mesh.nox;
Maxwelltime:Regional_read_input_from_files.c:    noy=E->mesh.noy;
Maxwelltime:Regional_read_input_from_files.c:    noz=E->mesh.noz;
Maxwelltime:Regional_read_input_from_files.c:    nox1=E->lmesh.nox;
Maxwelltime:Regional_read_input_from_files.c:    noz1=E->lmesh.noz;
Maxwelltime:Regional_read_input_from_files.c:    noy1=E->lmesh.noy;
Maxwelltime:Regional_read_input_from_files.c:    elx=E->lmesh.elx;
Maxwelltime:Regional_read_input_from_files.c:    elz=E->lmesh.elz;
Maxwelltime:Regional_read_input_from_files.c:    ely=E->lmesh.ely;
Maxwelltime:Regional_read_input_from_files.c:    emax=E->mesh.elx*E->mesh.elz*E->mesh.ely;
Maxwelltime:Regional_read_input_from_files.c:      if(!E->control.ggrd.vtop_control){	/* regular input */
Maxwelltime:Regional_read_input_from_files.c:      sprintf(output_file1,"%s%0.0f",E->control.velocity_boundary_file,newage1);
Maxwelltime:Regional_read_input_from_files.c:      sprintf(output_file2,"%s%0.0f",E->control.velocity_boundary_file,newage2);
Maxwelltime:Regional_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #4) Cannot open %s\n",output_file1);
Maxwelltime:Regional_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #5) Cannot open %s\n",output_file2);
Maxwelltime:Regional_read_input_from_files.c:      if((E->parallel.me==0) && (output==1))   {
Maxwelltime:Regional_read_input_from_files.c:         fprintf(E->fp,"Velocity: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Maxwelltime:Regional_read_input_from_files.c:         fprintf(E->fp,"Velocity: File1 = %s\n",output_file1);
Maxwelltime:Regional_read_input_from_files.c:           fprintf(E->fp,"Velocity: File2 = %s\n",output_file2);
Maxwelltime:Regional_read_input_from_files.c:           fprintf(E->fp,"Velocity: File2 = No file inputted (negative age)\n");
Maxwelltime:Regional_read_input_from_files.c:      if(!E->control.ggrd.age_control){	/* regular input */
Maxwelltime:Regional_read_input_from_files.c:        sprintf(output_file1,"%s%0.0f",E->control.lith_age_file,newage1);
Maxwelltime:Regional_read_input_from_files.c:        sprintf(output_file2,"%s%0.0f",E->control.lith_age_file,newage2);
Maxwelltime:Regional_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #6) Cannot open %s\n",output_file1);
Maxwelltime:Regional_read_input_from_files.c:            fprintf(E->fp,"(Problem_related #7) Cannot open %s\n",output_file2);            exit(8);
Maxwelltime:Regional_read_input_from_files.c:        if((E->parallel.me==0) && (output==1))   {
Maxwelltime:Regional_read_input_from_files.c:          fprintf(E->fp,"Age: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Maxwelltime:Regional_read_input_from_files.c:          fprintf(E->fp,"Age: File1 = %s\n",output_file1);
Maxwelltime:Regional_read_input_from_files.c:            fprintf(E->fp,"Age: File2 = %s\n",output_file2);
Maxwelltime:Regional_read_input_from_files.c:            fprintf(E->fp,"Age: File2 = No file inputted (negative age)\n");
Maxwelltime:Regional_read_input_from_files.c:	if(!E->control.ggrd.mat_control){
Maxwelltime:Regional_read_input_from_files.c:        sprintf(output_file1,"%s%0.0f.0",E->control.mat_file,newage1);
Maxwelltime:Regional_read_input_from_files.c:        sprintf(output_file2,"%s%0.0f.0",E->control.mat_file,newage2);
Maxwelltime:Regional_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #8) Cannot open %s\n",output_file1);
Maxwelltime:Regional_read_input_from_files.c:            fprintf(E->fp,"(Problem_related #9) Cannot open %s\n",output_file2);
Maxwelltime:Regional_read_input_from_files.c:        if((E->parallel.me==0) && (output==1))   {
Maxwelltime:Regional_read_input_from_files.c:          fprintf(E->fp,"Mat: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Maxwelltime:Regional_read_input_from_files.c:          fprintf(E->fp,"Mat: File1 = %s\n",output_file1);
Maxwelltime:Regional_read_input_from_files.c:            fprintf(E->fp,"Mat: File2 = %s\n",output_file2);
Maxwelltime:Regional_read_input_from_files.c:            fprintf(E->fp,"Mat: File2 = No file inputted (negative age)\n");
Maxwelltime:Regional_read_input_from_files.c:        sprintf(output_file1,"%s%0.0f",E->control.temperature_boundary_file,newage1);
Maxwelltime:Regional_read_input_from_files.c:        sprintf(output_file2,"%s%0.0f",E->control.temperature_boundary_file,newage2);
Maxwelltime:Regional_read_input_from_files.c:            fprintf(E->fp,"(Problem_related #10) Cannot open %s\n",output_file1);
Maxwelltime:Regional_read_input_from_files.c:            fprintf(E->fp,"(Problem_related #11) Cannot open %s\n",output_file2);
Maxwelltime:Regional_read_input_from_files.c:        if((E->parallel.me==0) && (output==1))   {
Maxwelltime:Regional_read_input_from_files.c:           fprintf(E->fp,"Surface Temperature: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Maxwelltime:Regional_read_input_from_files.c:           fprintf(E->fp,"Surface Temperature: File1 = %s\n",output_file1);
Maxwelltime:Regional_read_input_from_files.c:             fprintf(E->fp,"Surface Temperature: File2 = %s\n",output_file2);
Maxwelltime:Regional_read_input_from_files.c:             fprintf(E->fp,"Surface Temperature: File2 = No file inputted (negative age)\n");
Maxwelltime:Regional_read_input_from_files.c:      if(E->control.ggrd.vtop_control){
Maxwelltime:Regional_read_input_from_files.c:         VB1[1][i]=E->data.timedir*VB1[1][i];
Maxwelltime:Regional_read_input_from_files.c:         VB1[2][i]=E->data.timedir*VB1[2][i];
Maxwelltime:Regional_read_input_from_files.c:             VB2[1][i]=E->data.timedir*VB2[1][i];
Maxwelltime:Regional_read_input_from_files.c:             VB2[2][i]=E->data.timedir*VB2[2][i];
Maxwelltime:Regional_read_input_from_files.c:      if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Maxwelltime:Regional_read_input_from_files.c:                nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Maxwelltime:Regional_read_input_from_files.c:                    E->sphere.cap[1].VB[1][nodel] = (VB1[1][nodeg] + (VB2[1][nodeg]-VB1[1][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Maxwelltime:Regional_read_input_from_files.c:                    E->sphere.cap[1].VB[2][nodel] = (VB1[2][nodeg] + (VB2[2][nodeg]-VB1[2][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Maxwelltime:Regional_read_input_from_files.c:                    E->sphere.cap[1].VB[3][nodel] = 0.0;
Maxwelltime:Regional_read_input_from_files.c:                    E->sphere.cap[1].VB[1][nodel] = VB1[1][nodeg]*E->data.scalev;
Maxwelltime:Regional_read_input_from_files.c:                    E->sphere.cap[1].VB[2][nodel] = VB1[2][nodeg]*E->data.scalev;
Maxwelltime:Regional_read_input_from_files.c:                    E->sphere.cap[1].VB[3][nodel] = 0.0;
Maxwelltime:Regional_read_input_from_files.c:      }   /* end of E->parallel.me_loc[3]==E->parallel.nprocz-1   */
Maxwelltime:Regional_read_input_from_files.c:	if(E->control.ggrd.age_control){
Maxwelltime:Regional_read_input_from_files.c:              E->age_t[node] = (inputage1 + (inputage2-inputage1)/(newage2-newage1)*(age-newage1))/E->data.scalet;
Maxwelltime:Regional_read_input_from_files.c:              E->age_t[node] = inputage1;
Maxwelltime:Regional_read_input_from_files.c:	if(E->control.ggrd.mat_control){
Maxwelltime:Regional_read_input_from_files.c:            nodea = E->ien[1][el].node[2];
Maxwelltime:Regional_read_input_from_files.c:              E->mat[1][el] = llayer;
Maxwelltime:Regional_read_input_from_files.c:                el = j + (i-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Maxwelltime:Regional_read_input_from_files.c:                elg = E->lmesh.ezs+j + (E->lmesh.exs+i-1)*E->mesh.elz + (E->lmesh.eys+k-1)*E->mesh.elz*E->mesh.elx;
Maxwelltime:Regional_read_input_from_files.c:                E->VIP[1][el] = VIP1[elg]+(VIP2[elg]-VIP1[elg])/(newage2-newage1)*(age-newage1);
Maxwelltime:Regional_read_input_from_files.c:                /* E->mat[1][el] = LL1[elg]; */ /*use the mat numbers base on radius*/
Maxwelltime:Regional_read_input_from_files.c:      if(E->control.ggrd.ray_control)
Maxwelltime:Regional_read_input_from_files.c:         /* if( E->parallel.me == 0)  
Maxwelltime:Regional_read_input_from_files.c:      if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Maxwelltime:Regional_read_input_from_files.c:                nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Maxwelltime:Regional_read_input_from_files.c:                    E->sphere.cap[1].TB[1][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Maxwelltime:Regional_read_input_from_files.c:                    E->sphere.cap[1].TB[2][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Maxwelltime:Regional_read_input_from_files.c:                    E->sphere.cap[1].TB[3][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Maxwelltime:Regional_read_input_from_files.c:                    E->sphere.cap[1].TB[1][nodel] = TB1[nodeg];
Maxwelltime:Regional_read_input_from_files.c:                    E->sphere.cap[1].TB[2][nodel] = TB1[nodeg];
Maxwelltime:Regional_read_input_from_files.c:                    E->sphere.cap[1].TB[3][nodel] = TB1[nodeg];
Maxwelltime:Regional_read_input_from_files.c:      }   /* end of E->parallel.me_loc[3]==E->parallel.nprocz-1   */
Maxwelltime:Regional_solver.c:    E->solver.velocity_boundary_conditions = regional_velocity_boundary_conditions;
Maxwelltime:Regional_solver.c:    E->solver.temperature_boundary_conditions = regional_temperature_boundary_conditions;
Maxwelltime:Regional_solver.c:    E->solver.set_2dc_defaults = regional_set_2dc_defaults;
Maxwelltime:Regional_solver.c:    E->solver.set_2pt5dc_defaults = regional_set_2pt5dc_defaults;
Maxwelltime:Regional_solver.c:    E->solver.set_3dc_defaults = regional_set_3dc_defaults;
Maxwelltime:Regional_solver.c:    E->solver.set_3dsphere_defaults = regional_set_3dsphere_defaults;
Maxwelltime:Regional_solver.c:    E->solver.lith_age_read_files = regional_lith_age_read_files;
Maxwelltime:Regional_solver.c:    E->solver.parallel_processor_setup = regional_parallel_processor_setup;
Maxwelltime:Regional_solver.c:    E->solver.parallel_domain_decomp0 = regional_parallel_domain_decomp0;
Maxwelltime:Regional_solver.c:    E->solver.parallel_domain_boundary_nodes = regional_parallel_domain_boundary_nodes;
Maxwelltime:Regional_solver.c:    E->solver.parallel_communication_routs_v = regional_parallel_communication_routs_v;
Maxwelltime:Regional_solver.c:    E->solver.parallel_communication_routs_s = regional_parallel_communication_routs_s;
Maxwelltime:Regional_solver.c:    E->solver.exchange_id_d = regional_exchange_id_d;
Maxwelltime:Regional_solver.c:    E->solver.read_input_files_for_timesteps = regional_read_input_files_for_timesteps;
Maxwelltime:Regional_solver.c:    E->solver.node_locations = regional_node_locations;
Maxwelltime:Regional_solver.c:    E->solver.construct_boundary = regional_construct_boundary;
Maxwelltime:Regional_sphere_related.c:  gnox=E->mesh.nox;
Maxwelltime:Regional_sphere_related.c:  gnoy=E->mesh.noy;
Maxwelltime:Regional_sphere_related.c:  gnoz=E->mesh.noz;
Maxwelltime:Regional_sphere_related.c:  nox=E->lmesh.nox;
Maxwelltime:Regional_sphere_related.c:  noy=E->lmesh.noy;
Maxwelltime:Regional_sphere_related.c:  noz=E->lmesh.noz;
Maxwelltime:Regional_sphere_related.c:  nprocxl=E->parallel.nprocx;
Maxwelltime:Regional_sphere_related.c:  nprocyl=E->parallel.nprocy;
Maxwelltime:Regional_sphere_related.c:  nproczl=E->parallel.nprocz;
Maxwelltime:Regional_sphere_related.c:  temp = max(E->mesh.NOY[E->mesh.levmax],E->mesh.NOX[E->mesh.levmax]);
Maxwelltime:Regional_sphere_related.c:  E->sphere.cap[1].theta[1] = E->control.theta_min;
Maxwelltime:Regional_sphere_related.c:  E->sphere.cap[1].theta[2] = E->control.theta_max;
Maxwelltime:Regional_sphere_related.c:  E->sphere.cap[1].theta[3] = E->control.theta_max;
Maxwelltime:Regional_sphere_related.c:  E->sphere.cap[1].theta[4] = E->control.theta_min;
Maxwelltime:Regional_sphere_related.c:  E->sphere.cap[1].fi[1] = E->control.fi_min;
Maxwelltime:Regional_sphere_related.c:  E->sphere.cap[1].fi[2] = E->control.fi_min;
Maxwelltime:Regional_sphere_related.c:  E->sphere.cap[1].fi[3] = E->control.fi_max;
Maxwelltime:Regional_sphere_related.c:  E->sphere.cap[1].fi[4] = E->control.fi_max;
Maxwelltime:Regional_sphere_related.c:  if(E->control.coor==1) {
Maxwelltime:Regional_sphere_related.c:    for(i=E->mesh.gridmin;i<=E->mesh.gridmax;i++)  {
Maxwelltime:Regional_sphere_related.c:    temp = E->mesh.NOY[E->mesh.levmax]*E->mesh.NOX[E->mesh.levmax];
Maxwelltime:Regional_sphere_related.c:    sprintf(output_file,"%s",E->control.coor_file);
Maxwelltime:Regional_sphere_related.c:      fprintf(E->fp,"(Sphere_related #1) Cannot open %s\n",output_file);
Maxwelltime:Regional_sphere_related.c:        if(fscanf(fp,"%d %e",&nn,&theta1[E->mesh.gridmax][i]) != 2) {
Maxwelltime:Regional_sphere_related.c:            fprintf(E->fp,"Error while reading coor_file '%s'\n",output_file);
Maxwelltime:Regional_sphere_related.c:    E->control.theta_min = theta1[E->mesh.gridmax][1];
Maxwelltime:Regional_sphere_related.c:    E->control.theta_max = theta1[E->mesh.gridmax][gnox];
Maxwelltime:Regional_sphere_related.c:        if(fscanf(fp,"%d %e",&nn,&fi1[E->mesh.gridmax][i]) != 2) {
Maxwelltime:Regional_sphere_related.c:            fprintf(E->fp,"Error while reading coor_file '%s'\n",output_file);
Maxwelltime:Regional_sphere_related.c:    E->control.fi_min = fi1[E->mesh.gridmax][1];
Maxwelltime:Regional_sphere_related.c:    E->control.fi_max = fi1[E->mesh.gridmax][gnoy];
Maxwelltime:Regional_sphere_related.c:    E->sphere.cap[1].theta[1] = E->control.theta_min;
Maxwelltime:Regional_sphere_related.c:    E->sphere.cap[1].theta[2] = E->control.theta_max;
Maxwelltime:Regional_sphere_related.c:    E->sphere.cap[1].theta[3] = E->control.theta_max;
Maxwelltime:Regional_sphere_related.c:    E->sphere.cap[1].theta[4] = E->control.theta_min;
Maxwelltime:Regional_sphere_related.c:    E->sphere.cap[1].fi[1] = E->control.fi_min;
Maxwelltime:Regional_sphere_related.c:    E->sphere.cap[1].fi[2] = E->control.fi_min;
Maxwelltime:Regional_sphere_related.c:    E->sphere.cap[1].fi[3] = E->control.fi_max;
Maxwelltime:Regional_sphere_related.c:    E->sphere.cap[1].fi[4] = E->control.fi_max;
Maxwelltime:Regional_sphere_related.c:    for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Maxwelltime:Regional_sphere_related.c:      if (E->control.NMULTIGRID)
Maxwelltime:Regional_sphere_related.c:        step = (int) pow(2.0,(double)(E->mesh.levmax-lev));
Maxwelltime:Regional_sphere_related.c:      for (i=1;i<=E->mesh.NOX[lev];i++)
Maxwelltime:Regional_sphere_related.c:	theta1[lev][i] = theta1[E->mesh.gridmax][(i-1)*step+1];
Maxwelltime:Regional_sphere_related.c:      for (i=1;i<=E->mesh.NOY[lev];i++)
Maxwelltime:Regional_sphere_related.c:	fi1[lev][i] = fi1[E->mesh.gridmax][(i-1)*step+1];
Maxwelltime:Regional_sphere_related.c:  for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Maxwelltime:Regional_sphere_related.c:     elx = E->lmesh.ELX[lev];
Maxwelltime:Regional_sphere_related.c:     ely = E->lmesh.ELY[lev];
Maxwelltime:Regional_sphere_related.c:     nox = E->lmesh.NOX[lev];
Maxwelltime:Regional_sphere_related.c:     noy = E->lmesh.NOY[lev];
Maxwelltime:Regional_sphere_related.c:     noz = E->lmesh.NOZ[lev];
Maxwelltime:Regional_sphere_related.c:             nodesx = E->lmesh.NXS[lev]+j-1;
Maxwelltime:Regional_sphere_related.c:             nodesy = E->lmesh.NYS[lev]+k-1;
Maxwelltime:Regional_sphere_related.c:                E->SX[lev][m][1][node] = theta1[lev][nodesx];
Maxwelltime:Regional_sphere_related.c:                E->SX[lev][m][2][node] = fi1[lev][nodesy];
Maxwelltime:Regional_sphere_related.c:                E->SX[lev][m][3][node] = E->sphere.R[lev][i];
Maxwelltime:Regional_sphere_related.c:                E->X[lev][m][1][node] =
Maxwelltime:Regional_sphere_related.c:                            E->sphere.R[lev][i]*sin(theta1[lev][nodesx])*cos(fi1[lev][nodesy]);
Maxwelltime:Regional_sphere_related.c:                E->X[lev][m][2][node] =
Maxwelltime:Regional_sphere_related.c:                            E->sphere.R[lev][i]*sin(theta1[lev][nodesx])*sin(fi1[lev][nodesy]);
Maxwelltime:Regional_sphere_related.c:                E->X[lev][m][3][node] =
Maxwelltime:Regional_sphere_related.c:                            E->sphere.R[lev][i]*cos(theta1[lev][nodesx]);
Maxwelltime:Regional_sphere_related.c:  for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Maxwelltime:Regional_sphere_related.c: else if((E->control.coor==0) || (E->control.coor==2)|| (E->control.coor==3))   {
Maxwelltime:Regional_sphere_related.c:  x[i] = (double *) malloc((E->parallel.nproc+1)*sizeof(double));
Maxwelltime:Regional_sphere_related.c:  y[i] = (double *) malloc((E->parallel.nproc+1)*sizeof(double));
Maxwelltime:Regional_sphere_related.c:  z[i] = (double *) malloc((E->parallel.nproc+1)*sizeof(double));
Maxwelltime:Regional_sphere_related.c:  temp = E->lmesh.NOY[E->mesh.levmax]*E->lmesh.NOX[E->mesh.levmax];
Maxwelltime:Regional_sphere_related.c:     tt[1] = E->sphere.cap[m].theta[1]+(E->sphere.cap[m].theta[2] -E->sphere.cap[m].theta[1])/nprocxl*(E->parallel.me_loc[1]);
Maxwelltime:Regional_sphere_related.c:     tt[2] = E->sphere.cap[m].theta[1]+(E->sphere.cap[m].theta[2] -E->sphere.cap[m].theta[1])/nprocxl*(E->parallel.me_loc[1]+1);
Maxwelltime:Regional_sphere_related.c:     ff[1] = E->sphere.cap[m].fi[1]+(E->sphere.cap[m].fi[4] -E->sphere.cap[1].fi[1])/nprocyl*(E->parallel.me_loc[2]);
Maxwelltime:Regional_sphere_related.c:     ff[3] = E->sphere.cap[m].fi[1]+(E->sphere.cap[m].fi[4] -E->sphere.cap[1].fi[1])/nprocyl*(E->parallel.me_loc[2]+1);
Maxwelltime:Regional_sphere_related.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Maxwelltime:Regional_sphere_related.c:     elx = E->lmesh.ELX[lev];
Maxwelltime:Regional_sphere_related.c:     ely = E->lmesh.ELY[lev];
Maxwelltime:Regional_sphere_related.c:     nox = E->lmesh.NOX[lev];
Maxwelltime:Regional_sphere_related.c:     noy = E->lmesh.NOY[lev];
Maxwelltime:Regional_sphere_related.c:     noz = E->lmesh.NOZ[lev];
Maxwelltime:Regional_sphere_related.c:                E->SX[lev][m][1][node] = SX[0][nodes];
Maxwelltime:Regional_sphere_related.c:                E->SX[lev][m][2][node] = SX[1][nodes];
Maxwelltime:Regional_sphere_related.c:                E->SX[lev][m][3][node] = E->sphere.R[lev][i];
Maxwelltime:Regional_sphere_related.c:                E->X[lev][m][1][node] =
Maxwelltime:Regional_sphere_related.c:                            E->sphere.R[lev][i]*sin(SX[0][nodes])*cos(SX[1][nodes]);
Maxwelltime:Regional_sphere_related.c:                E->X[lev][m][2][node] =
Maxwelltime:Regional_sphere_related.c:                            E->sphere.R[lev][i]*sin(SX[0][nodes])*sin(SX[1][nodes]);
Maxwelltime:Regional_sphere_related.c:                E->X[lev][m][3][node] =
Maxwelltime:Regional_sphere_related.c:                            E->sphere.R[lev][i]*cos(SX[0][nodes]);
Maxwelltime:Regional_tracer_advection.c:    if (E->sphere.caps_per_proc>1) {
Maxwelltime:Regional_tracer_advection.c:    sprintf(output_file,"%s.tracer_log.%d",E->control.data_file,E->parallel.me);
Maxwelltime:Regional_tracer_advection.c:    E->trace.fpt=fopen(output_file,"w");
Maxwelltime:Regional_tracer_advection.c:    E->trace.istat_isend=0;
Maxwelltime:Regional_tracer_advection.c:    E->trace.istat_iempty=0;
Maxwelltime:Regional_tracer_advection.c:    E->trace.istat_elements_checked=0;
Maxwelltime:Regional_tracer_advection.c:    E->trace.istat1=0;
Maxwelltime:Regional_tracer_advection.c:    E->trace.box_cushion=0.00001;
Maxwelltime:Regional_tracer_advection.c:    E->trace.number_of_basic_quantities=12;
Maxwelltime:Regional_tracer_advection.c:    E->trace.number_of_extra_quantities = 0;
Maxwelltime:Regional_tracer_advection.c:    if (E->trace.nflavors > 0)
Maxwelltime:Regional_tracer_advection.c:        E->trace.number_of_extra_quantities += 1;
Maxwelltime:Regional_tracer_advection.c:    E->trace.number_of_tracer_quantities =
Maxwelltime:Regional_tracer_advection.c:        E->trace.number_of_basic_quantities +
Maxwelltime:Regional_tracer_advection.c:        E->trace.number_of_extra_quantities;
Maxwelltime:Regional_tracer_advection.c:    if (E->trace.number_of_basic_quantities>99) {
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of basic in tracer_defs.h\n");
Maxwelltime:Regional_tracer_advection.c:        fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:    if (E->trace.number_of_extra_quantities>99) {
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of extraq in tracer_defs.h\n");
Maxwelltime:Regional_tracer_advection.c:        fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:    if (E->trace.number_of_tracer_quantities>99) {
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of rlater in tracer_defs.h\n");
Maxwelltime:Regional_tracer_advection.c:        fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:    if (E->composition.on)
Maxwelltime:Regional_tracer_advection.c:    fprintf(E->trace.fpt, "Tracer intiailization takes %f seconds.\n",
Maxwelltime:Regional_tracer_advection.c:    fprintf(E->trace.fpt,"\nTracing Activated! (proc: %d)\n",E->parallel.me);
Maxwelltime:Regional_tracer_advection.c:    fprintf(E->trace.fpt,"   Allen K. McNamara 12-2003\n\n");
Maxwelltime:Regional_tracer_advection.c:    if (E->trace.ic_method==0) {
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt,"Generating New Tracer Array\n");
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt,"Tracers per element: %d\n",E->trace.itperel);
Maxwelltime:Regional_tracer_advection.c:    if (E->trace.ic_method==1) {
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt,"Reading tracer file %s\n",E->trace.tracer_file);
Maxwelltime:Regional_tracer_advection.c:    if (E->trace.ic_method==2) {
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt,"Read individual tracer files\n");
Maxwelltime:Regional_tracer_advection.c:    fprintf(E->trace.fpt,"Number of tracer flavors: %d\n", E->trace.nflavors);
Maxwelltime:Regional_tracer_advection.c:    if (E->trace.nflavors && E->trace.ic_method==0) {
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt,"Initialized tracer flavors by: %d\n", E->trace.ic_method_for_flavors);
Maxwelltime:Regional_tracer_advection.c:        if (E->trace.ic_method_for_flavors == 0) {
Maxwelltime:Regional_tracer_advection.c:            fprintf(E->trace.fpt,"Layered tracer flavors\n");
Maxwelltime:Regional_tracer_advection.c:            for (i=0; i<E->trace.nflavors-1; i++)
Maxwelltime:Regional_tracer_advection.c:                fprintf(E->trace.fpt,"Interface Height: %d %f\n",i,E->trace.z_interface[i]);
Maxwelltime:Regional_tracer_advection.c:	else if((E->trace.ic_method_for_flavors == 1)||(E->trace.ic_method_for_flavors == 99)) {
Maxwelltime:Regional_tracer_advection.c:          fprintf(E->trace.fpt,"ggrd not implemented et for regional, flavor method= %d\n",
Maxwelltime:Regional_tracer_advection.c:		  E->trace.ic_method_for_flavors);
Maxwelltime:Regional_tracer_advection.c:	  fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:            fprintf(E->trace.fpt,"Sorry-This IC methods for Flavors are Unavailable %d\n",E->trace.ic_method_for_flavors);
Maxwelltime:Regional_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:    for (i=0; i<E->trace.nflavors-2; i++) {
Maxwelltime:Regional_tracer_advection.c:        if (E->trace.z_interface[i] < E->trace.z_interface[i+1]) {
Maxwelltime:Regional_tracer_advection.c:            fprintf(E->trace.fpt,"Sorry - The %d-th z_interface is smaller than the next one.\n", i);
Maxwelltime:Regional_tracer_advection.c:            fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:    fprintf(E->trace.fpt,"Box Cushion: %f\n",E->trace.box_cushion);
Maxwelltime:Regional_tracer_advection.c:    fprintf(E->trace.fpt,"Number of Basic Quantities: %d\n",
Maxwelltime:Regional_tracer_advection.c:            E->trace.number_of_basic_quantities);
Maxwelltime:Regional_tracer_advection.c:    fprintf(E->trace.fpt,"Number of Extra Quantities: %d\n",
Maxwelltime:Regional_tracer_advection.c:            E->trace.number_of_extra_quantities);
Maxwelltime:Regional_tracer_advection.c:    fprintf(E->trace.fpt,"Total Number of Tracer Quantities: %d\n",
Maxwelltime:Regional_tracer_advection.c:            E->trace.number_of_tracer_quantities);
Maxwelltime:Regional_tracer_advection.c:    if (E->trace.itracer_warnings==0) {
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt,"\n WARNING EXITS ARE TURNED OFF! TURN THEM ON!\n");
Maxwelltime:Regional_tracer_advection.c:        fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:    nox=E->lmesh.nox;
Maxwelltime:Regional_tracer_advection.c:    noy=E->lmesh.noy;
Maxwelltime:Regional_tracer_advection.c:    noz=E->lmesh.noz;
Maxwelltime:Regional_tracer_advection.c:    E->trace.x_space=(double*) malloc(nox*sizeof(double));
Maxwelltime:Regional_tracer_advection.c:    E->trace.y_space=(double*) malloc(noy*sizeof(double));
Maxwelltime:Regional_tracer_advection.c:    E->trace.z_space=(double*) malloc(noz*sizeof(double));
Maxwelltime:Regional_tracer_advection.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Regional_tracer_advection.c:	    E->trace.x_space[i]=E->sx[m][1][i*noz+1];
Maxwelltime:Regional_tracer_advection.c:	    E->trace.y_space[j]=E->sx[m][2][j*nox*noz+1];
Maxwelltime:Regional_tracer_advection.c:	    E->trace.z_space[k]=E->sx[m][3][k+1];
Maxwelltime:Regional_tracer_advection.c:	fprintf(E->trace.fpt, "i=%d x=%e\n", i, E->trace.x_space[i]);
Maxwelltime:Regional_tracer_advection.c:	fprintf(E->trace.fpt, "j=%d y=%e\n", j, E->trace.y_space[j]);
Maxwelltime:Regional_tracer_advection.c:	fprintf(E->trace.fpt, "k=%d z=%e\n", k, E->trace.z_space[k]);
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.7, 0));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.7, 1));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.7, 2));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.7, 3));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.7, 4));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.56, 0));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.56, 1));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.56, 2));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.99, 2));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.99, 3));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.99, 4));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.5));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 1.1));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.55));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 1.0));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.551));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.99));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.7));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.75));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.775));
Maxwelltime:Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.7750001));
Maxwelltime:Regional_tracer_advection.c:    elx = E->lmesh.elx;
Maxwelltime:Regional_tracer_advection.c:    ely = E->lmesh.ely;
Maxwelltime:Regional_tracer_advection.c:    elz = E->lmesh.elz;
Maxwelltime:Regional_tracer_advection.c:	ii = isearch_neighbors(E->trace.x_space, elx+1, theta, i);
Maxwelltime:Regional_tracer_advection.c:	jj = isearch_neighbors(E->trace.y_space, ely+1, phi, j);
Maxwelltime:Regional_tracer_advection.c:	kk = isearch_neighbors(E->trace.z_space, elz+1, rad, k);
Maxwelltime:Regional_tracer_advection.c:    ii = isearch_all(E->trace.x_space, elx+1, theta);
Maxwelltime:Regional_tracer_advection.c:    jj = isearch_all(E->trace.y_space, ely+1, phi);
Maxwelltime:Regional_tracer_advection.c:    kk = isearch_all(E->trace.z_space, elz+1, rad);
Maxwelltime:Regional_tracer_advection.c:    theta_min = E->trace.theta_cap[icap][2];
Maxwelltime:Regional_tracer_advection.c:    theta_max = E->trace.theta_cap[icap][4];
Maxwelltime:Regional_tracer_advection.c:    phi_min = E->trace.phi_cap[icap][2];
Maxwelltime:Regional_tracer_advection.c:    phi_max = E->trace.phi_cap[icap][4];
Maxwelltime:Regional_tracer_advection.c:    elx = E->lmesh.elx;
Maxwelltime:Regional_tracer_advection.c:    ely = E->lmesh.ely;
Maxwelltime:Regional_tracer_advection.c:    elz = E->lmesh.elz;
Maxwelltime:Regional_tracer_advection.c:    tr_dx = theta - E->trace.x_space[i];
Maxwelltime:Regional_tracer_advection.c:    dx = E->trace.x_space[i+1] - E->trace.x_space[i];
Maxwelltime:Regional_tracer_advection.c:    tr_dy = phi - E->trace.y_space[j];
Maxwelltime:Regional_tracer_advection.c:    dy = E->trace.y_space[j+1] - E->trace.y_space[j];
Maxwelltime:Regional_tracer_advection.c:    tr_dz = rad - E->trace.z_space[k];
Maxwelltime:Regional_tracer_advection.c:    dz = E->trace.z_space[k+1] - E->trace.z_space[k];
Maxwelltime:Regional_tracer_advection.c:    fprintf(E->trace.fpt, "dr=(%e,%e,%e)  tr_dr=(%e,%e,%e)\n",
Maxwelltime:Regional_tracer_advection.c:    fprintf(E->trace.fpt, "shp: %e %e %e %e %e %e %e %e\n",
Maxwelltime:Regional_tracer_advection.c:    fprintf(E->trace.fpt, "sum(shp): %e\n",
Maxwelltime:Regional_tracer_advection.c:    fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt, "VV: %e %e %e %e %e %e %e %e: %e\n",
Maxwelltime:Regional_tracer_advection.c:        tmp += E->sx[m][1][E->ien[m][nelem].node[n]] * shp[n];
Maxwelltime:Regional_tracer_advection.c:    fprintf(E->trace.fpt, "THETA: %e -> %e\n", theta, tmp);
Maxwelltime:Regional_tracer_advection.c:    fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:    if (*theta > E->control.theta_max - E->trace.box_cushion) {
Maxwelltime:Regional_tracer_advection.c:        *theta = E->control.theta_max - E->trace.box_cushion;
Maxwelltime:Regional_tracer_advection.c:    if (*theta < E->control.theta_min + E->trace.box_cushion) {
Maxwelltime:Regional_tracer_advection.c:        *theta = E->control.theta_min + E->trace.box_cushion;
Maxwelltime:Regional_tracer_advection.c:    if (*phi > E->control.fi_max - E->trace.box_cushion) {
Maxwelltime:Regional_tracer_advection.c:        *phi = E->control.fi_max - E->trace.box_cushion;
Maxwelltime:Regional_tracer_advection.c:    if (*phi < E->control.fi_min + E->trace.box_cushion) {
Maxwelltime:Regional_tracer_advection.c:        *phi = E->control.fi_min + E->trace.box_cushion;
Maxwelltime:Regional_tracer_advection.c:    if (*rad > E->sphere.ro - E->trace.box_cushion) {
Maxwelltime:Regional_tracer_advection.c:        *rad = E->sphere.ro - E->trace.box_cushion;
Maxwelltime:Regional_tracer_advection.c:    if (*rad < E->sphere.ri + E->trace.box_cushion) {
Maxwelltime:Regional_tracer_advection.c:        *rad = E->sphere.ri + E->trace.box_cushion;
Maxwelltime:Regional_tracer_advection.c:    /* This part only works if E->sphere.caps_per_proc==1 */
Maxwelltime:Regional_tracer_advection.c:    int lev = E->mesh.levmax;
Maxwelltime:Regional_tracer_advection.c:    E->trace.istat_isend = E->trace.ilater[j];
Maxwelltime:Regional_tracer_advection.c:    for (d=0; d<E->mesh.nsd; d++) {
Maxwelltime:Regional_tracer_advection.c:        bounds[d][0] = E->sx[j][d+1][1];
Maxwelltime:Regional_tracer_advection.c:        bounds[d][1] = E->sx[j][d+1][E->lmesh.nno];
Maxwelltime:Regional_tracer_advection.c:        if (E->parallel.NUM_PASS[lev][j].bound[kk] == 1) {
Maxwelltime:Regional_tracer_advection.c:            ngbr_rank[kk] = E->parallel.PROCESSOR[lev][j].pass[ipass];
Maxwelltime:Regional_tracer_advection.c:    for (kk=1; kk<=E->trace.istat_isend; kk++) {
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt, "tracer#=%d xx=(%g,%g,%g)\n", kk,
Maxwelltime:Regional_tracer_advection.c:                E->trace.rlater[j][0][kk],
Maxwelltime:Regional_tracer_advection.c:                E->trace.rlater[j][1][kk],
Maxwelltime:Regional_tracer_advection.c:                E->trace.rlater[j][2][kk]);
Maxwelltime:Regional_tracer_advection.c:    for (d=0; d<E->mesh.nsd; d++) {
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt, "bounds(dim=%d) = (%e, %e)\n",
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt, "pass=%d  neighbor_rank=%d\n",
Maxwelltime:Regional_tracer_advection.c:    fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:    max_send_size = max(2*E->trace.ilater[j], E->trace.ntracers[j]/100);
Maxwelltime:Regional_tracer_advection.c:    itemp_size = max_send_size * E->trace.number_of_tracer_quantities;
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt,"Error(lost souls)-no memory (u388)\n");
Maxwelltime:Regional_tracer_advection.c:        fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt,"Error(lost souls)-no memory (u389)\n");
Maxwelltime:Regional_tracer_advection.c:        fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:    for (d=0; d<E->mesh.nsd; d++) {
Maxwelltime:Regional_tracer_advection.c:        int original_size = E->trace.ilater[j];
Maxwelltime:Regional_tracer_advection.c:        while (kk<=E->trace.ilater[j]) {
Maxwelltime:Regional_tracer_advection.c:            coord = E->trace.rlater[j][d][kk];
Maxwelltime:Regional_tracer_advection.c:                itemp_size = isize * E->trace.number_of_tracer_quantities;
Maxwelltime:Regional_tracer_advection.c:                    fprintf(E->trace.fpt,"Error(lost souls)-no memory (s4)\n");
Maxwelltime:Regional_tracer_advection.c:                    fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:                    fprintf(E->trace.fpt,"Error(lost souls)-no memory (s5)\n");
Maxwelltime:Regional_tracer_advection.c:                    fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:                fprintf(E->trace.fpt,"Expanding physical memory of send to "
Maxwelltime:Regional_tracer_advection.c:        if ((isend[0] + isend[1] + E->trace.ilater[j]) != original_size) {
Maxwelltime:Regional_tracer_advection.c:            fprintf(E->trace.fpt, "original_size: %d, rlater_size: %d, "
Maxwelltime:Regional_tracer_advection.c:                    original_size, E->trace.ilater[j], kk);
Maxwelltime:Regional_tracer_advection.c:                fprintf(E->trace.fpt, "dim:%d side:%d kk=%d coord[kk]=%e\n",
Maxwelltime:Regional_tracer_advection.c:                        send[i][kk*E->trace.number_of_tracer_quantities+d]);
Maxwelltime:Regional_tracer_advection.c:        fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:                          11, E->parallel.world, &request[idb++]);
Maxwelltime:Regional_tracer_advection.c:                          11, E->parallel.world, &request[idb++]);
Maxwelltime:Regional_tracer_advection.c:                fprintf(E->trace.fpt, "%d: %d send %d to proc %d\n",
Maxwelltime:Regional_tracer_advection.c:                fprintf(E->trace.fpt, "%d: %d recv %d from proc %d\n",
Maxwelltime:Regional_tracer_advection.c:            isize = irecv[i] * E->trace.number_of_tracer_quantities;
Maxwelltime:Regional_tracer_advection.c:                fprintf(E->trace.fpt, "Error(lost souls)-no memory (c721)\n");
Maxwelltime:Regional_tracer_advection.c:                fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:                isize = isend[i] * E->trace.number_of_tracer_quantities;
Maxwelltime:Regional_tracer_advection.c:                          12, E->parallel.world, &request[idb++]);
Maxwelltime:Regional_tracer_advection.c:                isize = irecv[i] * E->trace.number_of_tracer_quantities;
Maxwelltime:Regional_tracer_advection.c:                          12, E->parallel.world, &request[idb++]);
Maxwelltime:Regional_tracer_advection.c:                fprintf(E->trace.fpt, "recv: %d %e %e %e\n",
Maxwelltime:Regional_tracer_advection.c:                        recv[i][(kk-1)*E->trace.number_of_tracer_quantities],
Maxwelltime:Regional_tracer_advection.c:                        recv[i][(kk-1)*E->trace.number_of_tracer_quantities+1],
Maxwelltime:Regional_tracer_advection.c:                        recv[i][(kk-1)*E->trace.number_of_tracer_quantities+2]);
Maxwelltime:Regional_tracer_advection.c:        fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:    if (E->trace.ilater[j] > 0) {
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt, "Error(regional_lost_souls) lost tracers\n");
Maxwelltime:Regional_tracer_advection.c:        for (kk=1; kk<=E->trace.ilater[j]; kk++) {
Maxwelltime:Regional_tracer_advection.c:            fprintf(E->trace.fpt, "lost #%d xx=(%e, %e, %e)\n", kk,
Maxwelltime:Regional_tracer_advection.c:                    E->trace.rlater[j][0][kk],
Maxwelltime:Regional_tracer_advection.c:                    E->trace.rlater[j][1][kk],
Maxwelltime:Regional_tracer_advection.c:                    E->trace.rlater[j][2][kk]);
Maxwelltime:Regional_tracer_advection.c:        fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:    E->trace.lost_souls_time += CPU_time0() - begin_time;
Maxwelltime:Regional_tracer_advection.c:    isend_position = (*send_size) * E->trace.number_of_tracer_quantities;
Maxwelltime:Regional_tracer_advection.c:    for (pp=0; pp<E->trace.number_of_tracer_quantities; pp++) {
Maxwelltime:Regional_tracer_advection.c:        send[ipos] = E->trace.rlater[j][pp][kk];
Maxwelltime:Regional_tracer_advection.c:    ilast_tracer = E->trace.ilater[j];
Maxwelltime:Regional_tracer_advection.c:    for (pp=0; pp<E->trace.number_of_tracer_quantities; pp++) {
Maxwelltime:Regional_tracer_advection.c:        E->trace.rlater[j][pp][kk] = E->trace.rlater[j][pp][ilast_tracer];
Maxwelltime:Regional_tracer_advection.c:    E->trace.ilater[j]--;
Maxwelltime:Regional_tracer_advection.c:        ipos = kk * E->trace.number_of_tracer_quantities;
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt, "kk=%d, inside=%d, xx=(%e, %e, %e)\n",
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt, "before: %d %d\n",
Maxwelltime:Regional_tracer_advection.c:                E->trace.ilater[j], E->trace.ntracers[j]);
Maxwelltime:Regional_tracer_advection.c:            E->trace.ntracers[j]++;
Maxwelltime:Regional_tracer_advection.c:            ilast = E->trace.ntracers[j];
Maxwelltime:Regional_tracer_advection.c:            if (E->trace.ntracers[j] > (E->trace.max_ntracers[j]-5))
Maxwelltime:Regional_tracer_advection.c:            for (pp=0; pp<E->trace.number_of_basic_quantities; pp++)
Maxwelltime:Regional_tracer_advection.c:                E->trace.basicq[j][pp][ilast] = recv[ipos+pp];
Maxwelltime:Regional_tracer_advection.c:            ipos += E->trace.number_of_basic_quantities;
Maxwelltime:Regional_tracer_advection.c:            for (pp=0; pp<E->trace.number_of_extra_quantities; pp++)
Maxwelltime:Regional_tracer_advection.c:                E->trace.extraq[j][pp][ilast] = recv[ipos+pp];
Maxwelltime:Regional_tracer_advection.c:                fprintf(E->trace.fpt, "Error(regional lost souls) - "
Maxwelltime:Regional_tracer_advection.c:                fprintf(E->trace.fpt, "theta, phi, rad: %f %f %f\n",
Maxwelltime:Regional_tracer_advection.c:                fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:            E->trace.ielement[j][ilast] = iel;
Maxwelltime:Regional_tracer_advection.c:            if (E->trace.ilatersize[j]==0) {
Maxwelltime:Regional_tracer_advection.c:                E->trace.ilatersize[j]=E->trace.max_ntracers[j]/5;
Maxwelltime:Regional_tracer_advection.c:                for (kk=0;kk<E->trace.number_of_tracer_quantities;kk++) {
Maxwelltime:Regional_tracer_advection.c:                    if ((E->trace.rlater[j][kk]=(double *)malloc(E->trace.ilatersize[j]*sizeof(double)))==NULL) {
Maxwelltime:Regional_tracer_advection.c:                        fprintf(E->trace.fpt,"AKM(put_found_tracers)-no memory (%d)\n",kk);
Maxwelltime:Regional_tracer_advection.c:                        fflush(E->trace.fpt);
Maxwelltime:Regional_tracer_advection.c:            E->trace.ilater[j]++;
Maxwelltime:Regional_tracer_advection.c:            ilast = E->trace.ilater[j];
Maxwelltime:Regional_tracer_advection.c:            if (E->trace.ilater[j] > (E->trace.ilatersize[j]-5))
Maxwelltime:Regional_tracer_advection.c:            for (pp=0; pp<E->trace.number_of_tracer_quantities; pp++)
Maxwelltime:Regional_tracer_advection.c:                E->trace.rlater[j][pp][ilast] = recv[ipos+pp];
Maxwelltime:Regional_tracer_advection.c:        fprintf(E->trace.fpt, "after: %d %d\n",
Maxwelltime:Regional_tracer_advection.c:                E->trace.ilater[j], E->trace.ntracers[j]);
Maxwelltime:Regional_tracer_advection.c:        fflush(E->trace.fpt);
Maxwelltime:Regional_version_dependent.c:  rr = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Maxwelltime:Regional_version_dependent.c:  RR = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Maxwelltime:Regional_version_dependent.c:  nox=E->mesh.nox;
Maxwelltime:Regional_version_dependent.c:  noy=E->mesh.noy;
Maxwelltime:Regional_version_dependent.c:  noz=E->mesh.noz;
Maxwelltime:Regional_version_dependent.c:  switch(E->control.coor)    {	
Maxwelltime:Regional_version_dependent.c:    dr = (E->sphere.ro-E->sphere.ri)/(E->mesh.noz-1);
Maxwelltime:Regional_version_dependent.c:    for (k=1;k<=E->mesh.noz;k++)  {
Maxwelltime:Regional_version_dependent.c:      rr[k] = E->sphere.ri + (k-1)*dr;
Maxwelltime:Regional_version_dependent.c:    sprintf(output_file,"%s",E->control.coor_file);
Maxwelltime:Regional_version_dependent.c:      fprintf(E->fp,"(Nodal_mesh.c #1) Cannot open %s\n",output_file);
Maxwelltime:Regional_version_dependent.c:    for (k=1;k<=E->mesh.noz;k++)  {
Maxwelltime:Regional_version_dependent.c:    E->sphere.ri = rr[1];
Maxwelltime:Regional_version_dependent.c:    E->sphere.ro = rr[E->mesh.noz];
Maxwelltime:Regional_version_dependent.c:  for (i=1;i<=E->lmesh.noz;i++)  {
Maxwelltime:Regional_version_dependent.c:      k = E->lmesh.nzs+i-1;
Maxwelltime:Regional_version_dependent.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Maxwelltime:Regional_version_dependent.c:    if (E->control.NMULTIGRID)
Maxwelltime:Regional_version_dependent.c:        step = (int) pow(2.0,(double)(E->mesh.levmax-lev));
Maxwelltime:Regional_version_dependent.c:      for (i=1;i<=E->lmesh.NOZ[lev];i++)
Maxwelltime:Regional_version_dependent.c:         E->sphere.R[lev][i] = RR[(i-1)*step+1];
Maxwelltime:Regional_version_dependent.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Maxwelltime:Regional_version_dependent.c:  if (E->control.verbose) {
Maxwelltime:Regional_version_dependent.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Maxwelltime:Regional_version_dependent.c:    fprintf(E->fp_out,"output_coordinates before rotation %d \n",lev);
Maxwelltime:Regional_version_dependent.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Maxwelltime:Regional_version_dependent.c:      fprintf(E->fp_out,"output_coordinates for cap %d %d\n",j,E->lmesh.NNO[lev]);
Maxwelltime:Regional_version_dependent.c:      for (i=1;i<=E->lmesh.NNO[lev];i++)
Maxwelltime:Regional_version_dependent.c:        if(i%E->lmesh.NOZ[lev]==1)
Maxwelltime:Regional_version_dependent.c:             fprintf(E->fp_out,"%d %d %g %g %g\n",j,i,E->SX[lev][j][1][i],E->SX[lev][j][2][i],E->SX[lev][j][3][i]);
Maxwelltime:Regional_version_dependent.c:    fflush(E->fp_out);
Maxwelltime:Regional_version_dependent.c:  if(E->data.use_ellipse)
Maxwelltime:Regional_version_dependent.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Maxwelltime:Regional_version_dependent.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Regional_version_dependent.c:      for (i=1;i<=E->lmesh.NNO[lev];i++)  {
Maxwelltime:Regional_version_dependent.c:        E->SinCos[lev][j][0][i] = sin(E->SX[lev][j][1][i]);
Maxwelltime:Regional_version_dependent.c:        E->SinCos[lev][j][1][i] = sin(E->SX[lev][j][2][i]);
Maxwelltime:Regional_version_dependent.c:        E->SinCos[lev][j][2][i] = cos(E->SX[lev][j][1][i]);
Maxwelltime:Regional_version_dependent.c:        E->SinCos[lev][j][3][i] = cos(E->SX[lev][j][2][i]);
Maxwelltime:Regional_version_dependent.c:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)  {
Maxwelltime:Regional_version_dependent.c:    sprintf(output_file,"coord.%d",E->parallel.me);
Maxwelltime:Regional_version_dependent.c:          fprintf(E->fp,"(Nodal_mesh.c #2) Cannot open %s\n",output_file);
Maxwelltime:Regional_version_dependent.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Regional_version_dependent.c:      for(i=1;i<=E->lmesh.noy;i++) {
Maxwelltime:Regional_version_dependent.c:        for(j=1;j<=E->lmesh.nox;j++)  {
Maxwelltime:Regional_version_dependent.c:           node=1+(j-1)*E->lmesh.noz+(i-1)*E->lmesh.nox*E->lmesh.noz;
Maxwelltime:Regional_version_dependent.c:           t1 = 90.0-E->sx[m][1][node]/M_PI*180.0;
Maxwelltime:Regional_version_dependent.c:           f1 = E->sx[m][2][node]/M_PI*180.0;
Maxwelltime:Regional_version_dependent.c:      for(j=1;j<=E->lmesh.nox;j++)  {
Maxwelltime:Regional_version_dependent.c:        for(i=1;i<=E->lmesh.noy;i++) {
Maxwelltime:Regional_version_dependent.c:           node=1+(j-1)*E->lmesh.noz+(i-1)*E->lmesh.nox*E->lmesh.noz;
Maxwelltime:Regional_version_dependent.c:           t1 = 90.0-E->sx[m][1][node]/M_PI*180.0;
Maxwelltime:Regional_version_dependent.c:           f1 = E->sx[m][2][node]/M_PI*180.0;
Maxwelltime:Regional_version_dependent.c:  if (E->control.verbose) {
Maxwelltime:Regional_version_dependent.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)   {
Maxwelltime:Regional_version_dependent.c:    fprintf(E->fp_out,"output_coordinates after rotation %d \n",lev);
Maxwelltime:Regional_version_dependent.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Regional_version_dependent.c:      for (i=1;i<=E->lmesh.NNO[lev];i++)
Maxwelltime:Regional_version_dependent.c:        if(i%E->lmesh.NOZ[lev]==1)
Maxwelltime:Regional_version_dependent.c:             fprintf(E->fp_out,"%d %d %g %g %g\n",j,i,E->SX[lev][j][1][i],E->SX[lev][j][2][i],E->SX[lev][j][3][i]);
Maxwelltime:Regional_version_dependent.c:    fflush(E->fp_out);
Maxwelltime:Regional_version_dependent.c:  const int dims=E->mesh.nsd;
Maxwelltime:Regional_version_dependent.c:  int max_size = E->lmesh.elx*E->lmesh.ely*E->lmesh.elz
Maxwelltime:Regional_version_dependent.c:    - (E->lmesh.elx-2)*(E->lmesh.ely-2)*(E->lmesh.elz-2) + 1;
Maxwelltime:Regional_version_dependent.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Regional_version_dependent.c:    E->boundary.element[m] = (int *)malloc(max_size*sizeof(int));
Maxwelltime:Regional_version_dependent.c:      E->boundary.normal[m][d] = (int *)malloc(max_size*sizeof(int));
Maxwelltime:Regional_version_dependent.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Regional_version_dependent.c:    for(k=1; k<=E->lmesh.ely; k++)
Maxwelltime:Regional_version_dependent.c:      for(j=1; j<=E->lmesh.elx; j++)
Maxwelltime:Regional_version_dependent.c:	for(i=1; i<=E->lmesh.elz; i++) {
Maxwelltime:Regional_version_dependent.c:	  if((E->parallel.me_loc[1] == 0) && (j == 1)) {
Maxwelltime:Regional_version_dependent.c:	  if((E->parallel.me_loc[1] == E->parallel.nprocx - 1)
Maxwelltime:Regional_version_dependent.c:	     && (j == E->lmesh.elx)) {
Maxwelltime:Regional_version_dependent.c:	  if((E->parallel.me_loc[2] == 0) && (k == 1)) {
Maxwelltime:Regional_version_dependent.c:	  if((E->parallel.me_loc[2] == E->parallel.nprocy - 1)
Maxwelltime:Regional_version_dependent.c:	     && (k == E->lmesh.ely)) {
Maxwelltime:Regional_version_dependent.c:	  if((E->parallel.me_loc[3] == 0) && (i == 1)) {
Maxwelltime:Regional_version_dependent.c:	  if((E->parallel.me_loc[3] == E->parallel.nprocz - 1)
Maxwelltime:Regional_version_dependent.c:	     && (i == E->lmesh.elz)) {
Maxwelltime:Regional_version_dependent.c:	    el = i + (j-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Maxwelltime:Regional_version_dependent.c:	    E->boundary.element[m][count] = el;
Maxwelltime:Regional_version_dependent.c:	      E->boundary.normal[m][d][count] = normalFlag[d];
Maxwelltime:Regional_version_dependent.c:    E->boundary.nel = count - 1;
Maxwelltime:Sea_Level_Equation.c: * Sets E->slice.oceanload and E->slice.incr_oceanload based on
Maxwelltime:Sea_Level_Equation.c: *     E->potential[0] (geoid) and E->slice.surf[3] (topo).
Maxwelltime:Sea_Level_Equation.c:        scale_geoid =  4.0*M_PI * E->data.grav_const * E->data.density
Maxwelltime:Sea_Level_Equation.c:                     * E->sphere.dradius * E->sphere.dradius ; // dim'ful pot.
Maxwelltime:Sea_Level_Equation.c:        scale_geoid /= E->data.grav_acc;                       // dim'ful geoid
Maxwelltime:Sea_Level_Equation.c:        scale_geoid /= E->sphere.dradius ;                     // dimless geoid
Maxwelltime:Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.total_dynamic_oceanload[m] = (double *)
Maxwelltime:Sea_Level_Equation.c:                              malloc((E->lmesh.nsf+2)*sizeof(double));
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.init_oceanload[m] = (double *)
Maxwelltime:Sea_Level_Equation.c:                              malloc((E->lmesh.nsf+2)*sizeof(double));
Maxwelltime:Sea_Level_Equation.c:            for (j=1;j<=E->lmesh.nsf;j++) {
Maxwelltime:Sea_Level_Equation.c:                E->slice_ve.total_dynamic_oceanload[m][j] = 0.0 ;
Maxwelltime:Sea_Level_Equation.c:                E->slice_ve.init_oceanload[m][j] = 0.0 ;
Maxwelltime:Sea_Level_Equation.c:if (E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Maxwelltime:Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)    
Maxwelltime:Sea_Level_Equation.c:          E->slice_ve.init_oceanload[m][j]= E->slice_ve.total_dynamic_oceanload[m][j];
Maxwelltime:Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)  {
Maxwelltime:Sea_Level_Equation.c:            topo = E->slice_ve.surf[3][m][j] ;
Maxwelltime:Sea_Level_Equation.c:            geoid = scale_geoid*E->potential[0][m][j] ;
Maxwelltime:Sea_Level_Equation.c:            E->Xsurf[3][m][j] = (geoid - topo) * E->slice_ve.ocean_fcn[m][j] ;
Maxwelltime:Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)  {
Maxwelltime:Sea_Level_Equation.c:            i = j*E->lmesh.noz;
Maxwelltime:Sea_Level_Equation.c:            topo = E->slice_ve.surf[3][m][j] + E->U[m][E->id[m][i].doff[3]] ;
Maxwelltime:Sea_Level_Equation.c:            geoid = scale_geoid*E->potential[0][m][j] ;
Maxwelltime:Sea_Level_Equation.c:            E->Xsurf[3][m][j] = geoid - topo ;
Maxwelltime:Sea_Level_Equation.c:        remove_average(E,E->Xsurf[3],1); // should have no average in order
Maxwelltime:Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)  
Maxwelltime:Sea_Level_Equation.c:            E->Xsurf[3][m][j] *= E->slice_ve.ocean_fcn[m][j] ;
Maxwelltime:Sea_Level_Equation.c:    nu_volume = total_surface_integral( E, E->Xsurf[3], 1) ; 
Maxwelltime:Sea_Level_Equation.c:    c =  -nu_volume / E->ve_data_cont.ocean_area ;
Maxwelltime:Sea_Level_Equation.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:    for (j=1;j<=E->lmesh.nsf;j++)
Maxwelltime:Sea_Level_Equation.c:        E->slice_ve.total_dynamic_oceanload[m][j] = 1000.0/917.4*E->ve_data_cont.ice_stress_scale *
Maxwelltime:Sea_Level_Equation.c:                       ( E->Xsurf[3][m][j] + ( c * E->slice_ve.ocean_fcn[m][j] )) ;
Maxwelltime:Sea_Level_Equation.c:    if (E->ve_data_cont.SLE_lmax)  
Maxwelltime:Sea_Level_Equation.c:        truncate_Ylm_expansion(E, E->slice_ve.total_dynamic_oceanload, 
Maxwelltime:Sea_Level_Equation.c:                                  E->ve_data_cont.SLE_lmax );
Maxwelltime:Sea_Level_Equation.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:    for (j=1;j<=E->lmesh.nsf;j++)
Maxwelltime:Sea_Level_Equation.c:        E->slice_ve.dynamic_oceanload[m][j]= E->slice_ve.total_dynamic_oceanload[m][j]
Maxwelltime:Sea_Level_Equation.c:                                        - E->slice_ve.init_oceanload[m][j] ;
Maxwelltime:Sea_Level_Equation.c:    remove_average(E,E->slice_ve.dynamic_oceanload,1);
Maxwelltime:Sea_Level_Equation.c:    if (verbose && E->parallel.me==E->parallel.nprocz-1)
Maxwelltime:Sea_Level_Equation.c:        fp = (i==0)? stderr : E->fp_out ;
Maxwelltime:Sea_Level_Equation.c:                    E->ve_data_cont.tau*E->monitor.elapsed_time );    // time
Maxwelltime:Sea_Level_Equation.c:                    c * E->sphere.dradius,                // eust. SL (meters)
Maxwelltime:Sea_Level_Equation.c:                    nu_volume , E->ve_data_cont.ocean_area );
Maxwelltime:Sea_Level_Equation.c:        E->ve_data_cont.ocean_area = total_surface_integral( E, E->slice_ve.ocean_fcn, 1) ;
Maxwelltime:Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.total_static_oceanload[m] = (double *)
Maxwelltime:Sea_Level_Equation.c:                              malloc((E->lmesh.nsf+2)*sizeof(double));
Maxwelltime:Sea_Level_Equation.c:            for (n=1;n<=E->lmesh.nsf;n++)
Maxwelltime:Sea_Level_Equation.c:                E->slice_ve.total_static_oceanload[m][n] = 0.0;
Maxwelltime:Sea_Level_Equation.c:    ice_volume += E->ve_data_cont.incr_ice_volume ;
Maxwelltime:Sea_Level_Equation.c:        E->ve_data_cont.ocean_area += E->ve_data_cont.incr_ocean_area ;
Maxwelltime:Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)    
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.ocean_fcn[m][j] += E->slice_ve.incr_ocean_fcn[m][j] ;
Maxwelltime:Sea_Level_Equation.c:    c =  -ice_volume / E->ve_data_cont.ocean_area * E->ve_data_cont.ice_stress_scale ;
Maxwelltime:Sea_Level_Equation.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:    for (j=1;j<=E->lmesh.nsf;j++)
Maxwelltime:Sea_Level_Equation.c:        E->Xsurf[3][m][j] = c * E->slice_ve.ocean_fcn[m][j] ;  
Maxwelltime:Sea_Level_Equation.c:    if (E->ve_data_cont.SLE_lmax) 
Maxwelltime:Sea_Level_Equation.c:        truncate_Ylm_expansion(E, E->Xsurf[3], E->ve_data_cont.SLE_lmax );
Maxwelltime:Sea_Level_Equation.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:    for (j=1;j<=E->lmesh.nsf;j++) {
Maxwelltime:Sea_Level_Equation.c:        E->slice_ve.static_oceanload[m][j] = E->Xsurf[3][m][j]
Maxwelltime:Sea_Level_Equation.c:                                        - E->slice_ve.total_static_oceanload[m][j];
Maxwelltime:Sea_Level_Equation.c:        E->slice_ve.total_static_oceanload[m][j] = E->Xsurf[3][m][j] ;
Maxwelltime:Sea_Level_Equation.c:    remove_average(E,E->slice_ve.static_oceanload,1);
Maxwelltime:Sea_Level_Equation.c:    if (verbose && E->parallel.me==E->parallel.nprocz-1)
Maxwelltime:Sea_Level_Equation.c:       fp = (i==0)? stderr : E->fp_out ;
Maxwelltime:Sea_Level_Equation.c:               E->ve_data_cont.tau*E->monitor.elapsed_time ,          // time
Maxwelltime:Sea_Level_Equation.c:               c/E->ve_data_cont.ice_stress_scale * E->sphere.dradius // Eus SL (meters)
Maxwelltime:Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.ocean_fcn[m] = (double *)
Maxwelltime:Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.incr_ocean_fcn[m] = (double *)
Maxwelltime:Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.ocean_fcn_prev[m] = (double *)
Maxwelltime:Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.ocean_fcn_next[m] = (double *)
Maxwelltime:Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Maxwelltime:Sea_Level_Equation.c:            for (n=1;n<=E->lmesh.nsf;n++)  {  
Maxwelltime:Sea_Level_Equation.c:                E->slice_ve.ocean_fcn[m][n]      = 0.0;
Maxwelltime:Sea_Level_Equation.c:                E->slice_ve.incr_ocean_fcn[m][n] = 0.0;
Maxwelltime:Sea_Level_Equation.c:                E->slice_ve.ocean_fcn_prev[m][n] = 0.0;
Maxwelltime:Sea_Level_Equation.c:                E->slice_ve.ocean_fcn_next[m][n] = 0.0;
Maxwelltime:Sea_Level_Equation.c:                        E->ve_data_cont.ocean_file, E->parallel.me, start_epoch);
Maxwelltime:Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)  {
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.ocean_fcn_prev[m][j] = (float)temp0 ;
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.ocean_fcn[m][j] = E->slice_ve.ocean_fcn_prev[m][j] ;
Maxwelltime:Sea_Level_Equation.c:        total_time = E->ve_data_cont.tau*E->monitor.elapsed_time;
Maxwelltime:Sea_Level_Equation.c:        i = (total_time - E->ve_data_cont.stages_time[0]);
Maxwelltime:Sea_Level_Equation.c:        // note: if E->control.stage==0 (during glaciation),   i<0 (returns)
Maxwelltime:Sea_Level_Equation.c:        //       if E->control.stage==1 (during deglaciation), check ifile
Maxwelltime:Sea_Level_Equation.c:        //       if E->control.stage==2 (after deglaciation),  see next block
Maxwelltime:Sea_Level_Equation.c:    if (E->ve_data_cont.stage==2)  {                 // completed deglaciation 
Maxwelltime:Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++) 
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.incr_ocean_fcn[m][j] = 0.0;    // 0 => no more change
Maxwelltime:Sea_Level_Equation.c:        E->ve_data_cont.incr_ocean_area = 0.0 ;
Maxwelltime:Sea_Level_Equation.c:        E->ve_data_cont.incr_ice_volume = 0.0  ;
Maxwelltime:Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)  
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.ocean_fcn_prev[m][j] = E->slice_ve.ocean_fcn_next[m][j];   
Maxwelltime:Sea_Level_Equation.c:    sprintf(outfile,"%s.%d.time%d", E->ve_data_cont.ocean_file,E->parallel.me,ifile);
Maxwelltime:Sea_Level_Equation.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:    for (j=1;j<=E->lmesh.nsf;j++)  {
Maxwelltime:Sea_Level_Equation.c:        E->slice_ve.ocean_fcn_next[m][j] = (float)temp0 ;
Maxwelltime:Sea_Level_Equation.c:    if (ifile==1) steps_per_epoch = E->ve_data_cont.stages_step[0];
Maxwelltime:Sea_Level_Equation.c:    else  steps_per_epoch =  1000.0/E->ve_data_cont.tau   // nondim 1kyr
Maxwelltime:Sea_Level_Equation.c:                             / E->ve_data_cont.stages_timestep[E->ve_data_cont.stage] ;
Maxwelltime:Sea_Level_Equation.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:    for (j=1;j<=E->lmesh.nsf;j++) 
Maxwelltime:Sea_Level_Equation.c:        E->slice_ve.incr_ocean_fcn[m][j] = ( E->slice_ve.ocean_fcn_next[m][j]
Maxwelltime:Sea_Level_Equation.c:                                         -E->slice_ve.ocean_fcn_prev[m][j]) 
Maxwelltime:Sea_Level_Equation.c:    E->ve_data_cont.incr_ocean_area=total_surface_integral(E,E->slice_ve.incr_ocean_fcn,1);
Maxwelltime:Sea_Level_Equation.c:    E->ve_data_cont.incr_ice_volume = (ice_volume[ifile] - ice_volume[ifile-1]) 
Maxwelltime:Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.ocean_fcn[m] = (double *)
Maxwelltime:Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.incr_ocean_fcn[m] = (double *)
Maxwelltime:Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.ocean_fcn_prev[m] = (double *)
Maxwelltime:Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.ocean_fcn_next[m] = (double *)
Maxwelltime:Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Maxwelltime:Sea_Level_Equation.c:            for (n=1;n<=E->lmesh.nsf;n++)  {  
Maxwelltime:Sea_Level_Equation.c:                E->slice_ve.ocean_fcn[m][n]      = 0.0;
Maxwelltime:Sea_Level_Equation.c:                E->slice_ve.incr_ocean_fcn[m][n] = 0.0;
Maxwelltime:Sea_Level_Equation.c:                E->slice_ve.ocean_fcn_prev[m][n] = 0.0;
Maxwelltime:Sea_Level_Equation.c:                E->slice_ve.ocean_fcn_next[m][n] = 0.0;
Maxwelltime:Sea_Level_Equation.c:   if (E->ve_data_cont.DIRECT == 0 && been_here!=0)
Maxwelltime:Sea_Level_Equation.c:   ifile = E->ve_data_cont.stage + 1;
Maxwelltime:Sea_Level_Equation.c:           E->ve_data_cont.ocean_file, E->sphere.elx,E->sphere.ely, ifile-1);
Maxwelltime:Sea_Level_Equation.c:       read_reg_grids(E,outfile,E->slice_ve.ocean_fcn_prev);
Maxwelltime:Sea_Level_Equation.c:       for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:         for (j=1;j<=E->lmesh.nsf;j++)  
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.ocean_fcn[m][j] = E->slice_ve.ocean_fcn_prev[m][j];   
Maxwelltime:Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)  
Maxwelltime:Sea_Level_Equation.c:            E->slice_ve.ocean_fcn_prev[m][j] = E->slice_ve.ocean_fcn_next[m][j];   
Maxwelltime:Sea_Level_Equation.c:        step_prev = E->ve_data_cont.stages_step[E->ve_data_cont.stage-1];
Maxwelltime:Sea_Level_Equation.c:            E->ve_data_cont.ocean_file, E->sphere.elx,E->sphere.ely, ifile);
Maxwelltime:Sea_Level_Equation.c:   read_reg_grids(E,outfile,E->slice_ve.ocean_fcn_next);
Maxwelltime:Sea_Level_Equation.c:    steps_per_epoch = E->ve_data_cont.stages_step[E->ve_data_cont.stage] - step_prev;
Maxwelltime:Sea_Level_Equation.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sea_Level_Equation.c:    for (j=1;j<=E->lmesh.nsf;j++) 
Maxwelltime:Sea_Level_Equation.c:        E->slice_ve.incr_ocean_fcn[m][j] = ( E->slice_ve.ocean_fcn_next[m][j]
Maxwelltime:Sea_Level_Equation.c:                                         -E->slice_ve.ocean_fcn_prev[m][j]) 
Maxwelltime:Sea_Level_Equation.c:    E->ve_data_cont.incr_ocean_area=total_surface_integral(E,E->slice_ve.incr_ocean_fcn,1);
Maxwelltime:Sea_Level_Equation.c:    ice_volume_new=total_surface_integral(E,E->slice_ve.ice_height_curr,1);
Maxwelltime:Sea_Level_Equation.c:    ice_volume_old=total_surface_integral(E,E->slice_ve.ice_height_prev,1);
Maxwelltime:Sea_Level_Equation.c:    E->ve_data_cont.incr_ice_volume = (ice_volume_new - ice_volume_old) 
Maxwelltime:Sea_Level_Equation.c:    if (E->parallel.me==0) fprintf(E->fp,"ICE_Volume %g %g\n",ice_volume_new,ice_volume_old);
Maxwelltime:Shape_functions.c:    { E->N.vpt[i] = 0.0; 
Maxwelltime:Shape_functions.c:      E->Nx.vpt[i] = 0.0;
Maxwelltime:Shape_functions.c:      E->Nx.vpt[GNVI+i] = 0.0;
Maxwelltime:Shape_functions.c:      E->Nx.vpt[2*GNVI+i] = 0.0; 
Maxwelltime:Shape_functions.c:    { E->N.ppt[i] = 0.0; 
Maxwelltime:Shape_functions.c:      E->Nx.ppt[i] = 0.0;
Maxwelltime:Shape_functions.c:      E->Nx.ppt[GNPI+i] = 0.0;
Maxwelltime:Shape_functions.c:      E->Nx.ppt[2*GNPI+i] = 0.0; 
Maxwelltime:Shape_functions.c:    { E->M.vpt[i] = 0.0; 
Maxwelltime:Shape_functions.c:      E->Mx.vpt[i] = 0.0;
Maxwelltime:Shape_functions.c:      E->Mx.vpt[GN1VI+i] = 0.0;
Maxwelltime:Shape_functions.c:    { E->M.ppt[i] = 0.0; 
Maxwelltime:Shape_functions.c:      E->Mx.ppt[i] = 0.0;
Maxwelltime:Shape_functions.c:      E->Mx.ppt[GN1PI+i] = 0.0;
Maxwelltime:Shape_functions.c:    { E->L.vpt[i] = 0.0; 
Maxwelltime:Shape_functions.c:      E->Lx.vpt[i] = 0.0;
Maxwelltime:Shape_functions.c:      E->Lx.vpt[GN1VI+i] = 0.0;
Maxwelltime:Shape_functions.c:    { E->NM.vpt[i] = 0.0; 
Maxwelltime:Shape_functions.c:      E->NMx.vpt[i] = 0.0;
Maxwelltime:Shape_functions.c:      E->NMx.vpt[GNVI+i] = 0.0;
Maxwelltime:Shape_functions.c:      E->NMx.vpt[2*GNVI+i] = 0.0; 
Maxwelltime:Shape_functions.c:  for(i=1;i<=enodes[E->mesh.nsd];i++)   {
Maxwelltime:Shape_functions.c:      for(j=1;j<=vpoints[E->mesh.nsd];j++)  { 
Maxwelltime:Shape_functions.c:         E->N.vpt[GNVINDEX(i,j)] = 1.0;
Maxwelltime:Shape_functions.c:         for(d=1;d<=E->mesh.nsd;d++)   
Maxwelltime:Shape_functions.c:             E->N.vpt[GNVINDEX(i,j)] *=  
Maxwelltime:Shape_functions.c:         for(dd=1;dd<=E->mesh.nsd;dd++) {
Maxwelltime:Shape_functions.c:             E->Nx.vpt[GNVXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],g_point[j].x[dd-1]);
Maxwelltime:Shape_functions.c:             for(d=1;d<=E->mesh.nsd;d++)
Maxwelltime:Shape_functions.c:                   E->Nx.vpt[GNVXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],g_point[j].x[d-1]);
Maxwelltime:Shape_functions.c:      for(j=1;j<=ppoints[E->mesh.nsd];j++)  {
Maxwelltime:Shape_functions.c:         E->N.ppt[GNPINDEX(i,j)] = 1.0;
Maxwelltime:Shape_functions.c:         for(d=1;d<=E->mesh.nsd;d++) 
Maxwelltime:Shape_functions.c:            E->N.ppt[GNPINDEX(i,j)] *=  
Maxwelltime:Shape_functions.c:         for(dd=1;dd<=E->mesh.nsd;dd++) {
Maxwelltime:Shape_functions.c:            E->Nx.ppt[GNPXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],p_point[j].x[dd-1]);
Maxwelltime:Shape_functions.c:            for(d=1;d<=E->mesh.nsd;d++)
Maxwelltime:Shape_functions.c:                  E->Nx.ppt[GNPXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],p_point[j].x[d-1]); 
Maxwelltime:Shape_functions.c:  for(j=1;j<=onedvpoints[E->mesh.nsd];j++)
Maxwelltime:Shape_functions.c:    for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Maxwelltime:Shape_functions.c:       E->M.vpt[GMVINDEX(j,k)] = 1.0;
Maxwelltime:Shape_functions.c:       E->L.vpt[GMVINDEX(j,k)] = 1.0;
Maxwelltime:Shape_functions.c:       for(d=1;d<=E->mesh.nsd-1;d++) {
Maxwelltime:Shape_functions.c:          E->M.vpt[GMVINDEX(j,k)] *= lpoly(bb[d-1][j],s_point[k].x[d-1]);
Maxwelltime:Shape_functions.c:          E->L.vpt[GMVINDEX(j,k)] *= lpoly(bb[d-1][j],l_1d[k].x[d-1]);
Maxwelltime:Shape_functions.c:       for(dd=1;dd<=E->mesh.nsd-1;dd++) {
Maxwelltime:Shape_functions.c:          E->Mx.vpt[GMVXINDEX(dd-1,j,k)] = lpolydash(bb[dd-1][j],s_point[k].x[d-1]);
Maxwelltime:Shape_functions.c:          E->Lx.vpt[GMVXINDEX(dd-1,j,k)] = lpolydash(bb[dd-1][j],l_1d[k].x[d-1]);
Maxwelltime:Shape_functions.c:          for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Shape_functions.c:                E->Mx.vpt[GMVXINDEX(dd-1,j,k)] *= lpoly(bb[d-1][j],s_point[k].x[d-1]);
Maxwelltime:Shape_functions.c:                E->Lx.vpt[GMVXINDEX(dd-1,j,k)] *= lpoly(bb[d-1][j],l_1d[k].x[d-1]);
Maxwelltime:Shape_functions.c:  for(i=1;i<=enodes[E->mesh.nsd];i++)   {
Maxwelltime:Shape_functions.c:      for(j=1;j<=vpoints[E->mesh.nsd];j++)   {
Maxwelltime:Shape_functions.c:         E->NM.vpt[GNVINDEX(i,j)] = 1.0;
Maxwelltime:Shape_functions.c:         for(d=1;d<=E->mesh.nsd;d++)   
Maxwelltime:Shape_functions.c:             E->NM.vpt[GNVINDEX(i,j)] *=  
Maxwelltime:Shape_functions.c:         for(dd=1;dd<=E->mesh.nsd;dd++)                 {
Maxwelltime:Shape_functions.c:            E->NMx.vpt[GNVXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],s_point[j].x[dd-1]);
Maxwelltime:Shape_functions.c:            for(d=1;d<=E->mesh.nsd;d++)
Maxwelltime:Shape_functions.c:                  E->NMx.vpt[GNVXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],s_point[j].x[d-1]); 
Maxwelltime:Size_does_matter.c:    const int dims = E->mesh.nsd;
Maxwelltime:Size_does_matter.c:                x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]
Maxwelltime:Size_does_matter.c:                    * E->N.vpt[GNVINDEX(i,k)];
Maxwelltime:Size_does_matter.c:                    dxda[d][e] += E->X[lev][m][e][E->IEN[lev][m][el].node[i]]
Maxwelltime:Size_does_matter.c:                        * E->Nx.vpt[GNVXINDEX(d-1,i,k)];
Maxwelltime:Size_does_matter.c:        jacobian = determinant(dxda, E->mesh.nsd);
Maxwelltime:Size_does_matter.c:        E->GDA[lev][m][el].vpt[k] = jacobian;
Maxwelltime:Size_does_matter.c:                        E->Nx.vpt[GNVXINDEX(e-1,j,k)] *cof[e][d];
Maxwelltime:Size_does_matter.c:                E->GNX[lev][m][el].vpt[GNVXINDEX(d-1,j,k)]
Maxwelltime:Size_does_matter.c:                x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]
Maxwelltime:Size_does_matter.c:                    * E->N.ppt[GNPINDEX(i,k)];
Maxwelltime:Size_does_matter.c:                    dxda[d][e] += E->X[lev][m][e][E->IEN[lev][m][el].node[i]]
Maxwelltime:Size_does_matter.c:                        * E->Nx.ppt[GNPXINDEX(d-1,i,k)];
Maxwelltime:Size_does_matter.c:        jacobian = determinant(dxda,E->mesh.nsd);
Maxwelltime:Size_does_matter.c:        E->GDA[lev][m][el].ppt[k] = jacobian;
Maxwelltime:Size_does_matter.c:                cof[d][e]=cofactor(dxda,d,e,E->mesh.nsd);
Maxwelltime:Size_does_matter.c:                        E->Nx.ppt[GNPXINDEX(e-1,j,k)]*cof[e][d];
Maxwelltime:Size_does_matter.c:                E->GNX[lev][m][el].ppt[GNPXINDEX(d-1,j,k)]
Maxwelltime:Size_does_matter.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Size_does_matter.c:        for(lev=E->mesh.levmax; lev>=E->mesh.levmin; lev--)
Maxwelltime:Size_does_matter.c:            for(el=1; el<=E->lmesh.NEL[lev]; el++) {
Maxwelltime:Size_does_matter.c:    const int dims = E->mesh.nsd;
Maxwelltime:Size_does_matter.c:                x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]
Maxwelltime:Size_does_matter.c:                    * E->N.vpt[GNVINDEX(i,k)];
Maxwelltime:Size_does_matter.c:    const int dims = E->mesh.nsd;
Maxwelltime:Size_does_matter.c:                x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]
Maxwelltime:Size_does_matter.c:                    * E->N.ppt[GNPINDEX(i,k)];
Maxwelltime:Size_does_matter.c:  const int oned = onedvpoints[E->mesh.nsd];
Maxwelltime:Size_does_matter.c:  to = theta_g(E->eco[m][el].centre[1],E);
Maxwelltime:Size_does_matter.c:  to = E->eco[m][el].centre[1];	
Maxwelltime:Size_does_matter.c:  fo = E->eco[m][el].centre[2];
Maxwelltime:Size_does_matter.c:    node = E->ien[m][el].node[s];
Maxwelltime:Size_does_matter.c:    xx[1][i] = E->x[m][1][node]*dxdy[1][1]
Maxwelltime:Size_does_matter.c:             + E->x[m][2][node]*dxdy[1][2]
Maxwelltime:Size_does_matter.c:             + E->x[m][3][node]*dxdy[1][3];
Maxwelltime:Size_does_matter.c:    xx[2][i] = E->x[m][1][node]*dxdy[2][1]
Maxwelltime:Size_does_matter.c:             + E->x[m][2][node]*dxdy[2][2]
Maxwelltime:Size_does_matter.c:             + E->x[m][3][node]*dxdy[2][3];
Maxwelltime:Size_does_matter.c:    xx[3][i] = E->x[m][1][node]*dxdy[3][1]
Maxwelltime:Size_does_matter.c:             + E->x[m][2][node]*dxdy[3][2]
Maxwelltime:Size_does_matter.c:             + E->x[m][3][node]*dxdy[3][3];
Maxwelltime:Size_does_matter.c:  const int oned = onedvpoints[E->mesh.nsd];
Maxwelltime:Size_does_matter.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Size_does_matter.c:      E->surf_det[m][k] = (double *)malloc((1+E->lmesh.snel)*sizeof(double));
Maxwelltime:Size_does_matter.c:  for (m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Size_does_matter.c:  r2 = 1.0 / (E->sx[m][3][E->lmesh.elz+1] * E->sx[m][3][E->lmesh.elz+1]);
Maxwelltime:Size_does_matter.c:  for (es=1;es<=E->lmesh.snel;es++)   {
Maxwelltime:Size_does_matter.c:    el = es * E->lmesh.elz;
Maxwelltime:Size_does_matter.c:      for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Size_does_matter.c:        for(e=1;e<=E->mesh.nsd-1;e++)
Maxwelltime:Size_does_matter.c:        for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Size_does_matter.c:          for(e=1;e<=E->mesh.nsd-1;e++)
Maxwelltime:Size_does_matter.c:             dxda[d][e] += xx[e][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Maxwelltime:Size_does_matter.c:      jacobian = determinant(dxda,E->mesh.nsd-1);
Maxwelltime:Size_does_matter.c:      E->surf_det[m][k][es] = jacobian * r2;
Maxwelltime:Size_does_matter.c:  const int oned = onedvpoints[E->mesh.nsd];
Maxwelltime:Size_does_matter.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Size_does_matter.c:	E->boundary.det[m][side][d] = (double *)malloc((1+E->boundary.nel)*sizeof(double));
Maxwelltime:Size_does_matter.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Size_does_matter.c:    for (es=1;es<=E->boundary.nel;es++) {
Maxwelltime:Size_does_matter.c:      el = E->boundary.element[m][es];
Maxwelltime:Size_does_matter.c:	  for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Size_does_matter.c:	    for(e=1;e<=E->mesh.nsd-1;e++)
Maxwelltime:Size_does_matter.c:	    for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Size_does_matter.c:	      for(e=1;e<=E->mesh.nsd-1;e++)
Maxwelltime:Size_does_matter.c:		dxda[d][e] += xx[sidedim[side][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Maxwelltime:Size_does_matter.c:	  jacobian = determinant(dxda,E->mesh.nsd-1);
Maxwelltime:Size_does_matter.c:	  E->boundary.det[m][side][k][es] = jacobian;
Maxwelltime:Size_does_matter.c:	      E->boundary.det[m][side][1][es],
Maxwelltime:Size_does_matter.c:	      E->boundary.det[m][side][2][es],
Maxwelltime:Size_does_matter.c:	      E->boundary.det[m][side][3][es],
Maxwelltime:Size_does_matter.c:	      E->boundary.det[m][side][4][es],
Maxwelltime:Size_does_matter.c:	      E->boundary.det[m][side][1][es]+
Maxwelltime:Size_does_matter.c:	      E->boundary.det[m][side][2][es]+
Maxwelltime:Size_does_matter.c:	      E->boundary.det[m][side][3][es]+
Maxwelltime:Size_does_matter.c:	      E->boundary.det[m][side][4][es]);
Maxwelltime:Size_does_matter.c:  const int oned = onedvpoints[E->mesh.nsd];
Maxwelltime:Size_does_matter.c:      for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Size_does_matter.c:	for(e=1;e<=E->mesh.nsd-1;e++)
Maxwelltime:Size_does_matter.c:	for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Size_does_matter.c:	  for(e=1;e<=E->mesh.nsd-1;e++)
Maxwelltime:Size_does_matter.c:	    dxda[d][e] += xx[e][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Maxwelltime:Size_does_matter.c:      jacobian = determinant(dxda,E->mesh.nsd-1);
Maxwelltime:Size_does_matter.c:    const int oned = onedvpoints[E->mesh.nsd];
Maxwelltime:Size_does_matter.c:    to = theta_g(E->eco[m][el].centre[1],E);
Maxwelltime:Size_does_matter.c:    to = E->eco[m][el].centre[1]; 
Maxwelltime:Size_does_matter.c:    fo = E->eco[m][el].centre[2];
Maxwelltime:Size_does_matter.c:            node = E->ien[m][el].node[e];
Maxwelltime:Size_does_matter.c:            xx[1][i] = E->x[m][1][node]*dxdy[1][1]
Maxwelltime:Size_does_matter.c:                + E->x[m][2][node]*dxdy[1][2]
Maxwelltime:Size_does_matter.c:                + E->x[m][3][node]*dxdy[1][3];
Maxwelltime:Size_does_matter.c:            xx[2][i] = E->x[m][1][node]*dxdy[2][1]
Maxwelltime:Size_does_matter.c:                + E->x[m][2][node]*dxdy[2][2]
Maxwelltime:Size_does_matter.c:                + E->x[m][3][node]*dxdy[2][3];
Maxwelltime:Size_does_matter.c:            xx[3][i] = E->x[m][1][node]*dxdy[3][1]
Maxwelltime:Size_does_matter.c:                + E->x[m][2][node]*dxdy[3][2]
Maxwelltime:Size_does_matter.c:                + E->x[m][3][node]*dxdy[3][3];
Maxwelltime:Size_does_matter.c:            for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Size_does_matter.c:                for(e=1;e<=E->mesh.nsd-1;e++)
Maxwelltime:Size_does_matter.c:                for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Size_does_matter.c:                    for(e=1;e<=E->mesh.nsd-1;e++)
Maxwelltime:Size_does_matter.c:                        dxda[d][e] += xx[e][i]*E->Lx.vpt[GMVXINDEX(d-1,i,k)];
Maxwelltime:Size_does_matter.c:            jacobian = determinant(dxda,E->mesh.nsd-1);
Maxwelltime:Size_does_matter.c:  const int dims=E->mesh.nsd;
Maxwelltime:Size_does_matter.c:            x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[a]]
Maxwelltime:Size_does_matter.c:                   *E->N.vpt[GNVINDEX(a,k)];
Maxwelltime:Size_does_matter.c:          tt = E->SX[lev][m][1][E->IEN[lev][m][el].node[a]];
Maxwelltime:Size_does_matter.c:          ff = E->SX[lev][m][2][E->IEN[lev][m][el].node[a]];
Maxwelltime:Size_does_matter.c:            x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[a]]
Maxwelltime:Size_does_matter.c:                   *E->N.ppt[GNPINDEX(a,k)];
Maxwelltime:Size_does_matter.c:	  lnode = E->IEN[lev][m][el].node[a];
Maxwelltime:Size_does_matter.c:	  sintt = E->SinCos[lev][m][0][lnode];
Maxwelltime:Size_does_matter.c:	  sinff = E->SinCos[lev][m][1][lnode];
Maxwelltime:Size_does_matter.c:	  costt = E->SinCos[lev][m][2][lnode];
Maxwelltime:Size_does_matter.c:	  cosff = E->SinCos[lev][m][3][lnode];
Maxwelltime:Size_does_matter.c:  const int dims=E->mesh.nsd;
Maxwelltime:Size_does_matter.c:	  x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[a]]
Maxwelltime:Size_does_matter.c:	    *E->M.vpt[GMVINDEX(aa,k)];
Maxwelltime:Size_does_matter.c:	lnode = E->IEN[lev][m][el].node[a];
Maxwelltime:Size_does_matter.c:	sintt = E->SinCos[lev][m][0][lnode];
Maxwelltime:Size_does_matter.c:	sinff = E->SinCos[lev][m][1][lnode];
Maxwelltime:Size_does_matter.c:	costt = E->SinCos[lev][m][2][lnode];
Maxwelltime:Size_does_matter.c:	cosff = E->SinCos[lev][m][3][lnode];
Maxwelltime:Size_does_matter.c:      for(d=1;d<=E->mesh.nsd;d++)
Maxwelltime:Size_does_matter.c:       	x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[aa]]
Maxwelltime:Size_does_matter.c:       	  *E->M.ppt[GMPINDEX(a,k)];
Maxwelltime:Size_does_matter.c:	lnode = E->IEN[lev][m][el].node[aa];
Maxwelltime:Size_does_matter.c:	sintt = E->SinCos[lev][m][0][lnode];
Maxwelltime:Size_does_matter.c:	sinff = E->SinCos[lev][m][1][lnode];
Maxwelltime:Size_does_matter.c:	costt = E->SinCos[lev][m][2][lnode];
Maxwelltime:Size_does_matter.c:	cosff = E->SinCos[lev][m][3][lnode];
Maxwelltime:Size_does_matter.c:	for (i=1;i<=E->mesh.nsd;i++) {
Maxwelltime:Size_does_matter.c:	  for (j=1;j<=E->mesh.nsd;j++) {
Maxwelltime:Size_does_matter.c:  const int dims=E->mesh.nsd;
Maxwelltime:Size_does_matter.c: for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Maxwelltime:Size_does_matter.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Size_does_matter.c:    nel_surface = E->lmesh.NEL[lev]/E->lmesh.ELZ[lev];
Maxwelltime:Size_does_matter.c:      el = es*E->lmesh.ELZ[lev];
Maxwelltime:Size_does_matter.c:            x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[a]]
Maxwelltime:Size_does_matter.c:                   *E->N.vpt[GNVINDEX(a,k)];
Maxwelltime:Size_does_matter.c:	  lnode = E->IEN[lev][m][el].node[a];
Maxwelltime:Size_does_matter.c:	  sintt = E->SinCos[lev][m][0][lnode];
Maxwelltime:Size_does_matter.c:	  sinff = E->SinCos[lev][m][1][lnode];
Maxwelltime:Size_does_matter.c:	  costt = E->SinCos[lev][m][2][lnode];
Maxwelltime:Size_does_matter.c:	  cosff = E->SinCos[lev][m][3][lnode];
Maxwelltime:Size_does_matter.c:              E->CC[lev][m][es].vpt[BVINDEX(i,j,a,k)] =
Maxwelltime:Size_does_matter.c:              E->CCX[lev][m][es].vpt[BVXINDEX(i,j,1,a,k)] =
Maxwelltime:Size_does_matter.c:              E->CCX[lev][m][es].vpt[BVXINDEX(i,j,2,a,k)] =
Maxwelltime:Size_does_matter.c:            x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[a]]
Maxwelltime:Size_does_matter.c:                   *E->N.ppt[GNPINDEX(a,k)];
Maxwelltime:Size_does_matter.c:	  lnode = E->IEN[lev][m][el].node[a];
Maxwelltime:Size_does_matter.c:	  sintt = E->SinCos[lev][m][0][lnode];
Maxwelltime:Size_does_matter.c:	  sinff = E->SinCos[lev][m][1][lnode];
Maxwelltime:Size_does_matter.c:	  costt = E->SinCos[lev][m][2][lnode];
Maxwelltime:Size_does_matter.c:	  cosff = E->SinCos[lev][m][3][lnode];
Maxwelltime:Size_does_matter.c:              E->CC[lev][m][es].ppt[BPINDEX(i,j,a,k)] =
Maxwelltime:Size_does_matter.c:              E->CCX[lev][m][es].ppt[BPXINDEX(i,j,1,a,k)] =
Maxwelltime:Size_does_matter.c:              E->CCX[lev][m][es].ppt[BPXINDEX(i,j,2,a,k)] =
Maxwelltime:Size_does_matter.c:    const int vpts=vpoints[E->mesh.nsd];
Maxwelltime:Size_does_matter.c:    for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Maxwelltime:Size_does_matter.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Size_does_matter.c:            for(node=1;node<=E->lmesh.NNO[lev];node++)
Maxwelltime:Size_does_matter.c:                E->MASS[lev][m][node] = 0.0;
Maxwelltime:Size_does_matter.c:            for(e=1;e<=E->lmesh.NEL[lev];e++)  {
Maxwelltime:Size_does_matter.c:                for(node=1;node<=enodes[E->mesh.nsd];node++)
Maxwelltime:Size_does_matter.c:                    n[node] = E->IEN[lev][m][e].node[node];
Maxwelltime:Size_does_matter.c:                for(i=1;i<=E->mesh.nsd;i++)  {
Maxwelltime:Size_does_matter.c:                    for(node=1;node<=enodes[E->mesh.nsd];node++)
Maxwelltime:Size_does_matter.c:                        centre[i] += E->X[lev][m][i][n[node]];
Maxwelltime:Size_does_matter.c:                    centre[i] = centre[i]/enodes[E->mesh.nsd];
Maxwelltime:Size_does_matter.c:                E->ECO[lev][m][e].centre[1] = dx1;
Maxwelltime:Size_does_matter.c:                E->ECO[lev][m][e].centre[2] = dx2;
Maxwelltime:Size_does_matter.c:                E->ECO[lev][m][e].centre[3] = dx3;
Maxwelltime:Size_does_matter.c:                dx1 = max( fabs(E->SX[lev][m][1][n[3]]-E->SX[lev][m][1][n[1]]),
Maxwelltime:Size_does_matter.c:                           fabs(E->SX[lev][m][1][n[2]]-E->SX[lev][m][1][n[4]]) );
Maxwelltime:Size_does_matter.c:                E->ECO[lev][m][e].size[1] = dx1*E->ECO[lev][m][e].centre[3];
Maxwelltime:Size_does_matter.c:                dx1 = fabs(E->SX[lev][m][2][n[3]]-E->SX[lev][m][2][n[1]]);
Maxwelltime:Size_does_matter.c:                    dx1 = min(E->SX[lev][m][2][n[3]],E->SX[lev][m][2][n[1]]) + 2.0*M_PI -
Maxwelltime:Size_does_matter.c:                        max(E->SX[lev][m][2][n[3]],E->SX[lev][m][2][n[1]]) ;
Maxwelltime:Size_does_matter.c:                dx2 = fabs(E->SX[lev][m][2][n[2]]-E->SX[lev][m][2][n[4]]);
Maxwelltime:Size_does_matter.c:                    dx2 = min(E->SX[lev][m][2][n[2]],E->SX[lev][m][2][n[4]]) + 2.0*M_PI -
Maxwelltime:Size_does_matter.c:                        max(E->SX[lev][m][2][n[2]],E->SX[lev][m][2][n[4]]) ;
Maxwelltime:Size_does_matter.c:                E->ECO[lev][m][e].size[2] = dx2*E->ECO[lev][m][e].centre[3]
Maxwelltime:Size_does_matter.c:                    *sin(E->ECO[lev][m][e].centre[1]);
Maxwelltime:Size_does_matter.c:                dx3 = 0.25*(fabs(E->SX[lev][m][3][n[5]]+E->SX[lev][m][3][n[6]]
Maxwelltime:Size_does_matter.c:                                 +E->SX[lev][m][3][n[7]]+E->SX[lev][m][3][n[8]]
Maxwelltime:Size_does_matter.c:                                 -E->SX[lev][m][3][n[1]]-E->SX[lev][m][3][n[2]]
Maxwelltime:Size_does_matter.c:                                 -E->SX[lev][m][3][n[3]]-E->SX[lev][m][3][n[4]]));
Maxwelltime:Size_does_matter.c:                E->ECO[lev][m][e].size[3] = dx3;
Maxwelltime:Size_does_matter.c:                    area += g_point[nint].weight[E->mesh.nsd-1] * E->GDA[lev][m][e].vpt[nint];
Maxwelltime:Size_does_matter.c:                E->ECO[lev][m][e].area = area;
Maxwelltime:Size_does_matter.c:                for(node=1;node<=enodes[E->mesh.nsd];node++)  {
Maxwelltime:Size_does_matter.c:                        temp[node] += E->GDA[lev][m][e].vpt[nint]*g_point[nint].weight[E->mesh.nsd-1]
Maxwelltime:Size_does_matter.c:                            *E->N.vpt[GNVINDEX(node,nint)];       /* int Na dV */
Maxwelltime:Size_does_matter.c:                for(node=1;node<=enodes[E->mesh.nsd];node++)
Maxwelltime:Size_does_matter.c:                    E->MASS[lev][m][E->IEN[lev][m][e].node[node]] += temp[node];
Maxwelltime:Size_does_matter.c:                for(node=1;node<=enodes[E->mesh.nsd];node++)
Maxwelltime:Size_does_matter.c:                    E->TWW[lev][m][e].node[node] = temp[node];
Maxwelltime:Size_does_matter.c:        if(lev == E->mesh.levmax)
Maxwelltime:Size_does_matter.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Size_does_matter.c:                for(node=1;node<=E->lmesh.NNO[lev];node++)
Maxwelltime:Size_does_matter.c:                    E->NMass[m][node] = E->MASS[lev][m][node];
Maxwelltime:Size_does_matter.c:        if (E->control.NMULTIGRID||E->mesh.levmax==lev)
Maxwelltime:Size_does_matter.c:            (E->exchange_node_d)(E,E->MASS[lev],lev);
Maxwelltime:Size_does_matter.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Size_does_matter.c:            for(node=1;node<=E->lmesh.NNO[lev];node++)
Maxwelltime:Size_does_matter.c:                E->MASS[lev][m][node] = 1.0/E->MASS[lev][m][node];
Maxwelltime:Size_does_matter.c:    for (m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Size_does_matter.c:        for(node=1;node<=E->lmesh.nno;node++)
Maxwelltime:Size_does_matter.c:            E->TMass[m][node] = 0.0;
Maxwelltime:Size_does_matter.c:        for(e=1;e<=E->lmesh.nel;e++)  {
Maxwelltime:Size_does_matter.c:            for(node=1;node<=enodes[E->mesh.nsd];node++) {
Maxwelltime:Size_does_matter.c:                nz = ((E->ien[m][e].node[node]-1) % E->lmesh.noz) + 1;
Maxwelltime:Size_does_matter.c:                    temp[node] += E->refstate.rho[nz]
Maxwelltime:Size_does_matter.c:                        * E->refstate.heat_capacity[nz]
Maxwelltime:Size_does_matter.c:                        * E->gDA[m][e].vpt[nint]
Maxwelltime:Size_does_matter.c:                        * g_point[nint].weight[E->mesh.nsd-1]
Maxwelltime:Size_does_matter.c:                        * E->N.vpt[GNVINDEX(node,nint)];
Maxwelltime:Size_does_matter.c:            for(node=1;node<=enodes[E->mesh.nsd];node++)
Maxwelltime:Size_does_matter.c:                E->TMass[m][E->ien[m][e].node[node]] += temp[node];
Maxwelltime:Size_does_matter.c:    (E->exchange_node_d)(E,E->TMass,E->mesh.levmax);
Maxwelltime:Size_does_matter.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Size_does_matter.c:        for(node=1;node<=E->lmesh.nno;node++)
Maxwelltime:Size_does_matter.c:            E->TMass[m][node] = 1.0 / E->TMass[m][node];
Maxwelltime:Size_does_matter.c:    E->lmesh.volume = 0;
Maxwelltime:Size_does_matter.c:    E->mesh.volume = 0;
Maxwelltime:Size_does_matter.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Size_does_matter.c:        for(e=1;e<=E->lmesh.nel;e++)
Maxwelltime:Size_does_matter.c:            E->lmesh.volume += E->eco[m][e].area;
Maxwelltime:Size_does_matter.c:    MPI_Allreduce(&E->lmesh.volume, &E->mesh.volume, 1, MPI_DOUBLE,
Maxwelltime:Size_does_matter.c:                  MPI_SUM, E->parallel.world);
Maxwelltime:Size_does_matter.c:    if (E->control.verbose)  {
Maxwelltime:Size_does_matter.c:        fprintf(E->fp_out, "rank=%d my_volume=%e total_volume=%e\n",
Maxwelltime:Size_does_matter.c:                E->parallel.me, E->lmesh.volume, E->mesh.volume);
Maxwelltime:Size_does_matter.c:        for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Maxwelltime:Size_does_matter.c:            fprintf(E->fp_out,"output_mass lev=%d\n",lev);
Maxwelltime:Size_does_matter.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Size_does_matter.c:                fprintf(E->fp_out,"m=%d %d \n",E->sphere.capid[m],m);
Maxwelltime:Size_does_matter.c:                for(e=1;e<=E->lmesh.NEL[lev];e++)
Maxwelltime:Size_does_matter.c:                    fprintf(E->fp_out,"%d %g \n",e,E->ECO[lev][m][e].area);
Maxwelltime:Size_does_matter.c:                for (node=1;node<=E->lmesh.NNO[lev];node++)
Maxwelltime:Size_does_matter.c:                    fprintf(E->fp_out,"Mass[%d]= %g \n",node,E->MASS[lev][m][node]);
Maxwelltime:Size_does_matter.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Size_does_matter.c:            fprintf(E->fp_out,"m=%d %d \n",E->sphere.capid[m],m);
Maxwelltime:Size_does_matter.c:            for (node=1;node<=E->lmesh.nno;node++)
Maxwelltime:Size_does_matter.c:                fprintf(E->fp_out,"TMass[%d]= %g \n",node,E->TMass[m][node]);
Maxwelltime:Size_does_matter.c:        fflush(E->fp_out);
Maxwelltime:Size_does_matter.c:  lev = E->mesh.levmax;
Maxwelltime:Size_does_matter.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Size_does_matter.c:    for(e=1;e<=E->lmesh.snel;e++)          {
Maxwelltime:Size_does_matter.c:  const int oned = onedvpoints[E->mesh.nsd];
Maxwelltime:Size_does_matter.c:  el = (ic==1)?(ee*E->lmesh.ELZ[lev]):((ee-1)*E->lmesh.ELZ[lev]+1);
Maxwelltime:Size_does_matter.c:  to = E->ECO[lev][m][el].centre[1];
Maxwelltime:Size_does_matter.c:  fo = E->ECO[lev][m][el].centre[2];
Maxwelltime:Size_does_matter.c://fprintf(stderr,"aaa %d %d %g %g %g\n",E->parallel.me,el,to,fo,dxdy[3][3]);
Maxwelltime:Size_does_matter.c:     node = E->IEN[lev][m][el].node[e];
Maxwelltime:Size_does_matter.c:     xx[1][i] = E->X[lev][m][1][node]*dxdy[1][1]
Maxwelltime:Size_does_matter.c:              + E->X[lev][m][2][node]*dxdy[1][2]
Maxwelltime:Size_does_matter.c:              + E->X[lev][m][3][node]*dxdy[1][3];
Maxwelltime:Size_does_matter.c:     xx[2][i] = E->X[lev][m][1][node]*dxdy[2][1]
Maxwelltime:Size_does_matter.c:              + E->X[lev][m][2][node]*dxdy[2][2]
Maxwelltime:Size_does_matter.c:              + E->X[lev][m][3][node]*dxdy[2][3];
Maxwelltime:Size_does_matter.c:     xx[3][i] = E->X[lev][m][1][node]*dxdy[3][1]
Maxwelltime:Size_does_matter.c:              + E->X[lev][m][2][node]*dxdy[3][2]
Maxwelltime:Size_does_matter.c:              + E->X[lev][m][3][node]*dxdy[3][3];
Maxwelltime:Size_does_matter.c:    E->gDA0[m][ee].vpt[oned+1] = 0.0;
Maxwelltime:Size_does_matter.c:    E->gDA1[m][ee].vpt[oned+1] = 0.0;
Maxwelltime:Size_does_matter.c:     for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Size_does_matter.c:       for(e=1;e<=E->mesh.nsd-1;e++)
Maxwelltime:Size_does_matter.c:       for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Size_does_matter.c:         for(e=1;e<=E->mesh.nsd-1;e++)
Maxwelltime:Size_does_matter.c:             dxda[d][e] += xx[e][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Maxwelltime:Size_does_matter.c:     jacobian = determinant(dxda,E->mesh.nsd-1);
Maxwelltime:Size_does_matter.c:       E->gDA0[m][ee].vpt[k] = jacobian;
Maxwelltime:Size_does_matter.c:       E->gDA0[m][ee].vpt[1+oned] += jacobian;
Maxwelltime:Size_does_matter.c:       E->gDA1[m][ee].vpt[k] = jacobian;
Maxwelltime:Size_does_matter.c:       E->gDA1[m][ee].vpt[1+oned] += jacobian;
Maxwelltime:Size_does_matter.c:  const int oned = onedvpoints[E->mesh.nsd];
Maxwelltime:Size_does_matter.c:  to = E->ECO[lev][m][el].centre[1];
Maxwelltime:Size_does_matter.c:  fo = E->ECO[lev][m][el].centre[2];
Maxwelltime:Size_does_matter.c:     node = E->IEN[lev][m][el].node[e];
Maxwelltime:Size_does_matter.c:     xx[1][i] = E->X[lev][m][1][node]*dxdy[1][1]
Maxwelltime:Size_does_matter.c:              + E->X[lev][m][2][node]*dxdy[1][2]
Maxwelltime:Size_does_matter.c:              + E->X[lev][m][3][node]*dxdy[1][3];
Maxwelltime:Size_does_matter.c:     xx[2][i] = E->X[lev][m][1][node]*dxdy[2][1]
Maxwelltime:Size_does_matter.c:              + E->X[lev][m][2][node]*dxdy[2][2]
Maxwelltime:Size_does_matter.c:              + E->X[lev][m][3][node]*dxdy[2][3];
Maxwelltime:Size_does_matter.c:     xx[3][i] = E->X[lev][m][1][node]*dxdy[3][1]
Maxwelltime:Size_does_matter.c:              + E->X[lev][m][2][node]*dxdy[3][2]
Maxwelltime:Size_does_matter.c:              + E->X[lev][m][3][node]*dxdy[3][3];
Maxwelltime:Size_does_matter.c:     for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Size_does_matter.c:       for(e=1;e<=E->mesh.nsd-1;e++)
Maxwelltime:Size_does_matter.c:       for(d=1;d<=E->mesh.nsd-1;d++)
Maxwelltime:Size_does_matter.c:         for(e=1;e<=E->mesh.nsd-1;e++)
Maxwelltime:Size_does_matter.c:             dxda[d][e] += xx[e][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Maxwelltime:Size_does_matter.c:     jacobian = determinant(dxda,E->mesh.nsd-1);
Maxwelltime:Size_does_matter.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Size_does_matter.c:   for(k=1;k<=vpoints[E->mesh.nsd];k++)  {
Maxwelltime:Size_does_matter.c:            dxda[d][e] += E->NMx.vpt[GNVXINDEX(d-1,i,k)]
Maxwelltime:Size_does_matter.c:                * E->x[m][e][E->ien[m][el].node[i]];
Maxwelltime:Size_does_matter.c:        jacobian = sqrt(abs(determinant(cof,E->mesh.nsd)))/cof[3][3]; 
Maxwelltime:Size_does_matter.c: for (n=1;n<=E->lmesh.nsf;n++)   {
Maxwelltime:Size_does_matter.c:   t[1] = E->SX[lev][m][1][n*E->lmesh.NOZ[lev]];
Maxwelltime:Size_does_matter.c:   f[1] = E->SX[lev][m][2][n*E->lmesh.NOZ[lev]];
Maxwelltime:Size_does_matter.c:   for (mm=0; mm<=E->output.llmax; mm++)      {
Maxwelltime:Size_does_matter.c:     E->Tbl_cs[m][mm][n] = cos(mm*f[1]);
Maxwelltime:Size_does_matter.c:     E->Tbl_sn[m][mm][n] = sin(mm*f[1]);
Maxwelltime:Size_does_matter.c:   for (ll=0;ll<=E->output.llmax;ll++)
Maxwelltime:Size_does_matter.c:       p = E->sphere.hindex[ll][mm];
Maxwelltime:Size_does_matter.c:       E->Tbl_lm[m][p][n] = modified_plgndr_a(ll,mm,t[1]);
Maxwelltime:Size_does_matter.c: for(k1=1;k1<=onedvpoints[E->mesh.nsd];k1++)   {
Maxwelltime:Size_does_matter.c:   t[k1] = E->sx[m][1][E->ien[m][e*E->lmesh.elz].node[k1+4]];
Maxwelltime:Size_does_matter.c:   f[k1] = E->sx[m][2][E->ien[m][e*E->lmesh.elz].node[k1+4]];
Maxwelltime:Size_does_matter.c: for (mm=0; mm<=E->output.llmax; mm++)                 
Maxwelltime:Size_does_matter.c:   for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Maxwelltime:Size_does_matter.c:     E->Sph_Harm_Tblcs[m][mm][e].cs[k] = 0.0;
Maxwelltime:Size_does_matter.c:     E->Sph_Harm_Tblcs[m][mm][e].sn[k] = 0.0;
Maxwelltime:Size_does_matter.c:     for(k1=1;k1<=onedvpoints[E->mesh.nsd];k1++)   {
Maxwelltime:Size_does_matter.c:       E->Sph_Harm_Tblcs[m][mm][e].cs[k]+=cos(mm*f[k1])*E->M.vpt[GMVINDEX(k1,k)];
Maxwelltime:Size_does_matter.c:       E->Sph_Harm_Tblcs[m][mm][e].sn[k]+=sin(mm*f[k1])*E->M.vpt[GMVINDEX(k1,k)];
Maxwelltime:Size_does_matter.c: for (ll=0;ll<=E->output.llmax;ll++)
Maxwelltime:Size_does_matter.c:     p = E->sphere.hindex[ll][mm];
Maxwelltime:Size_does_matter.c:     for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Maxwelltime:Size_does_matter.c:       E->Sph_Harm_Tbllm[m][p][e].lm[k] = 0.0;
Maxwelltime:Size_does_matter.c:       for(k1=1;k1<=onedvpoints[E->mesh.nsd];k1++)   {
Maxwelltime:Size_does_matter.c:         E->Sph_Harm_Tbllm[m][p][e].lm[k]+= modified_plgndr_a(ll,mm,t[k1])*E->M.vpt[GMVINDEX(k1,k)];
Maxwelltime:Solver_conj_grad.c:  E->control.CONJ_GRAD = 1;
Maxwelltime:Solver_conj_grad.c:  E->build_forcing_term =   assemble_forces_iterative;
Maxwelltime:Solver_conj_grad.c:  E->solve_stokes_problem = solve_constrained_flow_iterative;
Maxwelltime:Solver_conj_grad.c:  E->solver_allocate_vars = cg_allocate_vars;
Maxwelltime:Solver_conj_grad.c:  strip_bcs_from_residual(E,E->F,E->mesh.levmax);
Maxwelltime:Solver_multigrid.c:  E->control.NMULTIGRID = 1;
Maxwelltime:Solver_multigrid.c:  E->build_forcing_term =   assemble_forces_iterative;
Maxwelltime:Solver_multigrid.c:  E->solve_stokes_problem = solve_constrained_flow_iterative;
Maxwelltime:Solver_multigrid.c:  E->solver_allocate_vars = mg_allocate_vars;
Maxwelltime:Solver_multigrid.c:    const int dims = E->mesh.nsd;
Maxwelltime:Solver_multigrid.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:    for (lev=E->mesh.levmax;lev>E->mesh.levmin;lev--) {
Maxwelltime:Solver_multigrid.c:      for(el=1;el<=E->lmesh.NEL[sl_minus];el++)
Maxwelltime:Solver_multigrid.c:          node_coarse = E->IEN[sl_minus][m][el].node[i];
Maxwelltime:Solver_multigrid.c:          node_fine=E->IEN[lev][m][E->EL[sl_minus][m][el].sub[i]].node[i];
Maxwelltime:Solver_multigrid.c:            E->SX[sl_minus][m][j][node_coarse] = E->SX[lev][m][j][node_fine];
Maxwelltime:Solver_multigrid.c:    const int dims = E->mesh.nsd;
Maxwelltime:Solver_multigrid.c:    if(start_lev == E->mesh.levmin)   {
Maxwelltime:Solver_multigrid.c:        fprintf(E->fp,"Warning, attempting to project below lowest level\n");
Maxwelltime:Solver_multigrid.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:      for(el=1;el<=E->lmesh.NEL[sl_minus];el++)
Maxwelltime:Solver_multigrid.c:          node_coarse = E->IEN[sl_minus][m][el].node[i];
Maxwelltime:Solver_multigrid.c:          node_fine=E->IEN[start_lev][m][E->EL[sl_minus][m][el].sub[i]].node[i];
Maxwelltime:Solver_multigrid.c:    const int dims = E->mesh.nsd;
Maxwelltime:Solver_multigrid.c:    if(start_lev == E->mesh.levmin)   {
Maxwelltime:Solver_multigrid.c:        fprintf(E->fp,"Warning, attempting to project below lowest level\n");
Maxwelltime:Solver_multigrid.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:      for(el=1;el<=E->lmesh.NEL[sl_minus];el++)
Maxwelltime:Solver_multigrid.c:          node_coarse = E->IEN[sl_minus][m][el].node[i];
Maxwelltime:Solver_multigrid.c:          node_fine=E->IEN[start_lev][m][E->EL[sl_minus][m][el].sub[i]].node[i];
Maxwelltime:Solver_multigrid.c:            eqn_fine   = E->ID[start_lev][m][node_fine].doff[j];
Maxwelltime:Solver_multigrid.c:            eqn_coarse = E->ID[sl_minus][m][node_coarse].doff[j];
Maxwelltime:Solver_multigrid.c:    const int dims = E->mesh.nsd;
Maxwelltime:Solver_multigrid.c:    const int neq = E->lmesh.NEQ[sl_plus];
Maxwelltime:Solver_multigrid.c:    const int nels = E->lmesh.NEL[start_lev];
Maxwelltime:Solver_multigrid.c:    assert(start_lev != E->mesh.levmax  /* un_injection */);
Maxwelltime:Solver_multigrid.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:          node = E->IEN[start_lev][m][el].node[i];
Maxwelltime:Solver_multigrid.c:	  node_plus=E->IEN[sl_plus][m][E->EL[start_lev][m][el].sub[i]].node[i];
Maxwelltime:Solver_multigrid.c:	  eqn1 = E->ID[start_lev][m][node].doff[1];
Maxwelltime:Solver_multigrid.c:	  eqn2 = E->ID[start_lev][m][node].doff[2];
Maxwelltime:Solver_multigrid.c:	  eqn3 = E->ID[start_lev][m][node].doff[3];
Maxwelltime:Solver_multigrid.c:	  eqn_plus1 = E->ID[sl_plus][m][node_plus].doff[1];
Maxwelltime:Solver_multigrid.c:	  eqn_plus2 = E->ID[sl_plus][m][node_plus].doff[2];
Maxwelltime:Solver_multigrid.c:	  eqn_plus3 = E->ID[sl_plus][m][node_plus].doff[3];
Maxwelltime:Solver_multigrid.c:    const int dims =E->mesh.nsd;
Maxwelltime:Solver_multigrid.c:    const int nox = E->lmesh.NOX[level];
Maxwelltime:Solver_multigrid.c:    const int noz = E->lmesh.NOZ[level];
Maxwelltime:Solver_multigrid.c:    const int noy = E->lmesh.NOY[level];
Maxwelltime:Solver_multigrid.c:    const int high_eqn = E->lmesh.NEQ[level];
Maxwelltime:Solver_multigrid.c:    if (start_lev==E->mesh.levmax) return;
Maxwelltime:Solver_multigrid.c:    un_inject_vector(E,start_lev,AU,E->temp); /*  information from lower level */
Maxwelltime:Solver_multigrid.c:    fill_in_gaps(E,E->temp,level);
Maxwelltime:Solver_multigrid.c:    from_xyz_to_rtf(E,level,E->temp,AU);      /* get back to rtf coordinates */
Maxwelltime:Solver_multigrid.c:    const int nsd=E->mesh.nsd;
Maxwelltime:Solver_multigrid.c:  lv = E->mesh.levmax;
Maxwelltime:Solver_multigrid.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Solver_multigrid.c:    viscU[m]=(float *)malloc((1+E->lmesh.NNO[lv])*sizeof(float));
Maxwelltime:Solver_multigrid.c:    viscD[m]=(float *)malloc((1+vpts*E->lmesh.NEL[lv-1])*sizeof(float));
Maxwelltime:Solver_multigrid.c:  for(lv=E->mesh.levmax;lv>E->mesh.levmin;lv--)     {
Maxwelltime:Solver_multigrid.c:    if (E->viscosity.smooth_cycles==1)  {
Maxwelltime:Solver_multigrid.c:      visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);
Maxwelltime:Solver_multigrid.c:      visc_from_nodes_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Maxwelltime:Solver_multigrid.c:    else if (E->viscosity.smooth_cycles==2)   {
Maxwelltime:Solver_multigrid.c:      visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv);
Maxwelltime:Solver_multigrid.c:      inject_scalar_e(E,lv,viscU,E->EVI[sl_minus]);
Maxwelltime:Solver_multigrid.c:    else if (E->viscosity.smooth_cycles==3)   {
Maxwelltime:Solver_multigrid.c:      visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv);
Maxwelltime:Solver_multigrid.c:      visc_from_ele_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Maxwelltime:Solver_multigrid.c:    else if (E->viscosity.smooth_cycles==0)  {
Maxwelltime:Solver_multigrid.c:/*      visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);
Maxwelltime:Solver_multigrid.c:      visc_from_nodes_to_gint(E,viscD,E->EVI[sl_minus],sl_minus); */
Maxwelltime:Solver_multigrid.c:      inject_scalar(E,lv,E->VI[lv],E->VI[sl_minus]);
Maxwelltime:Solver_multigrid.c:      visc_from_nodes_to_gint(E,E->VI[sl_minus],E->EVI[sl_minus],sl_minus);
Maxwelltime:Solver_multigrid.c:/*        for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Solver_multigrid.c:            for (i=1;i<=E->lmesh.NEL[lv-1];i++)
Maxwelltime:Solver_multigrid.c:               fprintf (E->fp_out,"%d %g\n",i,viscD[m][i]);
Maxwelltime:Solver_multigrid.c:            for (i=1;i<=E->lmesh.NEL[lv];i++)
Maxwelltime:Solver_multigrid.c:               fprintf (E->fp_out,"%d %g\n",i,viscU[m][i]);
Maxwelltime:Solver_multigrid.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Solver_multigrid.c:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Maxwelltime:Solver_multigrid.c:    const int dims=E->mesh.nsd;
Maxwelltime:Solver_multigrid.c:    const int ends=enodes[E->mesh.nsd];
Maxwelltime:Solver_multigrid.c:    const int vpts=vpoints[E->mesh.nsd];
Maxwelltime:Solver_multigrid.c: for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:                e = E->EL[sl_minus][m][el].sub[i];
Maxwelltime:Solver_multigrid.c:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Maxwelltime:Solver_multigrid.c:    const int  dims=E->mesh.nsd;
Maxwelltime:Solver_multigrid.c:    const int ends=enodes[E->mesh.nsd];
Maxwelltime:Solver_multigrid.c:    const int vpts=vpoints[E->mesh.nsd];
Maxwelltime:Solver_multigrid.c: for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:                e = E->EL[sl_minus][m][el].sub[i];
Maxwelltime:Solver_multigrid.c:    const int nno_minus=E->lmesh.NNO[start_lev-1];
Maxwelltime:Solver_multigrid.c:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Maxwelltime:Solver_multigrid.c:    const int  dims=E->mesh.nsd;
Maxwelltime:Solver_multigrid.c:    const int ends=enodes[E->mesh.nsd];
Maxwelltime:Solver_multigrid.c: for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:                node1 = E->EL[sl_minus][m][el].sub[i];
Maxwelltime:Solver_multigrid.c:                    node=E->IEN[start_lev][m][node1].node[j];
Maxwelltime:Solver_multigrid.c:                node= E->IEN[sl_minus][m][el].node[i];
Maxwelltime:Solver_multigrid.c:                AD[m][node] += w * E->TWW[sl_minus][m][el].node[i];
Maxwelltime:Solver_multigrid.c:   (E->exchange_node_f)(E,AD,sl_minus);
Maxwelltime:Solver_multigrid.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:       AD[m][i] *= E->MASS[sl_minus][m][i];
Maxwelltime:Solver_multigrid.c:    const int neq_minus=E->lmesh.NEQ[start_lev-1];
Maxwelltime:Solver_multigrid.c:    const int nno_minus=E->lmesh.NNO[start_lev-1];
Maxwelltime:Solver_multigrid.c:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Maxwelltime:Solver_multigrid.c:    const int  dims=E->mesh.nsd;
Maxwelltime:Solver_multigrid.c:    const int ends=enodes[E->mesh.nsd];
Maxwelltime:Solver_multigrid.c:   if (start_lev==E->mesh.levmin) return;
Maxwelltime:Solver_multigrid.c:      from_rtf_to_xyz(E,start_lev,AU,E->temp);
Maxwelltime:Solver_multigrid.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:        E->temp1[m][i] = 0.0;
Maxwelltime:Solver_multigrid.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:                node= E->IEN[sl_minus][m][el].node[i];
Maxwelltime:Solver_multigrid.c:		e1 = E->EL[sl_minus][m][el].sub[i];
Maxwelltime:Solver_multigrid.c:		    node1=E->IEN[start_lev][m][e1].node[j];
Maxwelltime:Solver_multigrid.c:		    average1 += E->temp[m][E->ID[start_lev][m][node1].doff[1]];
Maxwelltime:Solver_multigrid.c:		    average2 += E->temp[m][E->ID[start_lev][m][node1].doff[2]];
Maxwelltime:Solver_multigrid.c:		    average3 += E->temp[m][E->ID[start_lev][m][node1].doff[3]];
Maxwelltime:Solver_multigrid.c:		w = weight*E->TWW[sl_minus][m][el].node[i];
Maxwelltime:Solver_multigrid.c:		E->temp1[m][E->ID[sl_minus][m][node].doff[1]] += w * average1;
Maxwelltime:Solver_multigrid.c:		E->temp1[m][E->ID[sl_minus][m][node].doff[2]] += w * average2;
Maxwelltime:Solver_multigrid.c:	 	E->temp1[m][E->ID[sl_minus][m][node].doff[3]] += w * average3;
Maxwelltime:Solver_multigrid.c:   (E->solver.exchange_id_d)(E, E->temp1, sl_minus);
Maxwelltime:Solver_multigrid.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:       E->temp1[m][E->ID[sl_minus][m][i].doff[1]] *= E->MASS[sl_minus][m][i];
Maxwelltime:Solver_multigrid.c:       E->temp1[m][E->ID[sl_minus][m][i].doff[2]] *= E->MASS[sl_minus][m][i];
Maxwelltime:Solver_multigrid.c:       E->temp1[m][E->ID[sl_minus][m][i].doff[3]] *= E->MASS[sl_minus][m][i];
Maxwelltime:Solver_multigrid.c:   from_xyz_to_rtf(E,sl_minus,E->temp1,AD);
Maxwelltime:Solver_multigrid.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:   for (i=1;i<=E->lmesh.NNO[level];i++)  {
Maxwelltime:Solver_multigrid.c:     eqn1 = E->ID[level][m][i].doff[1];
Maxwelltime:Solver_multigrid.c:     eqn2 = E->ID[level][m][i].doff[2];
Maxwelltime:Solver_multigrid.c:     eqn3 = E->ID[level][m][i].doff[3];
Maxwelltime:Solver_multigrid.c:     sint = E->SinCos[level][m][0][i];
Maxwelltime:Solver_multigrid.c:     sinf = E->SinCos[level][m][1][i];
Maxwelltime:Solver_multigrid.c:     cost = E->SinCos[level][m][2][i];
Maxwelltime:Solver_multigrid.c:     cosf = E->SinCos[level][m][3][i];
Maxwelltime:Solver_multigrid.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Solver_multigrid.c:   for (i=1;i<=E->lmesh.NNO[level];i++)  {
Maxwelltime:Solver_multigrid.c:     eqn1 = E->ID[level][m][i].doff[1];
Maxwelltime:Solver_multigrid.c:     eqn2 = E->ID[level][m][i].doff[2];
Maxwelltime:Solver_multigrid.c:     eqn3 = E->ID[level][m][i].doff[3];
Maxwelltime:Solver_multigrid.c:     sint = E->SinCos[level][m][0][i];
Maxwelltime:Solver_multigrid.c:     sinf = E->SinCos[level][m][1][i];
Maxwelltime:Solver_multigrid.c:     cost = E->SinCos[level][m][2][i];
Maxwelltime:Solver_multigrid.c:     cosf = E->SinCos[level][m][3][i];
Maxwelltime:Solver_multigrid.c:    const int dims =E->mesh.nsd;
Maxwelltime:Solver_multigrid.c:    const int nox = E->lmesh.NOX[level];
Maxwelltime:Solver_multigrid.c:    const int noz = E->lmesh.NOZ[level];
Maxwelltime:Solver_multigrid.c:    const int noy = E->lmesh.NOY[level];
Maxwelltime:Solver_multigrid.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)       {
Maxwelltime:Solver_multigrid.c:	      eqn0=E->ID[level][m][node0].doff[1];
Maxwelltime:Solver_multigrid.c:	      eqn1=E->ID[level][m][node1].doff[1];
Maxwelltime:Solver_multigrid.c:	      eqn2=E->ID[level][m][node2].doff[1];
Maxwelltime:Solver_multigrid.c:	      eqn0=E->ID[level][m][node0].doff[2];
Maxwelltime:Solver_multigrid.c:	      eqn1=E->ID[level][m][node1].doff[2];
Maxwelltime:Solver_multigrid.c:	      eqn2=E->ID[level][m][node2].doff[2];
Maxwelltime:Solver_multigrid.c:	      eqn0=E->ID[level][m][node0].doff[3];
Maxwelltime:Solver_multigrid.c:	      eqn1=E->ID[level][m][node1].doff[3];
Maxwelltime:Solver_multigrid.c:	      eqn2=E->ID[level][m][node2].doff[3];
Maxwelltime:Solver_multigrid.c:	        eqn0=E->ID[level][m][node0].doff[1];
Maxwelltime:Solver_multigrid.c:	        eqn1=E->ID[level][m][node1].doff[1];
Maxwelltime:Solver_multigrid.c:	        eqn2=E->ID[level][m][node2].doff[1];
Maxwelltime:Solver_multigrid.c:	        eqn0=E->ID[level][m][node0].doff[2];
Maxwelltime:Solver_multigrid.c:	        eqn1=E->ID[level][m][node1].doff[2];
Maxwelltime:Solver_multigrid.c:	        eqn2=E->ID[level][m][node2].doff[2];
Maxwelltime:Solver_multigrid.c:	        eqn0=E->ID[level][m][node0].doff[3];
Maxwelltime:Solver_multigrid.c:	        eqn1=E->ID[level][m][node1].doff[3];
Maxwelltime:Solver_multigrid.c:	        eqn2=E->ID[level][m][node2].doff[3];
Maxwelltime:Solver_multigrid.c:       x1 = E->sphere.R[level][j] - E->sphere.R[level][j-1];
Maxwelltime:Solver_multigrid.c:       x2 = E->sphere.R[level][j+1] - E->sphere.R[level][j];
Maxwelltime:Solver_multigrid.c:	        eqn0=E->ID[level][m][node0].doff[1];
Maxwelltime:Solver_multigrid.c:	        eqn1=E->ID[level][m][node1].doff[1];
Maxwelltime:Solver_multigrid.c:	        eqn2=E->ID[level][m][node2].doff[1];
Maxwelltime:Solver_multigrid.c:	        eqn0=E->ID[level][m][node0].doff[2];
Maxwelltime:Solver_multigrid.c:	        eqn1=E->ID[level][m][node1].doff[2];
Maxwelltime:Solver_multigrid.c:	        eqn2=E->ID[level][m][node2].doff[2];
Maxwelltime:Solver_multigrid.c:	        eqn0=E->ID[level][m][node0].doff[3];
Maxwelltime:Solver_multigrid.c:	        eqn1=E->ID[level][m][node1].doff[3];
Maxwelltime:Solver_multigrid.c:	        eqn2=E->ID[level][m][node2].doff[3];
Maxwelltime:Sphere_harmonics.c:    for (ll=0;ll<=E->output.llmax;ll++)
Maxwelltime:Sphere_harmonics.c:            E->sphere.hindex[ll][mm] = i;
Maxwelltime:Sphere_harmonics.c:    E->sphere.hindice = i;
Maxwelltime:Sphere_harmonics.c:        E->sphere.harm_geoid[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Maxwelltime:Sphere_harmonics.c:        E->sphere.harm_geoid_from_bncy[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Maxwelltime:Sphere_harmonics.c:        E->sphere.harm_geoid_from_bncy_botm[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Maxwelltime:Sphere_harmonics.c:        E->sphere.harm_geoid_from_tpgt[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Maxwelltime:Sphere_harmonics.c:        E->sphere.harm_geoid_from_tpgb[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Maxwelltime:Sphere_harmonics.c:        E->sphere.harm_tpgt[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Maxwelltime:Sphere_harmonics.c:        E->sphere.harm_tpgb[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Maxwelltime:Sphere_harmonics.c:    proc_loc = E->parallel.me_loc[3];
Maxwelltime:Sphere_harmonics.c:    sphere_expansion_VE(E,ic,TG,sphc,sphs,E->output.llmax);
Maxwelltime:Sphere_harmonics.c:    for (i=0;i<E->sphere.hindice;i++)    {
Maxwelltime:Sphere_harmonics.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sphere_harmonics.c:        for (es=1;es<=E->lmesh.snel;es++)   {
Maxwelltime:Sphere_harmonics.c:            for (ll=0;ll<=E->output.llmax;ll++)
Maxwelltime:Sphere_harmonics.c:                    p = E->sphere.hindex[ll][mm];
Maxwelltime:Sphere_harmonics.c:                    for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Maxwelltime:Sphere_harmonics.c:                        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)   {
Maxwelltime:Sphere_harmonics.c:                            j = E->sien[m][es].node[d];
Maxwelltime:Sphere_harmonics.c:                            sphc[p] += TG[m][E->sien[m][es].node[d]]
Maxwelltime:Sphere_harmonics.c:                                * E->sphere.tablesplm[m][j][p]
Maxwelltime:Sphere_harmonics.c:                                * E->sphere.tablescosf[m][j][mm]
Maxwelltime:Sphere_harmonics.c:                                * E->M.vpt[GMVINDEX(d,nint)]
Maxwelltime:Sphere_harmonics.c:                                * E->surf_det[m][nint][es];
Maxwelltime:Sphere_harmonics.c:                            sphs[p] += TG[m][E->sien[m][es].node[d]]
Maxwelltime:Sphere_harmonics.c:                                * E->sphere.tablesplm[m][j][p]
Maxwelltime:Sphere_harmonics.c:                                * E->sphere.tablessinf[m][j][mm]
Maxwelltime:Sphere_harmonics.c:                                * E->M.vpt[GMVINDEX(d,nint)]
Maxwelltime:Sphere_harmonics.c:                                * E->surf_det[m][nint][es];
Maxwelltime:Sphere_harmonics.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sphere_harmonics.c:        TT[m] = (float *) malloc ((E->lmesh.nsf+1)*sizeof(float));
Maxwelltime:Sphere_harmonics.c:    sph_harm[0] = (float*)malloc(E->sphere.hindice*sizeof(float));
Maxwelltime:Sphere_harmonics.c:    sph_harm[1] = (float*)malloc(E->sphere.hindice*sizeof(float));
Maxwelltime:Sphere_harmonics.c:    for(k=1;k<=E->lmesh.noz;k++)  {
Maxwelltime:Sphere_harmonics.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Sphere_harmonics.c:            for(i=1;i<=E->lmesh.noy;i++)
Maxwelltime:Sphere_harmonics.c:                for(j=1;j<=E->lmesh.nox;j++)  {
Maxwelltime:Sphere_harmonics.c:                    node= k + (j-1)*E->lmesh.noz + (i-1)*E->lmesh.nox*E->lmesh.noz;
Maxwelltime:Sphere_harmonics.c:                    p = j + (i-1)*E->lmesh.nox;
Maxwelltime:Sphere_harmonics.c:                    TT[m][p] = E->T[m][node];
Maxwelltime:Sphere_harmonics.c:        if(E->parallel.me < E->parallel.nprocz) {
Maxwelltime:Sphere_harmonics.c:            for (ll=0;ll<=E->output.llmax;ll++)
Maxwelltime:Sphere_harmonics.c:                    p = E->sphere.hindex[ll][mm];
Maxwelltime:Sphere_harmonics.c:                            k+E->lmesh.nzs-1, ll, mm,
Maxwelltime:Sphere_harmonics.c:  E->sphere.sphc[0] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Maxwelltime:Sphere_harmonics.c:  E->sphere.sphc[1] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Maxwelltime:Sphere_harmonics.c:  E->sphere.sphs[0] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Maxwelltime:Sphere_harmonics.c:  E->sphere.sphs[1] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Maxwelltime:Sphere_harmonics.c:  E->sphere.sphc[2] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Maxwelltime:Sphere_harmonics.c:  E->sphere.sphc[3] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Maxwelltime:Sphere_harmonics.c:  E->sphere.sphc[4] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Maxwelltime:Sphere_harmonics.c:  E->sphere.sphc[5] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Maxwelltime:Sphere_harmonics.c:  E->sphere.sphs[2] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Maxwelltime:Sphere_harmonics.c:  E->sphere.sphs[3] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Maxwelltime:Sphere_harmonics.c:  E->sphere.sphs[4] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Maxwelltime:Sphere_harmonics.c:  E->sphere.sphs[5] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Maxwelltime:Sphere_harmonics.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Sphere_harmonics.c:    for (mm=0;mm<=E->output.llmax;mm++)  {
Maxwelltime:Sphere_harmonics.c:      E->Sph_Harm_Tblcs[m][mm] = (struct SPH1 *) malloc((E->lmesh.snel+2)*sizeof(struct SPH1));
Maxwelltime:Sphere_harmonics.c:      E->Tbl_cs[m][mm] = (float *) malloc((E->lmesh.nsf+2)*sizeof(float));
Maxwelltime:Sphere_harmonics.c:      E->Tbl_sn[m][mm] = (float *) malloc((E->lmesh.nsf+2)*sizeof(float));
Maxwelltime:Sphere_harmonics.c:    for (p=0;p<E->sphere.hindice;p++)    {
Maxwelltime:Sphere_harmonics.c:      E->Sph_Harm_Tbllm[m][p] = (struct SPH2 *) malloc((E->lmesh.snel+2)*sizeof(struct SPH2));
Maxwelltime:Sphere_harmonics.c:      E->Tbl_lm[m][p] = (float *) malloc((E->lmesh.nsf+2)*sizeof(float));
Maxwelltime:Sphere_harmonics.c: lev = E->mesh.levmax;
Maxwelltime:Sphere_harmonics.c: for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Sphere_harmonics.c:    for (e=1;e<=E->lmesh.snel;e++)   {
Maxwelltime:Sphere_harmonics.c: for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Sphere_harmonics.c:        E->sphere.tablesplm[m]   = (double **) malloc((E->lmesh.nsf+1)*sizeof(double*));
Maxwelltime:Sphere_harmonics.c:        E->sphere.tablescosf[m] = (double **) malloc((E->lmesh.nsf+1)*sizeof(double*));
Maxwelltime:Sphere_harmonics.c:        E->sphere.tablessinf[m] = (double **) malloc((E->lmesh.nsf+1)*sizeof(double*));
Maxwelltime:Sphere_harmonics.c:        for (i=1;i<=E->lmesh.nsf;i++)   {
Maxwelltime:Sphere_harmonics.c:            E->sphere.tablesplm[m][i]= (double *)malloc((E->sphere.hindice)*sizeof(double));
Maxwelltime:Sphere_harmonics.c:            E->sphere.tablescosf[m][i]= (double *)malloc((E->output.llmax+1)*sizeof(double));
Maxwelltime:Sphere_harmonics.c:            E->sphere.tablessinf[m][i]= (double *)malloc((E->output.llmax+1)*sizeof(double));
Maxwelltime:Sphere_harmonics.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Sphere_harmonics.c:        for (j=1;j<=E->lmesh.nsf;j++)  {
Maxwelltime:Sphere_harmonics.c:            node = j*E->lmesh.noz;
Maxwelltime:Sphere_harmonics.c:            f=E->sx[m][2][node];
Maxwelltime:Sphere_harmonics.c:            t=E->sx[m][1][node];
Maxwelltime:Sphere_harmonics.c:            for (mm=0;mm<=E->output.llmax;mm++)   {
Maxwelltime:Sphere_harmonics.c:                E->sphere.tablescosf[m][j][mm] = cos( mmf );
Maxwelltime:Sphere_harmonics.c:                E->sphere.tablessinf[m][j][mm] = sin( mmf );
Maxwelltime:Sphere_harmonics.c:            for (ll=0;ll<=E->output.llmax;ll++)
Maxwelltime:Sphere_harmonics.c:                    p = E->sphere.hindex[ll][mm];
Maxwelltime:Sphere_harmonics.c:                    E->sphere.tablesplm[m][j][p] = modified_plgndr_a(ll,mm,t) ;
Maxwelltime:Sphere_harmonics.c:    const int lev=E->mesh.levmax;
Maxwelltime:Sphere_harmonics.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Sphere_harmonics.c:   for (i=0;i<E->sphere.hindice;i++)    {
Maxwelltime:Sphere_harmonics.c:   for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Sphere_harmonics.c:     for (es=1;es<=E->lmesh.snel;es++) {
Maxwelltime:Sphere_harmonics.c:       el = (ic==1)?(E->lmesh.elz*es):(E->lmesh.elz*(es-1)+1);
Maxwelltime:Sphere_harmonics.c:       for(k1=1;k1<=onedvpoints[E->mesh.nsd];k1++)   {
Maxwelltime:Sphere_harmonics.c:         t[k1] = E->sx[1][j][E->ien[j][el].node[k1+j1]];
Maxwelltime:Sphere_harmonics.c:         f[k1] = E->sx[2][j][E->ien[j][el].node[k1+j1]];
Maxwelltime:Sphere_harmonics.c:       for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Maxwelltime:Sphere_harmonics.c:         for(k1=1;k1<=onedvpoints[E->mesh.nsd];k1++)   
Maxwelltime:Sphere_harmonics.c:           temp0[k] += TG[j][E->sien[j][es].node[k1]] * E->M.vpt[GMVINDEX(k1,k)];
Maxwelltime:Sphere_harmonics.c:         area += E->gDA1[j][es].vpt[5];
Maxwelltime:Sphere_harmonics.c:         for(k=1;k<=onedvpoints[E->mesh.nsd];k++)
Maxwelltime:Sphere_harmonics.c:           temp0[k] = temp0[k]*E->gDA1[j][es].vpt[k];
Maxwelltime:Sphere_harmonics.c:         area += E->gDA0[j][es].vpt[5];
Maxwelltime:Sphere_harmonics.c:         for(k=1;k<=onedvpoints[E->mesh.nsd];k++)
Maxwelltime:Sphere_harmonics.c:           temp0[k] = temp0[k]*E->gDA0[j][es].vpt[k];
Maxwelltime:Sphere_harmonics.c:           p = E->sphere.hindex[ll][mm];
Maxwelltime:Sphere_harmonics.c:           for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Maxwelltime:Sphere_harmonics.c:/*             for(k1=1;k1<=onedvpoints[E->mesh.nsd];k1++)   {
Maxwelltime:Sphere_harmonics.c:                temp1[k] += cos(mm*f[k1]) * E->M.vpt[GMVINDEX(k1,k)];
Maxwelltime:Sphere_harmonics.c:                temp2[k] += sin(mm*f[k1]) * E->M.vpt[GMVINDEX(k1,k)];
Maxwelltime:Sphere_harmonics.c:                temp3[k] += modified_plgndr_a(ll,mm,t[k1]) * E->M.vpt[GMVINDEX(k1,k)];
Maxwelltime:Sphere_harmonics.c:             sphc[p]+=temp0[k]*E->Sph_Harm_Tblcs[j][mm][es].cs[k]*E->Sph_Harm_Tbllm[j][p][es].lm[k];
Maxwelltime:Sphere_harmonics.c:             sphs[p]+=temp0[k]*E->Sph_Harm_Tblcs[j][mm][es].sn[k]*E->Sph_Harm_Tbllm[j][p][es].lm[k];
Maxwelltime:Sphere_harmonics.c:   sphs[E->sphere.hindice] = area;
Maxwelltime:Sphere_harmonics.c:   area = sphs[E->sphere.hindice];
Maxwelltime:Sphere_harmonics.c:   for (i=0;i<E->sphere.hindice;i++)    {
Maxwelltime:Sphere_util.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Sphere_util.c:        ia[2] = E->lmesh.noz*E->lmesh.nox-E->lmesh.noz+1;
Maxwelltime:Sphere_util.c:        ia[3] = E->lmesh.nno-E->lmesh.noz+1;
Maxwelltime:Sphere_util.c:        ia[4] = ia[3]-E->lmesh.noz*(E->lmesh.nox-1);
Maxwelltime:Sphere_util.c:            xx[1][i] = E->x[m][1][ia[i]]/E->sx[m][3][ia[1]];
Maxwelltime:Sphere_util.c:            xx[2][i] = E->x[m][2][ia[i]]/E->sx[m][3][ia[1]];
Maxwelltime:Sphere_util.c:            xx[3][i] = E->x[m][3][ia[i]]/E->sx[m][3][ia[1]];
Maxwelltime:Sphere_util.c:            E->sphere.angle[m][i] = angle[i];
Maxwelltime:Sphere_util.c:        E->sphere.area[m] = area_sphere_cap(angle);
Maxwelltime:Sphere_util.c:        for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)
Maxwelltime:Sphere_util.c:            for (es=1;es<=E->lmesh.SNEL[lev];es++)              {
Maxwelltime:Sphere_util.c:                el = (es-1)*E->lmesh.ELZ[lev]+1;
Maxwelltime:Sphere_util.c:                    ia[i] = E->IEN[lev][m][el].node[i];
Maxwelltime:Sphere_util.c:                    xx[1][i] = E->X[lev][m][1][ia[i]]/E->SX[lev][m][3][ia[1]];
Maxwelltime:Sphere_util.c:                    xx[2][i] = E->X[lev][m][2][ia[i]]/E->SX[lev][m][3][ia[1]];
Maxwelltime:Sphere_util.c:                    xx[3][i] = E->X[lev][m][3][ia[i]]/E->SX[lev][m][3][ia[1]];
Maxwelltime:Sphere_util.c:                    E->sphere.angle1[lev][m][i][es] = angle[i];
Maxwelltime:Sphere_util.c:                E->sphere.area1[lev][m][es] = area_sphere_cap(angle);
Maxwelltime:Sphere_util.c:/*              fprintf(E->fp_out,"lev%d %d %.6e %.6e %.6e %.6e %.6e\n",lev,es,angle[1],angle[2],angle[3],angle[4],E->sphere.area1[lev][m][es]); */
Maxwelltime:Sphere_util.c:        ia[i] = E->IEN[lev][m][el].node[i];
Maxwelltime:Sphere_util.c:    es = (el-1)/E->lmesh.ELZ[lev]+1;
Maxwelltime:Sphere_util.c:        xx[1] = E->X[lev][m][1][ia[i]]/E->SX[lev][m][3][ia[1]];
Maxwelltime:Sphere_util.c:        xx[2] = E->X[lev][m][2][ia[i]]/E->SX[lev][m][3][ia[1]];
Maxwelltime:Sphere_util.c:        xx[3] = E->X[lev][m][3][ia[i]]/E->SX[lev][m][3][ia[1]];
Maxwelltime:Sphere_util.c:        angle1[i]= E->sphere.angle1[lev][m][i][es];
Maxwelltime:Stokes_flow_Incomp.c:    cycles=E->control.p_iterations;
Maxwelltime:Stokes_flow_Incomp.c:    if (!E->ve_data_cont.compressible)   {     // incompressible VE
Maxwelltime:Stokes_flow_Incomp.c:       solve_Ahat_p_fhat(E,E->U,E->P,E->F,E->control.accuracy,&cycles);
Maxwelltime:Stokes_flow_Incomp.c:       p_to_nodes(E,E->P,E->NP,E->mesh.levmax);
Maxwelltime:Stokes_flow_Incomp.c:    else if (E->ve_data_cont.compressible)   {  // compressible VE
Maxwelltime:Stokes_flow_Incomp.c:       solve_Ahat_fhat(E,E->U,E->F,E->control.accuracy,&cycles);
Maxwelltime:Stokes_flow_Incomp.c:    cycles=E->control.p_iterations;
Maxwelltime:Stokes_flow_Incomp.c:    solve_Ahat_p_fhat(E,E->U,E->P,E->F,E->control.accuracy,&cycles);
Maxwelltime:Stokes_flow_Incomp.c:    p_to_nodes(E,E->P,E->NP,E->mesh.levmax);
Maxwelltime:Stokes_flow_Incomp.c:     * This norm is ~= E->monitor.momentum_residual */
Maxwelltime:Stokes_flow_Incomp.c:    const int lev = E->mesh.levmax;
Maxwelltime:Stokes_flow_Incomp.c:    const int neq = E->lmesh.neq;
Maxwelltime:Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Stokes_flow_Incomp.c:    assemble_grad_p(E, P, E->u1, lev);
Maxwelltime:Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:            r2[m][i] = F[m][i] - E->u1[m][i] - r1[m][i];
Maxwelltime:Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Stokes_flow_Incomp.c:    fprintf(E->fp, "(%03d) %5.1f s v=%e p=%e "
Maxwelltime:Stokes_flow_Incomp.c:            E->monitor.solution_cycles);
Maxwelltime:Stokes_flow_Incomp.c:            E->monitor.solution_cycles);
Maxwelltime:Stokes_flow_Incomp.c:    if(E->control.inv_gruneisen == 0)
Maxwelltime:Stokes_flow_Incomp.c:        if(strcmp(E->control.uzawa, "cg") == 0)
Maxwelltime:Stokes_flow_Incomp.c:        else if(strcmp(E->control.uzawa, "bicg") == 0)
Maxwelltime:Stokes_flow_Incomp.c:    const int npno = E->lmesh.npno;
Maxwelltime:Stokes_flow_Incomp.c:    const int neq = E->lmesh.neq;
Maxwelltime:Stokes_flow_Incomp.c:    const int lev = E->mesh.levmax;
Maxwelltime:Stokes_flow_Incomp.c:    const int gneq = E->mesh.neq;
Maxwelltime:Stokes_flow_Incomp.c:    const int gnpno = E->mesh.npno;
Maxwelltime:Stokes_flow_Incomp.c:      for (m=1; m<=E->sphere.caps_per_proc; m++)   
Maxwelltime:Stokes_flow_Incomp.c:    if (E->parallel.me==0) {
Maxwelltime:Stokes_flow_Incomp.c:      fprintf(E->fp,"initial residue of momentum equation F %.9e %d %d\n",v_res,gneq,E->monitor.solution_cycles);
Maxwelltime:Stokes_flow_Incomp.c:      fprintf(stderr,"initial residue of momentum equation F %.9e %d %d\n",v_res,gneq,E->monitor.solution_cycles);
Maxwelltime:Stokes_flow_Incomp.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Stokes_flow_Incomp.c:    valid = solve_del2_u(E, E->u1, F, aimp, lev);
Maxwelltime:Stokes_flow_Incomp.c:    if(!valid && (E->parallel.me==0)) {
Maxwelltime:Stokes_flow_Incomp.c:            fputs("Warning: solver not converging! 1\n", E->fp);
Maxwelltime:Stokes_flow_Incomp.c:    strip_bcs_from_residual(E, E->u1, lev);
Maxwelltime:Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:                V[m][j] = E->u1[m][j];
Maxwelltime:Stokes_flow_Incomp.c:      fflush(E->fp);
Maxwelltime:Stokes_flow_Incomp.c:      fprintf(stderr,"Au=F solve after %g seconds for step %d\n",CPU_time0()-time0,E->monitor.solution_cycles);
Maxwelltime:Stokes_flow_Incomp.c:    const int npno = E->lmesh.npno;
Maxwelltime:Stokes_flow_Incomp.c:    const int neq = E->lmesh.neq;
Maxwelltime:Stokes_flow_Incomp.c:    const int lev = E->mesh.levmax;
Maxwelltime:Stokes_flow_Incomp.c:    const int gneq = E->mesh.neq;
Maxwelltime:Stokes_flow_Incomp.c:    const int gnpno = E->mesh.npno;
Maxwelltime:Stokes_flow_Incomp.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)   {
Maxwelltime:Stokes_flow_Incomp.c:    v_res = sqrt(E->monitor.fdotf/gneq);
Maxwelltime:Stokes_flow_Incomp.c:    if (E->parallel.me==0) {
Maxwelltime:Stokes_flow_Incomp.c:      fprintf(E->fp,"initial residue of momentum equation F %.9e %d %d\n",v_res,gneq,E->monitor.solution_cycles);
Maxwelltime:Stokes_flow_Incomp.c:      fprintf(stderr,"initial residue of momentum equation F %.9e %d %d\n",v_res,gneq,E->monitor.solution_cycles);
Maxwelltime:Stokes_flow_Incomp.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Stokes_flow_Incomp.c:    if(E->control.inv_gruneisen != 0) {
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Stokes_flow_Incomp.c:    aimp = imp*v_res*E->control.sob_tolerance;    //one order higher accuracy
Maxwelltime:Stokes_flow_Incomp.c:    if(E->control.inv_gruneisen == 0)
Maxwelltime:Stokes_flow_Incomp.c:    if(E->control.inv_gruneisen != 0)
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Stokes_flow_Incomp.c:    E->monitor.vdotv = sqrt(global_vdot(E, V,V,lev)/gneq);
Maxwelltime:Stokes_flow_Incomp.c:    E->monitor.incompressibility = residual/E->monitor.vdotv; 
Maxwelltime:Stokes_flow_Incomp.c:    if (E->control.print_convergence && E->parallel.me==0)  {
Maxwelltime:Stokes_flow_Incomp.c:      fprintf(E->fp,"AhatP (%03d) after %g seconds with div/v=%.3e for step %d\n",count,CPU_time0()-time0,E->monitor.incompressibility,E->monitor.solution_cycles);
Maxwelltime:Stokes_flow_Incomp.c:      fflush(E->fp);
Maxwelltime:Stokes_flow_Incomp.c:      fprintf(stderr,"AhatP (%03d) after %g seconds with div/v=%.3e for step %d\n",count,CPU_time0()-time0,E->monitor.incompressibility,E->monitor.solution_cycles);
Maxwelltime:Stokes_flow_Incomp.c:                                   E->monitor.incompressibility); */
Maxwelltime:Stokes_flow_Incomp.c://           (E->monitor.incompressibility > E->control.tole_comp) && (dvelocity > imp || dpressure > imp))) {
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:                z1[m][j] = E->BPI[lev][m][j] * r1[m][j];
Maxwelltime:Stokes_flow_Incomp.c:            for (m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:        aimp = imp*v_res*E->control.sob_tolerance;
Maxwelltime:Stokes_flow_Incomp.c:        valid = solve_del2_u(E, E->u1, F, aimp, lev);
Maxwelltime:Stokes_flow_Incomp.c:        if(!valid && (E->parallel.me==0)) {
Maxwelltime:Stokes_flow_Incomp.c:            fputs("Warning: solver not converging! 1\n", E->fp);
Maxwelltime:Stokes_flow_Incomp.c:        strip_bcs_from_residual(E, E->u1, lev);
Maxwelltime:Stokes_flow_Incomp.c:        assemble_div_u(E, E->u1, F, lev);
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:                V[m][j] -= alpha * E->u1[m][j];
Maxwelltime:Stokes_flow_Incomp.c:        E->monitor.vdotv = global_vdot(E, V,V,lev);
Maxwelltime:Stokes_flow_Incomp.c:        E->monitor.incompressibility=sqrt((gneq/gnpno)*(1e-32+global_pdot(E,F,F,lev)/(1e-32+E->monitor.vdotv)));
Maxwelltime:Stokes_flow_Incomp.c:        dvelocity = alpha * sqrt(global_vdot(E, E->u1,E->u1,lev)/(1e-32 + E->monitor.vdotv));
Maxwelltime:Stokes_flow_Incomp.c:        if (E->control.print_convergence && E->parallel.me==0)  {
Maxwelltime:Stokes_flow_Incomp.c:      fprintf(E->fp,"AhatP (%03d) after %g seconds with div/v=%.3e dv/v=%.3e dp/p=%.3e for step %d\n",count,CPU_time0()-time0,E->monitor.incompressibility,dvelocity,dpressure,E->monitor.solution_cycles);
Maxwelltime:Stokes_flow_Incomp.c:      fflush(E->fp);
Maxwelltime:Stokes_flow_Incomp.c:      fprintf(stderr,"AhatP (%03d) after %g seconds with div/v=%.3e dv/v=%.3e dp/p=%.3e for step %d\n",count,CPU_time0()-time0,E->monitor.incompressibility,dvelocity,dpressure,E->monitor.solution_cycles);
Maxwelltime:Stokes_flow_Incomp.c:                                       E->monitor.incompressibility); */
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Stokes_flow_Incomp.c:    npno = E->lmesh.npno;
Maxwelltime:Stokes_flow_Incomp.c:    neq = E->lmesh.neq;
Maxwelltime:Stokes_flow_Incomp.c:    lev = E->mesh.levmax;
Maxwelltime:Stokes_flow_Incomp.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)   {
Maxwelltime:Stokes_flow_Incomp.c:    v_res = E->monitor.fdotf;
Maxwelltime:Stokes_flow_Incomp.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Stokes_flow_Incomp.c:    E->monitor.vdotv = global_v_norm2(E, V);
Maxwelltime:Stokes_flow_Incomp.c:    E->monitor.incompressibility = sqrt(global_div_norm2(E, r1)
Maxwelltime:Stokes_flow_Incomp.c:                                        / (1e-32 + E->monitor.vdotv));
Maxwelltime:Stokes_flow_Incomp.c:    v_norm = sqrt(E->monitor.vdotv);
Maxwelltime:Stokes_flow_Incomp.c:    p_norm = sqrt(E->monitor.pdotp);
Maxwelltime:Stokes_flow_Incomp.c:    if (E->control.print_convergence && E->parallel.me==0)  {
Maxwelltime:Stokes_flow_Incomp.c:                                   E->monitor.incompressibility);
Maxwelltime:Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:           (E->monitor.incompressibility > imp) &&
Maxwelltime:Stokes_flow_Incomp.c:            fprintf(E->fp, "BiCGstab method failed!!\n");
Maxwelltime:Stokes_flow_Incomp.c:            for (m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:                pt[m][j] = E->BPI[lev][m][j] * p2[m][j];
Maxwelltime:Stokes_flow_Incomp.c:        if(!valid && (E->parallel.me==0)) {
Maxwelltime:Stokes_flow_Incomp.c:            fputs("Warning: solver not converging! 1\n", E->fp);
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:                st[m][j] = E->BPI[lev][m][j] * s0[m][j];
Maxwelltime:Stokes_flow_Incomp.c:        valid = solve_del2_u(E, E->u1, F, imp*v_res, lev);
Maxwelltime:Stokes_flow_Incomp.c:        if(!valid && (E->parallel.me==0)) {
Maxwelltime:Stokes_flow_Incomp.c:            fputs("Warning: solver not converging! 2\n", E->fp);
Maxwelltime:Stokes_flow_Incomp.c:        strip_bcs_from_residual(E, E->u1, lev);
Maxwelltime:Stokes_flow_Incomp.c:        assemble_div_rho_u(E, E->u1, t0, lev);
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:                F[m][j] = alpha * u0[m][j] + omega * E->u1[m][j];
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:        E->monitor.vdotv = global_v_norm2(E, V);
Maxwelltime:Stokes_flow_Incomp.c:        E->monitor.pdotp = global_p_norm2(E, P);
Maxwelltime:Stokes_flow_Incomp.c:        v_norm = sqrt(E->monitor.vdotv);
Maxwelltime:Stokes_flow_Incomp.c:        p_norm = sqrt(E->monitor.pdotp);
Maxwelltime:Stokes_flow_Incomp.c:        dvelocity = sqrt(global_v_norm2(E, F) / (1e-32 + E->monitor.vdotv));
Maxwelltime:Stokes_flow_Incomp.c:        dpressure = sqrt(global_p_norm2(E, s0) / (1e-32 + E->monitor.pdotp));
Maxwelltime:Stokes_flow_Incomp.c:        E->monitor.incompressibility = sqrt(global_div_norm2(E, t0)
Maxwelltime:Stokes_flow_Incomp.c:                                            / (1e-32 + E->monitor.vdotv));
Maxwelltime:Stokes_flow_Incomp.c:        if(E->control.print_convergence && E->parallel.me==0) {
Maxwelltime:Stokes_flow_Incomp.c:                                       E->monitor.incompressibility);
Maxwelltime:Stokes_flow_Incomp.c:	if(E->control.only_check_vel_convergence){
Maxwelltime:Stokes_flow_Incomp.c:	  E->monitor.incompressibility = dvelocity;
Maxwelltime:Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Stokes_flow_Incomp.c:    const int npno = E->lmesh.npno;
Maxwelltime:Stokes_flow_Incomp.c:    const int neq = E->lmesh.neq;
Maxwelltime:Stokes_flow_Incomp.c:    const int lev = E->mesh.levmax;
Maxwelltime:Stokes_flow_Incomp.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Stokes_flow_Incomp.c:    cycles = E->control.p_iterations;
Maxwelltime:Stokes_flow_Incomp.c:                         imp * E->monitor.fdotf);
Maxwelltime:Stokes_flow_Incomp.c:          (num_of_loop <= E->control.compress_iter_maxstep)) {
Maxwelltime:Stokes_flow_Incomp.c:        for (m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Stokes_flow_Incomp.c:        assemble_div_rho_u(E, V, E->u1, lev);
Maxwelltime:Stokes_flow_Incomp.c:        div_res = sqrt(global_div_norm2(E, E->u1) / (1e-32 + E->monitor.vdotv));
Maxwelltime:Stokes_flow_Incomp.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Stokes_flow_Incomp.c:                               (1.0e-32 + E->monitor.vdotv) );
Maxwelltime:Stokes_flow_Incomp.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Stokes_flow_Incomp.c:                               (1.0e-32 + E->monitor.pdotp) );
Maxwelltime:Stokes_flow_Incomp.c:        if(E->parallel.me == 0) {
Maxwelltime:Stokes_flow_Incomp.c:            fprintf(E->fp, "itercg -- div(rho*v)/v=%.2e dv/v=%.2e and dp/p=%.2e loop %d\n\n", div_res, relative_err_v, relative_err_p, num_of_loop);
Maxwelltime:Stokes_flow_Incomp.c:	if(E->control.only_check_vel_convergence){
Maxwelltime:Stokes_flow_Incomp.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Maxwelltime:Stokes_flow_Incomp.c:    int neq = E->lmesh.neq;
Maxwelltime:Stokes_flow_Incomp.c:    int lev = E->mesh.levmax;
Maxwelltime:Stokes_flow_Incomp.c:    assemble_grad_p(E, P, E->u1, lev);
Maxwelltime:Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:            F[m][i] = F[m][i] - E->u1[m][i];
Maxwelltime:Stokes_flow_Incomp.c:    assemble_del2_u(E, V, E->u1, lev, 1);
Maxwelltime:Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:            F[m][i] = F[m][i] - E->u1[m][i];
Maxwelltime:Stokes_flow_Incomp.c:    valid = solve_del2_u(E, E->u1, F, acc, lev);
Maxwelltime:Stokes_flow_Incomp.c:    if(!valid && (E->parallel.me==0)) {
Maxwelltime:Stokes_flow_Incomp.c:        fputs("Warning: solver not converging! 0\n", E->fp);
Maxwelltime:Stokes_flow_Incomp.c:    strip_bcs_from_residual(E, E->u1, lev);
Maxwelltime:Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Stokes_flow_Incomp.c:            V[m][i] += E->u1[m][i];
Maxwelltime:Topo_gravity.c:    //if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Maxwelltime:Topo_gravity.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Topo_gravity.c:     for(snode=1;snode<=E->lmesh.nsf;snode++)   {
Maxwelltime:Topo_gravity.c:        node = E->surf_node[m][snode];
Maxwelltime:Topo_gravity.c:        tpgb[m][snode] =  2*SZZ[m][node-E->lmesh.noz+1]- SZZ[m][node-E->lmesh.noz+2];
Maxwelltime:Topo_gravity.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Maxwelltime:Topo_gravity.c:                for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Topo_gravity.c:                        for(snode=1;snode<=E->lmesh.nsf;snode++) {
Maxwelltime:Topo_gravity.c:                                node = E->surf_node[m][snode];
Maxwelltime:Topo_gravity.c:                                /*freesurf[m][snode] += 0.5*(E->sphere.cap[m].V[3][node]+E->sphere.cap[m].Vprev[3][node])*E->advection.timestep;*/
Maxwelltime:Topo_gravity.c:                                freesurf[m][snode] += E->sphere.cap[m].V[3][node]*E->advection.timestep;
Maxwelltime:Topo_gravity.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Topo_gravity.c:    SXX[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Maxwelltime:Topo_gravity.c:    SYY[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Maxwelltime:Topo_gravity.c:    SXY[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Maxwelltime:Topo_gravity.c:    SXZ[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Maxwelltime:Topo_gravity.c:    SZY[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Maxwelltime:Topo_gravity.c:    SZZ[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Maxwelltime:Topo_gravity.c:    divv[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Maxwelltime:Topo_gravity.c:    vorv[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Maxwelltime:Topo_gravity.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Topo_gravity.c:    for(i=1;i<=E->lmesh.nno;i++) {
Maxwelltime:Topo_gravity.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)        {
Maxwelltime:Topo_gravity.c:/*   stride = E->lmesh.nsf*6; */
Maxwelltime:Topo_gravity.c:/*   for(m=1;m<=E->sphere.caps_per_proc;m++) */
Maxwelltime:Topo_gravity.c:/*     for (node=1;node<=E->lmesh.nno;node++) */
Maxwelltime:Topo_gravity.c:/*       if ( (node%E->lmesh.noz)==0 )  { */
Maxwelltime:Topo_gravity.c:/*         i = node/E->lmesh.noz; */
Maxwelltime:Topo_gravity.c:/*         E->stress[m][(i-1)*6+1] = SXX[m][node]; */
Maxwelltime:Topo_gravity.c:/*         E->stress[m][(i-1)*6+2] = SYY[m][node]; */
Maxwelltime:Topo_gravity.c:/*         E->stress[m][(i-1)*6+3] = SZZ[m][node]; */
Maxwelltime:Topo_gravity.c:/*         E->stress[m][(i-1)*6+4] = SXY[m][node]; */
Maxwelltime:Topo_gravity.c:/*         E->stress[m][(i-1)*6+5] = SXZ[m][node]; */
Maxwelltime:Topo_gravity.c:/*         E->stress[m][(i-1)*6+6] = SZY[m][node]; */
Maxwelltime:Topo_gravity.c:/*      else if ( ((node+1)%E->lmesh.noz)==0 )  { */
Maxwelltime:Topo_gravity.c:/*         i = (node+1)/E->lmesh.noz; */
Maxwelltime:Topo_gravity.c:/*         E->stress[m][stride+(i-1)*6+1] = SXX[m][node]; */
Maxwelltime:Topo_gravity.c:/*         E->stress[m][stride+(i-1)*6+2] = SYY[m][node]; */
Maxwelltime:Topo_gravity.c:/*         E->stress[m][stride+(i-1)*6+3] = SZZ[m][node]; */
Maxwelltime:Topo_gravity.c:/*         E->stress[m][stride+(i-1)*6+4] = SXY[m][node]; */
Maxwelltime:Topo_gravity.c:/*         E->stress[m][stride+(i-1)*6+5] = SXZ[m][node]; */
Maxwelltime:Topo_gravity.c:/*         E->stress[m][stride+(i-1)*6+6] = SZY[m][node]; */
Maxwelltime:Topo_gravity.c:  const int dims=E->mesh.nsd;
Maxwelltime:Topo_gravity.c:  const int lev=E->mesh.levmax;
Maxwelltime:Topo_gravity.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Topo_gravity.c:    for(e=1;e<=E->lmesh.nel;e++)  {
Maxwelltime:Topo_gravity.c:      dOmega = &(E->gDA[m][e]);	/* Jacobian at integration points */
Maxwelltime:Topo_gravity.c:      GNx = &(E->gNX[m][e]);	/* derivatives of shape functions at
Maxwelltime:Topo_gravity.c:        pre[j] =  E->EVi[m][(e-1)*vpts+j]*dOmega->vpt[j];
Maxwelltime:Topo_gravity.c:          tww[i] += dOmega->vpt[j] * g_point[j].weight[E->mesh.nsd-1]
Maxwelltime:Topo_gravity.c:            * E->N.vpt[GNVINDEX(i,j)];
Maxwelltime:Topo_gravity.c:                        + VV[3][i]*E->N.vpt[GNVINDEX(i,j)] )*rtf[3][j];
Maxwelltime:Topo_gravity.c:                         + VV[1][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j]))/sin(rtf[1][j])
Maxwelltime:Topo_gravity.c:                        + VV[3][i]*E->N.vpt[GNVINDEX(i,j)] )*rtf[3][j];
Maxwelltime:Topo_gravity.c:                         - VV[2][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j]))/sin(rtf[1][j])
Maxwelltime:Topo_gravity.c:                                                                      *GNx->vpt[GNVXINDEX(0,i,j)]-VV[1][i]*E->N.vpt[GNVINDEX(i,j)]);
Maxwelltime:Topo_gravity.c:                                                                      *GNx->vpt[GNVXINDEX(1,i,j)]/sin(rtf[1][j])-VV[2][i]*E->N.vpt[GNVINDEX(i,j)]);
Maxwelltime:Topo_gravity.c:                                   + VV[1][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j])/sin(rtf[1][j])
Maxwelltime:Topo_gravity.c:              + VV[2][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j])
Maxwelltime:Topo_gravity.c:      if(E->control.inv_gruneisen != 0) { /* isotropic component */
Maxwelltime:Topo_gravity.c:      Sxx /= E->eco[m][e].area;
Maxwelltime:Topo_gravity.c:      Syy /= E->eco[m][e].area;
Maxwelltime:Topo_gravity.c:      Szz /= E->eco[m][e].area;
Maxwelltime:Topo_gravity.c:      Sxy /= E->eco[m][e].area;
Maxwelltime:Topo_gravity.c:      Sxz /= E->eco[m][e].area;
Maxwelltime:Topo_gravity.c:      Szy /= E->eco[m][e].area;
Maxwelltime:Topo_gravity.c:      div /= E->eco[m][e].area;
Maxwelltime:Topo_gravity.c:      vor /= E->eco[m][e].area;
Maxwelltime:Topo_gravity.c:      Szz -= E->P[m][e];
Maxwelltime:Topo_gravity.c:      Sxx -= E->P[m][e];
Maxwelltime:Topo_gravity.c:      Syy -= E->P[m][e];
Maxwelltime:Topo_gravity.c:        node = E->ien[m][e].node[i]; /* assign to global nodes */
Maxwelltime:Topo_gravity.c:  (E->exchange_node_f)(E,SXX,lev);
Maxwelltime:Topo_gravity.c:  (E->exchange_node_f)(E,SYY,lev);
Maxwelltime:Topo_gravity.c:  (E->exchange_node_f)(E,SZZ,lev);
Maxwelltime:Topo_gravity.c:  (E->exchange_node_f)(E,SXY,lev);
Maxwelltime:Topo_gravity.c:  (E->exchange_node_f)(E,SXZ,lev);
Maxwelltime:Topo_gravity.c:  (E->exchange_node_f)(E,SZY,lev);
Maxwelltime:Topo_gravity.c:  (E->exchange_node_f)(E,divv,lev);
Maxwelltime:Topo_gravity.c:  (E->exchange_node_f)(E,vorv,lev);
Maxwelltime:Topo_gravity.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Topo_gravity.c:    for(node=1;node<=E->lmesh.nno;node++)   {
Maxwelltime:Topo_gravity.c:      mass_fac = E->Mass[m][node]*stress_scaling;
Maxwelltime:Topo_gravity.c:      mass_fac = E->Mass[m][node]*velo_scaling;
Maxwelltime:Topo_gravity.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Topo_gravity.c:    for (node=1;node<=E->lmesh.nno;node++) {
Maxwelltime:Topo_gravity.c:      E->gstress[m][(node-1)*6+1] = SXX[m][node];
Maxwelltime:Topo_gravity.c:      E->gstress[m][(node-1)*6+2] = SYY[m][node];
Maxwelltime:Topo_gravity.c:      E->gstress[m][(node-1)*6+3] = SZZ[m][node];
Maxwelltime:Topo_gravity.c:      E->gstress[m][(node-1)*6+4] = SXY[m][node];
Maxwelltime:Topo_gravity.c:      E->gstress[m][(node-1)*6+5] = SXZ[m][node];
Maxwelltime:Topo_gravity.c:      E->gstress[m][(node-1)*6+6] = SZY[m][node];
Maxwelltime:Topo_gravity.c:                                   {0, 4, 2, 6}, /* E-W sides */
Maxwelltime:Topo_gravity.c:  if(E->control.side_sbcs) {
Maxwelltime:Topo_gravity.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Topo_gravity.c:      for(i=1; i<=E->lmesh.noy; i++)
Maxwelltime:Topo_gravity.c:        for(j=1; j<=E->lmesh.nox; j++)
Maxwelltime:Topo_gravity.c:          for(k=1; k<=E->lmesh.noz; k++) {
Maxwelltime:Topo_gravity.c:            n = k+(j-1)*E->lmesh.noz+(i-1)*E->lmesh.nox*E->lmesh.noz;
Maxwelltime:Topo_gravity.c:            for(d=1; d<=E->mesh.nsd; d++)
Maxwelltime:Topo_gravity.c:              if(E->node[m][n] & sbc_flag[d]) {
Maxwelltime:Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][2]] = E->sbc.SB[m][SIDE_WEST][d][ E->sbc.node[m][n] ];
Maxwelltime:Topo_gravity.c:                if(i==E->lmesh.noy)
Maxwelltime:Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][2]] = E->sbc.SB[m][SIDE_EAST][d][ E->sbc.node[m][n] ];
Maxwelltime:Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][1]] = E->sbc.SB[m][SIDE_NORTH][d][ E->sbc.node[m][n] ];
Maxwelltime:Topo_gravity.c:                if(j==E->lmesh.nox)
Maxwelltime:Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][1]] = E->sbc.SB[m][SIDE_SOUTH][d][ E->sbc.node[m][n] ];
Maxwelltime:Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][3]] = E->sbc.SB[m][SIDE_BOTTOM][d][ E->sbc.node[m][n] ];
Maxwelltime:Topo_gravity.c:                if(k==E->lmesh.noz)
Maxwelltime:Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][3]] = E->sbc.SB[m][SIDE_TOP][d][ E->sbc.node[m][n] ];
Maxwelltime:Topo_gravity.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Topo_gravity.c:      for(i=1; i<=E->lmesh.noy; i++)
Maxwelltime:Topo_gravity.c:        for(j=1; j<=E->lmesh.nox; j++)
Maxwelltime:Topo_gravity.c:          for(k=1; k<=E->lmesh.noz; k++) {
Maxwelltime:Topo_gravity.c:            n = k+(j-1)*E->lmesh.noz+(i-1)*E->lmesh.nox*E->lmesh.noz;
Maxwelltime:Topo_gravity.c:            for(d=1; d<=E->mesh.nsd; d++)
Maxwelltime:Topo_gravity.c:              if(E->node[m][n] & sbc_flag[d]) {
Maxwelltime:Topo_gravity.c:                if(i==1 || i==E->lmesh.noy)
Maxwelltime:Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][2]] = E->sphere.cap[m].VB[d][n];
Maxwelltime:Topo_gravity.c:                if(j==1 || j==E->lmesh.nox)
Maxwelltime:Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][1]] = E->sphere.cap[m].VB[d][n];
Maxwelltime:Topo_gravity.c:                if(k==1 || k==E->lmesh.noz)
Maxwelltime:Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][3]] = E->sphere.cap[m].VB[d][n];
Maxwelltime:Topo_gravity.c:     * E->buoyancy needs to be converted to density (-therm_exp*ref_T/Ra/g)
Maxwelltime:Topo_gravity.c:    nxnz = E->lmesh.nox*E->lmesh.noz;
Maxwelltime:Topo_gravity.c:    radius_m = E->data.radius_km*1e3;
Maxwelltime:Topo_gravity.c:    scaling2 = -E->data.therm_exp*E->data.ref_temperature*E->data.density
Maxwelltime:Topo_gravity.c:        / E->control.Atemp;
Maxwelltime:Topo_gravity.c:    scaling = 4.0 * M_PI * 1.0e3 * E->data.radius_km * E->data.grav_const
Maxwelltime:Topo_gravity.c:        / E->data.grav_acc;
Maxwelltime:Topo_gravity.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Topo_gravity.c:        TT[m] = (float *) malloc ((E->lmesh.nsf+1)*sizeof(float));
Maxwelltime:Topo_gravity.c:    geoid[0] = (float*)malloc(E->sphere.hindice*sizeof(float));
Maxwelltime:Topo_gravity.c:    geoid[1] = (float*)malloc(E->sphere.hindice*sizeof(float));
Maxwelltime:Topo_gravity.c:    for (p = 0; p < E->sphere.hindice; p++) {
Maxwelltime:Topo_gravity.c:    for(k=1;k<E->lmesh.noz;k++)  {
Maxwelltime:Topo_gravity.c:        grav = 0.5 * (E->refstate.gravity[k] + E->refstate.gravity[k+1]);
Maxwelltime:Topo_gravity.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Topo_gravity.c:            for(i=1;i<=E->lmesh.noy;i++)
Maxwelltime:Topo_gravity.c:                for(j=1;j<=E->lmesh.nox;j++)  {
Maxwelltime:Topo_gravity.c:                    node= k + (j-1)*E->lmesh.noz + (i-1)*nxnz;
Maxwelltime:Topo_gravity.c:                    p = j + (i-1)*E->lmesh.nox;
Maxwelltime:Topo_gravity.c:                    TT[m][p] = (E->buoyancy[m][node]+E->buoyancy[m][node+1])
Maxwelltime:Topo_gravity.c:        dlayer = (E->sx[1][3][k+1]-E->sx[1][3][k])*radius_m;
Maxwelltime:Topo_gravity.c:        radius = (E->sx[1][3][k+1]+E->sx[1][3][k])*0.5;
Maxwelltime:Topo_gravity.c:        for (ll=1;ll<=E->output.llmax;ll++) {
Maxwelltime:Topo_gravity.c:            conb = radius * pow(E->sphere.ri/radius, ((double)(ll)));
Maxwelltime:Topo_gravity.c:                p = E->sphere.hindex[ll][mm];
Maxwelltime:Topo_gravity.c:        //if(E->parallel.me==0)  fprintf(stderr,"layer %d %.5e %g %g %g\n",k,radius,dlayer,con1,con2);
Maxwelltime:Topo_gravity.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Topo_gravity.c:     * E->slice.tpg is essentailly non-dimensional stress(rr) and need
Maxwelltime:Topo_gravity.c:    stress_scaling = E->data.ref_viscosity*E->data.therm_diff/
Maxwelltime:Topo_gravity.c:        (E->data.radius_km*E->data.radius_km*1e6);
Maxwelltime:Topo_gravity.c:    den_contrast1 = E->data.density*E->refstate.rho[E->lmesh.noz] - E->data.density_above;
Maxwelltime:Topo_gravity.c:    den_contrast2 = E->data.density_below - E->data.density*E->refstate.rho[1];
Maxwelltime:Topo_gravity.c:    grav1 = E->refstate.gravity[E->lmesh.noz] * E->data.grav_acc;
Maxwelltime:Topo_gravity.c:    grav2 = E->refstate.gravity[1] * E->data.grav_acc;
Maxwelltime:Topo_gravity.c:    scaling = 4.0 * M_PI * 1.0e3 * E->data.radius_km * E->data.grav_const
Maxwelltime:Topo_gravity.c:        / E->data.grav_acc;
Maxwelltime:Topo_gravity.c:    if (E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Maxwelltime:Topo_gravity.c:        sphere_expansion(E, E->slice.tpg, tpgt[0], tpgt[1]);
Maxwelltime:Topo_gravity.c:            for (i=0; i<E->sphere.hindice; i++) {
Maxwelltime:Topo_gravity.c:    if (E->parallel.me_loc[3] == 0) {
Maxwelltime:Topo_gravity.c:        sphere_expansion(E, E->slice.tpgb, tpgb[0], tpgb[1]);
Maxwelltime:Topo_gravity.c:            for (i=0; i<E->sphere.hindice; i++) {
Maxwelltime:Topo_gravity.c:    broadcast_vertical(E, tpgt[0], tpgt[1], E->parallel.nprocz-1);
Maxwelltime:Topo_gravity.c:    den_contrast1 = E->data.density*E->refstate.rho[E->lmesh.noz] - E->data.density_above;
Maxwelltime:Topo_gravity.c:    den_contrast2 = E->data.density_below - E->data.density*E->refstate.rho[1];
Maxwelltime:Topo_gravity.c:    for (i = 0; i < E->sphere.hindice; i++) {
Maxwelltime:Topo_gravity.c:    if (E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Maxwelltime:Topo_gravity.c:        scaling = 4.0 * M_PI * 1.0e3 * E->data.radius_km * E->data.grav_const
Maxwelltime:Topo_gravity.c:            / E->data.grav_acc;
Maxwelltime:Topo_gravity.c:            for (ll=2; ll<=E->output.llmax; ll++)   {
Maxwelltime:Topo_gravity.c:                    i = E->sphere.hindex[ll][mm];
Maxwelltime:Topo_gravity.c:    if (E->parallel.me_loc[3] == 0) {
Maxwelltime:Topo_gravity.c:        scaling = 1.0e3 * 4.0 * M_PI * E->data.radius_km * E->data.grav_const
Maxwelltime:Topo_gravity.c:            / (E->data.grav_acc * E->refstate.gravity[1]);
Maxwelltime:Topo_gravity.c:            for (ll=2; ll<=E->output.llmax; ll++)   {
Maxwelltime:Topo_gravity.c:                con2 = con1 * pow(E->sphere.ri, ((double)(ll+2)));
Maxwelltime:Topo_gravity.c:                    i = E->sphere.hindex[ll][mm];
Maxwelltime:Topo_gravity.c:    broadcast_vertical(E, geoid_tpgt[0], geoid_tpgt[1], E->parallel.nprocz-1);
Maxwelltime:Topo_gravity.c:    ri = E->sphere.ri;
Maxwelltime:Topo_gravity.c:    den_contrast1 = E->data.density*E->refstate.rho[E->lmesh.noz] - E->data.density_above;
Maxwelltime:Topo_gravity.c:    den_contrast2 = E->data.density_below - E->data.density*E->refstate.rho[1];
Maxwelltime:Topo_gravity.c:    grav1 = E->refstate.gravity[E->lmesh.noz] * E->data.grav_acc;
Maxwelltime:Topo_gravity.c:    grav2 = E->refstate.gravity[1] * E->data.grav_acc;
Maxwelltime:Topo_gravity.c:    con4 = 4.0*M_PI*E->data.grav_const*E->data.radius_km*1000;
Maxwelltime:Topo_gravity.c:    for (i = 0; i < E->sphere.hindice; i++) {
Maxwelltime:Topo_gravity.c:    for (ll=2;ll<=E->output.llmax;ll++)   {
Maxwelltime:Topo_gravity.c:        a11 = den_contrast1*E->data.grav_acc - E->data.density*b1;
Maxwelltime:Topo_gravity.c:        a12 =                                - E->data.density*a1;
Maxwelltime:Topo_gravity.c:        a22 = den_contrast2*(E->data.grav_acc-a2);
Maxwelltime:Topo_gravity.c:            i = E->sphere.hindex[ll][mm];
Maxwelltime:Topo_gravity.c:            c1_0 = geoid_bncy[0][i]*E->data.density*grav1;
Maxwelltime:Topo_gravity.c:            c1_1 = geoid_bncy[1][i]*E->data.density*grav1;
Maxwelltime:Topo_gravity.c:    broadcast_vertical(E, geoid_tpgt[0], geoid_tpgt[1], E->parallel.nprocz-1);
Maxwelltime:Topo_gravity.c:    geoid_from_buoyancy(E, E->sphere.harm_geoid_from_bncy,
Maxwelltime:Topo_gravity.c:                        E->sphere.harm_geoid_from_bncy_botm);
Maxwelltime:Topo_gravity.c:    expand_topo_sph_harm(E, E->sphere.harm_tpgt, E->sphere.harm_tpgb);
Maxwelltime:Topo_gravity.c:    if(E->control.self_gravitation)
Maxwelltime:Topo_gravity.c:                                     E->sphere.harm_tpgt,
Maxwelltime:Topo_gravity.c:                                     E->sphere.harm_tpgb,
Maxwelltime:Topo_gravity.c:                                     E->sphere.harm_geoid_from_bncy,
Maxwelltime:Topo_gravity.c:                                     E->sphere.harm_geoid_from_bncy_botm,
Maxwelltime:Topo_gravity.c:                                     E->sphere.harm_geoid_from_tpgt,
Maxwelltime:Topo_gravity.c:                                     E->sphere.harm_geoid_from_tpgb);
Maxwelltime:Topo_gravity.c:        geoid_from_topography(E, E->sphere.harm_tpgt, E->sphere.harm_tpgb,
Maxwelltime:Topo_gravity.c:                              E->sphere.harm_geoid_from_tpgt,
Maxwelltime:Topo_gravity.c:                              E->sphere.harm_geoid_from_tpgb);
Maxwelltime:Topo_gravity.c:    if (E->parallel.me == (E->parallel.nprocz-1))  {
Maxwelltime:Topo_gravity.c:            for (p = 0; p < E->sphere.hindice; p++) {
Maxwelltime:Topo_gravity.c:                E->sphere.harm_geoid[i][p]
Maxwelltime:Topo_gravity.c:                    = E->sphere.harm_geoid_from_bncy[i][p]
Maxwelltime:Topo_gravity.c:                    + E->sphere.harm_geoid_from_tpgt[i][p]
Maxwelltime:Topo_gravity.c:                    + E->sphere.harm_geoid_from_tpgb[i][p];
Maxwelltime:Topo_gravity.c:    const int dims=E->mesh.nsd;
Maxwelltime:Topo_gravity.c:    const int noz=E->lmesh.noz;
Maxwelltime:Topo_gravity.c:    const int noy=E->lmesh.noy;
Maxwelltime:Topo_gravity.c:    const int nno=E->lmesh.nno;
Maxwelltime:Topo_gravity.c:    const int elz = E->lmesh.elz;
Maxwelltime:Topo_gravity.c:    const int ely = E->lmesh.ely;
Maxwelltime:Topo_gravity.c:    const int lev=E->mesh.levmax;
Maxwelltime:Topo_gravity.c:    const int lnsf=E->lmesh.nsf;
Maxwelltime:Topo_gravity.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)          {
Maxwelltime:Topo_gravity.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)          {
Maxwelltime:Topo_gravity.c:    for(els=1;els<=E->lmesh.snel;els++) {
Maxwelltime:Topo_gravity.c:      el = E->surf_element[j][els];
Maxwelltime:Topo_gravity.c:           res[m]  = eltf[m]  - E->elt_del[lev][j][el].g[m][0]  * E->P[j][el];
Maxwelltime:Topo_gravity.c:           resb[m] = eltfb[m] - E->elt_del[lev][j][elb].g[m][0]* E->P[j][elb];
Maxwelltime:Topo_gravity.c://           res[m]  = eltf[m] - eltg[m][0]  * E->P[j][el];
Maxwelltime:Topo_gravity.c://           resb[m] = eltfb[m] - eltgb[m][0]* E->P[j][elb];
Maxwelltime:Topo_gravity.c:                nodes = E->sien[j][els].node[1];
Maxwelltime:Topo_gravity.c:                nodes = E->sien[j][els].node[2];
Maxwelltime:Topo_gravity.c:                nodes = E->sien[j][els].node[3];
Maxwelltime:Topo_gravity.c:                nodes = E->sien[j][els].node[4];
Maxwelltime:Topo_gravity.c:                nodes = E->sien[j][els].node[1];
Maxwelltime:Topo_gravity.c:                nodes = E->sien[j][els].node[2];
Maxwelltime:Topo_gravity.c:                nodes = E->sien[j][els].node[3];
Maxwelltime:Topo_gravity.c:                nodes = E->sien[j][els].node[4];
Maxwelltime:Topo_gravity.c:    for(els=1;els<=E->lmesh.snel;els++) {
Maxwelltime:Topo_gravity.c:       el = E->surf_element[j][els];
Maxwelltime:Topo_gravity.c:                * E->L.vpt[GMVINDEX(m,n)] * E->L.vpt[GMVINDEX(m,n)];
Maxwelltime:Topo_gravity.c:                * E->L.vpt[GMVINDEX(m,n)] * E->L.vpt[GMVINDEX(m,n)];
Maxwelltime:Topo_gravity.c:            SL[j][E->sien[j][els].node[m]] += eltTL[m-1];
Maxwelltime:Topo_gravity.c:            SU[j][E->sien[j][els].node[m]] += eltTU[m-1];
Maxwelltime:Topo_gravity.c:  if(E->parallel.me_loc[3] == 0) {
Maxwelltime:Topo_gravity.c:  if(E->sphere.caps == 12)
Maxwelltime:Topo_gravity.c:      full_exchange_snode_f(E,RL,SL,E->mesh.levmax);
Maxwelltime:Topo_gravity.c:      regional_exchange_snode_f(E,RL,SL,E->mesh.levmax);
Maxwelltime:Topo_gravity.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Topo_gravity.c:      for(i=1;i<=E->lmesh.nsf;i++)
Maxwelltime:Topo_gravity.c:  if(E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Maxwelltime:Topo_gravity.c:  if(E->sphere.caps == 12)
Maxwelltime:Topo_gravity.c:      full_exchange_snode_f(E,RU,SU,E->mesh.levmax);
Maxwelltime:Topo_gravity.c:      regional_exchange_snode_f(E,RU,SU,E->mesh.levmax);
Maxwelltime:Topo_gravity.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)
Maxwelltime:Topo_gravity.c:      for(i=1;i<=E->lmesh.nsf;i++)
Maxwelltime:Topo_gravity.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Maxwelltime:Tracer_setup.c:    int m=E->parallel.me;
Maxwelltime:Tracer_setup.c:    input_boolean("tracer",&(E->control.tracer),"off",m);
Maxwelltime:Tracer_setup.c:		  &(E->control.tracer_enriched),"off",m);
Maxwelltime:Tracer_setup.c:    if(E->control.tracer_enriched){
Maxwelltime:Tracer_setup.c:      if(!E->control.tracer)	/* check here so that we can get away
Maxwelltime:Tracer_setup.c:      input_float("Q0_enriched",&(E->control.Q0ER),"0.0",m);
Maxwelltime:Tracer_setup.c:	       E->control.Q0,E->control.Q0ER);
Maxwelltime:Tracer_setup.c:      //if(E->composition.ncomp != 1)
Maxwelltime:Tracer_setup.c:    if(E->control.tracer) {
Maxwelltime:Tracer_setup.c:        input_int("tracer_ic_method",&(E->trace.ic_method),"0,0,nomax",m);
Maxwelltime:Tracer_setup.c:        if (E->trace.ic_method==0){
Maxwelltime:Tracer_setup.c:            input_int("tracers_per_element",&(E->trace.itperel),"10,0,nomax",m);
Maxwelltime:Tracer_setup.c:        else if (E->trace.ic_method==1)
Maxwelltime:Tracer_setup.c:            input_string("tracer_file",E->trace.tracer_file,"tracer.dat",m);
Maxwelltime:Tracer_setup.c:        else if (E->trace.ic_method==2) {
Maxwelltime:Tracer_setup.c:        input_int("tracer_flavors",&(E->trace.nflavors),"0,0,nomax",m);
Maxwelltime:Tracer_setup.c:		  &(E->trace.ic_method_for_flavors),"0,0,nomax",m);
Maxwelltime:Tracer_setup.c:        if (E->trace.nflavors > 1) {
Maxwelltime:Tracer_setup.c:            switch(E->trace.ic_method_for_flavors){
Maxwelltime:Tracer_setup.c:                E->trace.z_interface = (double*) malloc((E->trace.nflavors-1)
Maxwelltime:Tracer_setup.c:                for(i=0; i<E->trace.nflavors-1; i++)
Maxwelltime:Tracer_setup.c:                    E->trace.z_interface[i] = 0.7;
Maxwelltime:Tracer_setup.c:                input_double_vector("z_interface", E->trace.nflavors-1,
Maxwelltime:Tracer_setup.c:                                    E->trace.z_interface, m);
Maxwelltime:Tracer_setup.c:	      input_string("ictracer_grd_file",E->trace.ggrd_file,"",m); /* file from which to read */
Maxwelltime:Tracer_setup.c:	      input_int("ictracer_grd_layers",&(E->trace.ggrd_layers),"2",m); /* 
Maxwelltime:Tracer_setup.c:                fprintf(stderr,"ic_method_for_flavors %i undefined (1 and 99 only for ggrd mode)\n",E->trace.ic_method_for_flavors);
Maxwelltime:Tracer_setup.c:        input_boolean("itracer_warnings",&(E->trace.itracer_warnings),"on",m);
Maxwelltime:Tracer_setup.c:        if(E->parallel.nprocxy == 12)
Maxwelltime:Tracer_setup.c:   E->trace.advection_time = 0;
Maxwelltime:Tracer_setup.c:   E->trace.find_tracers_time = 0;
Maxwelltime:Tracer_setup.c:   E->trace.lost_souls_time = 0;
Maxwelltime:Tracer_setup.c:   if(E->parallel.nprocxy == 1) {
Maxwelltime:Tracer_setup.c:       E->problem_tracer_setup = regional_tracer_setup;
Maxwelltime:Tracer_setup.c:       E->trace.keep_within_bounds = regional_keep_within_bounds;
Maxwelltime:Tracer_setup.c:       E->trace.get_velocity = regional_get_velocity;
Maxwelltime:Tracer_setup.c:       E->trace.iget_element = regional_iget_element;
Maxwelltime:Tracer_setup.c:       E->problem_tracer_setup = full_tracer_setup;
Maxwelltime:Tracer_setup.c:       E->trace.keep_within_bounds = full_keep_within_bounds;
Maxwelltime:Tracer_setup.c:       E->trace.get_velocity = full_get_velocity;
Maxwelltime:Tracer_setup.c:       E->trace.iget_element = full_iget_element;
Maxwelltime:Tracer_setup.c:    if (E->trace.nflavors > 0)
Maxwelltime:Tracer_setup.c:    if (E->composition.on) {
Maxwelltime:Tracer_setup.c:    E->trace.advection_time += CPU_time0() - begin_time;
Maxwelltime:Tracer_setup.c:    E->trace.istat_isend=0;
Maxwelltime:Tracer_setup.c:    E->trace.istat_elements_checked=0;
Maxwelltime:Tracer_setup.c:    E->trace.istat1=0;
Maxwelltime:Tracer_setup.c:    if ((E->monitor.solution_cycles % 20) == 0) {
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt, "STEP %d\n", E->monitor.solution_cycles);
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt, "Advecting tracers takes %f seconds.\n",
Maxwelltime:Tracer_setup.c:                E->trace.advection_time - E->trace.find_tracers_time);
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt, "Finding element takes %f seconds.\n",
Maxwelltime:Tracer_setup.c:                E->trace.find_tracers_time - E->trace.lost_souls_time);
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt, "Exchanging lost tracers takes %f seconds.\n",
Maxwelltime:Tracer_setup.c:                E->trace.lost_souls_time);
Maxwelltime:Tracer_setup.c:    if(E->control.verbose){
Maxwelltime:Tracer_setup.c:      fprintf(E->trace.fpt,"Number of times for all element search  %d\n",E->trace.istat1);
Maxwelltime:Tracer_setup.c:      fprintf(E->trace.fpt,"Number of tracers sent to other processors: %d\n",E->trace.istat_isend);
Maxwelltime:Tracer_setup.c:      fprintf(E->trace.fpt,"Number of times element columns are checked: %d \n",E->trace.istat_elements_checked);
Maxwelltime:Tracer_setup.c:      if (E->composition.on) {
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt,"Empty elements filled with old compositional "
Maxwelltime:Tracer_setup.c:                "values: %d (%f percent)\n", E->trace.istat_iempty,
Maxwelltime:Tracer_setup.c:                (100.0*E->trace.istat_iempty)/E->lmesh.nel);
Maxwelltime:Tracer_setup.c:        E->trace.istat_iempty=0;
Maxwelltime:Tracer_setup.c:        if (E->parallel.me==0) {
Maxwelltime:Tracer_setup.c:            fprintf(E->fp,"composition: %e",E->monitor.elapsed_time);
Maxwelltime:Tracer_setup.c:            for (i=0; i<E->composition.ncomp; i++)
Maxwelltime:Tracer_setup.c:                fprintf(E->fp," %e", E->composition.bulk_composition[i]);
Maxwelltime:Tracer_setup.c:            fprintf(E->fp,"\n");
Maxwelltime:Tracer_setup.c:            fprintf(E->fp,"composition_error_fraction: %e",E->monitor.elapsed_time);
Maxwelltime:Tracer_setup.c:            for (i=0; i<E->composition.ncomp; i++)
Maxwelltime:Tracer_setup.c:                fprintf(E->fp," %e", E->composition.error_fraction[i]);
Maxwelltime:Tracer_setup.c:            fprintf(E->fp,"\n");
Maxwelltime:Tracer_setup.c:      fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    dt=E->advection.timestep;
Maxwelltime:Tracer_setup.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Tracer_setup.c:        numtracers=E->trace.ntracers[j];
Maxwelltime:Tracer_setup.c:            theta0=E->trace.basicq[j][0][kk];
Maxwelltime:Tracer_setup.c:            phi0=E->trace.basicq[j][1][kk];
Maxwelltime:Tracer_setup.c:            rad0=E->trace.basicq[j][2][kk];
Maxwelltime:Tracer_setup.c:            x0=E->trace.basicq[j][3][kk];
Maxwelltime:Tracer_setup.c:            y0=E->trace.basicq[j][4][kk];
Maxwelltime:Tracer_setup.c:            z0=E->trace.basicq[j][5][kk];
Maxwelltime:Tracer_setup.c:            nelem=E->trace.ielement[j][kk];
Maxwelltime:Tracer_setup.c:            (E->trace.get_velocity)(E,j,nelem,theta0,phi0,rad0,velocity_vector);
Maxwelltime:Tracer_setup.c:            (E->trace.keep_within_bounds)(E,&x_pred,&y_pred,&z_pred,&theta_pred,&phi_pred,&rad_pred);
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][0][kk]=theta_pred;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][1][kk]=phi_pred;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][2][kk]=rad_pred;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][3][kk]=x_pred;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][4][kk]=y_pred;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][5][kk]=z_pred;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][6][kk]=x0;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][7][kk]=y0;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][8][kk]=z0;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][9][kk]=velocity_vector[1];  /* Vx */
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][10][kk]=velocity_vector[2];  /* Vy */
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][11][kk]=velocity_vector[3];  /* Vz */
Maxwelltime:Tracer_setup.c:    dt=E->advection.timestep;
Maxwelltime:Tracer_setup.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Tracer_setup.c:        for (kk=1;kk<=E->trace.ntracers[j];kk++) {
Maxwelltime:Tracer_setup.c:            theta_pred=E->trace.basicq[j][0][kk];
Maxwelltime:Tracer_setup.c:            phi_pred=E->trace.basicq[j][1][kk];
Maxwelltime:Tracer_setup.c:            rad_pred=E->trace.basicq[j][2][kk];
Maxwelltime:Tracer_setup.c:            x_pred=E->trace.basicq[j][3][kk];
Maxwelltime:Tracer_setup.c:            y_pred=E->trace.basicq[j][4][kk];
Maxwelltime:Tracer_setup.c:            z_pred=E->trace.basicq[j][5][kk];
Maxwelltime:Tracer_setup.c:            x0=E->trace.basicq[j][6][kk];
Maxwelltime:Tracer_setup.c:            y0=E->trace.basicq[j][7][kk];
Maxwelltime:Tracer_setup.c:            z0=E->trace.basicq[j][8][kk];
Maxwelltime:Tracer_setup.c:            Vx0=E->trace.basicq[j][9][kk];
Maxwelltime:Tracer_setup.c:            Vy0=E->trace.basicq[j][10][kk];
Maxwelltime:Tracer_setup.c:            Vz0=E->trace.basicq[j][11][kk];
Maxwelltime:Tracer_setup.c:            nelem=E->trace.ielement[j][kk];
Maxwelltime:Tracer_setup.c:            (E->trace.get_velocity)(E,j,nelem,theta_pred,phi_pred,rad_pred,velocity_vector);
Maxwelltime:Tracer_setup.c:            (E->trace.keep_within_bounds)(E,&x_cor,&y_cor,&z_cor,&theta_cor,&phi_cor,&rad_cor);
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][0][kk]=theta_cor;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][1][kk]=phi_cor;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][2][kk]=rad_cor;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][3][kk]=x_cor;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][4][kk]=y_cor;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][5][kk]=z_cor;
Maxwelltime:Tracer_setup.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Tracer_setup.c:        E->trace.ilater[j]=E->trace.ilatersize[j]=0;
Maxwelltime:Tracer_setup.c:        E->trace.istat1=0;
Maxwelltime:Tracer_setup.c:            E->trace.istat_ichoice[j][kk]=0;
Maxwelltime:Tracer_setup.c:        num_tracers=E->trace.ntracers[j];
Maxwelltime:Tracer_setup.c:            theta=E->trace.basicq[j][0][it];
Maxwelltime:Tracer_setup.c:            phi=E->trace.basicq[j][1][it];
Maxwelltime:Tracer_setup.c:            rad=E->trace.basicq[j][2][it];
Maxwelltime:Tracer_setup.c:            x=E->trace.basicq[j][3][it];
Maxwelltime:Tracer_setup.c:            y=E->trace.basicq[j][4][it];
Maxwelltime:Tracer_setup.c:            z=E->trace.basicq[j][5][it];
Maxwelltime:Tracer_setup.c:            iprevious_element=E->trace.ielement[j][it];
Maxwelltime:Tracer_setup.c:            iel=(E->trace.iget_element)(E,j,iprevious_element,x,y,z,theta,phi,rad);
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt,"BB. kk %d %d %d %d %f %f %f %f %f %f\n",kk,j,iprevious_element,iel,x,y,z,theta,phi,rad);
Maxwelltime:Tracer_setup.c:            fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:            E->trace.ielement[j][it]=iel;
Maxwelltime:Tracer_setup.c:    if (E->parallel.nprocxy == 12)
Maxwelltime:Tracer_setup.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Tracer_setup.c:        if (E->trace.ilatersize[j]>0) {
Maxwelltime:Tracer_setup.c:            for (kk=0;kk<=((E->trace.number_of_tracer_quantities)-1);kk++) {
Maxwelltime:Tracer_setup.c:                free(E->trace.rlater[j][kk]);
Maxwelltime:Tracer_setup.c:    E->trace.find_tracers_time += CPU_time0() - begin_time;
Maxwelltime:Tracer_setup.c:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Maxwelltime:Tracer_setup.c:        for (flavor=0; flavor<E->trace.nflavors; flavor++)
Maxwelltime:Tracer_setup.c:            for (e=1; e<=E->lmesh.nel; e++)
Maxwelltime:Tracer_setup.c:                E->trace.ntracer_flavor[j][flavor][e] = 0;
Maxwelltime:Tracer_setup.c:        numtracers=E->trace.ntracers[j];
Maxwelltime:Tracer_setup.c:            e = E->trace.ielement[j][kk];
Maxwelltime:Tracer_setup.c:            flavor = E->trace.extraq[j][0][kk];
Maxwelltime:Tracer_setup.c:            E->trace.ntracer_flavor[j][flavor][e]++;
Maxwelltime:Tracer_setup.c:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Maxwelltime:Tracer_setup.c:        for (e=1; e<=E->lmesh.nel; e++) {
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt, "element=%d ntracer_flaver =", e);
Maxwelltime:Tracer_setup.c:            for (flavor=0; flavor<E->trace.nflavors; flavor++) {
Maxwelltime:Tracer_setup.c:                fprintf(E->trace.fpt, " %d",
Maxwelltime:Tracer_setup.c:                        E->trace.ntracer_flavor[j][flavor][e]);
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt, "\n");
Maxwelltime:Tracer_setup.c:    fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    if (E->trace.ic_method==0)
Maxwelltime:Tracer_setup.c:    else if (E->trace.ic_method==1)
Maxwelltime:Tracer_setup.c:    else if (E->trace.ic_method==2)
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt,"Not ready for other inputs yet\n");
Maxwelltime:Tracer_setup.c:        fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    E->trace.ilast_tracer_count = isum_tracers(E);
Maxwelltime:Tracer_setup.c:    fprintf(E->trace.fpt, "Sum of Tracers: %d\n", E->trace.ilast_tracer_count);
Maxwelltime:Tracer_setup.c:    if(E->parallel.me==0)
Maxwelltime:Tracer_setup.c:        fprintf(stderr, "Sum of Tracers: %d\n", E->trace.ilast_tracer_count);
Maxwelltime:Tracer_setup.c:    if (E->trace.nflavors > 0)
Maxwelltime:Tracer_setup.c:    if (E->parallel.me==0) fprintf(stderr,"Making Tracer Array\n");
Maxwelltime:Tracer_setup.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Tracer_setup.c:        processor_fraction=E->lmesh.volume/E->mesh.volume;
Maxwelltime:Tracer_setup.c:        tracers_cap=E->mesh.nel*E->trace.itperel*processor_fraction;
Maxwelltime:Tracer_setup.c:          fprintf(stderr,"AA: proc frac: %f (%d) %d %d %f %f\n",processor_fraction,tracers_cap,E->lmesh.nel,E->parallel.nprocz, E->sx[j][3][E->lmesh.noz],E->sx[j][3][1]);
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt,"\nGenerating %d Tracers\n",tracers_cap);
Maxwelltime:Tracer_setup.c:    if (E->trace.nflavors) init_tracer_flavors(E);
Maxwelltime:Tracer_setup.c:    /* One must loop over E->X to find the min/max, since the 8 corner */
Maxwelltime:Tracer_setup.c:    xmin = ymin = zmin = E->sphere.ro;
Maxwelltime:Tracer_setup.c:    xmax = ymax = zmax = -E->sphere.ro;
Maxwelltime:Tracer_setup.c:    for (kk=1; kk<=E->lmesh.nno; kk++) {
Maxwelltime:Tracer_setup.c:        x = E->x[j][1][kk];
Maxwelltime:Tracer_setup.c:        y = E->x[j][2][kk];
Maxwelltime:Tracer_setup.c:        z = E->x[j][3][kk];
Maxwelltime:Tracer_setup.c:    while (E->trace.ntracers[j]<tracers_cap) {
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt,"Error(make_tracer_array)-too many tries?\n");
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt,"%d %d %d\n",max_tries,number_of_tries,RAND_MAX);
Maxwelltime:Tracer_setup.c:            fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:        if (rad>=E->sx[j][3][E->lmesh.noz]) continue;
Maxwelltime:Tracer_setup.c:        if (rad<E->sx[j][3][1]) continue;
Maxwelltime:Tracer_setup.c:        if (E->parallel.nprocxy==1)
Maxwelltime:Tracer_setup.c:        (E->trace.keep_within_bounds)(E,&x,&y,&z,&theta,&phi,&rad);
Maxwelltime:Tracer_setup.c:        E->trace.ntracers[j]++;
Maxwelltime:Tracer_setup.c:        kk=E->trace.ntracers[j];
Maxwelltime:Tracer_setup.c:        E->trace.basicq[j][0][kk]=theta;
Maxwelltime:Tracer_setup.c:        E->trace.basicq[j][1][kk]=phi;
Maxwelltime:Tracer_setup.c:        E->trace.basicq[j][2][kk]=rad;
Maxwelltime:Tracer_setup.c:        E->trace.basicq[j][3][kk]=x;
Maxwelltime:Tracer_setup.c:        E->trace.basicq[j][4][kk]=y;
Maxwelltime:Tracer_setup.c:        E->trace.basicq[j][5][kk]=z;
Maxwelltime:Tracer_setup.c:    fptracer=fopen(E->trace.tracer_file,"r");
Maxwelltime:Tracer_setup.c:        fprintf(stderr,"Error while reading file '%s'\n", E->trace.tracer_file);
Maxwelltime:Tracer_setup.c:    fprintf(E->trace.fpt,"%d Tracers, %d columns in file \n",
Maxwelltime:Tracer_setup.c:    if (E->trace.number_of_extra_quantities+3 != ncolumns) {
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(read tracer file)-wrong # of columns\n");
Maxwelltime:Tracer_setup.c:        fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    iestimate=number_of_tracers/E->parallel.nproc + icushion;
Maxwelltime:Tracer_setup.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Tracer_setup.c:            ncol = 3 + E->trace.number_of_extra_quantities;
Maxwelltime:Tracer_setup.c:                fprintf(E->trace.fpt,"ERROR(read tracer file) - wrong input file format: %s\n", E->trace.tracer_file);
Maxwelltime:Tracer_setup.c:                fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:            (E->trace.keep_within_bounds)(E,&x,&y,&z,&theta,&phi,&rad);
Maxwelltime:Tracer_setup.c:            if (E->parallel.nprocz>1) icheck=icheck_processor_shell(E,j,rad);
Maxwelltime:Tracer_setup.c:            if (E->parallel.nprocxy==1)
Maxwelltime:Tracer_setup.c:            E->trace.ntracers[j]++;
Maxwelltime:Tracer_setup.c:            if (E->trace.ntracers[j]>=(E->trace.max_ntracers[j]-5)) expand_tracer_arrays(E,j);
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][0][E->trace.ntracers[j]]=theta;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][1][E->trace.ntracers[j]]=phi;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][2][E->trace.ntracers[j]]=rad;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][3][E->trace.ntracers[j]]=x;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][4][E->trace.ntracers[j]]=y;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][5][E->trace.ntracers[j]]=z;
Maxwelltime:Tracer_setup.c:            for (i=0; i<E->trace.number_of_extra_quantities; i++)
Maxwelltime:Tracer_setup.c:                E->trace.extraq[j][i][E->trace.ntracers[j]]=buffer[i+3];
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt,"Number of tracers in this cap is: %d\n",
Maxwelltime:Tracer_setup.c:                E->trace.ntracers[j]);
Maxwelltime:Tracer_setup.c:        for (kk=1; kk<=E->trace.ntracers[j]; kk++) {
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt, "tracer#=%d sph_coord=(%g,%g,%g)", kk,
Maxwelltime:Tracer_setup.c:                    E->trace.basicq[j][0][kk],
Maxwelltime:Tracer_setup.c:                    E->trace.basicq[j][1][kk],
Maxwelltime:Tracer_setup.c:                    E->trace.basicq[j][2][kk]);
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt, "   extraq=");
Maxwelltime:Tracer_setup.c:            for (i=0; i<E->trace.number_of_extra_quantities; i++)
Maxwelltime:Tracer_setup.c:                fprintf(E->trace.fpt, " %g", E->trace.extraq[j][i][kk]);
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt, "\n");
Maxwelltime:Tracer_setup.c:        fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(read_tracer_file) - tracers != number in file\n");
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt,"Tracers in system: %d\n", icheck);
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt,"Tracers in file: %d\n", number_of_tracers);
Maxwelltime:Tracer_setup.c:        fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    if (E->trace.number_of_extra_quantities>99) {
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-increase size of extra[]\n");
Maxwelltime:Tracer_setup.c:        fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    if(strcmp(E->output.format, "ascii-gz") == 0){
Maxwelltime:Tracer_setup.c:	      E->control.data_dir_old,E->monitor.solution_cycles_init,E->parallel.me,E->monitor.solution_cycles_init);
Maxwelltime:Tracer_setup.c:      sprintf(output_file,"%s.tracer.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-gziped file not found %s\n",output_file);
Maxwelltime:Tracer_setup.c:        fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    sprintf(output_file,"%s.tracer.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-file not found %s\n",output_file);
Maxwelltime:Tracer_setup.c:        fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Tracer_setup.c:        if (E->trace.number_of_extra_quantities+3 != ncolumns) {
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-wrong # of columns\n");
Maxwelltime:Tracer_setup.c:            fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:        E->trace.ntracers[j]=numtracers;
Maxwelltime:Tracer_setup.c:            ncol = 3 + E->trace.number_of_extra_quantities;
Maxwelltime:Tracer_setup.c:                fprintf(E->trace.fpt,"ERROR(read_old_tracer_file) - wrong input file format: %s\n", output_file);
Maxwelltime:Tracer_setup.c:                fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:            (E->trace.keep_within_bounds)(E,&x,&y,&z,&theta,&phi,&rad);
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][0][kk]=theta;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][1][kk]=phi;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][2][kk]=rad;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][3][kk]=x;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][4][kk]=y;
Maxwelltime:Tracer_setup.c:            E->trace.basicq[j][5][kk]=z;
Maxwelltime:Tracer_setup.c:            for (i=0; i<E->trace.number_of_extra_quantities; i++)
Maxwelltime:Tracer_setup.c:                E->trace.extraq[j][i][kk]=buffer[i+3];
Maxwelltime:Tracer_setup.c:        for (kk=1; kk<=E->trace.ntracers[j]; kk++) {
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt, "tracer#=%d sph_coord=(%g,%g,%g)", kk,
Maxwelltime:Tracer_setup.c:                    E->trace.basicq[j][0][kk],
Maxwelltime:Tracer_setup.c:                    E->trace.basicq[j][1][kk],
Maxwelltime:Tracer_setup.c:                    E->trace.basicq[j][2][kk]);
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt, "   extraq=");
Maxwelltime:Tracer_setup.c:            for (i=0; i<E->trace.number_of_extra_quantities; i++)
Maxwelltime:Tracer_setup.c:                fprintf(E->trace.fpt, " %g", E->trace.extraq[j][i][kk]);
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt, "\n");
Maxwelltime:Tracer_setup.c:        fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt,"Read %d tracers from file %s\n",numtracers,output_file);
Maxwelltime:Tracer_setup.c:        fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    if(strcmp(E->output.format, "ascii-gz") == 0)
Maxwelltime:Tracer_setup.c:    iold_number = E->trace.ilast_tracer_count;
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(check_sum)-break in conservation %d %d\n",
Maxwelltime:Tracer_setup.c:        fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:        if (E->trace.itracer_warnings)
Maxwelltime:Tracer_setup.c:    E->trace.ilast_tracer_count = number;
Maxwelltime:Tracer_setup.c:    for (j=1; j<=E->sphere.caps_per_proc; j++)
Maxwelltime:Tracer_setup.c:        imycount = imycount + E->trace.ntracers[j];
Maxwelltime:Tracer_setup.c:    MPI_Allreduce(&imycount,&iallcount,1,MPI_INT,MPI_SUM,E->parallel.world);
Maxwelltime:Tracer_setup.c:    switch(E->trace.ic_method_for_flavors){
Maxwelltime:Tracer_setup.c:      for (j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Tracer_setup.c:	number_of_tracers = E->trace.ntracers[j];
Maxwelltime:Tracer_setup.c:	  rad = E->trace.basicq[j][2][kk];
Maxwelltime:Tracer_setup.c:          flavor = E->trace.nflavors - 1;
Maxwelltime:Tracer_setup.c:          for (i=0; i<E->trace.nflavors-1; i++) {
Maxwelltime:Tracer_setup.c:              if (rad > E->trace.z_interface[i]) {
Maxwelltime:Tracer_setup.c:          E->trace.extraq[j][0][kk] = flavor;
Maxwelltime:Tracer_setup.c:	      E->trace.ic_method_for_flavors);
Maxwelltime:Tracer_setup.c:      fprintf(stderr,"ic_method_for_flavors %i undefined\n",E->trace.ic_method_for_flavors);
Maxwelltime:Tracer_setup.c:/* which is later used by (E->trace.icheck_cap)()                            */
Maxwelltime:Tracer_setup.c:    nox=E->lmesh.nox;
Maxwelltime:Tracer_setup.c:    noy=E->lmesh.noy;
Maxwelltime:Tracer_setup.c:    noz=E->lmesh.noz;
Maxwelltime:Tracer_setup.c:    lev = E->mesh.levmax;
Maxwelltime:Tracer_setup.c:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Maxwelltime:Tracer_setup.c:                xx[n] = E->sx[j][d+1][node[i]];
Maxwelltime:Tracer_setup.c:        num_ngb = E->parallel.TNUM_PASS[lev][j];
Maxwelltime:Tracer_setup.c:            neighbor_proc = E->parallel.PROCESSOR[lev][j].pass[kk];
Maxwelltime:Tracer_setup.c:                      tag, E->parallel.world, &request[idb]);
Maxwelltime:Tracer_setup.c:                      tag, E->parallel.world, &request[idb]);
Maxwelltime:Tracer_setup.c:         *      1) E->sphere.caps_per_proc==1
Maxwelltime:Tracer_setup.c:         *      2) E->mesh.nsd==3
Maxwelltime:Tracer_setup.c:                rad = E->sphere.ro;
Maxwelltime:Tracer_setup.c:                E->trace.xcap[kk][i] = x;
Maxwelltime:Tracer_setup.c:                E->trace.ycap[kk][i] = y;
Maxwelltime:Tracer_setup.c:                E->trace.zcap[kk][i] = z;
Maxwelltime:Tracer_setup.c:                E->trace.theta_cap[kk][i] = theta;
Maxwelltime:Tracer_setup.c:                E->trace.phi_cap[kk][i] = phi;
Maxwelltime:Tracer_setup.c:                E->trace.rad_cap[kk][i] = rad;
Maxwelltime:Tracer_setup.c:                E->trace.cos_theta[kk][i] = cos(theta);
Maxwelltime:Tracer_setup.c:                E->trace.sin_theta[kk][i] = sin(theta);
Maxwelltime:Tracer_setup.c:                E->trace.cos_phi[kk][i] = cos(phi);
Maxwelltime:Tracer_setup.c:                E->trace.sin_phi[kk][i] = sin(phi);
Maxwelltime:Tracer_setup.c:                neighbor_proc = E->parallel.me;
Maxwelltime:Tracer_setup.c:                neighbor_proc = E->parallel.PROCESSOR[lev][1].pass[kk];
Maxwelltime:Tracer_setup.c:                fprintf(E->trace.fpt, "pass=%d rank=%d corner=%d "
Maxwelltime:Tracer_setup.c:                        E->trace.theta_cap[kk][i],
Maxwelltime:Tracer_setup.c:                        E->trace.phi_cap[kk][i],
Maxwelltime:Tracer_setup.c:                        E->trace.rad_cap[kk][i]);
Maxwelltime:Tracer_setup.c:        fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    E->trace.max_ntracers[j]=number_of_tracers+number_of_tracers/4;
Maxwelltime:Tracer_setup.c:    E->trace.ntracers[j]=0;
Maxwelltime:Tracer_setup.c:    if ((E->trace.ielement[j]=(int *) malloc(E->trace.max_ntracers[j]*sizeof(int)))==NULL) {
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(make tracer array)-no memory 1a\n");
Maxwelltime:Tracer_setup.c:        fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    for (kk=1;kk<E->trace.max_ntracers[j];kk++)
Maxwelltime:Tracer_setup.c:        E->trace.ielement[j][kk]=-99;
Maxwelltime:Tracer_setup.c:    for (kk=0;kk<E->trace.number_of_basic_quantities;kk++) {
Maxwelltime:Tracer_setup.c:        if ((E->trace.basicq[j][kk]=(double *)malloc(E->trace.max_ntracers[j]*sizeof(double)))==NULL) {
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt,"ERROR(initialize tracer arrays)-no memory 1b.%d\n",kk);
Maxwelltime:Tracer_setup.c:            fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    for (kk=0;kk<E->trace.number_of_extra_quantities;kk++) {
Maxwelltime:Tracer_setup.c:        if ((E->trace.extraq[j][kk]=(double *)malloc(E->trace.max_ntracers[j]*sizeof(double)))==NULL) {
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt,"ERROR(initialize tracer arrays)-no memory 1c.%d\n",kk);
Maxwelltime:Tracer_setup.c:            fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    if (E->trace.nflavors > 0) {
Maxwelltime:Tracer_setup.c:        E->trace.ntracer_flavor[j]=(int **)malloc(E->trace.nflavors*sizeof(int*));
Maxwelltime:Tracer_setup.c:        for (kk=0;kk<E->trace.nflavors;kk++) {
Maxwelltime:Tracer_setup.c:            if ((E->trace.ntracer_flavor[j][kk]=(int *)malloc((E->lmesh.nel+1)*sizeof(int)))==NULL) {
Maxwelltime:Tracer_setup.c:                fprintf(E->trace.fpt,"ERROR(initialize tracer arrays)-no memory 1c.%d\n",kk);
Maxwelltime:Tracer_setup.c:                fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    fprintf(E->trace.fpt,"Physical size of tracer arrays (max_ntracers): %d\n",
Maxwelltime:Tracer_setup.c:            E->trace.max_ntracers[j]);
Maxwelltime:Tracer_setup.c:    fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    inewsize=E->trace.max_ntracers[j]+E->trace.max_ntracers[j]/5+icushion;
Maxwelltime:Tracer_setup.c:    if ((E->trace.ielement[j]=(int *)realloc(E->trace.ielement[j],inewsize*sizeof(int)))==NULL) {
Maxwelltime:Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(expand tracer arrays )-no memory (ielement)\n");
Maxwelltime:Tracer_setup.c:        fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++) {
Maxwelltime:Tracer_setup.c:        if ((E->trace.basicq[j][kk]=(double *)realloc(E->trace.basicq[j][kk],inewsize*sizeof(double)))==NULL) {
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt,"ERROR(expand tracer arrays )-no memory (%d)\n",kk);
Maxwelltime:Tracer_setup.c:            fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++) {
Maxwelltime:Tracer_setup.c:        if ((E->trace.extraq[j][kk]=(double *)realloc(E->trace.extraq[j][kk],inewsize*sizeof(double)))==NULL) {
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt,"ERROR(expand tracer arrays )-no memory 78 (%d)\n",kk);
Maxwelltime:Tracer_setup.c:            fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    fprintf(E->trace.fpt,"Expanding physical memory of ielement, basicq, and extraq to %d from %d\n",
Maxwelltime:Tracer_setup.c:            inewsize,E->trace.max_ntracers[j]);
Maxwelltime:Tracer_setup.c:    E->trace.max_ntracers[j]=inewsize;
Maxwelltime:Tracer_setup.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Maxwelltime:Tracer_setup.c:        iempty_space=(E->trace.max_ntracers[j]-E->trace.ntracers[j]);
Maxwelltime:Tracer_setup.c:        if (iempty_space>(E->trace.ntracers[j]+icushion)) {
Maxwelltime:Tracer_setup.c:            inewsize=E->trace.ntracers[j]+E->trace.ntracers[j]/4+icushion;
Maxwelltime:Tracer_setup.c:                fprintf(E->trace.fpt,"Error(reduce tracer arrays)-something up (hdf3)\n");
Maxwelltime:Tracer_setup.c:                fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:            if ((E->trace.ielement[j]=(int *)realloc(E->trace.ielement[j],inewsize*sizeof(int)))==NULL) {
Maxwelltime:Tracer_setup.c:                fprintf(E->trace.fpt,"ERROR(reduce tracer arrays )-no memory (ielement)\n");
Maxwelltime:Tracer_setup.c:                fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:            for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++) {
Maxwelltime:Tracer_setup.c:                if ((E->trace.basicq[j][kk]=(double *)realloc(E->trace.basicq[j][kk],inewsize*sizeof(double)))==NULL) {
Maxwelltime:Tracer_setup.c:                    fprintf(E->trace.fpt,"AKM(reduce tracer arrays )-no memory (%d)\n",kk);
Maxwelltime:Tracer_setup.c:                    fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:            for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++) {
Maxwelltime:Tracer_setup.c:                if ((E->trace.extraq[j][kk]=(double *)realloc(E->trace.extraq[j][kk],inewsize*sizeof(double)))==NULL) {
Maxwelltime:Tracer_setup.c:                    fprintf(E->trace.fpt,"AKM(reduce tracer arrays )-no memory 783 (%d)\n",kk);
Maxwelltime:Tracer_setup.c:                    fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt,"Reducing physical memory of ielement, basicq, and extraq to %d from %d\n",
Maxwelltime:Tracer_setup.c:                    E->trace.max_ntracers[j],inewsize);
Maxwelltime:Tracer_setup.c:            E->trace.max_ntracers[j]=inewsize;
Maxwelltime:Tracer_setup.c:    if (E->trace.ilatersize[j]==0) {
Maxwelltime:Tracer_setup.c:        E->trace.ilatersize[j]=E->trace.max_ntracers[j]/5;
Maxwelltime:Tracer_setup.c:        for (kk=0;kk<=((E->trace.number_of_tracer_quantities)-1);kk++) {
Maxwelltime:Tracer_setup.c:            if ((E->trace.rlater[j][kk]=(double *)malloc(E->trace.ilatersize[j]*sizeof(double)))==NULL) {
Maxwelltime:Tracer_setup.c:                fprintf(E->trace.fpt,"AKM(put_away_later)-no memory (%d)\n",kk);
Maxwelltime:Tracer_setup.c:                fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    E->trace.ilater[j]++;
Maxwelltime:Tracer_setup.c:    if (E->trace.ilater[j] >= (E->trace.ilatersize[j]-5)) expand_later_array(E,j);
Maxwelltime:Tracer_setup.c:    for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++)
Maxwelltime:Tracer_setup.c:        E->trace.rlater[j][kk][E->trace.ilater[j]]=E->trace.basicq[j][kk][it];
Maxwelltime:Tracer_setup.c:    for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++)
Maxwelltime:Tracer_setup.c:        E->trace.rlater[j][E->trace.number_of_basic_quantities+kk][E->trace.ilater[j]]=E->trace.extraq[j][kk][it];
Maxwelltime:Tracer_setup.c:    inewsize=E->trace.ilatersize[j]+E->trace.ilatersize[j]/5+icushion;
Maxwelltime:Tracer_setup.c:    for (kk=0;kk<=((E->trace.number_of_tracer_quantities)-1);kk++) {
Maxwelltime:Tracer_setup.c:        if ((E->trace.rlater[j][kk]=(double *)realloc(E->trace.rlater[j][kk],inewsize*sizeof(double)))==NULL) {
Maxwelltime:Tracer_setup.c:            fprintf(E->trace.fpt,"AKM(expand later array )-no memory (%d)\n",kk);
Maxwelltime:Tracer_setup.c:            fflush(E->trace.fpt);
Maxwelltime:Tracer_setup.c:    fprintf(E->trace.fpt,"Expanding physical memory of rlater to %d from %d\n",
Maxwelltime:Tracer_setup.c:            inewsize,E->trace.ilatersize[j]);
Maxwelltime:Tracer_setup.c:    E->trace.ilatersize[j]=inewsize;
Maxwelltime:Tracer_setup.c:    ilast_tracer=E->trace.ntracers[j];
Maxwelltime:Tracer_setup.c:    E->trace.ielement[j][it]=E->trace.ielement[j][ilast_tracer];
Maxwelltime:Tracer_setup.c:    for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++)
Maxwelltime:Tracer_setup.c:        E->trace.basicq[j][kk][it]=E->trace.basicq[j][kk][ilast_tracer];
Maxwelltime:Tracer_setup.c:    for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++)
Maxwelltime:Tracer_setup.c:        E->trace.extraq[j][kk][it]=E->trace.extraq[j][kk][ilast_tracer];
Maxwelltime:Tracer_setup.c:    E->trace.ntracers[j]--;
Maxwelltime:Tracer_setup.c:    const int noz = E->lmesh.noz;
Maxwelltime:Tracer_setup.c:    const int nprocz = E->parallel.nprocz;
Maxwelltime:Tracer_setup.c:    top_r = E->sx[j][3][noz];
Maxwelltime:Tracer_setup.c:    bottom_r = E->sx[j][3][1];
Maxwelltime:Tracer_setup.c:    if ( (rad<=top_r) && (E->parallel.me_loc[3]==nprocz-1) ) return 1;
Maxwelltime:Tracer_setup.c:    int me = E->parallel.me;
Maxwelltime:Tracer_setup.c:    fprintf(E->trace.fpt, "Should not be here\n");
Maxwelltime:Tracer_setup.c:    fprintf(E->trace.fpt, "Error(check_shell) nprocessor: %d, radius: %f\n",
Maxwelltime:Tracer_setup.c:    fflush(E->trace.fpt);
Maxwelltime:Visco_elastic.c:       E->monitor.length_scale = E->data.layer_km/E->mesh.layer[2]; /* km */
Maxwelltime:Visco_elastic.c:       E->monitor.time_scale = pow(E->data.layer_km*1000.0,2.0)/
Maxwelltime:Visco_elastic.c:            (E->data.therm_diff*3600.0*24.0*365.25*1.0e6);   /* Million years */
Maxwelltime:Visco_elastic.c:    if (E->ve_data_cont.SELFG)   {
Maxwelltime:Visco_elastic.c:      // calculate E->incr_potential[0/1] from slice.surf/botm[2]
Maxwelltime:Visco_elastic.c:      calculate_potential( E, E->slice_ve.surf[2], E->slice_ve.botm[2],
Maxwelltime:Visco_elastic.c:                       E->incr_potential[0], E->incr_potential[1], 1 );
Maxwelltime:Visco_elastic.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Visco_elastic.c:      for (i=1;i<=E->lmesh.nsf;i++)   {
Maxwelltime:Visco_elastic.c:        E->init_potential[1][m][i] += E->incr_potential[1][m][i];
Maxwelltime:Visco_elastic.c:        E->init_potential[0][m][i] += E->incr_potential[0][m][i];
Maxwelltime:Visco_elastic.c:      if (E->ve_data_cont.polar_wander) {
Maxwelltime:Visco_elastic.c:         E->ve_data_cont.PW[0] += E->ve_data_cont.PW_incr[0];
Maxwelltime:Visco_elastic.c:         E->ve_data_cont.PW[1] += E->ve_data_cont.PW_incr[1];
Maxwelltime:Visco_elastic.c:if (E->parallel.me==0) fprintf(E->fp,"m0m1 in process_new_ve %g %g\n",E->ve_data_cont.PW_incr[0],E->ve_data_cont.PW_incr[1]);
Maxwelltime:Visco_elastic.c:    if (E->ve_data_cont.Heaviside==1) {  // single harmonic for benchmark
Maxwelltime:Visco_elastic.c: *       E->slice.surf/botm[1]    incr deformation (from E->U)
Maxwelltime:Visco_elastic.c: *       E->slice.surf/botm[2]    incr stresses    (no iceload)
Maxwelltime:Visco_elastic.c: *       E->slice.surf/botm[3]    cum  deformation (+= surf/botm[1])
Maxwelltime:Visco_elastic.c: *       E->slice.load[0/2]       cum  stresses, w/ iceload (+= surf/botm[2])
Maxwelltime:Visco_elastic.c:    lev=E->mesh.levmax;
Maxwelltime:Visco_elastic.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:      for (i=1;i<=E->lmesh.nno;i++)  {
Maxwelltime:Visco_elastic.c:         sint = E->SinCos[lev][m][0][i];
Maxwelltime:Visco_elastic.c:         sinf = E->SinCos[lev][m][1][i];
Maxwelltime:Visco_elastic.c:         cost = E->SinCos[lev][m][2][i];
Maxwelltime:Visco_elastic.c:         cosf = E->SinCos[lev][m][3][i];
Maxwelltime:Visco_elastic.c:         ux = E->sphere.cap[m].V[1][i]*cost*cosf
Maxwelltime:Visco_elastic.c:            - E->sphere.cap[m].V[2][i]*sinf
Maxwelltime:Visco_elastic.c:            + E->sphere.cap[m].V[3][i]*sint*cosf;
Maxwelltime:Visco_elastic.c:         uy = E->sphere.cap[m].V[1][i]*cost*sinf
Maxwelltime:Visco_elastic.c:            + E->sphere.cap[m].V[2][i]*cosf
Maxwelltime:Visco_elastic.c:            + E->sphere.cap[m].V[3][i]*sint*sinf;
Maxwelltime:Visco_elastic.c:         uz =-E->sphere.cap[m].V[1][i]*sint
Maxwelltime:Visco_elastic.c:            + E->sphere.cap[m].V[3][i]*cost;
Maxwelltime:Visco_elastic.c:         E->X[lev][m][1][i] += ux;
Maxwelltime:Visco_elastic.c:         E->X[lev][m][2][i] += uy;
Maxwelltime:Visco_elastic.c:         E->X[lev][m][3][i] += uz;
Maxwelltime:Visco_elastic.c:         E->SX[lev][m][3][i] += E->U[m][E->id[m][i].doff[3]];
Maxwelltime:Visco_elastic.c:         E->SX[lev][m][1][i] = acos(E->X[lev][m][3][i]/E->SX[lev][m][3][i]);
Maxwelltime:Visco_elastic.c:         E->SX[lev][m][2][i] = myatan(E->X[lev][m][2][i],E->X[lev][m][1][i]);
Maxwelltime:Visco_elastic.c:         E->SinCos[lev][m][0][i] = sin(E->SX[lev][m][1][i]);
Maxwelltime:Visco_elastic.c:         E->SinCos[lev][m][1][i] = sin(E->SX[lev][m][2][i]);
Maxwelltime:Visco_elastic.c:         E->SinCos[lev][m][2][i] = cos(E->SX[lev][m][1][i]);
Maxwelltime:Visco_elastic.c:         E->SinCos[lev][m][3][i] = cos(E->SX[lev][m][2][i]);
Maxwelltime:Visco_elastic.c:  if (E->control.NMULTIGRID||E->control.EMULTIGRID)   {
Maxwelltime:Visco_elastic.c:    if (E->monitor.solution_cycles%E->ve_data_cont.KERNEL==0 || E->ve_data_cont.DIRECT)  {
Maxwelltime:Visco_elastic.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)  {
Maxwelltime:Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:            for (i=1;i<=E->lmesh.nsf;i++)  {
Maxwelltime:Visco_elastic.c:                node = i*E->lmesh.noz;
Maxwelltime:Visco_elastic.c:                E->slice_ve.surf[1][m][i] = E->U[m][E->id[m][node].doff[3]];
Maxwelltime:Visco_elastic.c:            remove_average(E,E->slice_ve.surf[1],1);
Maxwelltime:Visco_elastic.c:            if (E->ve_data_cont.Heaviside==1)  {   /* single-harmonic */
Maxwelltime:Visco_elastic.c:                for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:                for (i=1;i<=E->lmesh.nsf;i++)
Maxwelltime:Visco_elastic.c:                    E->slice_ve.surf[2][m][i] = E->slice_ve.surf[1][m][i]
Maxwelltime:Visco_elastic.c:                                            *E->ve_data_cont.surf_scaling;
Maxwelltime:Visco_elastic.c:            else if (E->ve_data_cont.Heaviside==2) {    /* ice-model  */
Maxwelltime:Visco_elastic.c:                for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:                for (i=1;i<=E->lmesh.nsf;i++)
Maxwelltime:Visco_elastic.c:                    E->slice_ve.surf[2][m][i] = E->slice_ve.surf[1][m][i]
Maxwelltime:Visco_elastic.c:                                              *E->ve_data_cont.surf_scaling 
Maxwelltime:Visco_elastic.c:                                            + E->slice_ve.dynamic_oceanload[m][i];
Maxwelltime:Visco_elastic.c:        if (E->parallel.me_loc[3]==0)  {
Maxwelltime:Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:            for (i=1;i<=E->lmesh.nsf;i++)  {
Maxwelltime:Visco_elastic.c:                node = (i-1)*E->lmesh.noz+1;
Maxwelltime:Visco_elastic.c:                E->slice_ve.botm[1][m][i] = E->U[m][E->id[m][node].doff[3]];
Maxwelltime:Visco_elastic.c:            remove_average(E,E->slice_ve.botm[1],0);
Maxwelltime:Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:            for (i=1;i<=E->lmesh.nsf;i++)  {
Maxwelltime:Visco_elastic.c:                E->slice_ve.botm[2][m][i] = E->slice_ve.botm[1][m][i]
Maxwelltime:Visco_elastic.c:                                        *E->ve_data_cont.botm_scaling;
Maxwelltime:Visco_elastic.c:        if (E->ve_data_cont.change_of_load==0) 
Maxwelltime:Visco_elastic.c:        load_to_CM_grav( E, E->slice_ve.surf[2], E->slice_ve.botm[2], count );
Maxwelltime:Visco_elastic.c:        shift_U_to_CM(E, E->slice_ve.surf[1], E->slice_ve.botm[1]);
Maxwelltime:Visco_elastic.c://        if (E->parallel.me_loc[3]==E->parallel.nprocz-1) 
Maxwelltime:Visco_elastic.c://            shift_to_CM(E, E->slice_ve.surf[1] );
Maxwelltime:Visco_elastic.c://        if (E->parallel.me_loc[3]==0) 
Maxwelltime:Visco_elastic.c://            shift_to_CM(E, E->slice_ve.botm[1] );
Maxwelltime:Visco_elastic.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)  {
Maxwelltime:Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:            for (i=1;i<=E->lmesh.nsf;i++) {
Maxwelltime:Visco_elastic.c:                E->slice_ve.surf[3][m][i] += E->slice_ve.surf[1][m][i];
Maxwelltime:Visco_elastic.c:                E->slice_ve.load[0][m][i] += E->slice_ve.surf[2][m][i];
Maxwelltime:Visco_elastic.c:        if (E->parallel.me_loc[3]==0)  {
Maxwelltime:Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:            for (i=1;i<=E->lmesh.nsf;i++)  {
Maxwelltime:Visco_elastic.c:                E->slice_ve.botm[3][m][i] += E->slice_ve.botm[1][m][i];
Maxwelltime:Visco_elastic.c:                E->slice_ve.load[2][m][i] += E->slice_ve.botm[2][m][i];
Maxwelltime:Visco_elastic.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Maxwelltime:Visco_elastic.c:    nox = E->lmesh.NOX[lev];
Maxwelltime:Visco_elastic.c:    noy = E->lmesh.NOY[lev];
Maxwelltime:Visco_elastic.c:    noz = E->lmesh.NOZ[lev];
Maxwelltime:Visco_elastic.c:    nno = E->lmesh.NNO[lev];
Maxwelltime:Visco_elastic.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:          E->X[lev][m][1][i] = E->SX[lev][m][3][i]*sin(E->SX[lev][m][1][i])*cos(E->SX[lev][m][2][i]);
Maxwelltime:Visco_elastic.c:          E->X[lev][m][2][i] = E->SX[lev][m][3][i]*sin(E->SX[lev][m][1][i])*sin(E->SX[lev][m][2][i]);
Maxwelltime:Visco_elastic.c:          E->X[lev][m][3][i] = E->SX[lev][m][3][i]*cos(E->SX[lev][m][1][i]);
Maxwelltime:Visco_elastic.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:        E->SinCos[lev][m][0][i] = sin(E->SX[lev][m][1][i]);
Maxwelltime:Visco_elastic.c:        E->SinCos[lev][m][1][i] = sin(E->SX[lev][m][2][i]);
Maxwelltime:Visco_elastic.c:        E->SinCos[lev][m][2][i] = cos(E->SX[lev][m][1][i]);
Maxwelltime:Visco_elastic.c:        E->SinCos[lev][m][3][i] = cos(E->SX[lev][m][2][i]);
Maxwelltime:Visco_elastic.c:    nsf  = E->lmesh.nsf;
Maxwelltime:Visco_elastic.c: if(E->ve_data_cont.apply_potential==0) {    // surface loading
Maxwelltime:Visco_elastic.c:    const1 = (2*E->convection.perturb_ll[0]+1)*E->data.grav_acc/(4.0*M_PI*E->data.grav_const*E->sphere.dradius*E->data.density);
Maxwelltime:Visco_elastic.c:    const2 = (2*E->convection.perturb_ll[0]+1);
Maxwelltime:Visco_elastic.c:    const3 = const1/sqrt(E->convection.perturb_ll[0]*(E->convection.perturb_ll[0]+1));
Maxwelltime:Visco_elastic.c: else if(E->ve_data_cont.apply_potential==1) {    // apply potential loading
Maxwelltime:Visco_elastic.c:    const1 = E->data.grav_acc/(4.0*M_PI*E->data.grav_const*E->sphere.dradius*E->data.density);
Maxwelltime:Visco_elastic.c:    const3 = const1/sqrt(E->convection.perturb_ll[0]*(E->convection.perturb_ll[0]+1));
Maxwelltime:Visco_elastic.c: if ( been_here ==0 || (ii % (E->control.record_every) == 0) || ii==E->advection.max_timesteps)    {
Maxwelltime:Visco_elastic.c:   if (E->parallel.me==E->parallel.nprocz-1)  {  // only for one cpu
Maxwelltime:Visco_elastic.c:      for (ll=0;ll<=E->output.llmax;ll++)
Maxwelltime:Visco_elastic.c:        i = E->sphere.hindex[ll][mm];
Maxwelltime:Visco_elastic.c:        if (ll==E->convection.perturb_ll[0]&&mm==E->convection.perturb_mm[0]) {
Maxwelltime:Visco_elastic.c:          h_love = E->sphere.sphc[2][i];
Maxwelltime:Visco_elastic.c:          k_love = E->sphere.sphc[3][i];
Maxwelltime:Visco_elastic.c:          if (fabs(E->sphere.sphs[2][i]) > hdispersion_err) 
Maxwelltime:Visco_elastic.c:                       hdispersion_err = fabs(E->sphere.sphs[2][i]);
Maxwelltime:Visco_elastic.c:          if (fabs(E->sphere.sphs[3][i]) > kdispersion_err) 
Maxwelltime:Visco_elastic.c:                       kdispersion_err = fabs(E->sphere.sphs[3][i]);
Maxwelltime:Visco_elastic.c:          if (fabs(E->sphere.sphc[2][i]) > hdispersion_err) 
Maxwelltime:Visco_elastic.c:                       hdispersion_err = fabs(E->sphere.sphc[2][i]);
Maxwelltime:Visco_elastic.c:          if (fabs(E->sphere.sphs[2][i]) > hdispersion_err) 
Maxwelltime:Visco_elastic.c:                       hdispersion_err = fabs(E->sphere.sphs[2][i]);
Maxwelltime:Visco_elastic.c:          if (fabs(E->sphere.sphc[3][i]) > kdispersion_err) 
Maxwelltime:Visco_elastic.c:                       kdispersion_err = fabs(E->sphere.sphc[3][i]);
Maxwelltime:Visco_elastic.c:          if (fabs(E->sphere.sphs[3][i]) > kdispersion_err) 
Maxwelltime:Visco_elastic.c:                       kdispersion_err = fabs(E->sphere.sphs[3][i]);
Maxwelltime:Visco_elastic.c:     h_love = h_love*const1/E->convection.perturb_mag[0];
Maxwelltime:Visco_elastic.c:     hdispersion_err = hdispersion_err*const1/E->convection.perturb_mag[0];
Maxwelltime:Visco_elastic.c:     k_love = k_love*const2/E->convection.perturb_mag[0] - 1.0;
Maxwelltime:Visco_elastic.c:     kdispersion_err = kdispersion_err*const2/E->convection.perturb_mag[0];
Maxwelltime:Visco_elastic.c:    if (E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Maxwelltime:Visco_elastic.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Visco_elastic.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Visco_elastic.c:      for (i=1;i<=E->lmesh.nsf;i++)  {
Maxwelltime:Visco_elastic.c:        j = E->surf_node[m][i];
Maxwelltime:Visco_elastic.c:        ve1[m][i]=E->sphere.cap[m].total_VS[1][i];
Maxwelltime:Visco_elastic.c:        ve2[m][i]=E->sphere.cap[m].total_VS[2][i];
Maxwelltime:Visco_elastic.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Visco_elastic.c:      for (i=1;i<=E->lmesh.nsf;i++)  {
Maxwelltime:Visco_elastic.c:    l_love = sqrt(l_love)*const3/E->convection.perturb_mag[0];
Maxwelltime:Visco_elastic.c:   if (E->parallel.me==E->parallel.nprocz-1)  {  // only for one cpu
Maxwelltime:Visco_elastic.c:     fprintf(E->fp_LN,"%d %.4e %.6e %.6e %.6e %.6e %.6e\n",ii,E->monitor.elapsed_time,h_love,hdispersion_err,k_love,kdispersion_err,l_love);
Maxwelltime:Visco_elastic.c:     fflush(E->fp_LN);
Maxwelltime:Visco_elastic.c:    for (m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Visco_elastic.c:       for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:         stress[m] = (float *) malloc ((E->lmesh.nno + 1)*sizeof(float));
Maxwelltime:Visco_elastic.c:       visc_h = (float *) malloc ((E->lmesh.noz + 1)*sizeof(float));
Maxwelltime:Visco_elastic.c:       stress_h = (float *) malloc ((E->lmesh.noz + 1)*sizeof(float));
Maxwelltime:Visco_elastic.c:    if ( been_here ==0 || (ii % (5*E->control.record_every) == 0) || ii==E->advection.max_timesteps)    {
Maxwelltime:Visco_elastic.c:      return_horiz_ave_f(E,E->Vi,visc_h);
Maxwelltime:Visco_elastic.c:      ele_to_nodes(E,E->S2inv,stress,E->mesh.levmax);
Maxwelltime:Visco_elastic.c:      if (E->parallel.me<E->parallel.nprocz)  {
Maxwelltime:Visco_elastic.c:                   E->control.data_file,E->parallel.me,ii);
Maxwelltime:Visco_elastic.c:                    ii,  E->lmesh.noz,                                // timstep
Maxwelltime:Visco_elastic.c:                    E->ve_data_cont.tau*E->monitor.elapsed_time, // current time (years)
Maxwelltime:Visco_elastic.c:                    E->ve_data_cont.tau*E->advection.timestep);  // length of timestep
Maxwelltime:Visco_elastic.c:        for (j=1;j<=E->lmesh.noz;j++)
Maxwelltime:Visco_elastic.c:          fprintf(fp,"%.5e %.5e %.5e\n",E->sx[m][3][j],visc_h[j],stress_h[j]);
Maxwelltime:Visco_elastic.c:                   E->control.data_file,E->parallel.me,ii);
Maxwelltime:Visco_elastic.c:                    ii,  E->lmesh.nno,                                // timstep
Maxwelltime:Visco_elastic.c:                    E->ve_data_cont.tau*E->monitor.elapsed_time, // current time (years)
Maxwelltime:Visco_elastic.c:                    E->ve_data_cont.tau*E->advection.timestep);  // length of timestep
Maxwelltime:Visco_elastic.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:        for (j=1;j<=E->lmesh.nno;j++)
Maxwelltime:Visco_elastic.c:          fprintf(fp,"%.5e %.5e\n",E->Vi[m][j],stress[m][j]);
Maxwelltime:Visco_elastic.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)  {
Maxwelltime:Visco_elastic.c:                     E->control.data_file,E->parallel.me);
Maxwelltime:Visco_elastic.c:            fprintf(fp,"%05d %.5e\n",ii,E->ve_data_cont.tau*E->monitor.elapsed_time);
Maxwelltime:Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Visco_elastic.c:                for (j=1;j<=E->lmesh.nsf;j++)  { 
Maxwelltime:Visco_elastic.c:                    i=j*E->lmesh.noz;
Maxwelltime:Visco_elastic.c:                    E->Xsurf[1][m][j] = E->SX[E->mesh.levmax][m][1][i];
Maxwelltime:Visco_elastic.c:                    E->Xsurf[2][m][j] = E->SX[E->mesh.levmax][m][2][i];
Maxwelltime:Visco_elastic.c:                                E->Xsurf[1][m][j],E->Xsurf[2][m][j]);
Maxwelltime:Visco_elastic.c://                for (j=1;j<=E->lmesh.noz;j++)  { 
Maxwelltime:Visco_elastic.c://                    fprintf(fp,"%.5e\n",E->SX[E->mesh.levmax][m][3][j]); 
Maxwelltime:Visco_elastic.c:                sphere_expansion_output(E,1,E->slice_ve.surf[3],
Maxwelltime:Visco_elastic.c:                        E->sphere.sphc[2],E->sphere.sphs[2],
Maxwelltime:Visco_elastic.c:                        E->monitor.solution_cycles,"tps");
Maxwelltime:Visco_elastic.c:                for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:                for (j=1;j<=E->lmesh.nsf;j++)
Maxwelltime:Visco_elastic.c:                    E->Xsurf[3][m][j] =  E->incr_potential[0][m][j]  
Maxwelltime:Visco_elastic.c:                                       + E->incr_potential[2][m][j] ;
Maxwelltime:Visco_elastic.c:                sphere_expansion_output(E,1,E->Xsurf[3],
Maxwelltime:Visco_elastic.c:                        E->sphere.sphc[3],E->sphere.sphs[3],
Maxwelltime:Visco_elastic.c:                        E->monitor.solution_cycles,"pttl");
Maxwelltime:Visco_elastic.c:                if (E->ve_data_cont.SLE) {
Maxwelltime:Visco_elastic.c:                    for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:                    for (j=1;j<=E->lmesh.nsf;j++)
Maxwelltime:Visco_elastic.c:                        E->Xsurf[3][m][j] =  E->slice_ve.static_oceanload[m][j]
Maxwelltime:Visco_elastic.c:                                           + E->slice_ve.dynamic_oceanload[m][j];
Maxwelltime:Visco_elastic.c:                    sphere_expansion_output(E,1,E->Xsurf[3],
Maxwelltime:Visco_elastic.c:                            E->sphere.sphc[0],E->sphere.sphs[0],
Maxwelltime:Visco_elastic.c:                            E->monitor.solution_cycles,"oceanload");
Maxwelltime:Visco_elastic.c:                    fp = (i==0)? stderr : E->fp_out ;
Maxwelltime:Visco_elastic.c:    if ( ((ii % E->control.record_every) == 0) || (ii == E->advection.max_timesteps))    {
Maxwelltime:Visco_elastic.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)  {
Maxwelltime:Visco_elastic.c:            //       E->control.data_file2,E->parallel.me,ii);
Maxwelltime:Visco_elastic.c:                   E->control.data_file,E->parallel.me,ii);
Maxwelltime:Visco_elastic.c:                    E->ve_data_cont.tau*E->monitor.elapsed_time, // current time (years)
Maxwelltime:Visco_elastic.c:                    E->ve_data_cont.tau*E->advection.timestep,  // length of timestep
Maxwelltime:Visco_elastic.c:              E->ve_data_cont.PW[0],E->ve_data_cont.PW[1], // cumu. polar motion
Maxwelltime:Visco_elastic.c:              E->ve_data_cont.PW_incr[0],E->ve_data_cont.PW_incr[1]); // polar motion
Maxwelltime:Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:            for (j=1;j<=E->lmesh.nsf;j++)
Maxwelltime:Visco_elastic.c:                E->Xsurf[3][m][j] =  E->incr_potential[0][m][j]  
Maxwelltime:Visco_elastic.c:                                   + E->incr_potential[2][m][j] ;
Maxwelltime:Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:            for (j=1;j<=E->lmesh.nsf;j++)  { 
Maxwelltime:Visco_elastic.c:                i=j*E->lmesh.noz;
Maxwelltime:Visco_elastic.c:                E->Xsurf[1][m][j] = E->SX[E->mesh.levmax][m][1][i];
Maxwelltime:Visco_elastic.c:                E->Xsurf[2][m][j] = E->SX[E->mesh.levmax][m][2][i];
Maxwelltime:Visco_elastic.c:                E->Xsurf[3][m][j] = E->SX[E->mesh.levmax][m][3][i]; */
Maxwelltime:Visco_elastic.c:                   E->slice_ve.surf[3][m][j],       // total topography
Maxwelltime:Visco_elastic.c:                   E->slice_ve.surf[1][m][j],       // incr topo
Maxwelltime:Visco_elastic.c:                   E->init_potential[0][m][j],   // total potential
Maxwelltime:Visco_elastic.c:                   E->incr_potential[0][m][j],   // incr potential
Maxwelltime:Visco_elastic.c:                   E->slice_ve.total_static_oceanload[m][j]  // oceanload
Maxwelltime:Visco_elastic.c:                   /E->ve_data_cont.ice_stress_scale,        // (nondim height)
Maxwelltime:Visco_elastic.c:                   E->slice_ve.total_dynamic_oceanload[m][j] //   
Maxwelltime:Visco_elastic.c:                   /E->ve_data_cont.ice_stress_scale         // 
Maxwelltime:Visco_elastic.c:                        E->slice_ve.surf[3][m][j],       // total topography
Maxwelltime:Visco_elastic.c:                        E->slice_ve.surf[1][m][j],       // incr topo
Maxwelltime:Visco_elastic.c:                        E->init_potential[0][m][j],   // total potential
Maxwelltime:Visco_elastic.c:                        E->Xsurf[3][m][j],           // incr potential
Maxwelltime:Visco_elastic.c:                        //E->incr_potential[0][m][j]);  // incr potential due to loads change only
Maxwelltime:Visco_elastic.c:                        E->sphere.cap[m].total_VS[1][j],        
Maxwelltime:Visco_elastic.c:                        E->sphere.cap[m].V[1][i],        
Maxwelltime:Visco_elastic.c:                        E->sphere.cap[m].total_VS[2][j],        
Maxwelltime:Visco_elastic.c:                        E->sphere.cap[m].V[2][i]);        
Maxwelltime:Visco_elastic.c:            sphere_expansion_output(E,1, E->slice_ve.surf[3],
Maxwelltime:Visco_elastic.c:                                         E->sphere.sphc[2], E->sphere.sphs[2],
Maxwelltime:Visco_elastic.c:                                         E->monitor.solution_cycles, "tps");
Maxwelltime:Visco_elastic.c:            sphere_expansion_output(E,1, E->slice_ve.surf[1],
Maxwelltime:Visco_elastic.c:                                         E->sphere.sphc[0],E->sphere.sphs[0],
Maxwelltime:Visco_elastic.c:                                         E->monitor.solution_cycles,"vtps");
Maxwelltime:Visco_elastic.c:            sphere_expansion_output(E,1, E->init_potential[0],
Maxwelltime:Visco_elastic.c:                                         E->sphere.sphc[3],E->sphere.sphs[3],
Maxwelltime:Visco_elastic.c:                                         E->monitor.solution_cycles,"pttl");
Maxwelltime:Visco_elastic.c:            sphere_expansion_output(E,1, E->Xsurf[3],
Maxwelltime:Visco_elastic.c:                                         E->sphere.sphc[0],E->sphere.sphs[0],
Maxwelltime:Visco_elastic.c:                                         E->monitor.solution_cycles,"pttldot");
Maxwelltime:Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Visco_elastic.c:                for (j=1;j<=E->lmesh.nsf;j++)  { 
Maxwelltime:Visco_elastic.c:                    i=j*E->lmesh.noz;
Maxwelltime:Visco_elastic.c:                    E->Xsurf[1][m][j] = E->sphere.cap[m].total_VS[1][j];
Maxwelltime:Visco_elastic.c:                    E->Xsurf[2][m][j] = E->sphere.cap[m].total_VS[2][j];
Maxwelltime:Visco_elastic.c:            sphere_expansion_output(E,1, E->Xsurf[1],
Maxwelltime:Visco_elastic.c:                                         E->sphere.sphc[4],E->sphere.sphs[4],
Maxwelltime:Visco_elastic.c:                                         E->monitor.solution_cycles,"utheta");
Maxwelltime:Visco_elastic.c:            sphere_expansion_output(E,1, E->Xsurf[2],
Maxwelltime:Visco_elastic.c:                                         E->sphere.sphc[5],E->sphere.sphs[5],
Maxwelltime:Visco_elastic.c:                                         E->monitor.solution_cycles,"ufi");
Maxwelltime:Visco_elastic.c:        if (E->parallel.me_loc[3]==0)  {
Maxwelltime:Visco_elastic.c:                             E->control.data_file2,E->parallel.me,ii);
Maxwelltime:Visco_elastic.c:            //                 E->control.data_file,E->parallel.me,ii);
Maxwelltime:Visco_elastic.c:            fprintf(fp,"%05d %.5e\n",ii,E->monitor.elapsed_time);
Maxwelltime:Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:                for (j=1;j<=E->lmesh.nsf;j++)  { 
Maxwelltime:Visco_elastic.c:                    i=(j-1)*E->lmesh.noz+1;
Maxwelltime:Visco_elastic.c:                    E->Xsurf[1][m][j] = E->SX[E->mesh.levmax][m][1][i];
Maxwelltime:Visco_elastic.c:                    E->Xsurf[2][m][j] = E->SX[E->mesh.levmax][m][2][i];
Maxwelltime:Visco_elastic.c:                    E->Xsurf[3][m][j] = E->SX[E->mesh.levmax][m][3][i];
Maxwelltime:Visco_elastic.c:                               E->Xsurf[1][m][j],E->Xsurf[2][m][j],
Maxwelltime:Visco_elastic.c:                               E->slice_ve.botm[3][m][j],
Maxwelltime:Visco_elastic.c:                               E->U[m][E->id[m][i].doff[3]],E->potential[m][i]);
Maxwelltime:Visco_elastic.c:            sphere_expansion_output(E,0,E->slice_ve.botm[3],
Maxwelltime:Visco_elastic.c:                                        E->sphere.sphc[0],E->sphere.sphs[0],
Maxwelltime:Visco_elastic.c:                                        E->monitor.solution_cycles,"tpb");
Maxwelltime:Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Visco_elastic.c:                for (j=1;j<=E->lmesh.nsf;j++)  { 
Maxwelltime:Visco_elastic.c:                    i=(j-1)*E->lmesh.noz+1;
Maxwelltime:Visco_elastic.c:                    E->Xsurf[3][m][j] = E->U[m][E->id[m][i].doff[3]];
Maxwelltime:Visco_elastic.c:            sphere_expansion_output(E,0,E->Xsurf[3],
Maxwelltime:Visco_elastic.c:                                     E->sphere.sphc[0],E->sphere.sphs[0],
Maxwelltime:Visco_elastic.c:                                     E->monitor.solution_cycles,"vtpb");
Maxwelltime:Visco_elastic.c: timea = E->monitor.elapsed_time;
Maxwelltime:Visco_elastic.c:  const int vpts = vpoints[E->mesh.nsd];
Maxwelltime:Visco_elastic.c:for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Visco_elastic.c:  for (i=1;i<=E->lmesh.nel;i++)   {
Maxwelltime:Visco_elastic.c:    alpha = E->Maxwelltime[m][i]/(2.0*visc)*E->advection.timestep;
Maxwelltime:Visco_elastic.c:      evisc[m][(i-1)*vpts+j]=E->Maxwelltime[m][i]/(1.0+alpha);
Maxwelltime:Visco_elastic.c:    E->Maxwelltime[m][i] = (1.0-alpha)/(1.0+alpha);
Maxwelltime:Visco_elastic.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Visco_elastic.c:    const int nno=E->lmesh.nno;
Maxwelltime:Visco_elastic.c:    const int lev=E->mesh.levmax;
Maxwelltime:Visco_elastic.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)      {
Maxwelltime:Visco_elastic.c:    for(e=1;e<=E->lmesh.nel;e++)  {
Maxwelltime:Visco_elastic.c:      gnxx = E->gNX[m][e].vpt;
Maxwelltime:Visco_elastic.c:      get_rtf_at_vpts(E,m,E->mesh.levmax,e,rtf);
Maxwelltime:Visco_elastic.c:      if ((e-1)%E->lmesh.elz==0)
Maxwelltime:Visco_elastic.c:        construct_c3x3matrix_el(E,e,&Cc,&Ccx,E->mesh.levmax,m,0);
Maxwelltime:Visco_elastic.c:        Visc = E->EVi[m][(e-1)*vpts+j];
Maxwelltime:Visco_elastic.c:                 +E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(1,k,1,i,j)]
Maxwelltime:Visco_elastic.c:                 +E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(3,k,i,j)]);
Maxwelltime:Visco_elastic.c:                (E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(1,k,i,j)]*ct
Maxwelltime:Visco_elastic.c:                +E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(3,k,i,j)]
Maxwelltime:Visco_elastic.c:                 +E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(2,k,2,i,j)])/sinaa);
Maxwelltime:Visco_elastic.c:                +E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(2,k,1,i,j)]
Maxwelltime:Visco_elastic.c:                -ct*Cc.vpt[BVINDEX(2,k,i,j)]*E->N.vpt[GNVINDEX(i,j)]
Maxwelltime:Visco_elastic.c:                +(E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(1,k,2,i,j)]
Maxwelltime:Visco_elastic.c:                +(E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(3,k,1,i,j)]
Maxwelltime:Visco_elastic.c:                 -E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(1,k,i,j)]));
Maxwelltime:Visco_elastic.c:                -rtf[3][j]*E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(2,k,i,j)]
Maxwelltime:Visco_elastic.c:                +rtf[3][j]/sinaa*(E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(3,k,2,i,j)]+gnxx[GNVXINDEX(1,i,j)]*Cc.vpt[BVINDEX(3,k,i,j)]));
Maxwelltime:Visco_elastic.c:        E->Sxx[m][(e-1)*vpts+j]=2.0*Visc*Sxyz1 + E->Maxwelltime[m][e]*E->Sxx[m][(e-1)*vpts+j];
Maxwelltime:Visco_elastic.c:        E->Syy[m][(e-1)*vpts+j]=2.0*Visc*Sxyz2 + E->Maxwelltime[m][e]*E->Syy[m][(e-1)*vpts+j];
Maxwelltime:Visco_elastic.c:        E->Szz[m][(e-1)*vpts+j]=2.0*Visc*Sxyz3 + E->Maxwelltime[m][e]*E->Szz[m][(e-1)*vpts+j];
Maxwelltime:Visco_elastic.c:        E->Sxy[m][(e-1)*vpts+j]=    Visc*Sxyz4 + E->Maxwelltime[m][e]*E->Sxy[m][(e-1)*vpts+j];
Maxwelltime:Visco_elastic.c:        E->Sxz[m][(e-1)*vpts+j]=    Visc*Sxyz5 + E->Maxwelltime[m][e]*E->Sxz[m][(e-1)*vpts+j];
Maxwelltime:Visco_elastic.c:        E->Szy[m][(e-1)*vpts+j]=    Visc*Sxyz6 + E->Maxwelltime[m][e]*E->Szy[m][(e-1)*vpts+j];
Maxwelltime:Visco_elastic.c:      E->S2xx[m][e] = E->S2yy[m][e] = E->S2zz[m][e] = E->S2xy[m][e] = E->S2xz[m][e] = E->S2zy[m][e] = 0.0;
Maxwelltime:Visco_elastic.c:         E->S2xx[m][e] += E->Sxx[m][(e-1)*vpts+j];
Maxwelltime:Visco_elastic.c:         E->S2yy[m][e] += E->Syy[m][(e-1)*vpts+j];
Maxwelltime:Visco_elastic.c:         E->S2zz[m][e] += E->Szz[m][(e-1)*vpts+j];
Maxwelltime:Visco_elastic.c:         E->S2xy[m][e] += E->Sxy[m][(e-1)*vpts+j];
Maxwelltime:Visco_elastic.c:         E->S2xz[m][e] += E->Sxz[m][(e-1)*vpts+j];
Maxwelltime:Visco_elastic.c:         E->S2zy[m][e] += E->Szy[m][(e-1)*vpts+j];
Maxwelltime:Visco_elastic.c:      E->S2xx[m][e] = E->S2xx[m][e]/vpts;
Maxwelltime:Visco_elastic.c:      E->S2yy[m][e] = E->S2yy[m][e]/vpts;
Maxwelltime:Visco_elastic.c:      E->S2zz[m][e] = E->S2zz[m][e]/vpts;
Maxwelltime:Visco_elastic.c:      E->S2xy[m][e] = E->S2xy[m][e]/vpts;
Maxwelltime:Visco_elastic.c:      E->S2xz[m][e] = E->S2xz[m][e]/vpts;
Maxwelltime:Visco_elastic.c:      E->S2zy[m][e] = E->S2zy[m][e]/vpts;
Maxwelltime:Visco_elastic.c:      if (!E->viscosity.SDEPV)  {
Maxwelltime:Visco_elastic.c:      E->S2inv[m][e]=E->S2xx[m][e]*E->S2xx[m][e]+E->S2xy[m][e]*E->S2xy[m][e]*2.0
Maxwelltime:Visco_elastic.c:                    +E->S2yy[m][e]*E->S2yy[m][e]+E->S2zy[m][e]*E->S2zy[m][e]*2.0
Maxwelltime:Visco_elastic.c:                    +E->S2zz[m][e]*E->S2zz[m][e]+E->S2xz[m][e]*E->S2xz[m][e]*2.0;
Maxwelltime:Visco_elastic.c:      E->S2inv[m][e] = sqrt(0.5*E->S2inv[m][e]);   
Maxwelltime:Visco_elastic.c:    const int dims=E->mesh.nsd;
Maxwelltime:Visco_elastic.c:    const int dofs=E->mesh.dof;
Maxwelltime:Visco_elastic.c:    const int nno=E->mesh.nno;
Maxwelltime:Visco_elastic.c:    const int lev=E->mesh.levmax;
Maxwelltime:Visco_elastic.c:    if(E->advection.fixed_timestep != 0.0) {
Maxwelltime:Visco_elastic.c:      E->advection.timestep = E->advection.fixed_timestep;
Maxwelltime:Visco_elastic.c:  E->ve_data_cont.DIRECT=0;    // 1: means updating viscosity/stiffness matrix
Maxwelltime:Visco_elastic.c: for (i=stages;i<E->ve_data_cont.stages;i++) {
Maxwelltime:Visco_elastic.c:    E->ve_data_cont.stage = i;
Maxwelltime:Visco_elastic.c:    E->advection.timestep = E->ve_data_cont.stages_timestep[i];
Maxwelltime:Visco_elastic.c:       been = E->ve_data_cont.stages_step[i-1]+1;
Maxwelltime:Visco_elastic.c:    if ( E->monitor.solution_cycles < E->ve_data_cont.stages_step[i] )  {
Maxwelltime:Visco_elastic.c:       E->advection.next_timestep = E->ve_data_cont.stages_timestep[i];
Maxwelltime:Visco_elastic.c:       if (E->monitor.solution_cycles==been) {  // the 1st step of the stage
Maxwelltime:Visco_elastic.c:             E->ve_data_cont.DIRECT=1;
Maxwelltime:Visco_elastic.c:    else if ( E->monitor.solution_cycles == E->ve_data_cont.stages_step[i] )  {
Maxwelltime:Visco_elastic.c:       if ( i == E->ve_data_cont.stages-1 ) // last stage
Maxwelltime:Visco_elastic.c:           E->advection.next_timestep = E->advection.timestep ;
Maxwelltime:Visco_elastic.c:           E->advection.next_timestep = E->ve_data_cont.stages_timestep[i+1];
Maxwelltime:Visco_elastic.c:  stages = E->ve_data_cont.stage;
Maxwelltime:Viscosity_structures.c:    int m=E->parallel.me;
Maxwelltime:Viscosity_structures.c:        E->viscosity.N0[i]=1.0;
Maxwelltime:Viscosity_structures.c:        E->viscosity.T[i] = 0.0;
Maxwelltime:Viscosity_structures.c:        E->viscosity.Z[i] = 0.0;
Maxwelltime:Viscosity_structures.c:        E->viscosity.E[i] = 0.0;
Maxwelltime:Viscosity_structures.c:	E->viscosity.pdepv_a[i] = 1.e20; /* \sigma_y = min(a + b * (1-r),y) */
Maxwelltime:Viscosity_structures.c:	E->viscosity.pdepv_b[i] = 0.0;
Maxwelltime:Viscosity_structures.c:	E->viscosity.pdepv_y[i] = 1.e20;
Maxwelltime:Viscosity_structures.c:      E->viscosity.cdepv_ff[i] = 1.0; /* flavor factors for CDEPV */
Maxwelltime:Viscosity_structures.c:    input_boolean("VISC_UPDATE",&(E->viscosity.update_allowed),"on",m);
Maxwelltime:Viscosity_structures.c:    input_int("rheol",&(E->viscosity.RHEOL),"3",m);
Maxwelltime:Viscosity_structures.c:    E->viscosity.FROM_FILE = 0;
Maxwelltime:Viscosity_structures.c:    input_int("3d_visc_from_file",&(E->viscosity.FROM_FILE),"0",m);
Maxwelltime:Viscosity_structures.c:    if (E->viscosity.FROM_FILE) {
Maxwelltime:Viscosity_structures.c:      input_string("3d_visc_datafile",E->ve_data_cont.visc_file,"initialize",m);
Maxwelltime:Viscosity_structures.c:    input_int("compressible",&(E->ve_data_cont.compressible),"0",m);
Maxwelltime:Viscosity_structures.c:    E->ve_data_cont.1Dmodel_read=0;
Maxwelltime:Viscosity_structures.c:    input_int("1Dmodel_from_file",&(E->ve_data_cont.1Dmodel_read),"0",m);
Maxwelltime:Viscosity_structures.c:    if(E->ve_data_cont.1Dmodel_read) {
Maxwelltime:Viscosity_structures.c:      input_string("1Dmodel_datafile",E->ve_data_cont.1Dmodel_file,"initialize",m);
Maxwelltime:Viscosity_structures.c:    input_float_vector("visc0",E->viscosity.num_mat,(E->viscosity.N0),m);
Maxwelltime:Viscosity_structures.c:    input_float_vector("shearModulus",E->viscosity.num_mat,(E->viscosity.G),m);
Maxwelltime:Viscosity_structures.c:    input_boolean("TDEPV",&(E->viscosity.TDEPV),"on",m);
Maxwelltime:Viscosity_structures.c:    if (E->viscosity.TDEPV) {
Maxwelltime:Viscosity_structures.c:        input_float_vector("viscT",E->viscosity.num_mat,(E->viscosity.T),m);
Maxwelltime:Viscosity_structures.c:        input_float_vector("viscE",E->viscosity.num_mat,(E->viscosity.E),m);
Maxwelltime:Viscosity_structures.c:        input_float_vector("viscZ",E->viscosity.num_mat,(E->viscosity.Z),m);
Maxwelltime:Viscosity_structures.c:        input_float("T_sol0",&(E->viscosity.T_sol0),"0.6",m);
Maxwelltime:Viscosity_structures.c:        input_float("ET_red",&(E->viscosity.ET_red),"0.1",m);
Maxwelltime:Viscosity_structures.c:    E->viscosity.beta=1.0;
Maxwelltime:Viscosity_structures.c:    input_float("polar_wander_relax",&(E->viscosity.beta),"1.000",m);
Maxwelltime:Viscosity_structures.c:    E->viscosity.sdepv_misfit = 1.0;
Maxwelltime:Viscosity_structures.c:    input_boolean("SDEPV",&(E->viscosity.SDEPV),"off",m);
Maxwelltime:Viscosity_structures.c:    if (E->viscosity.SDEPV) {
Maxwelltime:Viscosity_structures.c:      E->viscosity.sdepv_visited = 0;
Maxwelltime:Viscosity_structures.c:      input_float_vector("sdepv_expt",E->viscosity.num_mat,(E->viscosity.sdepv_expt),m);
Maxwelltime:Viscosity_structures.c:      input_float_vector("sdepv_trns",E->viscosity.num_mat,(E->viscosity.sdepv_trns),m);
Maxwelltime:Viscosity_structures.c:      input_float_vector("sdepv_bg",E->viscosity.num_mat,(E->viscosity.sdepv_bg),m);
Maxwelltime:Viscosity_structures.c:      input_float("sdepv_relax_alpha",&(E->viscosity.alpha),"1.000",m);
Maxwelltime:Viscosity_structures.c:      for(i=0;i<E->viscosity.num_mat;i++) {
Maxwelltime:Viscosity_structures.c:        E->viscosity.sdepv_trns[i]=E->viscosity.sdepv_trns[i]/E->ve_data_cont.shear_mod;
Maxwelltime:Viscosity_structures.c:        E->viscosity.sdepv_bg[i]  =E->viscosity.sdepv_bg[i]  /E->ve_data_cont.shear_mod;
Maxwelltime:Viscosity_structures.c:    input_boolean("PDEPV",&(E->viscosity.PDEPV),"off",m); /* plasticity addition by TWB */
Maxwelltime:Viscosity_structures.c:    if (E->viscosity.PDEPV) {
Maxwelltime:Viscosity_structures.c:      E->viscosity.pdepv_visited = 0;
Maxwelltime:Viscosity_structures.c:      input_boolean("pdepv_eff",&(E->viscosity.pdepv_eff),"on",m);
Maxwelltime:Viscosity_structures.c:      input_float_vector("pdepv_a",E->viscosity.num_mat,(E->viscosity.pdepv_a),m);
Maxwelltime:Viscosity_structures.c:      input_float_vector("pdepv_b",E->viscosity.num_mat,(E->viscosity.pdepv_b),m);
Maxwelltime:Viscosity_structures.c:      input_float_vector("pdepv_y",E->viscosity.num_mat,(E->viscosity.pdepv_y),m);
Maxwelltime:Viscosity_structures.c:      input_float("pdepv_offset",&(E->viscosity.pdepv_offset),"0.0",m);
Maxwelltime:Viscosity_structures.c:      input_float("sdepv_misfit",&(E->viscosity.sdepv_misfit),"0.001",m);
Maxwelltime:Viscosity_structures.c:    input_boolean("CDEPV",&(E->viscosity.CDEPV),"off",m);
Maxwelltime:Viscosity_structures.c:    if(E->viscosity.CDEPV){
Maxwelltime:Viscosity_structures.c:      if(E->control.tracer < 1){
Maxwelltime:Viscosity_structures.c:      if(E->trace.nflavors > 10)
Maxwelltime:Viscosity_structures.c:      input_float_vector("cdepv_ff",E->trace.nflavors,
Maxwelltime:Viscosity_structures.c:			 (E->viscosity.cdepv_ff),m);
Maxwelltime:Viscosity_structures.c:      for(i=0;i<E->trace.nflavors;i++)
Maxwelltime:Viscosity_structures.c:	E->viscosity.cdepv_ff[i] = log(E->viscosity.cdepv_ff[i]);
Maxwelltime:Viscosity_structures.c:    input_boolean("low_visc_channel",&(E->viscosity.channel),"off",m);
Maxwelltime:Viscosity_structures.c:    input_boolean("low_visc_wedge",&(E->viscosity.wedge),"off",m);
Maxwelltime:Viscosity_structures.c:    input_float("lv_min_radius",&(E->viscosity.lv_min_radius),"0.9764",m);
Maxwelltime:Viscosity_structures.c:    input_float("lv_max_radius",&(E->viscosity.lv_max_radius),"0.9921",m);
Maxwelltime:Viscosity_structures.c:    input_float("lv_channel_thickness",&(E->viscosity.lv_channel_thickness),"0.0047",m);
Maxwelltime:Viscosity_structures.c:    input_float("lv_reduction",&(E->viscosity.lv_reduction),"0.5",m);
Maxwelltime:Viscosity_structures.c:    input_boolean("VMAX",&(E->viscosity.MAX),"off",m);
Maxwelltime:Viscosity_structures.c:    if (E->viscosity.MAX)
Maxwelltime:Viscosity_structures.c:        input_float("visc_max",&(E->viscosity.max_value),"1e22,1,nomax",m);
Maxwelltime:Viscosity_structures.c:    input_boolean("VMIN",&(E->viscosity.MIN),"off",m);
Maxwelltime:Viscosity_structures.c:    if (E->viscosity.MIN)
Maxwelltime:Viscosity_structures.c:        input_float("visc_min",&(E->viscosity.min_value),"1e20",m);
Maxwelltime:Viscosity_structures.c:    int m = E->parallel.me;
Maxwelltime:Viscosity_structures.c:    input_string("Viscosity",E->viscosity.STRUCTURE,"system",m);
Maxwelltime:Viscosity_structures.c:    input_int ("visc_smooth_method",&(E->viscosity.smooth_cycles),"0",m);
Maxwelltime:Viscosity_structures.c:    E->viscosity.FROM_SYSTEM = 1;
Maxwelltime:Viscosity_structures.c:    if (E->viscosity.FROM_SYSTEM)
Maxwelltime:Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Maxwelltime:Viscosity_structures.c:    if (E->viscosity.SDEPV)  {
Maxwelltime:Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Viscosity_structures.c:          for(e=1;e<=E->lmesh.nel;e++) {
Maxwelltime:Viscosity_structures.c:            E->EVolder[m][e] = 1.0;
Maxwelltime:Viscosity_structures.c:            E->EVold[m][e] = 1.0;
Maxwelltime:Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Viscosity_structures.c:          for(e=1;e<=E->lmesh.nel;e++) {
Maxwelltime:Viscosity_structures.c:            E->EVolder[m][e] = E->EVold[m][e];
Maxwelltime:Viscosity_structures.c:            E->EVold[m][e] = 0.125*
Maxwelltime:Viscosity_structures.c: 		(visc[m][E->ien[m][e].node[1]] + visc[m][E->ien[m][e].node[2]]
Maxwelltime:Viscosity_structures.c: 		+visc[m][E->ien[m][e].node[3]] + visc[m][E->ien[m][e].node[4]]
Maxwelltime:Viscosity_structures.c: 		+visc[m][E->ien[m][e].node[5]] + visc[m][E->ien[m][e].node[6]]
Maxwelltime:Viscosity_structures.c: 		+visc[m][E->ien[m][e].node[7]] + visc[m][E->ien[m][e].node[8]]);
Maxwelltime:Viscosity_structures.c:    if (!E->ve_data_cont.1Dmodel_read) {   // use mat group
Maxwelltime:Viscosity_structures.c:       if (E->viscosity.FROM_FILE)   // read 3D viscosity
Maxwelltime:Viscosity_structures.c://    if(E->viscosity.TDEPV)
Maxwelltime:Viscosity_structures.c://    if(E->viscosity.CDEPV)	/* compositional prefactor */
Maxwelltime:Viscosity_structures.c:    if(E->viscosity.SDEPV)
Maxwelltime:Viscosity_structures.c:    if(E->viscosity.PDEPV)	/* "plasticity" */
Maxwelltime:Viscosity_structures.c://    if(E->viscosity.channel || E->viscosity.wedge)
Maxwelltime:Viscosity_structures.c:    if(E->viscosity.MAX) {
Maxwelltime:Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Viscosity_structures.c:            for(i=1;i<=E->lmesh.nel;i++)
Maxwelltime:Viscosity_structures.c:                    if(evisc[m][(i-1)*vpts + j] > E->viscosity.max_value)
Maxwelltime:Viscosity_structures.c:                        evisc[m][(i-1)*vpts + j] = E->viscosity.max_value;
Maxwelltime:Viscosity_structures.c:    if(E->viscosity.MIN) {
Maxwelltime:Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Viscosity_structures.c:            for(i=1;i<=E->lmesh.nel;i++)
Maxwelltime:Viscosity_structures.c:                    if(evisc[m][(i-1)*vpts + j] < E->viscosity.min_value)
Maxwelltime:Viscosity_structures.c:                        evisc[m][(i-1)*vpts + j] = E->viscosity.min_value;
Maxwelltime:Viscosity_structures.c:    if (E->control.verbose)  {
Maxwelltime:Viscosity_structures.c:      fprintf(E->fp_out,"output_evisc0 %d\n",E->monitor.solution_cycles);
Maxwelltime:Viscosity_structures.c:      for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Viscosity_structures.c:        fprintf(E->fp_out,"output_evisc for cap %d\n",E->sphere.capid[m]);
Maxwelltime:Viscosity_structures.c:      for(i=1;i<=E->lmesh.elz;i++)
Maxwelltime:Viscosity_structures.c:          fprintf(E->fp_out,"%d %d %f\n",i,E->mat[m][i],evisc[m][(i-1)*vpts+1]);
Maxwelltime:Viscosity_structures.c:      fflush(E->fp_out);
Maxwelltime:Viscosity_structures.c:    visc_from_gint_to_nodes(E,evisc,visc,E->mesh.levmax);
Maxwelltime:Viscosity_structures.c:    if (!E->ve_data_cont.compressible)
Maxwelltime:Viscosity_structures.c:    else if (E->ve_data_cont.compressible)
Maxwelltime:Viscosity_structures.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Viscosity_structures.c:    for(i=1;i<=E->lmesh.nel;i++)  {   
Maxwelltime:Viscosity_structures.c:      E->Maxwelltime[m][i] = E->viscosity.G[E->mat[m][i]-1];
Maxwelltime:Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Maxwelltime:Viscosity_structures.c:    const int lev = E->mesh.levmax;
Maxwelltime:Viscosity_structures.c:    sprintf(output_file,"%s",E->ve_data_cont.1Dmodel_file);
Maxwelltime:Viscosity_structures.c:      radius[i] = tmp1*1000.0/E->sphere.dradius;
Maxwelltime:Viscosity_structures.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Viscosity_structures.c:    for (jj=1;jj<=E->lmesh.elz;jj++)  {
Maxwelltime:Viscosity_structures.c:      rr = (E->sx[m][3][jj]+E->sx[m][3][jj+1])/2.0;
Maxwelltime:Viscosity_structures.c:      for (i=1;i<=E->lmesh.ely;i++)  
Maxwelltime:Viscosity_structures.c:      for (j=1;j<=E->lmesh.elx;j++)  {
Maxwelltime:Viscosity_structures.c:         el = jj + (j-1)*E->lmesh.elz + (i-1)*E->lmesh.elz*E->lmesh.elx;
Maxwelltime:Viscosity_structures.c:         E->erho[lev][m][el] = tmp1/E->data.density;
Maxwelltime:Viscosity_structures.c:         E->elambda[lev][m][el] = tmp2/E->ve_data_cont.shear_mod;;
Maxwelltime:Viscosity_structures.c:         E->esmu[lev][m][el] = tmp3/E->ve_data_cont.shear_mod;;
Maxwelltime:Viscosity_structures.c:         E->egrav[lev][m][el] = tmp4/E->data.grav_acc;
Maxwelltime:Viscosity_structures.c:         E->Maxwelltime[m][el] = E->esmu[lev][m][el];
Maxwelltime:Viscosity_structures.c:         for(k=1;k<=vpoints[E->mesh.nsd];k++)
Maxwelltime:Viscosity_structures.c:            EEta[m][ (el-1)*vpts+k ] = tmp5/E->data.ref_viscosity;
Maxwelltime:Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Maxwelltime:Viscosity_structures.c:    sprintf(output_file,"%s",E->ve_data_cont.visc_file);
Maxwelltime:Viscosity_structures.c:      ave_visc = (float *)malloc((E->lmesh.noz+1)*sizeof(float));
Maxwelltime:Viscosity_structures.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Viscosity_structures.c:         visc_FE[m] = (double *)malloc((E->lmesh.nsf+1)*sizeof(double));
Maxwelltime:Viscosity_structures.c:      radius_visc[i] = E->sphere.ro-temp1*1000.0/E->sphere.dradius;
Maxwelltime:Viscosity_structures.c://if(E->parallel.me==0) fprintf(E->fp_out,"visc model radius info %d %g\n",i,radius_visc[i]);
Maxwelltime:Viscosity_structures.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Viscosity_structures.c:    for (jj=1;jj<=E->lmesh.elz;jj++)  {
Maxwelltime:Viscosity_structures.c:      rr = (E->sx[m][3][jj]+E->sx[m][3][jj+1])/2.0;
Maxwelltime:Viscosity_structures.c:      sprintf(output_file,"%s",E->ve_data_cont.visc_file);
Maxwelltime:Viscosity_structures.c://if(E->parallel.me==0) fprintf(stderr,"%d %d %d rr= %g %g %g\n",jj,i1,i2,rr,temp1,temp2);
Maxwelltime:Viscosity_structures.c:      for (i=1;i<=E->lmesh.ely;i++)  
Maxwelltime:Viscosity_structures.c:      for (j=1;j<=E->lmesh.elx;j++)  {
Maxwelltime:Viscosity_structures.c:         ee = j + (i-1)*E->lmesh.elx;      
Maxwelltime:Viscosity_structures.c:         temp1 =( visc_FE[m][E->sien[m][ee].node[1]] 
Maxwelltime:Viscosity_structures.c:                + visc_FE[m][E->sien[m][ee].node[2]] 
Maxwelltime:Viscosity_structures.c:                + visc_FE[m][E->sien[m][ee].node[3]] 
Maxwelltime:Viscosity_structures.c:                + visc_FE[m][E->sien[m][ee].node[4]])/4.0; 
Maxwelltime:Viscosity_structures.c:         el = jj + (j-1)*E->lmesh.elz + (i-1)*E->lmesh.elz*E->lmesh.elx;
Maxwelltime:Viscosity_structures.c:         for(k=1;k<=vpoints[E->mesh.nsd];k++)
Maxwelltime:Viscosity_structures.c:            EEta[m][ (el-1)*vpts+k ] = temp1/E->data.ref_viscosity;
Maxwelltime:Viscosity_structures.c:  visc_from_gint_to_nodes(E,EEta,visc,E->mesh.levmax);
Maxwelltime:Viscosity_structures.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Viscosity_structures.c:    for(k=1;k<=E->lmesh.noz;k++)   {
Maxwelltime:Viscosity_structures.c:      sprintf(output_file,"visc.%d.%d",k,E->parallel.me);
Maxwelltime:Viscosity_structures.c:      fprintf(fp1,"%.6e %.6e\n",E->sx[m][3][k],6370.0*(1.0-E->sx[m][3][k]));
Maxwelltime:Viscosity_structures.c:      for(i=1;i<=E->lmesh.noy;i++)  
Maxwelltime:Viscosity_structures.c:        for(j=1;j<=E->lmesh.nox;j++)  {
Maxwelltime:Viscosity_structures.c:          nn=k+(j-1)*E->lmesh.noz+(i-1)*E->lmesh.noz*E->lmesh.nox;
Maxwelltime:Viscosity_structures.c:          visc[m][nn] = visc[m][nn]*E->data.ref_viscosity;
Maxwelltime:Viscosity_structures.c:          fprintf(fp1,"%.5e %.5e %.5e\n",90-180*E->sx[m][1][nn]/M_PI,180*E->sx[m][2][nn]/M_PI,visc[m][nn]);
Maxwelltime:Viscosity_structures.c:          visc[m][nn] = visc[m][nn]/E->data.ref_viscosity;
Maxwelltime:Viscosity_structures.c:   if (E->parallel.me==0)  {
Maxwelltime:Viscosity_structures.c:     fprintf(E->fp_out,"average visc vs radius after the interpolation to FE grid\n"); 
Maxwelltime:Viscosity_structures.c:     for(k=1;k<=E->lmesh.noz;k++)   {
Maxwelltime:Viscosity_structures.c:       fprintf(E->fp_out,"%d %.5e %.5e\n",k,E->sx[1][3][k],ave_visc[k]*E->data.ref_viscosity); 
Maxwelltime:Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Maxwelltime:Viscosity_structures.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Viscosity_structures.c:        for(i=1;i<=E->lmesh.nel;i++)
Maxwelltime:Viscosity_structures.c:            for(jj=1;jj<=vpoints[E->mesh.nsd];jj++)
Maxwelltime:Viscosity_structures.c:                EEta[m][ (i-1)*vpts+jj ] = E->viscosity.N0[E->mat[m][i]-1];
Maxwelltime:Viscosity_structures.c:      fprintf(E->fp_out,"output_evisc0 %d\n",E->monitor.solution_cycles);
Maxwelltime:Viscosity_structures.c:      for(m=1;m<=E->sphere.caps_per_proc;m++) {
Maxwelltime:Viscosity_structures.c:        fprintf(E->fp_out,"output_evisc0 for cap %d\n",E->sphere.capid[m]);
Maxwelltime:Viscosity_structures.c:      for(i=1;i<=E->lmesh.elz;i++)
Maxwelltime:Viscosity_structures.c:          fprintf(E->fp_out,"%d %d %f %f\n",i,E->mat[m][i],EEta[m][(i-1)*8+1],EEta[m][(i-1)*8+7]);
Maxwelltime:Viscosity_structures.c:      fflush(E->fp_out);
Maxwelltime:Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Maxwelltime:Viscosity_structures.c:    const int ends = enodes[E->mesh.nsd];
Maxwelltime:Viscosity_structures.c:    const int nel = E->lmesh.nel;
Maxwelltime:Viscosity_structures.c:    switch (E->viscosity.RHEOL)   {
Maxwelltime:Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Viscosity_structures.c:                l = E->mat[m][i] - 1;
Maxwelltime:Viscosity_structures.c:                if(E->control.mat_control==0)
Maxwelltime:Viscosity_structures.c:                    tempa = E->viscosity.N0[l];
Maxwelltime:Viscosity_structures.c:                else if(E->control.mat_control==1)
Maxwelltime:Viscosity_structures.c:                    tempa = E->viscosity.N0[l]*E->VIP[m][i];
Maxwelltime:Viscosity_structures.c:                    TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Maxwelltime:Viscosity_structures.c:                        temp += TT[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Maxwelltime:Viscosity_structures.c:                        exp( E->viscosity.E[l] * (E->viscosity.T[l] - temp));
Maxwelltime:Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Viscosity_structures.c:                l = E->mat[m][i] - 1;
Maxwelltime:Viscosity_structures.c:                if(E->control.mat_control==0)
Maxwelltime:Viscosity_structures.c:                    tempa = E->viscosity.N0[l];
Maxwelltime:Viscosity_structures.c:                else if(E->control.mat_control==1)
Maxwelltime:Viscosity_structures.c:                    tempa = E->viscosity.N0[l]*E->VIP[m][i];
Maxwelltime:Viscosity_structures.c:                    TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Maxwelltime:Viscosity_structures.c:                        temp += TT[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Maxwelltime:Viscosity_structures.c:                        exp( -temp / E->viscosity.T[l]);
Maxwelltime:Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Viscosity_structures.c:                l = E->mat[m][i] - 1;
Maxwelltime:Viscosity_structures.c:		if(E->control.mat_control) /* switch moved up here TWB */
Maxwelltime:Viscosity_structures.c:		  tempa = E->viscosity.N0[l] * E->VIP[m][i];
Maxwelltime:Viscosity_structures.c:		  tempa = E->viscosity.N0[l];
Maxwelltime:Viscosity_structures.c:		  TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Maxwelltime:Viscosity_structures.c:		      temp += min(TT[kk],one) * E->N.vpt[GNVINDEX(kk,jj)];
Maxwelltime:Viscosity_structures.c:		      exp( E->viscosity.E[l]/(temp+E->viscosity.T[l])
Maxwelltime:Viscosity_structures.c:			   - E->viscosity.E[l]/(one +E->viscosity.T[l]) );
Maxwelltime:Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Maxwelltime:Viscosity_structures.c:                l = E->mat[m][i] - 1;
Maxwelltime:Viscosity_structures.c:		if(E->control.mat_control) /* moved this up here TWB */
Maxwelltime:Viscosity_structures.c:		  tempa = E->viscosity.N0[l] * E->VIP[m][i];
Maxwelltime:Viscosity_structures.c:		  tempa = E->viscosity.N0[l];
Maxwelltime:Viscosity_structures.c:                    TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Maxwelltime:Viscosity_structures.c:                    zz[kk] = (1.-E->sx[m][3][E->ien[m][i].node[kk]]);
Maxwelltime:Viscosity_structures.c:                        temp += min(TT[kk],one) * E->N.vpt[GNVINDEX(kk,jj)];
Maxwelltime:Viscosity_structures.c:                        zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Maxwelltime:Viscosity_structures.c:		      exp( (E->viscosity.E[l] +  E->viscosity.Z[l]*zzz )
Maxwelltime:Viscosity_structures.c:			   / (E->viscosity.T[l]+temp) );
Maxwelltime:Viscosity_structures.c:                E->viscosity.RHEOL);
Maxwelltime:Viscosity_structures.c:        fprintf(stderr, "Invalid value of 'rheol=%d'\n", E->viscosity.RHEOL);
Maxwelltime:Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Maxwelltime:Viscosity_structures.c:    const int nel = E->lmesh.nel;
Maxwelltime:Viscosity_structures.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Viscosity_structures.c:	  E->S2inv[m][e] = 1.0;
Maxwelltime:Viscosity_structures.c:      stress_2_inv(E,E->S2inv,1,E->viscosity.iterate);
Maxwelltime:Viscosity_structures.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)  
Maxwelltime:Viscosity_structures.c:           l = E->mat[m][e] - 1;
Maxwelltime:Viscosity_structures.c:           temp1 = (E->S2inv[m][e] + E->viscosity.sdepv_bg[l])/E->viscosity.sdepv_trns[l];
Maxwelltime:Viscosity_structures.c:           exponent1= E->viscosity.sdepv_expt[l]-one;
Maxwelltime:Viscosity_structures.c:           temp2 = E->viscosity.sdepv_bg[l]/E->viscosity.sdepv_trns[l];
Maxwelltime:Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Maxwelltime:Viscosity_structures.c:    const int nel = E->lmesh.nel;
Maxwelltime:Viscosity_structures.c:    const int ends = enodes[E->mesh.nsd];
Maxwelltime:Viscosity_structures.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Maxwelltime:Viscosity_structures.c:      if(E->viscosity.pdepv_visited){
Maxwelltime:Viscosity_structures.c:	if(m == E->sphere.caps_per_proc)
Maxwelltime:Viscosity_structures.c:	  E->viscosity.pdepv_visited = 1;
Maxwelltime:Viscosity_structures.c:	if((E->parallel.me == 0)&&(E->control.verbose)){
Maxwelltime:Viscosity_structures.c:	  for(e=0;e < E->viscosity.num_mat;e++)
Maxwelltime:Viscosity_structures.c:		    e,E->viscosity.pdepv_a[e],E->viscosity.pdepv_b[e],E->viscosity.pdepv_y[e]);
Maxwelltime:Viscosity_structures.c:	l = E->mat[m][e] -1 ;	/* material of this element */
Maxwelltime:Viscosity_structures.c:	  zz[kk] = (1.0 - E->sx[m][3][E->ien[m][e].node[kk]]); /* for depth, zz = 1 - r */
Maxwelltime:Viscosity_structures.c:	    zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Maxwelltime:Viscosity_structures.c:	  tau = E->viscosity.pdepv_a[l] + zzz * E->viscosity.pdepv_b[l];
Maxwelltime:Viscosity_structures.c:	  tau = min(tau,  E->viscosity.pdepv_y[l]);
Maxwelltime:Viscosity_structures.c:	  eta_p = tau/(2.0 * eedot[e] + 1e-7) + E->viscosity.pdepv_offset;
Maxwelltime:Viscosity_structures.c:	  if(E->viscosity.pdepv_eff){
Maxwelltime:Viscosity_structures.c:	  //zzz,l,E->viscosity.pdepv_a[l], E->viscosity.pdepv_b[l],E->viscosity.pdepv_y[l],
Maxwelltime:Viscosity_structures.c:  const int vpts = vpoints[E->mesh.nsd];
Maxwelltime:Viscosity_structures.c:  const int nel = E->lmesh.nel;
Maxwelltime:Viscosity_structures.c:  const int ends = enodes[E->mesh.nsd];
Maxwelltime:Viscosity_structures.c:  for(m=1;m <= E->sphere.caps_per_proc;m++)  {
Maxwelltime:Viscosity_structures.c:        for(p=0; p<E->composition.ncomp; p++) {
Maxwelltime:Viscosity_structures.c:                CC[p][kk] = E->composition.comp_node[m][p][E->ien[m][i].node[kk]];
Maxwelltime:Viscosity_structures.c:            for(p=0; p<E->composition.ncomp; p++) {
Maxwelltime:Viscosity_structures.c:                    cc_loc[p] += CC[p][kk] * E->N.vpt[GNVINDEX(kk, jj)];
Maxwelltime:Viscosity_structures.c:            vmean = cbackground * E->viscosity.cdepv_ff[0];
Maxwelltime:Viscosity_structures.c:            for(p=0; p<E->composition.ncomp; p++) {
Maxwelltime:Viscosity_structures.c:                vmean += cc_loc[p] * E->viscosity.cdepv_ff[p+1];
Maxwelltime:Viscosity_structures.c:    const int nel = E->lmesh.nel;
Maxwelltime:Viscosity_structures.c:    const int dims = E->mesh.nsd;
Maxwelltime:Viscosity_structures.c:    const int lev = E->mesh.levmax;
Maxwelltime:Viscosity_structures.c:        GNx = &(E->gNX[m][e]);
Maxwelltime:Viscosity_structures.c:        if ((E->control.precise_strain_rate) || (theta < 0.09) || (theta > 3.05)) {
Maxwelltime:Viscosity_structures.c:            if ((e-1)%E->lmesh.elz==0) {
Maxwelltime:Viscosity_structures.c:                construct_c3x3matrix_el(E,e,&E->element_Cc,&E->element_Ccx,lev,m,1);
Maxwelltime:Viscosity_structures.c:            get_ba_p(&(E->N), GNx, &E->element_Cc, &E->element_Ccx,
Maxwelltime:Viscosity_structures.c:                     rtf, E->mesh.nsd, ba);
Maxwelltime:Viscosity_structures.c:                                   + VV[3][i] * E->N.ppt[GNPINDEX(i, j)])
Maxwelltime:Viscosity_structures.c:                                    + VV[1][i] * E->N.ppt[GNPINDEX(i, j)]
Maxwelltime:Viscosity_structures.c:                                   + VV[3][i] * E->N.ppt[GNPINDEX(i, j)])
Maxwelltime:Viscosity_structures.c:                                    - VV[2][i] * E->N.ppt[GNPINDEX(i, j)]
Maxwelltime:Viscosity_structures.c:                                       - VV[1][i] * E->N.ppt[GNPINDEX(i, j)]);
Maxwelltime:Viscosity_structures.c:                                       - VV[2][i] * E->N.ppt[GNPINDEX(i, j)]);
Maxwelltime:Viscosity_structures.c:        if(E->control.inv_gruneisen != 0) {
Maxwelltime:Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Maxwelltime:Viscosity_structures.c:    if(E->control.tracer == 0) {
Maxwelltime:Viscosity_structures.c:        if(E->parallel.me == 0) {
Maxwelltime:Viscosity_structures.c:            fprintf(E->fp, "Error: low viscosity channel/wedge is turned on, "
Maxwelltime:Viscosity_structures.c:            fflush(E->fp);
Maxwelltime:Viscosity_structures.c:    F = (float *)malloc((E->lmesh.nel+1)*sizeof(float));
Maxwelltime:Viscosity_structures.c:    for(i=1 ; i<=E->lmesh.nel ; i++)
Maxwelltime:Viscosity_structures.c:    if(E->viscosity.channel)
Maxwelltime:Viscosity_structures.c:    if(E->viscosity.wedge)
Maxwelltime:Viscosity_structures.c:    for(i=1 ; i<=E->lmesh.nel ; i++) {
Maxwelltime:Viscosity_structures.c:            for(m = 1 ; m <= E->sphere.caps_per_proc ; m++) {
Maxwelltime:Viscosity_structures.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Viscosity_structures.c:        for(e=1; e<=E->lmesh.elz; e++) {
Maxwelltime:Viscosity_structures.c:            rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Maxwelltime:Viscosity_structures.c:                              E->sx[m][3][E->ien[m][e].node[8]]);
Maxwelltime:Viscosity_structures.c:            if(rad_mean >= E->viscosity.lv_min_radius) break;
Maxwelltime:Viscosity_structures.c:        for(e=E->lmesh.elz; e>=1; e--) {
Maxwelltime:Viscosity_structures.c:            rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Maxwelltime:Viscosity_structures.c:                              E->sx[m][3][E->ien[m][e].node[8]]);
Maxwelltime:Viscosity_structures.c:            if(rad_mean <= E->viscosity.lv_max_radius) break;
Maxwelltime:Viscosity_structures.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Viscosity_structures.c:        for(k=1; k<=E->lmesh.elx*E->lmesh.ely; k++) {
Maxwelltime:Viscosity_structures.c:                e = (k-1)*E->lmesh.elz + i;
Maxwelltime:Viscosity_structures.c:                rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Maxwelltime:Viscosity_structures.c:                                  E->sx[m][3][E->ien[m][e].node[8]]);
Maxwelltime:Viscosity_structures.c:                    ee = (k-1)*E->lmesh.elz + ii;
Maxwelltime:Viscosity_structures.c:                    rr = 0.5 * (E->sx[m][3][E->ien[m][ee].node[1]] +
Maxwelltime:Viscosity_structures.c:                                E->sx[m][3][E->ien[m][ee].node[8]]);
Maxwelltime:Viscosity_structures.c:                    if((E->trace.ntracer_flavor[m][flavor][ee] > 0) &&
Maxwelltime:Viscosity_structures.c:                       (rad_mean <= rr + E->viscosity.lv_channel_thickness)) {
Maxwelltime:Viscosity_structures.c:                           F[e] = E->viscosity.lv_reduction;
Maxwelltime:Viscosity_structures.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Viscosity_structures.c:        for(e=1; e<=E->lmesh.nel; e++)
Maxwelltime:Viscosity_structures.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Viscosity_structures.c:        for(e=1; e<=E->lmesh.elz; e++) {
Maxwelltime:Viscosity_structures.c:            rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Maxwelltime:Viscosity_structures.c:                              E->sx[m][3][E->ien[m][e].node[8]]);
Maxwelltime:Viscosity_structures.c:            if(rad_mean >= E->viscosity.lv_min_radius) break;
Maxwelltime:Viscosity_structures.c:        for(e=E->lmesh.elz; e>=1; e--) {
Maxwelltime:Viscosity_structures.c:            rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Maxwelltime:Viscosity_structures.c:                              E->sx[m][3][E->ien[m][e].node[8]]);
Maxwelltime:Viscosity_structures.c:            if(rad_mean <= E->viscosity.lv_max_radius) break;
Maxwelltime:Viscosity_structures.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Maxwelltime:Viscosity_structures.c:        for(k=1; k<=E->lmesh.elx*E->lmesh.ely; k++) {
Maxwelltime:Viscosity_structures.c:                e = (k-1)*E->lmesh.elz + i;
Maxwelltime:Viscosity_structures.c:                rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Maxwelltime:Viscosity_structures.c:                                  E->sx[m][3][E->ien[m][e].node[8]]);
Maxwelltime:Viscosity_structures.c:                    ee = (k-1)*E->lmesh.elz + ii;
Maxwelltime:Viscosity_structures.c:                    if(E->trace.ntracer_flavor[m][flavor][ee] > 0) {
Maxwelltime:Viscosity_structures.c:                        F[e] = E->viscosity.lv_reduction;
Maxwelltime:Viscosity_structures.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Maxwelltime:Viscosity_structures.c:        for(e=1; e<=E->lmesh.nel; e++)
Maxwelltime:Viscosity_structures.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Maxwelltime:Viscosity_structures.c:    const int nno=E->lmesh.nno;
Maxwelltime:Viscosity_structures.c:    const int lev=E->mesh.levmax;
Maxwelltime:Viscosity_structures.c:   alpha = E->viscosity.alpha;
Maxwelltime:Viscosity_structures.c:   onep_alpha = 1.0 - E->viscosity.alpha;
Maxwelltime:Viscosity_structures.c://fprintf(E->fp_out,"in_stress_2_inv %d %d\n",E->monitor.solution_cycles,E->viscosity.iterate);
Maxwelltime:Viscosity_structures.c:for(m=1;m<=E->sphere.caps_per_proc;m++)      {
Maxwelltime:Viscosity_structures.c:  for(e=1;e<=E->lmesh.nel;e++)  {
Maxwelltime:Viscosity_structures.c:        edot[1][1] = E->S2xx[m][e]; 
Maxwelltime:Viscosity_structures.c:        edot[2][2] = E->S2yy[m][e]; 
Maxwelltime:Viscosity_structures.c:        edot[3][3] = E->S2zz[m][e];
Maxwelltime:Viscosity_structures.c:        edot[1][2] = E->S2xy[m][e];
Maxwelltime:Viscosity_structures.c:        edot[1][3] = E->S2xz[m][e];
Maxwelltime:Viscosity_structures.c:        edot[2][3] = E->S2zy[m][e];
Maxwelltime:Viscosity_structures.c:/*        E->S2xx[m][e] = E->Maxwelltime[m][e]*E->S2xx[m][e]; 
Maxwelltime:Viscosity_structures.c:        E->S2yy[m][e] = E->Maxwelltime[m][e]*E->S2yy[m][e]; 
Maxwelltime:Viscosity_structures.c:        E->S2zz[m][e] = E->Maxwelltime[m][e]*E->S2zz[m][e]; 
Maxwelltime:Viscosity_structures.c:        E->S2xy[m][e] = E->Maxwelltime[m][e]*E->S2xy[m][e]; 
Maxwelltime:Viscosity_structures.c:        E->S2xz[m][e] = E->Maxwelltime[m][e]*E->S2xz[m][e]; 
Maxwelltime:Viscosity_structures.c:        E->S2zy[m][e] = E->Maxwelltime[m][e]*E->S2zy[m][e]; 
Maxwelltime:Viscosity_structures.c:      gnxx = E->gNX[m][e].ppt;
Maxwelltime:Viscosity_structures.c:      get_rtf_at_ppts(E,m,E->mesh.levmax,e,rtf);
Maxwelltime:Viscosity_structures.c:      if ((e-1)%E->lmesh.elz==0)
Maxwelltime:Viscosity_structures.c:        construct_c3x3matrix_el(E,e,&Cc,&Ccx,E->mesh.levmax,m,1);
Maxwelltime:Viscosity_structures.c:                 +E->N.ppt[GNPINDEX(i,1)]*Ccx.ppt[BPXINDEX(1,k,1,i,1)]
Maxwelltime:Viscosity_structures.c:                 +E->N.ppt[GNPINDEX(i,1)]*Cc.ppt[BPINDEX(3,k,i,1)]);
Maxwelltime:Viscosity_structures.c:                (E->N.ppt[GNPINDEX(i,1)]*Cc.ppt[BPINDEX(1,k,i,1)]*ct
Maxwelltime:Viscosity_structures.c:                +E->N.ppt[GNPINDEX(i,1)]*Cc.ppt[BPINDEX(3,k,i,1)]
Maxwelltime:Viscosity_structures.c:                 +E->N.ppt[GNPINDEX(i,1)]*Ccx.ppt[BPXINDEX(2,k,2,i,1)])/sinaa);
Maxwelltime:Viscosity_structures.c:                +E->N.ppt[GNPINDEX(i,1)]*Ccx.ppt[BPXINDEX(2,k,1,i,1)]
Maxwelltime:Viscosity_structures.c:                -ct*Cc.ppt[BPINDEX(2,k,i,1)]*E->N.ppt[GNPINDEX(i,1)]
Maxwelltime:Viscosity_structures.c:                +(E->N.ppt[GNPINDEX(i,1)]*Ccx.ppt[BPXINDEX(1,k,2,i,1)]
Maxwelltime:Viscosity_structures.c:                +(E->N.ppt[GNPINDEX(i,1)]*Ccx.ppt[BPXINDEX(3,k,1,i,1)]
Maxwelltime:Viscosity_structures.c:                 -E->N.ppt[GNPINDEX(i,1)]*Cc.ppt[BPINDEX(1,k,i,1)]));
Maxwelltime:Viscosity_structures.c:                -rtf[3][1]*E->N.ppt[GNPINDEX(i,1)]*Cc.ppt[BPINDEX(2,k,i,1)]
Maxwelltime:Viscosity_structures.c:                +rtf[3][1]/sinaa*(E->N.ppt[GNPINDEX(i,1)]*Ccx.ppt[BPXINDEX(3,k,2,i,1)]+gnxx[GNPXINDEX(1,i,1)]*Cc.ppt[BPINDEX(3,k,i,1)]));
Maxwelltime:Viscosity_structures.c:        visc1=onep_alpha*E->EVolder[m][e]+alpha*E->EVold[m][e];
Maxwelltime:Viscosity_structures.c:        a = E->Maxwelltime[m][e]/(2.0*visc1)*E->advection.timestep;
Maxwelltime:Viscosity_structures.c:        visc0 = E->Maxwelltime[m][e]/(1.0+a);
Maxwelltime:Viscosity_structures.c:        edot[1][1] = 2.0*visc0*Sxyz1 + maxwell0*E->S2xx[m][e]; 
Maxwelltime:Viscosity_structures.c:        edot[2][2] = 2.0*visc0*Sxyz2 + maxwell0*E->S2yy[m][e]; 
Maxwelltime:Viscosity_structures.c:        edot[3][3] = 2.0*visc0*Sxyz3 + maxwell0*E->S2zz[m][e];
Maxwelltime:Viscosity_structures.c:        edot[1][2] =    visc0*Sxyz4  + maxwell0*E->S2xy[m][e];
Maxwelltime:Viscosity_structures.c:        edot[1][3] =    visc0*Sxyz5  + maxwell0*E->S2xz[m][e];
Maxwelltime:Viscosity_structures.c:        edot[2][3] =    visc0*Sxyz6  + maxwell0*E->S2zy[m][e];
Maxwelltime:Viscosity_structures.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)   
Maxwelltime:Viscosity_structures.c:     for(e=1;e<=E->lmesh.nel;e++)
Maxwelltime:Viscosity_structures.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)   
Maxwelltime:Viscosity_structures.c:     for(e=1;e<=E->lmesh.nel;e++)
Mineral_physics_models.c:    if(!E->output.horiz_avg)
Mineral_physics_models.c:    rhor = malloc((E->lmesh.noz+1) * sizeof(double));
Mineral_physics_models.c:    vpr = malloc((E->lmesh.noz+1) * sizeof(double));
Mineral_physics_models.c:    vsr = malloc((E->lmesh.noz+1) * sizeof(double));
Mineral_physics_models.c:    depthkm = malloc((E->lmesh.noz+1) * sizeof(double));
Mineral_physics_models.c:    for(nz=1; nz<=E->lmesh.noz; nz++) {
Mineral_physics_models.c:        get_prem(E->sx[m][3][nz], &vpr[nz], &vsr[nz], &rhor[nz]);
Mineral_physics_models.c:        depthkm[nz] = (1.0 - E->sx[m][3][nz]) * E->data.radius_km;
Mineral_physics_models.c:    for(i=0; i<E->lmesh.nno; i++) {
Mineral_physics_models.c:        nz = (i % E->lmesh.noz) + 1;
Mineral_physics_models.c:        dT = (E->T[m][i+1] - E->Have.T[nz]) * E->data.ref_temperature;
Mineral_physics_models.c:        drho = -dT * E->refstate.thermal_expansivity[nz] * E->data.therm_exp;
Mineral_physics_models.c:        if(E->control.tracer && E->composition.on && E->composition.ichemical_buoyancy)
Mineral_physics_models.c:            for(j=0; j<E->composition.ncomp; j++) {
Mineral_physics_models.c:                dC = E->composition.comp_node[m][j][i+1] - E->Have.C[j][nz];
Mineral_physics_models.c:                drho += dC * E->composition.buoyancy_ratio[j]
Mineral_physics_models.c:                    * E->data.ref_temperature * E->data.therm_exp / E->refstate.rho[nz];
Mineral_physics_models.c:    switch(E->control.mineral_physics_model) {
Mineral_physics_models.c:                E->control.mineral_physics_model);
Mineral_physics_models.c:                E->control.mineral_physics_model);
Mineral_physics_models.c:                E->control.mineral_physics_model);
Mineral_physics_models.c:                E->control.mineral_physics_model);
Mineral_physics_models.c:                E->control.mineral_physics_model);
Nodal_mesh.c:    const int nno = E->lmesh.nno;
Nodal_mesh.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Nodal_mesh.c:            E->sphere.cap[m].V[1][node] = E->U[m][E->id[m][node].doff[1]];
Nodal_mesh.c:            E->sphere.cap[m].V[2][node] = E->U[m][E->id[m][node].doff[2]];
Nodal_mesh.c:            E->sphere.cap[m].V[3][node] = E->U[m][E->id[m][node].doff[3]];
Nodal_mesh.c:            if (E->node[m][node] & VBX)
Nodal_mesh.c:                E->sphere.cap[m].V[1][node] = E->sphere.cap[m].VB[1][node];
Nodal_mesh.c:            if (E->node[m][node] & VBY)
Nodal_mesh.c:                E->sphere.cap[m].V[2][node] = E->sphere.cap[m].VB[2][node];
Nodal_mesh.c:            if (E->node[m][node] & VBZ)
Nodal_mesh.c:                E->sphere.cap[m].V[3][node] = E->sphere.cap[m].VB[3][node];
Nodal_mesh.c:    const int nno = E->lmesh.nno;
Nodal_mesh.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Nodal_mesh.c:            E->sphere.cap[m].Vprev[1][node] = E->sphere.cap[m].V[1][node];
Nodal_mesh.c:            E->sphere.cap[m].Vprev[2][node] = E->sphere.cap[m].V[2][node];
Nodal_mesh.c:            E->sphere.cap[m].Vprev[3][node] = E->sphere.cap[m].V[3][node];
Nodal_mesh.c:            E->sphere.cap[m].V[1][node] = E->U[m][E->id[m][node].doff[1]];
Nodal_mesh.c:            E->sphere.cap[m].V[2][node] = E->U[m][E->id[m][node].doff[2]];
Nodal_mesh.c:            E->sphere.cap[m].V[3][node] = E->U[m][E->id[m][node].doff[3]];
Nodal_mesh.c:            if (E->node[m][node] & VBX)
Nodal_mesh.c:                E->sphere.cap[m].V[1][node] = E->sphere.cap[m].VB[1][node];
Nodal_mesh.c:            if (E->node[m][node] & VBY)
Nodal_mesh.c:                E->sphere.cap[m].V[2][node] = E->sphere.cap[m].VB[2][node];
Nodal_mesh.c:            if (E->node[m][node] & VBZ)
Nodal_mesh.c:                E->sphere.cap[m].V[3][node] = E->sphere.cap[m].VB[3][node];
Nodal_mesh.c:            sum_dV += (E->sphere.cap[m].V[1][node] - E->sphere.cap[m].Vprev[1][node])*(E->sphere.cap[m].V[1][node] - E->sphere.cap[m].Vprev[1][node])
Nodal_mesh.c:                + (E->sphere.cap[m].V[2][node] - E->sphere.cap[m].Vprev[2][node])*(E->sphere.cap[m].V[2][node] - E->sphere.cap[m].Vprev[2][node])
Nodal_mesh.c:                + (E->sphere.cap[m].V[3][node] - E->sphere.cap[m].Vprev[3][node])*(E->sphere.cap[m].V[3][node] - E->sphere.cap[m].Vprev[3][node]);
Nodal_mesh.c:            sum_V += E->sphere.cap[m].V[1][node]*E->sphere.cap[m].V[1][node]
Nodal_mesh.c:                + E->sphere.cap[m].V[2][node]*E->sphere.cap[m].V[2][node]
Nodal_mesh.c:                + E->sphere.cap[m].V[3][node]*E->sphere.cap[m].V[3][node];
Nodal_mesh.c:        MPI_Allreduce(&rel_error,&global_max_error,1,MPI_DOUBLE,MPI_MAX,E->parallel.world);
Nodal_mesh.c:        if(global_max_error <= tol_error) E->monitor.stop_topo_loop = 1;
Nodal_mesh.c:        if(E->parallel.me==0)
Nodal_mesh.c:            fprintf(stderr,"global_max_error=%e stop_topo_loop=%d\n",global_max_error,E->monitor.stop_topo_loop);
Nodal_mesh.c:    const int ends=enodes[E->mesh.nsd];
Nodal_mesh.c:    const int lev=E->mesh.levmax;
Nodal_mesh.c:            node = E->ien[m][el].node[a];
Nodal_mesh.c:            VV[1][a] = E->sphere.cap[m].V[1][node];
Nodal_mesh.c:            VV[2][a] = E->sphere.cap[m].V[2][node];
Nodal_mesh.c:            VV[3][a] = E->sphere.cap[m].V[3][node];
Nodal_mesh.c:            node = E->ien[m][el].node[a];
Nodal_mesh.c:            sint = E->SinCos[lev][m][0][node]; 
Nodal_mesh.c:            sinf = E->SinCos[lev][m][1][node];
Nodal_mesh.c:            cost = E->SinCos[lev][m][2][node];
Nodal_mesh.c:            cosf = E->SinCos[lev][m][3][node];
Nodal_mesh.c:            VV[1][a] = E->sphere.cap[m].V[1][node]*cost*cosf
Nodal_mesh.c:                - E->sphere.cap[m].V[2][node]*sinf
Nodal_mesh.c:                + E->sphere.cap[m].V[3][node]*sint*cosf;
Nodal_mesh.c:            VV[2][a] = E->sphere.cap[m].V[1][node]*cost*sinf
Nodal_mesh.c:                + E->sphere.cap[m].V[2][node]*cosf
Nodal_mesh.c:                + E->sphere.cap[m].V[3][node]*sint*sinf;
Nodal_mesh.c:            VV[3][a] = -E->sphere.cap[m].V[1][node]*sint
Nodal_mesh.c:                + E->sphere.cap[m].V[3][node]*cost;
Nodal_mesh.c:    const int dims=E->mesh.nsd;
Nodal_mesh.c:    const int ends=enodes[E->mesh.nsd];
Nodal_mesh.c:    const int nno=E->lmesh.nno;
Nodal_mesh.c:    const int lev=E->mesh.levmax;
Nodal_mesh.c:            node = E->ien[m][el].node[a];
Nodal_mesh.c:/*            VV[1][a] = E->U[m][E->id[m][node].doff[1]];
Nodal_mesh.c:            VV[2][a] = E->U[m][E->id[m][node].doff[2]];
Nodal_mesh.c:            VV[3][a] = E->U[m][E->id[m][node].doff[3]]; */
Nodal_mesh.c:            VV[1][a] = E->sphere.cap[m].V[1][node];
Nodal_mesh.c:            VV[2][a] = E->sphere.cap[m].V[2][node];
Nodal_mesh.c:            VV[3][a] = E->sphere.cap[m].V[3][node];  
Nodal_mesh.c:            node = E->ien[m][el].node[a];
Nodal_mesh.c:            sint = E->SinCos[lev][m][0][node];
Nodal_mesh.c:            sinf = E->SinCos[lev][m][1][node];
Nodal_mesh.c:            cost = E->SinCos[lev][m][2][node];
Nodal_mesh.c:            cosf = E->SinCos[lev][m][3][node];
Nodal_mesh.c:            VV[1][a] = E->U[m][E->id[m][node].doff[1]]*cost*cosf
Nodal_mesh.c:                - E->U[m][E->id[m][node].doff[2]]*sinf
Nodal_mesh.c:                + E->U[m][E->id[m][node].doff[3]]*sint*cosf;
Nodal_mesh.c:            VV[2][a] = E->U[m][E->id[m][node].doff[1]]*cost*sinf
Nodal_mesh.c:                + E->U[m][E->id[m][node].doff[2]]*cosf
Nodal_mesh.c:                + E->U[m][E->id[m][node].doff[3]]*sint*sinf;
Nodal_mesh.c:            VV[3][a] = -E->U[m][E->id[m][node].doff[1]]*sint
Nodal_mesh.c:                + E->U[m][E->id[m][node].doff[3]]*cost;
Nodal_mesh.c:/*            VV[1][a] = E->sphere.cap[m].V[1][node]*cost*cosf
Nodal_mesh.c:                - E->sphere.cap[m].V[2][node]*sinf
Nodal_mesh.c:                + E->sphere.cap[m].V[3][node]*sint*cosf;
Nodal_mesh.c:            VV[2][a] = E->sphere.cap[m].V[1][node]*cost*sinf
Nodal_mesh.c:                + E->sphere.cap[m].V[2][node]*cosf
Nodal_mesh.c:                + E->sphere.cap[m].V[3][node]*sint*sinf;
Nodal_mesh.c:            VV[3][a] = -E->sphere.cap[m].V[1][node]*sint
Nodal_mesh.c:                + E->sphere.cap[m].V[3][node]*cost;
Nodal_mesh.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:    for(node=1;node<=E->lmesh.NNO[lev];node++)
Nodal_mesh.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:    for(element=1;element<=E->lmesh.NEL[lev];element++)
Nodal_mesh.c:       for(j=1;j<=enodes[E->mesh.nsd];j++)  {
Nodal_mesh.c:     	  node = E->IEN[lev][m][element].node[j];
Nodal_mesh.c:    	  PN[m][node] += P[m][element] * E->TWW[lev][m][element].node[j] ;
Nodal_mesh.c:   (E->exchange_node_f)(E,PN,lev);
Nodal_mesh.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:     for(node=1;node<=E->lmesh.NNO[lev];node++)
Nodal_mesh.c:        PN[m][node] *= E->MASS[lev][m][node];
Nodal_mesh.c:  const int nsd=E->mesh.nsd;
Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:   for(i=1;i<=E->lmesh.NNO[lev];i++)
Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)   {
Nodal_mesh.c:       n = E->IEN[lev][m][e].node[j];
Nodal_mesh.c:       VN[m][n] += E->TWW[lev][m][e].node[j] * VE[m][e];
Nodal_mesh.c:   (E->exchange_node_f)(E,VN,lev);
Nodal_mesh.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:     for(n=1;n<=E->lmesh.NNO[lev];n++)
Nodal_mesh.c:        VN[m][n] *= E->MASS[lev][m][n];
Nodal_mesh.c:  const int nsd=E->mesh.nsd;
Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:   for(i=1;i<=E->lmesh.NNO[lev];i++)
Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)   {
Nodal_mesh.c:       n = E->IEN[lev][m][e].node[j];
Nodal_mesh.c:       VN[m][n] += E->TWW[lev][m][e].node[j] * temp_visc;
Nodal_mesh.c:   (E->exchange_node_f)(E,VN,lev);
Nodal_mesh.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:     for(n=1;n<=E->lmesh.NNO[lev];n++)
Nodal_mesh.c:        VN[m][n] *= E->MASS[lev][m][n];
Nodal_mesh.c:  const int nsd=E->mesh.nsd;
Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Nodal_mesh.c:	 temp_visc += E->N.vpt[GNVINDEX(j,i)]*VN[m][E->IEN[lev][m][e].node[j]];
Nodal_mesh.c:  const int nsd=E->mesh.nsd;
Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:   for(i=1;i<=E->lmesh.NEL[lev];i++)
Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)   {
Nodal_mesh.c:  const int nsd=E->mesh.nsd;
Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Nodal_mesh.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Nodal_mesh.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Obsolete.c:  const int dims=E->mesh.nsd;
Obsolete.c:          x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]*
Obsolete.c:                E->N.vpt[GNVINDEX(i,k)];
Obsolete.c:            dxda[d][e] += E->X[lev][m][e][E->IEN[lev][m][el].node[i]]
Obsolete.c:               * E->Nx.vpt[GNVXINDEX(d-1,i,k)];
Obsolete.c:      jacobian = determinant(dxda,E->mesh.nsd);
Obsolete.c:                 E->Nx.vpt[GNVXINDEX(e-1,j,k)] *cof[e][d];
Obsolete.c:                 E->Nx.vpt[GNVXINDEX(e-1,j,k)] *cof[e][d];
Obsolete.c:          x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]
Obsolete.c:                 *E->N.ppt[GNPINDEX(i,k)];
Obsolete.c:            dxda[d][e] += E->X[lev][m][e][E->IEN[lev][m][el].node[i]]
Obsolete.c:                     * E->Nx.ppt[GNPXINDEX(d-1,i,k)];
Obsolete.c:      jacobian = determinant(dxda,E->mesh.nsd);
Obsolete.c:          cof[d][e]=cofactor(dxda,d,e,E->mesh.nsd);
Obsolete.c:                E->Nx.ppt[GNPXINDEX(e-1,j,k)]*cof[e][d];
Obsolete.c:                E->Nx.ppt[GNPXINDEX(e-1,j,k)]*cof[e][d];
Obsolete.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Obsolete.c:   for(k=1;k<=vpoints[E->mesh.nsd];k++)  {
Obsolete.c:            dxda[d][e] += E->NMx.vpt[GNVXINDEX(d-1,i,k)]
Obsolete.c:                * E->x[m][e][E->ien[m][el].node[i]];
Obsolete.c:        jacobian = sqrt(fabs(determinant(cof,E->mesh.nsd)))/cof[3][3];
Obsolete.c:  const int oned = onedvpoints[E->mesh.nsd];
Obsolete.c:  const int vpts = vpoints[E->mesh.nsd-1];
Obsolete.c:  const int ppts = ppoints[E->mesh.nsd-1];
Obsolete.c:  const int ends = enodes[E->mesh.nsd-1];
Obsolete.c:  to = E->eco[m][el].centre[1];
Obsolete.c:  fo = E->eco[m][el].centre[2];
Obsolete.c:  ro = E->eco[m][el].centre[3];
Obsolete.c:    node=E->ien[m][el].node[a];
Obsolete.c:    xx[1][i] = E->x[m][1][node]*dxdy[1][1]
Obsolete.c:      + E->x[m][2][node]*dxdy[1][2]
Obsolete.c:      + E->x[m][3][node]*dxdy[1][3];
Obsolete.c:    xx[2][i] = E->x[m][1][node]*dxdy[2][1]
Obsolete.c:      + E->x[m][2][node]*dxdy[2][2]
Obsolete.c:      + E->x[m][3][node]*dxdy[2][3];
Obsolete.c:    xx[3][i] = E->x[m][1][node]*dxdy[3][1]
Obsolete.c:      + E->x[m][2][node]*dxdy[3][2]
Obsolete.c:      + E->x[m][3][node]*dxdy[3][3];
Obsolete.c:    for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:      for(e=1;e<=E->mesh.nsd-1;e++)
Obsolete.c:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Obsolete.c:	    dxda[d][e] += xx[dims[NS][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Obsolete.c:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Obsolete.c:	    dxda[d][e] += xx[dims[NS][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Obsolete.c:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Obsolete.c:	    dxda[d][e] += xx[dims[NS][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Obsolete.c:    jacobian = determinant(dxda,E->mesh.nsd-1);
Obsolete.c:    for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:      for(e=1;e<=E->mesh.nsd-1;e++)
Obsolete.c:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:	  for(e=1;e<=E->mesh.nsd-1;e++)
Obsolete.c:	    dxda[d][e] += xx[dims[NS][e]][k]*E->Mx.ppt[GMPXINDEX(d-1,k,i)];
Obsolete.c:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Obsolete.c:	    node=E->ien[m][el].node[a];
Obsolete.c:	    dxda[d][e] += xx[dims[NS][e]][k]*E->Mx.ppt[GMPXINDEX(d-1,k,i)];
Obsolete.c:	for(d=1;d<=E->mesh.nsd-1;d++)
Obsolete.c:	  for(e=1;e<=E->mesh.nsd-1;e++) {
Obsolete.c:	    node=E->ien[m][el].node[a];
Obsolete.c:	    dxda[d][e] += xx[dims[NS][e]][k]*E->Mx.ppt[GMPXINDEX(d-1,k,i)];
Obsolete.c:    jacobian = determinant(dxda,E->mesh.nsd-1);
Obsolete.c:  for(i=1;i<=E->mesh.nsd;i++)
Obsolete.c:    { for(a=1;a<=enodes[E->mesh.nsd];a++)
Obsolete.c:	{ if (E->node[m][E->ien[m][el].node[a]] & type)
Obsolete.c:		{  get_elt_g(E,el,elt_g,E->mesh.levmax,m);
Obsolete.c:	      p=E->mesh.nsd*(a-1) + i - 1;
Obsolete.c:	      for(b=1;b<=pnodes[E->mesh.nsd];b++)
Obsolete.c:		  elt_h[q] -= elt_g[p][q] * E->sphere.cap[m].VB[i][E->ien[m][el].node[a]];
Obsolete.c:  const int nel=E->lmesh.nel;
Obsolete.c:  const int vpts=vpoints[E->mesh.nsd];
Obsolete.c:  lev = E->mesh.levmax;
Obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:        EV[el] +=  E->EVI[lev][m][(el-1)*vpts+j];
Obsolete.c:    E->sphere.con = (double *)malloc(E->sphere.hindice*sizeof(double));
Obsolete.c:    for (ll=0;ll<=E->output.llmax;ll++)
Obsolete.c:	    E->sphere.con[E->sphere.hindex[ll][mm]] =
Obsolete.c:    E->sphere.tablenplm   = (double **) malloc((E->sphere.nox+1)
Obsolete.c:    for (i=1;i<=E->sphere.nox;i++)
Obsolete.c:	E->sphere.tablenplm[i]= (double *)malloc(E->sphere.hindice
Obsolete.c:    E->sphere.tablencosf  = (double **) malloc((E->sphere.noy+1)
Obsolete.c:    E->sphere.tablensinf  = (double **) malloc((E->sphere.noy+1)
Obsolete.c:    for (i=1;i<=E->sphere.noy;i++)   {
Obsolete.c:	E->sphere.tablencosf[i]= (double *)malloc((E->output.llmax+3)
Obsolete.c:	E->sphere.tablensinf[i]= (double *)malloc((E->output.llmax+3)
Obsolete.c:    E->sphere.sx[1] = (double *) malloc((E->sphere.nsf+1)*sizeof(double));
Obsolete.c:    E->sphere.sx[2] = (double *) malloc((E->sphere.nsf+1)*sizeof(double));
Obsolete.c:    dth = M_PI/E->sphere.elx;
Obsolete.c:    dfi = 2.0*M_PI/E->sphere.ely;
Obsolete.c:    for (j=1;j<=E->sphere.noy;j++)
Obsolete.c:	for (i=1;i<=E->sphere.nox;i++) {
Obsolete.c:	    node = i+(j-1)*E->sphere.nox;
Obsolete.c:	    E->sphere.sx[1][node] = dth*(i-1);
Obsolete.c:	    E->sphere.sx[2][node] = dfi*(j-1);
Obsolete.c:    for (j=1;j<=E->sphere.nox;j++)  {
Obsolete.c:	t=E->sphere.sx[1][j];
Obsolete.c:	for (ll=0;ll<=E->output.llmax;ll++)
Obsolete.c:		p = E->sphere.hindex[ll][mm];
Obsolete.c:		E->sphere.tablenplm[j][p] = modified_plgndr_a(ll,mm,t) ;
Obsolete.c:    for (j=1;j<=E->sphere.noy;j++)  {
Obsolete.c:	node = 1+(j-1)*E->sphere.nox;
Obsolete.c:	f=E->sphere.sx[2][node];
Obsolete.c:	for (mm=0;mm<=E->output.llmax;mm++)   {
Obsolete.c:	    E->sphere.tablencosf[j][mm] = cos( (double)(mm)*f );
Obsolete.c:	    E->sphere.tablensinf[j][mm] = sin( (double)(mm)*f );
Obsolete.c:    for (i=1;i<=E->sphere.nox;i++)
Obsolete.c:	for (j=1;j<=E->sphere.noy;j++)   {
Obsolete.c:	    node = i+(j-1)*E->sphere.nox;
Obsolete.c:	    E->sphere.int_cap[node]=0;
Obsolete.c:	    E->sphere.int_ele[node]=0;
Obsolete.c:    for (i=1;i<=E->sphere.nox;i++)
Obsolete.c:	for (j=1;j<=E->sphere.noy;j++)   {
Obsolete.c:	    node = i+(j-1)*E->sphere.nox;
Obsolete.c:	    t = E->sphere.sx[1][node];
Obsolete.c:	    f = E->sphere.sx[2][node];
Obsolete.c:	    fprintf(E->fp,"mmm0=%d\n",node);
Obsolete.c:	    fprintf(E->fp,"mmm=%d\n",m);
Obsolete.c:		    fprintf(stderr,"!!! Processor %d cannot find the right element in cap %d\n",E->parallel.me,m);
Obsolete.c:		E->sphere.int_cap[node]=m;
Obsolete.c:		E->sphere.int_ele[node]=el;
Obsolete.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Obsolete.c:	ia[2] = E->lmesh.noz*E->lmesh.nox-E->lmesh.noz+1;
Obsolete.c:	ia[3] = E->lmesh.nno-E->lmesh.noz+1;
Obsolete.c:	ia[4] = ia[3]-E->lmesh.noz*(E->lmesh.nox-1);
Obsolete.c:	    xx[1] = E->x[m][1][ia[i]]/E->sx[m][3][ia[1]];
Obsolete.c:	    xx[2] = E->x[m][2][ia[i]]/E->sx[m][3][ia[1]];
Obsolete.c:	    xx[3] = E->x[m][3][ia[i]]/E->sx[m][3][ia[1]];
Obsolete.c:	    angle1[i]=E->sphere.angle[m][i];
Obsolete.c:	if ( fabs ((area1-E->sphere.area[m])/E->sphere.area[m]) <e_7 ) {
Obsolete.c:    level=E->mesh.levmin;
Obsolete.c:    for (es=1;es<=E->lmesh.SNEL[level];es++)              {
Obsolete.c:	el = (es-1)*E->lmesh.ELZ[level]+1;
Obsolete.c:	area = E->sphere.area1[level][m][es];
Obsolete.c:	    for (lev=E->mesh.levmin;lev<E->mesh.levmax;lev++)  {
Obsolete.c:		    el_plus = E->EL[lev][m][el].sub[j];
Obsolete.c:		    es_plus = (el_plus-1)/E->lmesh.ELZ[lev_plus]+1;
Obsolete.c:		    area = E->sphere.area1[lev_plus][m][es_plus];
Obsolete.c:    es = (el-1)/E->lmesh.elz+1;
Obsolete.c:    to = E->eco[m][el].centre[1];
Obsolete.c:    fo = E->eco[m][el].centre[2];
Obsolete.c:	node = E->ien[m][el].node[i];
Obsolete.c:	snode = E->sien[m][es].node[i];
Obsolete.c:	for (j=1;j<=E->mesh.nsd;j++)
Obsolete.c:	    yy[j][i] = E->x[m][1][node]*dxdy[j][1]
Obsolete.c:                + E->x[m][2][node]*dxdy[j][2]
Obsolete.c:                + E->x[m][3][node]*dxdy[j][3];
Obsolete.c:    for (j=1;j<=E->mesh.nsd;j++)
Obsolete.c:    /*if(fabs(xx1)>1.5 || fabs(yy1)>1.5)fprintf(E->fp_out,"ME= %d %d %d %g %g %g %g %g %g %g\n",ne,m,es,t[1],t[2],t[3],t[4],ta,xx1,yy1);
Obsolete.c:    for (i=1;i<=E->sphere.nox;i++)
Obsolete.c:	for (j=1;j<=E->sphere.noy;j++)   {
Obsolete.c:	    node = i+(j-1)*E->sphere.nox;
Obsolete.c:	    m = E->sphere.int_cap[node];
Obsolete.c:	    el = E->sphere.int_ele[node];
Obsolete.c:		t = E->sphere.sx[1][node];
Obsolete.c:		f = E->sphere.sx[2][node];
Obsolete.c:		x[1] = E->sx[1][3][1]*sin(t)*cos(f);
Obsolete.c:		x[2] = E->sx[1][3][1]*sin(t)*sin(f);
Obsolete.c:		x[3] = E->sx[1][3][1]*cos(t);
Obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Obsolete.c:    for(i=1;i<=E->lmesh.nno;i++)  {
Obsolete.c:      e_pressure = (E->sphere.ro-E->sx[m][3][i])-E->viscosity.z410-
Obsolete.c:            E->control.clapeyron410*(E->T[m][i]-E->control.transT410);
Obsolete.c:      B[m][i] = pt5*(one+tanh(E->control.width410*e_pressure));
Obsolete.c:    for (k=1;k<=E->lmesh.noy;k++)
Obsolete.c:      for (j=1;j<=E->lmesh.nox;j++)  {
Obsolete.c:        for (i=1;i<E->lmesh.noz;i++)   {
Obsolete.c:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Obsolete.c:            B_b[m][ns]=(E->sx[m][3][n+1]-E->sx[m][3][n])*(pt5-B[m][n])/(B[m][n+1]-B[m][n])+E->sx[m][3][n];
Obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Obsolete.c:    for(i=1;i<=E->lmesh.nno;i++)  {
Obsolete.c:      e_pressure = (E->sphere.ro-E->sx[m][3][i])-E->viscosity.zlm-
Obsolete.c:            E->control.clapeyron670*(E->T[m][i]-E->control.transT670);
Obsolete.c:      B[m][i] = pt5*(one+tanh(E->control.width670*e_pressure));
Obsolete.c:    for (k=1;k<=E->lmesh.noy;k++)
Obsolete.c:      for (j=1;j<=E->lmesh.nox;j++)  {
Obsolete.c:        for (i=1;i<E->lmesh.noz;i++)   {
Obsolete.c:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Obsolete.c:            B_b[m][ns]=(E->sx[m][3][n+1]-E->sx[m][3][n])*(pt5-B[m][n])/(B[m][n+1]-B[m][n])+E->sx[m][3][n];
Obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Obsolete.c:    for(i=1;i<=E->lmesh.nno;i++)  {
Obsolete.c:      e_pressure = (E->sphere.ro-E->sx[m][3][i])-E->viscosity.zcmb-
Obsolete.c:            E->control.clapeyroncmb*(E->T[m][i]-E->control.transTcmb);
Obsolete.c:      B[m][i] = pt5*(one+tanh(E->control.widthcmb*e_pressure));
Obsolete.c:    for (k=1;k<=E->lmesh.noy;k++)
Obsolete.c:      for (j=1;j<=E->lmesh.nox;j++)  {
Obsolete.c:        for (i=1;i<E->lmesh.noz;i++)   {
Obsolete.c:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Obsolete.c:            B_b[m][ns]=(E->sx[m][3][n+1]-E->sx[m][3][n])*(pt5-B[m][n])/(B[m][n+1]-B[m][n])+E->sx[m][3][n];
Obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:    for(p=1;p<=E->lmesh.NEL[lev];p++)
Obsolete.c:   weight=1.0/((double)enodes[E->mesh.nsd]) ;
Obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:    for(p=1;p<=E->lmesh.NEL[lev];p++)
Obsolete.c:      for(j=1;j<=enodes[E->mesh.nsd];j++)
Obsolete.c:        P[m][p] += PN[m][E->IEN[lev][m][p].node[j]] * weight;
Obsolete.c:   const int nsd=E->mesh.nsd;
Obsolete.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Obsolete.c:          VE[m][(e-1)*vpts + i] += VN[m][E->IEN[lev][m][e].node[j]]*E->N.vpt[GNVINDEX(j,i)];
Obsolete.c:   const int nsd=E->mesh.nsd;
Obsolete.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:   for(e=1;e<=E->lmesh.NEL[lev];e++)
Obsolete.c:          VE[m][(e-1)*vpts + i] += log(VN[m][E->IEN[lev][m][e].node[j]]) *  E->N.vpt[GNVINDEX(j,i)];
Obsolete.c:    if(!input_string(input_token,filename,"initialize",E->parallel.me)) {
Obsolete.c:	fprintf(E->fp,"No previous %s information found in input file\n",name);fflush(E->fp);
Obsolete.c:    fprintf(E->fp,"Previous %s information is in file %s\n",name,filename);fflush(E->fp);
Obsolete.c:	fprintf(E->fp,"Unable to open the required file `%s' (this is fatal)",filename);
Obsolete.c:	fflush(E->fp);
Obsolete.c:	fprintf(E->fp,"File %s is not in the correct format\n",filename);fflush(E->fp);
Obsolete.c:	fprintf(E->fp,"Unable to deciphre the columns in the input file");fflush(E->fp);
Obsolete.c:	fprintf(E->fp,"\t%s (%s) found in column %d\n",name,abbr,column);fflush(E->fp);
Obsolete.c:	fprintf(E->fp,"\t%s (%s) not found in file: %s\n",name,abbr,filename);fflush(E->fp);
Obsolete.c:    if(((3!= E->mesh.nsd) && (fnodesy !=1)) || ((3==E->mesh.nsd) && (1==fnodesy))) {
Obsolete.c:	fprintf(E->fp,"Input data for file `%s'  is of inappropriate dimension (not %dD)\n",filename,E->mesh.nsd);fflush(E->fp);
Obsolete.c:    if(fnodesx != E->lmesh.nox || fnodesz != E->lmesh.noz || fnodesy != E->lmesh.noy) {
Obsolete.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:  n = loc_mat_size[E->mesh.nsd];
Obsolete.c:    const int dims=E->mesh.nsd;
Obsolete.c:    const int n=loc_mat_size[E->mesh.nsd];
Obsolete.c:    const int neq=E->lmesh.NEQ[level];
Obsolete.c:    const int num_nodes=E->lmesh.NNO[level];
Obsolete.c:    const int nox=E->lmesh.NOX[level];
Obsolete.c:    const int noz=E->lmesh.NOY[level];
Obsolete.c:    const int noy=E->lmesh.NOZ[level];
Obsolete.c:    gneq = E->mesh.NEQ[level];
Obsolete.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:      r1[m] = (double *)malloc(E->lmesh.neq*sizeof(double));
Obsolete.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c: 	for(i=1;i<=E->lmesh.NNO[level];i++)  {
Obsolete.c:	    eqn1=E->ID[level][m][i].doff[1];
Obsolete.c:	    eqn2=E->ID[level][m][i].doff[2];
Obsolete.c:	    eqn3=E->ID[level][m][i].doff[3];
Obsolete.c:            d0[m][eqn1] += r1[m][eqn1]*E->BI[level][m][eqn1];
Obsolete.c:            d0[m][eqn2] += r1[m][eqn2]*E->BI[level][m][eqn2];
Obsolete.c:            d0[m][eqn3] += r1[m][eqn3]*E->BI[level][m][eqn3];
Obsolete.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c: 	for(i=1;i<=E->lmesh.NNO[level];i++)  {
Obsolete.c:	    eqn1=E->ID[level][m][i].doff[1];
Obsolete.c:	    eqn2=E->ID[level][m][i].doff[2];
Obsolete.c:	    eqn3=E->ID[level][m][i].doff[3];
Obsolete.c:            C=E->Node_map[level][m]+(i-1)*max_eqn;
Obsolete.c:	    B1=E->Eqn_k1[level][m]+(i-1)*max_eqn;
Obsolete.c:	    B2=E->Eqn_k2[level][m]+(i-1)*max_eqn;
Obsolete.c: 	    B3=E->Eqn_k3[level][m]+(i-1)*max_eqn;
Obsolete.c:      (E->solver.exchange_id_d)(E, Ad, level);
Obsolete.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Obsolete.c:   if(E->parallel.me==0)fprintf(stderr,"residuall =%.5e for %d\n",residual,count);
Obsolete.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Output.c:    int m = E->parallel.me;
Output.c:    input_string("output_format", E->output.format, "ascii",m);
Output.c:    input_string("output_optional", E->output.optional, "surf,botm,tracer",m);
Output.c:    E->output.gzdir.vtk_io = 0;
Output.c:    E->output.gzdir.rnr = 0;
Output.c:    if(strcmp(E->output.format, "ascii-gz") == 0){
Output.c:      input_int("gzdir_vtkio",&(E->output.gzdir.vtk_io),"0",m);
Output.c:      input_boolean("gzdir_rnr",&(E->output.gzdir.rnr),"off",m);
Output.c:      E->output.gzdir.vtk_base_init = 0;
Output.c:      E->output.gzdir.vtk_base_save = 1; /* should we save the basis vectors? (memory!) */
Output.c:      //      E->output.gzdir.vtk_io,E->output.gzdir.vtk_base_save);
Output.c:    if (E->output.coord_bin)
Output.c:  if (E->output.geoid)		/* this needs to be called after the
Output.c:  if (E->output.stress){
Output.c:  if (E->output.pressure)
Output.c:  if (E->output.horiz_avg)
Output.c:  if (E->output.seismic)
Output.c:  if(E->output.tracer && E->control.tracer)
Output.c:  if (E->output.comp_nd && E->composition.on)
Output.c:  if (E->output.comp_el && E->composition.on)
Output.c:  if(E->output.heating && E->control.disptn_number != 0)
Output.c:  sprintf(output_file,"%s.coord.%d",E->control.data_file,E->parallel.me);
Output.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Output.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Output.c:    for(i=1;i<=E->lmesh.nno;i++)
Output.c:      fprintf(fp1,"%.6e %.6e %.6e\n",E->sx[j][1][i],E->sx[j][2][i],E->sx[j][3][i]);
Output.c:    const int nox = E->lmesh.nox;
Output.c:    const int noy = E->lmesh.noy;
Output.c:    const int noz = E->lmesh.noz;
Output.c:    buffer[0] = E->sx[j][3][1];
Output.c:    buffer[1] = E->sx[j][3][noz];
Output.c:    buffer[2] = E->sx[j][1][corner_nodes[0]];
Output.c:    buffer[3] = E->sx[j][2][corner_nodes[0]];
Output.c:    buffer[4] = E->sx[j][1][corner_nodes[1]];
Output.c:    buffer[5] = E->sx[j][2][corner_nodes[1]];
Output.c:    buffer[6] = E->sx[j][1][corner_nodes[2]];
Output.c:    buffer[7] = E->sx[j][2][corner_nodes[2]];
Output.c:    buffer[8] = E->sx[j][1][corner_nodes[3]];
Output.c:    buffer[9] = E->sx[j][2][corner_nodes[3]];
Output.c:    if(E->parallel.me == 0) {
Output.c:        sprintf(output_file,"%s.domain",E->control.data_file);
Output.c:        header[0] = E->parallel.nproc;
Output.c:        for(rank=1; rank<E->parallel.nproc; rank++) {
Output.c:            MPI_Recv(buffer, ncolumns, MPI_DOUBLE, rank, tag, E->parallel.world, &status);
Output.c:        MPI_Send(buffer, ncolumns, MPI_DOUBLE, receiver, tag, E->parallel.world);
Output.c:  sprintf(output_file,"%s.coord_bin.%d",E->control.data_file,E->parallel.me);
Output.c:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:      header[0] = E->lmesh.nox;
Output.c:      header[1] = E->lmesh.noy;
Output.c:      header[2] = E->lmesh.noz;
Output.c:      fwrite(&(E->x[j][1][1]), sizeof(double), E->lmesh.nno, fp1);
Output.c:      fwrite(&(E->x[j][2][1]), sizeof(double), E->lmesh.nno, fp1);
Output.c:      fwrite(&(E->x[j][3][1]), sizeof(double), E->lmesh.nno, fp1);
Output.c:  int lev = E->mesh.levmax;
Output.c:  sprintf(output_file,"%s.visc.%d.%d", E->control.data_file,
Output.c:          E->parallel.me, cycles);
Output.c:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Output.c:    for(i=1;i<=E->lmesh.nno;i++)
Output.c:      fprintf(fp1,"%.4e\n",E->VI[lev][j][i]);
Output.c:  sprintf(output_file,"%s.velo.%d.%d", E->control.data_file,
Output.c:          E->parallel.me, cycles);
Output.c:  fprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output.c:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Output.c:    for(i=1;i<=E->lmesh.nno;i++) {
Output.c:        fprintf(fp1,"%.6e %.6e %.6e %.6e\n",E->sphere.cap[j].V[1][i],E->sphere.cap[j].V[2][i],E->sphere.cap[j].V[3][i],E->T[j][i]);
Output.c:  if((E->output.write_q_files == 0) || (cycles == 0) ||
Output.c:     (cycles % E->output.write_q_files)!=0)
Output.c:  if(E->control.use_cbf_topo){
Output.c:    get_CBF_topo(E,E->slice.tpg,E->slice.tpgb);
Output.c:    get_STD_topo(E,E->slice.tpg,E->slice.tpgb,E->slice.divg,E->slice.vort,cycles);
Output.c:  if (E->output.surf && (E->parallel.me_loc[3]==E->parallel.nprocz-1)) {
Output.c:    sprintf(output_file,"%s.surf.%d.%d", E->control.data_file,
Output.c:            E->parallel.me, cycles);
Output.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Output.c:        if(E->control.pseudo_free_surf)
Output.c:            topo = E->slice.freesurf[j];
Output.c:            topo = E->slice.tpg[j];
Output.c:        fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Output.c:        for(i=1;i<=E->lmesh.nsf;i++)   {
Output.c:            s = i*E->lmesh.noz;
Output.c:		    topo[i],E->slice.shflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Output.c:  if (E->output.botm && (E->parallel.me_loc[3]==0)) {
Output.c:    sprintf(output_file,"%s.botm.%d.%d", E->control.data_file,
Output.c:            E->parallel.me, cycles);
Output.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Output.c:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Output.c:      for(i=1;i<=E->lmesh.nsf;i++)  {
Output.c:        s = (i-1)*E->lmesh.noz + 1;
Output.c:		E->slice.tpgb[j][i],E->slice.bhflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Output.c:    if (E->parallel.me == (E->parallel.nprocz-1))  {
Output.c:        sprintf(output_file, "%s.geoid.%d.%d", E->control.data_file,
Output.c:                E->parallel.me, cycles);
Output.c:        fprintf(fp1, "%d %d %.5e\n", cycles, E->output.llmax,
Output.c:                E->monitor.elapsed_time);
Output.c:        for (ll=0; ll<=E->output.llmax; ll++)
Output.c:                p = E->sphere.hindex[ll][mm];
Output.c:                        E->sphere.harm_geoid[0][p],
Output.c:                        E->sphere.harm_geoid[1][p],
Output.c:                        E->sphere.harm_geoid_from_tpgt[0][p],
Output.c:                        E->sphere.harm_geoid_from_tpgt[1][p],
Output.c:                        E->sphere.harm_geoid_from_bncy[0][p],
Output.c:                        E->sphere.harm_geoid_from_bncy[1][p]);
Output.c:  if(E->control.use_cbf_topo)	{/* for CBF topo, stress will not have been computed */
Output.c:  sprintf(output_file,"%s.stress.%d.%d", E->control.data_file,
Output.c:          E->parallel.me, cycles);
Output.c:  fprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Output.c:    fprintf(fp1,"%3d %7d\n",m,E->lmesh.nno);
Output.c:    for (node=1;node<=E->lmesh.nno;node++)
Output.c:              E->gstress[m][(node-1)*6+1],
Output.c:              E->gstress[m][(node-1)*6+2],
Output.c:              E->gstress[m][(node-1)*6+3],
Output.c:              E->gstress[m][(node-1)*6+4],
Output.c:              E->gstress[m][(node-1)*6+5],
Output.c:              E->gstress[m][(node-1)*6+6]);
Output.c:  if (E->parallel.me<E->parallel.nprocz)  {
Output.c:    sprintf(output_file,"%s.horiz_avg.%d.%d", E->control.data_file,
Output.c:            E->parallel.me, cycles);
Output.c:    for(j=1;j<=E->lmesh.noz;j++)  {
Output.c:        fprintf(fp1,"%.4e %.4e %.4e %.4e",E->sx[1][3][j],
Output.c:		E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j]);
Output.c:        if (E->composition.on) {
Output.c:            for(n=0; n<E->composition.ncomp; n++)
Output.c:                fprintf(fp1," %.4e", E->Have.C[n][j]);
Output.c:    const int len = E->lmesh.nno;
Output.c:    sprintf(output_file,"%s.seismic.%d.%d", E->control.data_file, E->parallel.me, cycles);
Output.c:    fwrite(rho, sizeof(double), E->lmesh.nno, fp);
Output.c:    fwrite(vp, sizeof(double), E->lmesh.nno, fp);
Output.c:    fwrite(vs, sizeof(double), E->lmesh.nno, fp);
Output.c:    sprintf(output_file,"%s.dv.%d.%d", E->control.data_file, E->parallel.me, cycles);
Output.c:    fprintf(fp, "%d %d %.5e\n", cycles, E->lmesh.nno, E->monitor.elapsed_time);
Output.c:    for(i=0; i<E->lmesh.nno; i++) {
Output.c:        int nz = (i % E->lmesh.noz) + 1;
Output.c:        get_prem(E->sx[1][3][nz], &vpr, &vsr, &rhor);
Output.c:  sprintf(output_file,"%s.mat.%d", E->control.data_file,E->parallel.me);
Output.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Output.c:    for(el=1;el<=E->lmesh.nel;el++)
Output.c:      fprintf(fp,"%d %d %f\n", el,E->mat[m][el],E->VIP[m][el]);
Output.c:  sprintf(output_file,"%s.pressure.%d.%d", E->control.data_file,
Output.c:          E->parallel.me, cycles);
Output.c:  fprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output.c:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Output.c:    for(i=1;i<=E->lmesh.nno;i++)
Output.c:      fprintf(fp1,"%.6e\n",E->NP[j][i]);
Output.c:  sprintf(output_file,"%s.tracer.%d.%d", E->control.data_file,
Output.c:          E->parallel.me, cycles);
Output.c:  ncolumns = 3 + E->trace.number_of_extra_quantities;
Output.c:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:      fprintf(fp1,"%d %d %d %.5e\n", cycles, E->trace.ntracers[j],
Output.c:              ncolumns, E->monitor.elapsed_time);
Output.c:      for(n=1;n<=E->trace.ntracers[j];n++) {
Output.c:                  E->trace.basicq[j][0][n],
Output.c:                  E->trace.basicq[j][1][n],
Output.c:                  E->trace.basicq[j][2][n]);
Output.c:          for (i=0; i<E->trace.number_of_extra_quantities; i++) {
Output.c:              fprintf(fp1," %.12e", E->trace.extraq[j][i][n]);
Output.c:    sprintf(output_file,"%s.comp_nd.%d.%d", E->control.data_file,
Output.c:            E->parallel.me, cycles);
Output.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:                j, E->lmesh.nel,
Output.c:                E->monitor.elapsed_time, E->composition.ncomp);
Output.c:        for(i=0;i<E->composition.ncomp;i++) {
Output.c:                    E->composition.initial_bulk_composition[i],
Output.c:                    E->composition.bulk_composition[i]);
Output.c:        for(i=1;i<=E->lmesh.nno;i++) {
Output.c:            for(k=0;k<E->composition.ncomp;k++) {
Output.c:                fprintf(fp1,"%.6e ",E->composition.comp_node[j][k][i]);
Output.c:    sprintf(output_file,"%s.comp_el.%d.%d", E->control.data_file,
Output.c:            E->parallel.me, cycles);
Output.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:                j, E->lmesh.nel,
Output.c:                E->monitor.elapsed_time, E->composition.ncomp);
Output.c:        for(i=0;i<E->composition.ncomp;i++) {
Output.c:                    E->composition.initial_bulk_composition[i],
Output.c:                    E->composition.bulk_composition[i]);
Output.c:        for(i=1;i<=E->lmesh.nel;i++) {
Output.c:            for(k=0;k<E->composition.ncomp;k++) {
Output.c:			E->composition.comp_el[j][k][i]);
Output.c:    sprintf(output_file,"%s.heating.%d.%d", E->control.data_file,
Output.c:            E->parallel.me, cycles);
Output.c:    fprintf(fp1,"%.5e\n",E->monitor.elapsed_time);
Output.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output.c:        fprintf(fp1,"%3d %7d\n", j, E->lmesh.nel);
Output.c:        for(e=1; e<=E->lmesh.nel; e++)
Output.c:            fprintf(fp1, "%.4e %.4e %.4e\n", E->heating_adi[j][e],
Output.c:                    E->heating_visc[j][e], E->heating_latent[j][e]);
Output.c:  if (E->parallel.me == 0) {
Output.c:    fprintf(E->fptime,"%d %.4e %.4e %.4e %.4e\n",
Output.c:            E->monitor.elapsed_time,
Output.c:            E->advection.timestep,
Output.c:            current_time - E->monitor.cpu_time_at_start,
Output.c:            current_time - E->monitor.cpu_time_at_last_cycle);
Output.c:    fflush(E->fptime);
Output.c:  E->monitor.cpu_time_at_last_cycle = current_time;
Output.c: if (E->parallel.me==proc_loc)  {
Output.c:     sprintf(output_file,"%s.%s_sharm.%d",E->control.data_file,filen,ii);
Output.c:     fprintf(fp1,"%d %.5e %s\n",ii,E->monitor.elapsed_time,filen);
Output.c:     for (ll=0;ll<=E->output.llmax;ll++)
Output.c:        i = E->sphere.hindex[ll][mm];
Output_gzdir.c:    if (E->output.coord_bin)
Output_gzdir.c:  snprintf(output_dir,255,"%s/%d",E->control.data_dir,out_cycles);
Output_gzdir.c:  if (E->output.geoid)
Output_gzdir.c:  if (E->output.stress){
Output_gzdir.c:  if (E->output.pressure)
Output_gzdir.c:  if (E->output.horiz_avg)
Output_gzdir.c:  if(E->control.tracer){
Output_gzdir.c:    if(E->output.tracer ||
Output_gzdir.c:       (out_cycles == E->advection.max_timesteps))
Output_gzdir.c:  if (E->output.comp_nd && E->composition.on)
Output_gzdir.c:  if (E->output.comp_el && E->composition.on)
Output_gzdir.c:  if(E->output.heating && E->control.disptn_number != 0)
Output_gzdir.c:  if((E->output.gzdir.vtk_io == 2)||(E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2) /* serial */
Output_gzdir.c:    E->output.gzdir.vtk_ocount = -1;
Output_gzdir.c:    if(E->parallel.me == 0){
Output_gzdir.c:      snprintf(message,255,"%s/vtk_time.log",E->control.data_dir);
Output_gzdir.c:      E->output.gzdir.vtk_fp = output_open(message,"w");
Output_gzdir.c:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:      if(E->output.gzdir.vtk_io == 2) /* serial */
Output_gzdir.c:		E->lmesh.nno * E->parallel.nproc *
Output_gzdir.c:		E->sphere.caps_per_proc);
Output_gzdir.c:		E->lmesh.nno * E->sphere.caps_per_proc);
Output_gzdir.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:    for(j=1;j <= E->sphere.caps_per_proc;j++)     {
Output_gzdir.c:      for(i=1;i <= E->lmesh.nno;i++) {
Output_gzdir.c:	x[0]=E->x[j][1][i];x[1]=E->x[j][2][i];x[2]=E->x[j][3][i];
Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2){ /* serial output, close and have
Output_gzdir.c:      if(E->parallel.me <  E->parallel.nproc-1){/* send to next if not last*/
Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:    if((E->output.gzdir.vtk_io == 3) || (E->parallel.me == 0)){ /* in first CPU, or parallel output */
Output_gzdir.c:      if(E->output.gzdir.vtk_io == 2){ /* need to reopen, serial */
Output_gzdir.c:	j = E->parallel.nproc * E->lmesh.nel *
Output_gzdir.c:	  E->sphere.caps_per_proc; /* total number of elements */
Output_gzdir.c:	j = E->lmesh.nel * E->sphere.caps_per_proc;
Output_gzdir.c:	      j,j*(enodes[E->mesh.nsd]+1));
Output_gzdir.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:    if(enodes[E->mesh.nsd] != 8)
Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2){ /* serial, global node numbers */
Output_gzdir.c:      offset = E->lmesh.nno * E->parallel.me - 1;
Output_gzdir.c:    ix[0] = enodes[E->mesh.nsd];
Output_gzdir.c:    for(j=1;j <= E->sphere.caps_per_proc;j++)     {
Output_gzdir.c:      for(i=1;i <= E->lmesh.nel;i++) {
Output_gzdir.c:	ix[1]= E->ien[j][i].node[1]+offset;ix[2] = E->ien[j][i].node[2]+offset;
Output_gzdir.c:	ix[3]= E->ien[j][i].node[3]+offset;ix[4] = E->ien[j][i].node[4]+offset;
Output_gzdir.c:	ix[5]= E->ien[j][i].node[5]+offset;ix[6] = E->ien[j][i].node[6]+offset;
Output_gzdir.c:	ix[7]= E->ien[j][i].node[7]+offset;ix[8] = E->ien[j][i].node[8]+offset;
Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2){ /* serial IO */
Output_gzdir.c:      if(E->parallel.me <  E->parallel.nproc-1)
Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:    if((E->output.gzdir.vtk_io==3) || (E->parallel.me == 0) ){
Output_gzdir.c:      if(E->output.gzdir.vtk_io == 2){ /* serial */
Output_gzdir.c:	j=E->parallel.nproc*E->lmesh.nel*E->sphere.caps_per_proc;
Output_gzdir.c:	j = E->lmesh.nel*E->sphere.caps_per_proc;
Output_gzdir.c:      if(E->parallel.me == 0)
Output_gzdir.c:	   E->control.data_dir,E->parallel.me);
Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)     {
Output_gzdir.c:      gzprintf(gz1,"%3d %7d\n",j,E->lmesh.nno);
Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:		 E->sx[j][1][i],E->sx[j][2][i],E->sx[j][3][i]);
Output_gzdir.c:    if(E->output.gzdir.vtk_io == 1){
Output_gzdir.c:	       E->control.data_dir,E->parallel.me);
Output_gzdir.c:      for(j=1;j <= E->sphere.caps_per_proc;j++)     {
Output_gzdir.c:	for(i=1;i <= E->lmesh.nno;i++) {
Output_gzdir.c:		   E->x[j][1][i],E->x[j][2][i],E->x[j][3][i]);
Output_gzdir.c:      offset = E->lmesh.nno * E->parallel.me - 1;
Output_gzdir.c:	       E->control.data_dir,E->parallel.me);
Output_gzdir.c:      for(j=1;j <= E->sphere.caps_per_proc;j++)     {
Output_gzdir.c:	for(i=1;i <= E->lmesh.nel;i++) {
Output_gzdir.c:	  gzprintf(gz1,"%2i\t",enodes[E->mesh.nsd]);
Output_gzdir.c:	  if(enodes[E->mesh.nsd] != 8){
Output_gzdir.c:		   E->ien[j][i].node[1]+offset,E->ien[j][i].node[2]+offset,
Output_gzdir.c:		   E->ien[j][i].node[3]+offset,E->ien[j][i].node[4]+offset,
Output_gzdir.c:		   E->ien[j][i].node[5]+offset,E->ien[j][i].node[6]+offset,
Output_gzdir.c:		   E->ien[j][i].node[7]+offset,E->ien[j][i].node[8]+offset);
Output_gzdir.c:  if(E->output.gzdir.vtk_io){	/* all VTK modes need basis vectors */
Output_gzdir.c:    os = E->lmesh.nno*9;
Output_gzdir.c:    if((!E->output.gzdir.vtk_base_init) ||(!E->output.gzdir.vtk_base_save)){
Output_gzdir.c:      if(!E->output.gzdir.vtk_base_init) /* init space */
Output_gzdir.c:	E->output.gzdir.vtk_base = (float *)safe_malloc(sizeof(float)*os*E->sphere.caps_per_proc);
Output_gzdir.c:      for(k=0,j=1;j <= E->sphere.caps_per_proc;j++,k += os)     {
Output_gzdir.c:	for(i=1;i <= E->lmesh.nno;i++,k += 9){
Output_gzdir.c:	  calc_cbase_at_node(j,i,(E->output.gzdir.vtk_base+k),E);
Output_gzdir.c:      E->output.gzdir.vtk_base_init = 1;
Output_gzdir.c:  if(E->output.gzdir.rnr){	/* remove the whole model net rotation */
Output_gzdir.c:    if((E->control.remove_rigid_rotation || E->control.remove_angular_momentum) &&
Output_gzdir.c:       (E->parallel.me == 0))	/* that's not too terrible but wastes time */
Output_gzdir.c:    if(E->parallel.me == 0)
Output_gzdir.c:  if((E->output.gzdir.vtk_io == 2) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:    E->output.gzdir.vtk_ocount++; /* regular output file name */
Output_gzdir.c:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:      if(E->parallel.me == 0){
Output_gzdir.c:	fprintf(E->output.gzdir.vtk_fp,"%12i %12i %12.6e %s\n",
Output_gzdir.c:		E->output.gzdir.vtk_ocount,cycles,E->monitor.elapsed_time,output_file);
Output_gzdir.c:      if(E->output.gzdir.vtk_io == 2) /* serial */
Output_gzdir.c:	sprintf(message,"POINT_DATA %i\n",E->lmesh.nno*E->parallel.nproc*E->sphere.caps_per_proc);
Output_gzdir.c:	sprintf(message,"POINT_DATA %i\n",E->lmesh.nno*E->sphere.caps_per_proc);
Output_gzdir.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 7, E->parallel.world, &mpi_stat);
Output_gzdir.c:    for(j=1; j<= E->sphere.caps_per_proc;j++) /* print the temperatures */
Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:	cvec[0] = E->T[j][i];
Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2){
Output_gzdir.c:      if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 7, E->parallel.world);
Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, 0, 6, E->parallel.world); /* tell m=0 to go ahead */
Output_gzdir.c:    if((E->output.gzdir.vtk_io == 3) || (E->parallel.me == 0)){
Output_gzdir.c:      if(E->output.gzdir.vtk_io == 2){
Output_gzdir.c:	mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, E->parallel.nproc-1 , 6, E->parallel.world, &mpi_stat);
Output_gzdir.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 5, E->parallel.world, &mpi_stat);
Output_gzdir.c:    for(k=0,j=1;j <= E->sphere.caps_per_proc;j++,k += os)     {
Output_gzdir.c:      if(E->output.gzdir.rnr){
Output_gzdir.c:	for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Output_gzdir.c:	  vcorr[0] = E->sphere.cap[j].V[1][i]; /* vtheta */
Output_gzdir.c:	  vcorr[1] = E->sphere.cap[j].V[2][i]; /* vphi */
Output_gzdir.c:	  sub_netr(E->sx[j][3][i],E->sx[j][1][i],E->sx[j][2][i],(vcorr+0),(vcorr+1),omega);
Output_gzdir.c:	  convert_pvec_to_cvec(E->sphere.cap[j].V[3][i],vcorr[0],vcorr[1],
Output_gzdir.c:			       (E->output.gzdir.vtk_base+k),cvec);
Output_gzdir.c:	for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Output_gzdir.c:	  convert_pvec_to_cvec(E->sphere.cap[j].V[3][i],E->sphere.cap[j].V[1][i],E->sphere.cap[j].V[2][i],
Output_gzdir.c:			       (E->output.gzdir.vtk_base+k),cvec);
Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2){
Output_gzdir.c:      if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 5, E->parallel.world);
Output_gzdir.c:      if(E->parallel.me == 0)
Output_gzdir.c:    if(E->output.gzdir.vtk_io == 1) {
Output_gzdir.c:	       E->control.data_dir,
Output_gzdir.c:	       cycles,E->parallel.me,cycles);
Output_gzdir.c:	       E->control.data_dir,cycles,
Output_gzdir.c:	       E->parallel.me,cycles);
Output_gzdir.c:	     cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output_gzdir.c:    for(j=1; j<= E->sphere.caps_per_proc;j++)     {
Output_gzdir.c:      gzprintf(gzout,"%3d %7d\n",j,E->lmesh.nno);
Output_gzdir.c:      if(E->output.gzdir.vtk_io){
Output_gzdir.c:	for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:	  gzprintf(gzout,"%.6e\n",E->T[j][i]);
Output_gzdir.c:	if(E->output.gzdir.rnr){
Output_gzdir.c:	  for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:	    vcorr[0] = E->sphere.cap[j].V[1][i]; /* vt */
Output_gzdir.c:	    vcorr[1] = E->sphere.cap[j].V[2][i]; /* vphi */
Output_gzdir.c:	    sub_netr(E->sx[j][3][i],E->sx[j][1][i],E->sx[j][2][i],(vcorr+0),(vcorr+1),omega);
Output_gzdir.c:		     E->sphere.cap[j].V[3][i],E->T[j][i]);
Output_gzdir.c:	  for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:		     E->sphere.cap[j].V[1][i],
Output_gzdir.c:		     E->sphere.cap[j].V[2][i],
Output_gzdir.c:		     E->sphere.cap[j].V[3][i],E->T[j][i]);
Output_gzdir.c:    if(E->output.gzdir.vtk_io){
Output_gzdir.c:	       E->control.data_dir,cycles,E->parallel.me,cycles);
Output_gzdir.c:      for(k=0,j=1;j <= E->sphere.caps_per_proc;j++,k += os)     {
Output_gzdir.c:	if(E->output.gzdir.rnr){
Output_gzdir.c:	  for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Output_gzdir.c:	    vcorr[0] = E->sphere.cap[j].V[1][i];
Output_gzdir.c:	    vcorr[1] = E->sphere.cap[j].V[2][i];
Output_gzdir.c:	    sub_netr(E->sx[j][3][i],E->sx[j][1][i],E->sx[j][2][i],(vcorr+0),(vcorr+1),omega);
Output_gzdir.c:	    convert_pvec_to_cvec(E->sphere.cap[j].V[3][i],vcorr[0],vcorr[1],
Output_gzdir.c:				 (E->output.gzdir.vtk_base+k),cvec);
Output_gzdir.c:	  for(i=1;i<=E->lmesh.nno;i++,k += 9) {
Output_gzdir.c:	    convert_pvec_to_cvec(E->sphere.cap[j].V[3][i],
Output_gzdir.c:				 E->sphere.cap[j].V[1][i],
Output_gzdir.c:				 E->sphere.cap[j].V[2][i],
Output_gzdir.c:				 (E->output.gzdir.vtk_base+k),cvec);
Output_gzdir.c:  if(E->output.gzdir.vtk_io){	/* all VTK modes */
Output_gzdir.c:    if(!E->output.gzdir.vtk_base_save)
Output_gzdir.c:      free(E->output.gzdir.vtk_base);
Output_gzdir.c:  int lev = E->mesh.levmax;
Output_gzdir.c:  if(E->output.gzdir.vtk_io < 2){
Output_gzdir.c:	     "%s/%d/visc.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:	     cycles,E->parallel.me, cycles);
Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output_gzdir.c:      gzprintf(gz1,"%3d %7d\n",j,E->lmesh.nno);
Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:	gzprintf(gz1,"%.4e\n",E->VI[lev][j][i]);
Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:    for(j=1; j<= E->sphere.caps_per_proc;j++)
Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:	ftmp = log10(E->VI[lev][j][i]);
Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:      if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:  if((E->output.write_q_files == 0) || (cycles == 0) ||
Output_gzdir.c:     (cycles % E->output.write_q_files)!=0)
Output_gzdir.c:  if(E->control.use_cbf_topo){
Output_gzdir.c:    get_CBF_topo(E,E->slice.tpg,E->slice.tpgb);
Output_gzdir.c:    get_STD_topo(E,E->slice.tpg,E->slice.tpgb,E->slice.divg,E->slice.vort,cycles);
Output_gzdir.c:  if (E->output.surf && (E->parallel.me_loc[3]==E->parallel.nprocz-1)) {
Output_gzdir.c:    snprintf(output_file,255,"%s/%d/surf.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:	    cycles,E->parallel.me, cycles);
Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Output_gzdir.c:        if(E->control.pseudo_free_surf)
Output_gzdir.c:            topo = E->slice.freesurf[j];
Output_gzdir.c:            topo = E->slice.tpg[j];
Output_gzdir.c:        gzprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Output_gzdir.c:        for(i=1;i<=E->lmesh.nsf;i++)   {
Output_gzdir.c:            s = i*E->lmesh.noz;
Output_gzdir.c:		     topo[i],E->slice.shflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Output_gzdir.c:  if (E->output.botm && (E->parallel.me_loc[3]==0)) {
Output_gzdir.c:    snprintf(output_file,255,"%s/%d/botm.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:	    cycles,E->parallel.me, cycles);
Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Output_gzdir.c:      gzprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Output_gzdir.c:      for(i=1;i<=E->lmesh.nsf;i++)  {
Output_gzdir.c:        s = (i-1)*E->lmesh.noz + 1;
Output_gzdir.c:		 E->slice.tpgb[j][i],E->slice.bhflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Output_gzdir.c:    if (E->parallel.me == (E->parallel.nprocz-1))  {
Output_gzdir.c:		 "%s/%d/geoid.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:		cycles,E->parallel.me, cycles);
Output_gzdir.c:        gzprintf(fp1, "%d %d %.5e\n", cycles, E->output.llmax,
Output_gzdir.c:                E->monitor.elapsed_time);
Output_gzdir.c:        for (ll=0; ll<=E->output.llmax; ll++)
Output_gzdir.c:                p = E->sphere.hindex[ll][mm];
Output_gzdir.c:                        E->sphere.harm_geoid[0][p],
Output_gzdir.c:                        E->sphere.harm_geoid[1][p],
Output_gzdir.c:                        E->sphere.harm_geoid_from_tpgt[0][p],
Output_gzdir.c:                        E->sphere.harm_geoid_from_tpgt[1][p],
Output_gzdir.c:                        E->sphere.harm_geoid_from_bncy[0][p],
Output_gzdir.c:                        E->sphere.harm_geoid_from_bncy[1][p]);
Output_gzdir.c:  if(E->control.use_cbf_topo)	{/* for CBF topo, stress will not have been computed */
Output_gzdir.c:  snprintf(output_file,255,"%s/%d/stress.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:	  cycles,E->parallel.me, cycles);
Output_gzdir.c:  gzprintf(fp1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output_gzdir.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Output_gzdir.c:    gzprintf(fp1,"%3d %7d\n",m,E->lmesh.nno);
Output_gzdir.c:    for (node=1;node<=E->lmesh.nno;node++)
Output_gzdir.c:              E->gstress[m][(node-1)*6+1], /*  stt */
Output_gzdir.c:              E->gstress[m][(node-1)*6+2], /*  spp */
Output_gzdir.c:              E->gstress[m][(node-1)*6+3], /*  srr */
Output_gzdir.c:              E->gstress[m][(node-1)*6+4], /*  stp */
Output_gzdir.c:              E->gstress[m][(node-1)*6+5], /*  str */
Output_gzdir.c:              E->gstress[m][(node-1)*6+6]); /* srp */
Output_gzdir.c:  if (E->parallel.me<E->parallel.nprocz)  {
Output_gzdir.c:    snprintf(output_file,255,"%s/%d/horiz_avg.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:	    cycles,E->parallel.me, cycles);
Output_gzdir.c:    for(j=1;j<=E->lmesh.noz;j++)  {
Output_gzdir.c:        gzprintf(fp1,"%.4e %.4e %.4e %.4e",E->sx[1][3][j],E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j]);
Output_gzdir.c:        if (E->composition.on) {
Output_gzdir.c:            for(n=0; n<E->composition.ncomp; n++)
Output_gzdir.c:                gzprintf(fp1," %.4e", E->Have.C[n][j]);
Output_gzdir.c:  snprintf(output_file,255,"%s/mat.%d.gz", E->control.data_dir,E->parallel.me);
Output_gzdir.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Output_gzdir.c:    for(el=1;el<=E->lmesh.nel;el++)
Output_gzdir.c:      gzprintf(fp,"%d %d %f\n", el,E->mat[m][el],E->VIP[m][el]);
Output_gzdir.c:  if(E->output.gzdir.vtk_io < 2){ /* old */
Output_gzdir.c:    snprintf(output_file,255,"%s/%d/pressure.%d.%d.gz", E->control.data_dir,cycles,
Output_gzdir.c:	     E->parallel.me, cycles);
Output_gzdir.c:    gzprintf(gz1,"%d %d %.5e\n",cycles,E->lmesh.nno,E->monitor.elapsed_time);
Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output_gzdir.c:      gzprintf(gz1,"%3d %7d\n",j,E->lmesh.nno);
Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++)
Output_gzdir.c:	gzprintf(gz1,"%.6e\n",E->NP[j][i]);
Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:    if((E->parallel.me == 0) || (E->output.gzdir.vtk_io == 3)){
Output_gzdir.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:    for(j=1; j<= E->sphere.caps_per_proc;j++)
Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:	ftmp = E->NP[j][i];
Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:      if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:	   E->control.data_dir,cycles,
Output_gzdir.c:	   E->parallel.me, cycles);
Output_gzdir.c:  ncolumns = 3 + E->trace.number_of_extra_quantities;
Output_gzdir.c:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output_gzdir.c:      gzprintf(fp1,"%d %d %d %.5e\n", cycles, E->trace.ntracers[j],
Output_gzdir.c:              ncolumns, E->monitor.elapsed_time);
Output_gzdir.c:      for(n=1;n<=E->trace.ntracers[j];n++) {
Output_gzdir.c:                  E->trace.basicq[j][0][n],
Output_gzdir.c:                  E->trace.basicq[j][1][n],
Output_gzdir.c:                  E->trace.basicq[j][2][n]);
Output_gzdir.c:          for (i=0; i<E->trace.number_of_extra_quantities; i++) {
Output_gzdir.c:              gzprintf(fp1," %9.5e", E->trace.extraq[j][i][n]);
Output_gzdir.c:  if(E->output.gzdir.vtk_io < 2){
Output_gzdir.c:	     E->control.data_dir,cycles,
Output_gzdir.c:	     E->parallel.me, cycles);
Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output_gzdir.c:	       j, E->lmesh.nel,
Output_gzdir.c:	       E->monitor.elapsed_time,
Output_gzdir.c:	       E->composition.initial_bulk_composition,
Output_gzdir.c:	       E->composition.bulk_composition);
Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++) {
Output_gzdir.c:	for(k=0;k<E->composition.ncomp;k++)
Output_gzdir.c:	  gzprintf(gz1,"%.6e ",E->composition.comp_node[j][k][i]);
Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2)
Output_gzdir.c:    if((E->output.gzdir.vtk_io==3) || (E->parallel.me == 0)){
Output_gzdir.c:      if(E->composition.ncomp > 4)
Output_gzdir.c:      sprintf(message,"SCALARS composition float %d\n",E->composition.ncomp);
Output_gzdir.c:      mpi_rc = MPI_Recv(&mpi_inmsg, 1, MPI_INT, (E->parallel.me-1), 0, E->parallel.world, &mpi_stat);
Output_gzdir.c:    for(j=1; j<= E->sphere.caps_per_proc;j++)
Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:	for(k=0;k<E->composition.ncomp;k++){
Output_gzdir.c:	  ftmp = E->composition.comp_node[j][k][i];
Output_gzdir.c:    if(E->output.gzdir.vtk_io == 2) /* serial */
Output_gzdir.c:      if(E->parallel.me <  E->parallel.nproc-1){
Output_gzdir.c:	mpi_rc = MPI_Send(&mpi_success_message, 1, MPI_INT, (E->parallel.me+1), 0, E->parallel.world);
Output_gzdir.c:    snprintf(output_file,255,"%s/%d/comp_el.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:	    cycles,E->parallel.me, cycles);
Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output_gzdir.c:                j, E->lmesh.nel,
Output_gzdir.c:                E->monitor.elapsed_time,
Output_gzdir.c:                E->composition.initial_bulk_composition,
Output_gzdir.c:                E->composition.bulk_composition);
Output_gzdir.c:        for(i=1;i<=E->lmesh.nel;i++) {
Output_gzdir.c:	  for(k=0;k<E->composition.ncomp;k++)
Output_gzdir.c:            gzprintf(fp1,"%.6e ",E->composition.comp_el[j][k][i]);
Output_gzdir.c:    snprintf(output_file,255,"%s/%d/heating.%d.%d.gz", E->control.data_dir,
Output_gzdir.c:	    cycles,E->parallel.me, cycles);
Output_gzdir.c:    gzprintf(fp1,"%.5e\n",E->monitor.elapsed_time);
Output_gzdir.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Output_gzdir.c:        gzprintf(fp1,"%3d %7d\n", j, E->lmesh.nel);
Output_gzdir.c:        for(e=1; e<=E->lmesh.nel; e++)
Output_gzdir.c:            gzprintf(fp1, "%.4e %.4e %.4e\n", E->heating_adi[j][e],
Output_gzdir.c:                      E->heating_visc[j][e], E->heating_latent[j][e]);
Output_gzdir.c:  ii = E->monitor.solution_cycles_init;
Output_gzdir.c:  switch(E->output.gzdir.vtk_io){
Output_gzdir.c:	     E->control.data_dir_old,
Output_gzdir.c:	     ii,E->parallel.me,ii);
Output_gzdir.c:	     E->control.data_dir_old,ii,
Output_gzdir.c:	     E->parallel.me,ii);
Output_gzdir.c:  if (E->parallel.me==0){
Output_gzdir.c:    fprintf(E->fp,"restart_tic_from_gzdir_file: using  %s for restarted temperature\n",
Output_gzdir.c:  if(mm != E->lmesh.nno){
Output_gzdir.c:    fprintf(stderr,"%i %i\n",mm, E->lmesh.nno);
Output_gzdir.c:  switch(E->output.gzdir.vtk_io) {
Output_gzdir.c:    for(m=1;m <= E->sphere.caps_per_proc;m++) {
Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++){
Output_gzdir.c:	E->T[m][i] = g;
Output_gzdir.c:    for(m=1;m <= E->sphere.caps_per_proc;m++) {
Output_gzdir.c:      for(i=1;i<=E->lmesh.nno;i++)  {
Output_gzdir.c:	/*  E->sphere.cap[m].V[1][i] = v1;
Output_gzdir.c:	    E->sphere.cap[m].V[1][i] = v2;
Output_gzdir.c:	    E->sphere.cap[m].V[1][i] = v3;  */
Output_gzdir.c:	//E->T[m][i] = max(0.0,min(g,1.0));
Output_gzdir.c:	E->T[m][i] = g;
Output_gzdir.c:  if(E->output.gzdir.vtk_io == 2){ /* serial */
Output_gzdir.c:	       E->control.data_dir);
Output_gzdir.c:	       E->control.data_dir, E->output.gzdir.vtk_ocount);
Output_gzdir.c:	       E->control.data_dir,E->parallel.me);
Output_gzdir.c:	       E->control.data_dir,cycles,
Output_gzdir.c:	       E->output.gzdir.vtk_ocount,
Output_gzdir.c:	       E->parallel.me);
Output_h5.c:    int nprocx = E->parallel.nprocx;
Output_h5.c:    int nprocy = E->parallel.nprocy;
Output_h5.c:    int nprocz = E->parallel.nprocz;
Output_h5.c:    E->hdf5.cap = (E->parallel.me) / (nprocx * nprocy * nprocz);
Output_h5.c:    if (E->output.stress == 1)
Output_h5.c:        E->hdf5.data = (float *)malloc((tensor3d->n) * sizeof(float));
Output_h5.c:        E->hdf5.data = (float *)malloc((vector3d->n) * sizeof(float));
Output_h5.c:    tensor3d->data = E->hdf5.data;
Output_h5.c:    vector3d->data = E->hdf5.data;
Output_h5.c:    vector2d->data = E->hdf5.data;
Output_h5.c:    scalar3d->data = E->hdf5.data;
Output_h5.c:    scalar2d->data = E->hdf5.data;
Output_h5.c:    scalar1d->data = E->hdf5.data;
Output_h5.c:    E->hdf5.tensor3d = tensor3d;
Output_h5.c:    E->hdf5.vector3d = vector3d;
Output_h5.c:    E->hdf5.vector2d = vector2d;
Output_h5.c:    E->hdf5.scalar3d = scalar3d;
Output_h5.c:    E->hdf5.scalar2d = scalar2d;
Output_h5.c:    E->hdf5.scalar1d = scalar1d;
Output_h5.c: * These represent possible choices for (E->output) function pointer.       *
Output_h5.c:    if(E->parallel.me == 0)
Output_h5.c:        if (E->output.coord_bin)
Output_h5.c:    int m = E->parallel.me;
Output_h5.c:    input_int("cb_block_size", &(E->output.cb_block_size), "1048576", m);
Output_h5.c:    input_int("cb_buffer_size", &(E->output.cb_buffer_size), "4194304", m);
Output_h5.c:    input_int("sieve_buf_size", &(E->output.sieve_buf_size), "1048576", m);
Output_h5.c:    input_int("output_alignment", &(E->output.alignment), "262144", m);
Output_h5.c:    input_int("output_alignment_threshold", &(E->output.alignment_threshold), "524288", m);
Output_h5.c:    input_int("cache_mdc_nelmts", &(E->output.cache_mdc_nelmts), "10330", m);
Output_h5.c:    input_int("cache_rdcc_nelmts", &(E->output.cache_rdcc_nelmts), "521", m);
Output_h5.c:    input_int("cache_rdcc_nbytes", &(E->output.cache_rdcc_nbytes), "1048576", m);
Output_h5.c:    snprintf(filename, (size_t)100, "%s.h5", E->control.data_file);
Output_h5.c:             E->control.data_file, cycles);
Output_h5.c:    if(E->control.tracer == 1)
Output_h5.c:    if(E->output.geoid == 1)
Output_h5.c:    if(E->output.stress == 1){
Output_h5.c:    if(E->output.pressure == 1)
Output_h5.c:    if (E->output.horiz_avg == 1)
Output_h5.c:    MPI_Comm comm = E->parallel.world;
Output_h5.c:    snprintf(tmp, (size_t)100, "%d", E->output.cb_block_size);
Output_h5.c:    snprintf(tmp, (size_t)100, "%d", E->output.cb_buffer_size);
Output_h5.c:    status = H5Pset_sieve_buf_size(fapl_id, (size_t)(E->output.sieve_buf_size));
Output_h5.c:    status = H5Pset_alignment(fapl_id, (hsize_t)(E->output.alignment_threshold),
Output_h5.c:                                       (hsize_t)(E->output.alignment));
Output_h5.c:    status = H5Pset_cache(fapl_id, E->output.cache_mdc_nelmts,
Output_h5.c:                                   (size_t)(E->output.cache_rdcc_nelmts),
Output_h5.c:                                   (size_t)(E->output.cache_rdcc_nbytes),
Output_h5.c:    E->hdf5.file_id = file_id;
Output_h5.c:    status = H5Fclose(E->hdf5.file_id);
Output_h5.c:    field = E->hdf5.vector3d;
Output_h5.c:    nx = E->lmesh.nox;
Output_h5.c:    ny = E->lmesh.noy;
Output_h5.c:    nz = E->lmesh.noz;
Output_h5.c:                field->data[3*m+0] = E->sx[1][1][n+1];
Output_h5.c:                field->data[3*m+1] = E->sx[1][2][n+1];
Output_h5.c:                field->data[3*m+2] = E->sx[1][3][n+1];
Output_h5.c:    h5create_field(E->hdf5.file_id, field, "coord", "coordinates of nodes");
Output_h5.c:    dataset = H5Dopen(E->hdf5.file_id, "/coord");
Output_h5.c:    field = E->hdf5.vector3d;
Output_h5.c:    nx = E->lmesh.nox;
Output_h5.c:    ny = E->lmesh.noy;
Output_h5.c:    nz = E->lmesh.noz;
Output_h5.c:                field->data[3*m+0] = E->sphere.cap[1].V[1][n+1];
Output_h5.c:                field->data[3*m+1] = E->sphere.cap[1].V[2][n+1];
Output_h5.c:                field->data[3*m+2] = E->sphere.cap[1].V[3][n+1];
Output_h5.c:    h5create_field(E->hdf5.file_id, field, "velocity", "velocity values on nodes");
Output_h5.c:    dataset = H5Dopen(E->hdf5.file_id, "/velocity");
Output_h5.c:    field = E->hdf5.scalar3d;
Output_h5.c:    nx = E->lmesh.nox;
Output_h5.c:    ny = E->lmesh.noy;
Output_h5.c:    nz = E->lmesh.noz;
Output_h5.c:                field->data[m] = E->T[1][n+1];
Output_h5.c:    h5create_field(E->hdf5.file_id, field, "temperature", "temperature values on nodes");
Output_h5.c:    dataset = H5Dopen(E->hdf5.file_id, "/temperature");
Output_h5.c:    field = E->hdf5.scalar3d;
Output_h5.c:    lev = E->mesh.levmax;
Output_h5.c:    nx = E->lmesh.nox;
Output_h5.c:    ny = E->lmesh.noy;
Output_h5.c:    nz = E->lmesh.noz;
Output_h5.c:                field->data[m] = E->VI[lev][1][n+1];
Output_h5.c:    h5create_field(E->hdf5.file_id, field, "viscosity", "viscosity values on nodes");
Output_h5.c:    dataset = H5Dopen(E->hdf5.file_id, "/viscosity");
Output_h5.c:    field = E->hdf5.scalar3d;
Output_h5.c:    nx = E->lmesh.nox;
Output_h5.c:    ny = E->lmesh.noy;
Output_h5.c:    nz = E->lmesh.noz;
Output_h5.c:                field->data[m] = E->NP[1][n+1];
Output_h5.c:    h5create_field(E->hdf5.file_id, field, "pressure", "pressure values on nodes");
Output_h5.c:    dataset = H5Dopen(E->hdf5.file_id, "/pressure");
Output_h5.c:    if(E->control.use_cbf_topo)	{/* for CBF topo, stress will not have been computed */
Output_h5.c:    field = E->hdf5.tensor3d;
Output_h5.c:    nx = E->lmesh.nox;
Output_h5.c:    ny = E->lmesh.noy;
Output_h5.c:    nz = E->lmesh.noz;
Output_h5.c:                field->data[6*m+0] = E->gstress[1][6*n+1];
Output_h5.c:                field->data[6*m+1] = E->gstress[1][6*n+2];
Output_h5.c:                field->data[6*m+2] = E->gstress[1][6*n+3];
Output_h5.c:                field->data[6*m+3] = E->gstress[1][6*n+4];
Output_h5.c:                field->data[6*m+4] = E->gstress[1][6*n+5];
Output_h5.c:                field->data[6*m+5] = E->gstress[1][6*n+6];
Output_h5.c:    h5create_field(E->hdf5.file_id, field, "stress", "stress values on nodes");
Output_h5.c:    dataset = H5Dopen(E->hdf5.file_id, "/stress");
Output_h5.c:    int pz = E->parallel.me_loc[3];
Output_h5.c:    int nprocz = E->parallel.nprocz;
Output_h5.c:    field = E->hdf5.vector2d;
Output_h5.c:    nx = E->lmesh.nox;
Output_h5.c:    ny = E->lmesh.noy;
Output_h5.c:    nz = E->lmesh.noz;
Output_h5.c:    if (E->output.surf == 1)
Output_h5.c:                field->data[2*m+0] = E->sx[1][1][n+1];
Output_h5.c:                field->data[2*m+1] = E->sx[1][2][n+1];
Output_h5.c:        dataset = H5Dopen(E->hdf5.file_id, "/surf/coord");
Output_h5.c:    if (E->output.botm == 1)
Output_h5.c:                field->data[2*m+0] = E->sx[1][1][n+1];
Output_h5.c:                field->data[2*m+1] = E->sx[1][2][n+1];
Output_h5.c:        dataset = H5Dopen(E->hdf5.file_id, "/botm/coord");
Output_h5.c:    int pz = E->parallel.me_loc[3];
Output_h5.c:    int nprocz = E->parallel.nprocz;
Output_h5.c:    file_id = E->hdf5.file_id;
Output_h5.c:    scalar = E->hdf5.scalar2d;
Output_h5.c:    vector = E->hdf5.vector2d;
Output_h5.c:    nx = E->lmesh.nox;
Output_h5.c:    ny = E->lmesh.noy;
Output_h5.c:    nz = E->lmesh.noz;
Output_h5.c:    if((E->output.write_q_files == 0) || (cycles == 0) ||
Output_h5.c:       (cycles % E->output.write_q_files)!=0)
Output_h5.c:    if(E->control.use_cbf_topo){
Output_h5.c:      get_CBF_topo(E, E->slice.tpg, E->slice.tpgb);
Output_h5.c:      get_STD_topo(E, E->slice.tpg, E->slice.tpgb, E->slice.divg, E->slice.vort, cycles);
Output_h5.c:    if (E->output.surf == 1)
Output_h5.c:        h5create_field(surf_group, E->hdf5.vector2d, "velocity",
Output_h5.c:        h5create_field(surf_group, E->hdf5.scalar2d, "heatflux",
Output_h5.c:        h5create_field(surf_group, E->hdf5.scalar2d, "topography",
Output_h5.c:                vector->data[2*m+0] = E->sphere.cap[1].V[1][n+1];
Output_h5.c:                vector->data[2*m+1] = E->sphere.cap[1].V[2][n+1];
Output_h5.c:                scalar->data[m] = E->slice.shflux[1][n+1];
Output_h5.c:        if (E->control.pseudo_free_surf)
Output_h5.c:            topo = E->slice.freesurf[1];
Output_h5.c:            topo = E->slice.tpg[1];
Output_h5.c:    if (E->output.botm == 1)
Output_h5.c:        h5create_field(botm_group, E->hdf5.vector2d, "velocity",
Output_h5.c:        h5create_field(botm_group, E->hdf5.scalar2d, "heatflux",
Output_h5.c:        h5create_field(botm_group, E->hdf5.scalar2d, "topography",
Output_h5.c:                vector->data[2*m+0] = E->sphere.cap[1].V[1][n+1];
Output_h5.c:                vector->data[2*m+1] = E->sphere.cap[1].V[2][n+1];
Output_h5.c:                scalar->data[m] = E->slice.bhflux[1][n+1];
Output_h5.c:        topo = E->slice.tpg[1];
Output_h5.c:    int px = E->parallel.me_loc[1];
Output_h5.c:    int py = E->parallel.me_loc[2];
Output_h5.c:    field = E->hdf5.scalar1d;
Output_h5.c:    if (E->output.horiz_avg == 1)
Output_h5.c:            field->data[k] = E->sx[1][3][k+1];
Output_h5.c:        dataset = H5Dopen(E->hdf5.file_id, "/horiz_avg/coord");
Output_h5.c:    int px = E->parallel.me_loc[1];
Output_h5.c:    int py = E->parallel.me_loc[2];
Output_h5.c:    file_id = E->hdf5.file_id;
Output_h5.c:    field = E->hdf5.scalar1d;
Output_h5.c:    h5create_field(avg_group, E->hdf5.scalar1d, "temperature",
Output_h5.c:    h5create_field(avg_group, E->hdf5.scalar1d, "velocity_xy",
Output_h5.c:    h5create_field(avg_group, E->hdf5.scalar1d, "velocity_z",
Output_h5.c:        field->data[k] = E->Have.T[k+1];
Output_h5.c:        field->data[k] = E->Have.V[1][k+1];
Output_h5.c:        field->data[k] = E->Have.V[2][k+1];
Output_h5.c:    hsize_t dim = E->sphere.hindice;
Output_h5.c:    dataset = H5Dcreate(E->hdf5.file_id, "geoid", datatype,
Output_h5.c:    if (E->parallel.me == 0) {
Output_h5.c:        row = (struct HDF5_GEOID *) malloc((E->sphere.hindice)
Output_h5.c:        for(ll = 0; ll <= E->output.llmax; ll++)
Output_h5.c:                row[i].total_sin = E->sphere.harm_geoid[0][i];
Output_h5.c:                row[i].total_cos = E->sphere.harm_geoid[1][i];
Output_h5.c:                row[i].tpgt_sin = E->sphere.harm_geoid_from_tpgt[0][i];
Output_h5.c:                row[i].tpgt_cos = E->sphere.harm_geoid_from_tpgt[1][i];
Output_h5.c:                row[i].bncy_sin = E->sphere.harm_geoid_from_bncy[0][i];
Output_h5.c:                row[i].bncy_cos = E->sphere.harm_geoid_from_bncy[1][i];
Output_h5.c:    int px = E->parallel.me_loc[1];
Output_h5.c:    int py = E->parallel.me_loc[2];
Output_h5.c:    int pz = E->parallel.me_loc[3];
Output_h5.c:    int nprocx = E->parallel.nprocx;
Output_h5.c:    int nprocy = E->parallel.nprocy;
Output_h5.c:    int nprocz = E->parallel.nprocz;
Output_h5.c:    int nel = E->lmesh.nel;
Output_h5.c:    if (E->output.connectivity == 1)
Output_h5.c:            ien = E->ien[1][e+1].node;
Output_h5.c:        h5create_connectivity(E->hdf5.file_id, E->lmesh.nel * procs_per_cap);
Output_h5.c:        dataset = H5Dopen(E->hdf5.file_id, "/connectivity");
Output_h5.c:                                 0, (E->hdf5.cap == 0));
Output_h5.c:    root = H5Gopen(E->hdf5.file_id, "/");
Output_h5.c:    status = set_attribute_float(root, "time", E->monitor.elapsed_time);
Output_h5.c:    input = h5create_group(E->hdf5.file_id, "input", (size_t)0);
Output_h5.c:    status = set_attribute_int(input, "PID", E->control.PID);
Output_h5.c:    status = set_attribute_int(input, "ADV", E->advection.ADVECTION);
Output_h5.c:    status = set_attribute_int(input, "filter_temp", E->advection.filter_temperature);
Output_h5.c:    status = set_attribute_float(input, "finetunedt", E->advection.fine_tune_dt);
Output_h5.c:    status = set_attribute_float(input, "fixed_timestep", E->advection.fixed_timestep);
Output_h5.c:    status = set_attribute_float(input, "inputdiffusivity", E->control.inputdiff);
Output_h5.c:    status = set_attribute_int(input, "adv_sub_iterations", E->advection.temp_iterations);
Output_h5.c:    status = set_attribute_int(input, "side_sbcs", E->control.side_sbcs);
Output_h5.c:    status = set_attribute_int(input, "pseudo_free_surf", E->control.pseudo_free_surf);
Output_h5.c:    status = set_attribute_int(input, "topvbc", E->mesh.topvbc);
Output_h5.c:    status = set_attribute_float(input, "topvbxval", E->control.VBXtopval);
Output_h5.c:    status = set_attribute_float(input, "topvbyval", E->control.VBYtopval);
Output_h5.c:    status = set_attribute_int(input, "botvbc", E->mesh.botvbc);
Output_h5.c:    status = set_attribute_float(input, "botvbxval", E->control.VBXbotval);
Output_h5.c:    status = set_attribute_float(input, "botvbyval", E->control.VBYbotval);
Output_h5.c:    status = set_attribute_int(input, "toptbc", E->mesh.toptbc);
Output_h5.c:    status = set_attribute_float(input, "toptbcval", E->control.TBCtopval);
Output_h5.c:    status = set_attribute_int(input, "bottbc", E->mesh.bottbc);
Output_h5.c:    status = set_attribute_float(input, "bottbcval", E->control.TBCbotval);
Output_h5.c:    status = set_attribute_int(input, "temperature_bound_adj", E->control.temperature_bound_adj);
Output_h5.c:    status = set_attribute_float(input, "depth_bound_adj", E->control.depth_bound_adj);
Output_h5.c:    status = set_attribute_float(input, "width_bound_adj", E->control.width_bound_adj);
Output_h5.c:    status = set_attribute_float(input, "density", E->data.density);
Output_h5.c:    status = set_attribute_float(input, "thermdiff", E->data.therm_diff);
Output_h5.c:    status = set_attribute_float(input, "gravacc", E->data.grav_acc);
Output_h5.c:    status = set_attribute_float(input, "thermexp", E->data.therm_exp);
Output_h5.c:    status = set_attribute_float(input, "refvisc", E->data.ref_viscosity);
Output_h5.c:    status = set_attribute_float(input, "cp", E->data.Cp);
Output_h5.c:    status = set_attribute_float(input, "density_above", E->data.density_above);
Output_h5.c:    status = set_attribute_float(input, "density_below", E->data.density_below);
Output_h5.c:    status = set_attribute_float(input, "z_lith", E->viscosity.zlith);
Output_h5.c:    status = set_attribute_float(input, "z_410", E->viscosity.z410);
Output_h5.c:    status = set_attribute_float(input, "z_lmantle", E->viscosity.zlm);
Output_h5.c:    status = set_attribute_float(input, "z_cmb", E->viscosity.zcmb);
Output_h5.c:    status = set_attribute_float(input, "radius_km", E->data.radius_km);
Output_h5.c:    status = set_attribute_float(input, "scalev", E->data.scalev);
Output_h5.c:    status = set_attribute_float(input, "scalet", E->data.scalet);
Output_h5.c:    status = set_attribute_int(input, "restart", E->control.restart);
Output_h5.c:    status = set_attribute_int(input, "post_p", E->control.post_p);
Output_h5.c:    status = set_attribute_int(input, "solution_cycles_init", E->monitor.solution_cycles_init);
Output_h5.c:    status = set_attribute_int(input, "zero_elapsed_time", E->control.zero_elapsed_time);
Output_h5.c:    status = set_attribute_int(input, "tic_method", E->convection.tic_method);
Output_h5.c:    n = E->convection.number_of_perturbations;
Output_h5.c:    status = set_attribute_int_vector(input, "perturbl", n, E->convection.perturb_ll);
Output_h5.c:    status = set_attribute_int_vector(input, "perturbm", n, E->convection.perturb_mm);
Output_h5.c:    status = set_attribute_int_vector(input, "perturblayer", n, E->convection.load_depth);
Output_h5.c:    status = set_attribute_float_vector(input, "perturbmag", n, E->convection.perturb_mag);
Output_h5.c:    status = set_attribute_float(input, "half_space_age", E->convection.half_space_age);
Output_h5.c:    status = set_attribute_float(input, "mantle_temp", E->control.mantle_temp);
Output_h5.c:    if (E->convection.tic_method == 2)
Output_h5.c:        status = set_attribute_float_vector(input, "blob_center", 3, E->convection.blob_center);
Output_h5.c:        status = set_attribute_float(input, "blob_radius", E->convection.blob_radius);
Output_h5.c:        status = set_attribute_float(input, "blob_dT", E->convection.blob_dT);
Output_h5.c:    status = set_attribute_int(input, "file_vbcs", E->control.vbcs_file);
Output_h5.c:    status = set_attribute_string(input, "vel_bound_file", E->control.velocity_boundary_file);
Output_h5.c:    status = set_attribute_int(input, "file_tbcs", E->control.tbcs_file);
Output_h5.c:    status = set_attribute_string(input, "temp_bound_file", E->control.temperature_boundary_file);
Output_h5.c:    status = set_attribute_int(input, "mat_control", E->control.mat_control);
Output_h5.c:    status = set_attribute_string(input, "mat_file", E->control.mat_file);
Output_h5.c:    status = set_attribute_int(input, "lith_age", E->control.lith_age);
Output_h5.c:    status = set_attribute_string(input, "lith_age_file", E->control.lith_age_file);
Output_h5.c:    status = set_attribute_int(input, "lith_age_time", E->control.lith_age_time);
Output_h5.c:    status = set_attribute_float(input, "lith_age_depth", E->control.lith_age_depth);
Output_h5.c:    status = set_attribute_float(input, "start_age", E->control.start_age);
Output_h5.c:    status = set_attribute_int(input, "reset_startage", E->control.reset_startage);
Output_h5.c:    status = set_attribute_float(input, "Ra_410", E->control.Ra_410);
Output_h5.c:    status = set_attribute_float(input, "clapeyron410", E->control.clapeyron410);
Output_h5.c:    status = set_attribute_float(input, "transT410", E->control.transT410);
Output_h5.c:                                 (E->control.inv_width410 == 0)?
Output_h5.c:                                 E->control.inv_width410 :
Output_h5.c:				 1.0/E->control.inv_width410);
Output_h5.c:    status = set_attribute_float(input, "Ra_670", E->control.Ra_670);
Output_h5.c:    status = set_attribute_float(input, "clapeyron670", E->control.clapeyron670);
Output_h5.c:    status = set_attribute_float(input, "transT670", E->control.transT670);
Output_h5.c:                                 (E->control.inv_width670 == 0)?
Output_h5.c:                                 E->control.inv_width670 :
Output_h5.c:				 1.0/E->control.inv_width670);
Output_h5.c:    status = set_attribute_float(input, "Ra_cmb", E->control.Ra_cmb);
Output_h5.c:    status = set_attribute_float(input, "clapeyroncmb", E->control.clapeyroncmb);
Output_h5.c:    status = set_attribute_float(input, "transTcmb", E->control.transTcmb);
Output_h5.c:                                 (E->control.inv_widthcmb == 0)?
Output_h5.c:                                 E->control.inv_widthcmb :
Output_h5.c:				 1.0/E->control.inv_widthcmb);
Output_h5.c:    status = set_attribute_string(input, "datadir", E->control.data_dir);
Output_h5.c:    status = set_attribute_string(input, "datafile", E->control.data_file);
Output_h5.c:    status = set_attribute_string(input, "datadir_old", E->control.data_dir_old);
Output_h5.c:    status = set_attribute_string(input, "datafile_old", E->control.old_P_file);
Output_h5.c:    status = set_attribute_float(input, "rayleigh", E->control.Atemp);
Output_h5.c:    status = set_attribute_float(input, "dissipation_number", E->control.disptn_number);
Output_h5.c:                                 (E->control.inv_gruneisen == 0)?
Output_h5.c:                                  1.0/E->control.inv_gruneisen :
Output_h5.c:				 E->control.inv_gruneisen);
Output_h5.c:    status = set_attribute_float(input, "surfaceT", E->control.surface_temp);
Output_h5.c:    status = set_attribute_float(input, "Q0", E->control.Q0);
Output_h5.c:    status = set_attribute_int(input, "stokes_flow_only", E->control.stokes);
Output_h5.c:    status = set_attribute_string(input, "output_format", E->output.format);
Output_h5.c:    status = set_attribute_string(input, "output_optional", E->output.optional);
Output_h5.c:    status = set_attribute_int(input, "output_ll_max", E->output.llmax);
Output_h5.c:    status = set_attribute_int(input, "verbose", E->control.verbose);
Output_h5.c:    status = set_attribute_int(input, "see_convergence", E->control.print_convergence);
Output_h5.c:    status = set_attribute_int(input, "nproc_surf", E->parallel.nprocxy);
Output_h5.c:    status = set_attribute_int(input, "nprocx", E->parallel.nprocx);
Output_h5.c:    status = set_attribute_int(input, "nprocy", E->parallel.nprocy);
Output_h5.c:    status = set_attribute_int(input, "nprocz", E->parallel.nprocz);
Output_h5.c:    status = set_attribute_int(input, "coor", E->control.coor);
Output_h5.c:    status = set_attribute_string(input, "coor_file", E->control.coor_file);
Output_h5.c:    status = set_attribute_int(input, "nodex", E->mesh.nox);
Output_h5.c:    status = set_attribute_int(input, "nodey", E->mesh.noy);
Output_h5.c:    status = set_attribute_int(input, "nodez", E->mesh.noz);
Output_h5.c:    status = set_attribute_int(input, "levels", E->mesh.levels);
Output_h5.c:    status = set_attribute_int(input, "mgunitx", E->mesh.mgunitx);
Output_h5.c:    status = set_attribute_int(input, "mgunity", E->mesh.mgunity);
Output_h5.c:    status = set_attribute_int(input, "mgunitz", E->mesh.mgunitz);
Output_h5.c:    status = set_attribute_double(input, "radius_outer", E->sphere.ro);
Output_h5.c:    status = set_attribute_double(input, "radius_inner", E->sphere.ri);
Output_h5.c:    status = set_attribute_int(input, "caps", E->sphere.caps);
Output_h5.c:    dims[0] = E->sphere.caps;
Output_h5.c:    for(n = 1; n <= E->sphere.caps; n++)
Output_h5.c:        data[4*(n-1) + 0] = E->sphere.cap[n].theta[1];
Output_h5.c:        data[4*(n-1) + 1] = E->sphere.cap[n].theta[2];
Output_h5.c:        data[4*(n-1) + 2] = E->sphere.cap[n].theta[3];
Output_h5.c:        data[4*(n-1) + 3] = E->sphere.cap[n].theta[4];
Output_h5.c:    for(n = 1; n <= E->sphere.caps; n++)
Output_h5.c:        data[4*(n-1) + 0] = E->sphere.cap[n].fi[1];
Output_h5.c:        data[4*(n-1) + 1] = E->sphere.cap[n].fi[2];
Output_h5.c:        data[4*(n-1) + 2] = E->sphere.cap[n].fi[3];
Output_h5.c:        data[4*(n-1) + 3] = E->sphere.cap[n].fi[4];
Output_h5.c:    if (E->sphere.caps == 1)
Output_h5.c:        status = set_attribute_double(input, "theta_min", E->control.theta_min);
Output_h5.c:        status = set_attribute_double(input, "theta_max", E->control.theta_max);
Output_h5.c:        status = set_attribute_double(input, "fi_min", E->control.fi_min);
Output_h5.c:        status = set_attribute_double(input, "fi_max", E->control.fi_max);
Output_h5.c:    status = set_attribute_int(input, "tracer", E->control.tracer);
Output_h5.c:    status = set_attribute_string(input, "tracer_file", E->trace.tracer_file);
Output_h5.c:    status = set_attribute_string(input, "Viscosity", E->viscosity.STRUCTURE);
Output_h5.c:    status = set_attribute_int(input, "visc_smooth_method", E->viscosity.smooth_cycles);
Output_h5.c:    status = set_attribute_int(input, "VISC_UPDATE", E->viscosity.update_allowed);
Output_h5.c:    n = E->viscosity.num_mat;
Output_h5.c:    status = set_attribute_float_vector(input, "visc0", n, E->viscosity.N0);
Output_h5.c:    status = set_attribute_int(input, "TDEPV", E->viscosity.TDEPV);
Output_h5.c:    status = set_attribute_int(input, "rheol", E->viscosity.RHEOL);
Output_h5.c:    status = set_attribute_float_vector(input, "viscE", n, E->viscosity.E);
Output_h5.c:    status = set_attribute_float_vector(input, "viscT", n, E->viscosity.T);
Output_h5.c:    status = set_attribute_float_vector(input, "viscZ", n, E->viscosity.Z);
Output_h5.c:    status = set_attribute_int(input, "SDEPV", E->viscosity.SDEPV);
Output_h5.c:    status = set_attribute_float(input, "sdepv_misfit", E->viscosity.sdepv_misfit);
Output_h5.c:    status = set_attribute_float_vector(input, "sdepv_expt", n, E->viscosity.sdepv_expt);
Output_h5.c:    status = set_attribute_int(input, "VMIN", E->viscosity.MIN);
Output_h5.c:    status = set_attribute_float(input, "visc_min", E->viscosity.min_value);
Output_h5.c:    status = set_attribute_int(input, "VMAX", E->viscosity.MAX);
Output_h5.c:    status = set_attribute_float(input, "visc_max", E->viscosity.max_value);
Output_h5.c:    status = set_attribute_string(input, "Solver", E->control.SOLVER_TYPE);
Output_h5.c:    status = set_attribute_int(input, "node_assemble", E->control.NASSEMBLE);
Output_h5.c:    status = set_attribute_int(input, "precond", E->control.precondition);
Output_h5.c:    status = set_attribute_double(input, "accuracy", E->control.accuracy);
Output_h5.c:    status = set_attribute_int(input, "mg_cycle", E->control.mg_cycle);
Output_h5.c:    status = set_attribute_int(input, "down_heavy", E->control.down_heavy);
Output_h5.c:    status = set_attribute_int(input, "up_heavy", E->control.up_heavy);
Output_h5.c:    status = set_attribute_int(input, "vlowstep", E->control.v_steps_low);
Output_h5.c:    status = set_attribute_int(input, "vhighstep", E->control.v_steps_high);
Output_h5.c:    status = set_attribute_int(input, "piterations", E->control.p_iterations);
Output_h5.c:    status = set_attribute_int(input, "aug_lagr", E->control.augmented_Lagr);
Output_h5.c:    status = set_attribute_double(input, "aug_number", E->control.augmented);
Output_h5.c:    /* status = set_attribute(input, "", H5T_NATIVE_, &(E->)); */
Output_h5.c:    px = E->parallel.me_loc[1];
Output_h5.c:    py = E->parallel.me_loc[2];
Output_h5.c:    pz = E->parallel.me_loc[3];
Output_h5.c:    nprocx = E->parallel.nprocx;
Output_h5.c:    nprocy = E->parallel.nprocy;
Output_h5.c:    nprocz = E->parallel.nprocz;
Output_h5.c:    nodex = E->mesh.nox;
Output_h5.c:    nodey = E->mesh.noy;
Output_h5.c:    nodez = E->mesh.noz;
Output_h5.c:    nx = E->lmesh.nox;
Output_h5.c:    ny = E->lmesh.noy;
Output_h5.c:    nz = E->lmesh.noz;
Output_h5.c:            (*field)->dims[s] = E->sphere.caps;
Output_h5.c:            (*field)->maxdims[s] = E->sphere.caps;
Output_h5.c:            (*field)->offset[s] = E->hdf5.cap;
Output_h5.c:        if(E->control.verbose) {
Output_h5.c:            fprintf(E->fp_out, "creating dataset: rank=%d  size=%d\n",
Output_h5.c:            fprintf(E->fp_out, "  s=%d  x=%d  y=%d  z=%d  c=%d\n",
Output_h5.c:            fprintf(E->fp_out, "\tdim\tmaxdim\toffset\tstride\tcount\tblock\n");
Output_h5.c:                fprintf(E->fp_out, "\t%d\t%d\t%d\t%d\t%d\t%d\n",
Output_vtk.c:             E->lmesh.exs, E->lmesh.exs + E->lmesh.elx,
Output_vtk.c:             E->lmesh.eys, E->lmesh.eys + E->lmesh.ely,
Output_vtk.c:             E->lmesh.ezs, E->lmesh.ezs + E->lmesh.elz);
Output_vtk.c:    for(j=1; j<=E->sphere.caps_per_proc; j++) {
Output_vtk.c:        for(i=1; i<=E->lmesh.nno; i++) {
Output_vtk.c:            fprintf(fp, "%.6e\n", E->T[j][i]);
Output_vtk.c:    const int lev = E->mesh.levmax;
Output_vtk.c:    for(j=1; j<=E->sphere.caps_per_proc; j++) {
Output_vtk.c:        V[1] = E->sphere.cap[j].V[1];
Output_vtk.c:        V[2] = E->sphere.cap[j].V[2];
Output_vtk.c:        V[3] = E->sphere.cap[j].V[3];
Output_vtk.c:        for(i=1; i<=E->lmesh.nno; i++) {
Output_vtk.c:            sint = E->SinCos[lev][j][0][i];
Output_vtk.c:            sinf = E->SinCos[lev][j][1][i];
Output_vtk.c:            cost = E->SinCos[lev][j][2][i];
Output_vtk.c:            cosf = E->SinCos[lev][j][3][i];
Output_vtk.c:    int lev = E->mesh.levmax;
Output_vtk.c:    for(j=1; j<=E->sphere.caps_per_proc; j++) {
Output_vtk.c:        for(i=1; i<=E->lmesh.nno; i++)
Output_vtk.c:            fprintf(fp, "%.4e\n", E->VI[lev][j][i]);
Output_vtk.c:    for(j=1; j<=E->sphere.caps_per_proc; j++) {
Output_vtk.c:        for(i=1; i<=E->lmesh.nno; i++)
Output_vtk.c:                    E->x[j][1][i],
Output_vtk.c:                    E->x[j][2][i],
Output_vtk.c:                    E->x[j][3][i]);
Output_vtk.c:             E->control.data_file, E->parallel.me, cycles);
Pan_problem_misc_functions.c:   if (E->parallel.me==0) {
Pan_problem_misc_functions.c:    sprintf(unique_name,"%06d.%s-%s",E->control.PID,comment,name);
Pan_problem_misc_functions.c:  /* This function is called only when E->control.side_sbcs is true.
Pan_problem_misc_functions.c:  if(E->parallel.total_surf_proc==12) {
Pan_problem_misc_functions.c:  for(m=1; m<=E->sphere.caps_per_proc; m++) {
Pan_problem_misc_functions.c:    E->sbc.node[m] = (int* ) malloc((E->lmesh.nno+1)*sizeof(int));
Pan_problem_misc_functions.c:    for(i=1; i<=E->lmesh.nno; i++) {
Pan_problem_misc_functions.c:      if(E->node[m][i] & sbc_flags) {
Pan_problem_misc_functions.c:	E->sbc.node[m][i] = n;
Pan_problem_misc_functions.c:	E->sbc.node[m][i] = 0;
Pan_problem_misc_functions.c:      for(d=1; d<=E->mesh.nsd; d++) {
Pan_problem_misc_functions.c:	E->sbc.SB[m][side][d] = (double *) malloc(n*sizeof(double));
Pan_problem_misc_functions.c:	  E->sbc.SB[m][side][d][i] = 0;
Pan_problem_misc_functions.c:    for(d=1; d<=E->mesh.nsd; d++)
Pan_problem_misc_functions.c:      for(i=1; i<=E->lmesh.nno; i++)
Pan_problem_misc_functions.c:	if(E->node[m][i] & sbc_flag[d] && E->sphere.cap[m].VB[d][i] != 0) {
Pan_problem_misc_functions.c:	  j = E->sbc.node[m][i];
Pan_problem_misc_functions.c:	    E->sbc.SB[m][side][d][j] = E->sphere.cap[m].VB[d][i];
Pan_problem_misc_functions.c:    int lev = E->mesh.levmax;
Pan_problem_misc_functions.c:    nxny = E->lmesh.nox*E->lmesh.noy;
Pan_problem_misc_functions.c:    temp = E->control.Atemp;
Pan_problem_misc_functions.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Pan_problem_misc_functions.c:      for(i=1;i<=E->lmesh.nno;i++) {
Pan_problem_misc_functions.c:	nz = ((i-1) % E->lmesh.noz) + 1;
Pan_problem_misc_functions.c:        buoy[m][i] =  temp * E->refstate.rho[nz]
Pan_problem_misc_functions.c:	  * E->refstate.thermal_expansivity[nz] * E->T[m][i];
Pan_problem_misc_functions.c:    if(E->control.tracer &&
Pan_problem_misc_functions.c:       (E->composition.ichemical_buoyancy)) {
Pan_problem_misc_functions.c:      for(j=0;j<E->composition.ncomp;j++) {
Pan_problem_misc_functions.c:	temp2 = E->composition.buoyancy_ratio[j] * temp;
Pan_problem_misc_functions.c:            for(m=1;m<=E->sphere.caps_per_proc;m++)
Pan_problem_misc_functions.c:	      for(i=1;i<=E->lmesh.nno;i++)
Pan_problem_misc_functions.c:		buoy[m][i] -= temp2 * E->composition.comp_node[m][j][i];
Pan_problem_misc_functions.c:    if(E->control.ggrd.ray_control)
Pan_problem_misc_functions.c:    if(E->data.use_rotation_g){
Pan_problem_misc_functions.c:      rfac = E->data.ge*(5./2.*E->data.rotm-E->data.ellipticity);
Pan_problem_misc_functions.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)
Pan_problem_misc_functions.c:	  for(i=1;i<=E->lmesh.noz;i++)
Pan_problem_misc_functions.c:	    n = j*E->lmesh.noz + i; /* this could be improved by only
Pan_problem_misc_functions.c:	    cost2 = cos(E->sx[m][1][n]);cost2 = cost2*cost2;	    /* cos^2(theta) */
Pan_problem_misc_functions.c:	    buoy[m][n] *= E->refstate.gravity[i] * (E->data.ge+rfac*cost2);
Pan_problem_misc_functions.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)
Pan_problem_misc_functions.c:	  for(i=1;i<=E->lmesh.noz;i++){
Pan_problem_misc_functions.c:	    n = j*E->lmesh.noz + i;
Pan_problem_misc_functions.c:	    buoy[m][n] *= E->refstate.gravity[i];
Pan_problem_misc_functions.c:  lev = E->mesh.levmax;
Pan_problem_misc_functions.c:  st = E->SinCos[lev][cap][0][node]; /* for elliptical, sincos would be  corrected */
Pan_problem_misc_functions.c:  sp = E->SinCos[lev][cap][1][node];
Pan_problem_misc_functions.c:  ct = E->SinCos[lev][cap][2][node];
Pan_problem_misc_functions.c:  cp = E->SinCos[lev][cap][3][node];
Pan_problem_misc_functions.c:  E->control.verbose = 1;
Pan_problem_misc_functions.c:	  E->parallel.me,message);
Pan_problem_misc_functions.c:  brange = (double)E->control.coor_refine[0];
Pan_problem_misc_functions.c:  bfrac =  (double)E->control.coor_refine[1];
Pan_problem_misc_functions.c:  trange = (double)E->control.coor_refine[2];
Pan_problem_misc_functions.c:  tfrac = (double)E->control.coor_refine[3];
Pan_problem_misc_functions.c:  range = (double) E->sphere.ro - E->sphere.ri;		/* original range */
Pan_problem_misc_functions.c:  nb = E->mesh.noz * bfrac;
Pan_problem_misc_functions.c:  nt = E->mesh.noz * tfrac;
Pan_problem_misc_functions.c:  nm = E->mesh.noz - nb - nt;
Pan_problem_misc_functions.c:  for(r=E->sphere.ri,k=1;k<=nb;k++,r+=drb){
Pan_problem_misc_functions.c:  klim = E->mesh.noz - nt + 1;
Pan_problem_misc_functions.c:  for(;k <= E->mesh.noz;k++,r+=drt){
Pan_problem_misc_functions.c:rr[1...E->mesh.noz]
Pan_problem_misc_functions.c:  if(E->control.nrlayer[0] != 1)
Pan_problem_misc_functions.c:  if(E->control.nrlayer[E->control.rlayers-1] != E->mesh.noz)
Pan_problem_misc_functions.c:  if(fabs(E->control.rrlayer[0] -E->sphere.ri) > 1e-5)
Pan_problem_misc_functions.c:  if(fabs(E->control.rrlayer[ E->control.rlayers-1] - E->sphere.ro)>1e-6)
Pan_problem_misc_functions.c:  if(E->control.rlayers < 2)
Pan_problem_misc_functions.c:  rr[1] =  E->control.rrlayer[0];
Pan_problem_misc_functions.c:  for(j = 1; j < E->control.rlayers; j++){
Pan_problem_misc_functions.c:    ddr = (E->control.rrlayer[j] - E->control.rrlayer[j - 1]) /
Pan_problem_misc_functions.c:      (E->control.nrlayer[j] - E->control.nrlayer[j - 1]);
Pan_problem_misc_functions.c:    for(k = E->control.nrlayer[j-1]+1;k <= E->control.nrlayer[j];k++)
Pan_problem_misc_functions.c:  if(E->data.use_ellipse){
Pan_problem_misc_functions.c:    return M_PI_2 - atan2(tan(tmp),E->data.efac);
Parallel_util.c:  MPI_Barrier(E->parallel.world);
Parsing.c:    int m=E->parallel.me;
Phase_change.c:  int nno  = E->lmesh.nno;
Phase_change.c:  int nsf  = E->lmesh.nsf;
Phase_change.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Phase_change.c:    E->Fas410[j]   = (float *) malloc((nno+1)*sizeof(float));
Phase_change.c:    E->Fas410_b[j] = (float *) malloc((nsf+1)*sizeof(float));
Phase_change.c:    E->Fas670[j]   = (float *) malloc((nno+1)*sizeof(float));
Phase_change.c:    E->Fas670_b[j] = (float *) malloc((nsf+1)*sizeof(float));
Phase_change.c:    E->Fascmb[j]   = (float *) malloc((nno+1)*sizeof(float));
Phase_change.c:    E->Fascmb_b[j] = (float *) malloc((nsf+1)*sizeof(float));
Phase_change.c:  int m = E->parallel.me;
Phase_change.c:  input_float("Ra_410",&(E->control.Ra_410),"0.0",m);
Phase_change.c:  input_float("clapeyron410",&(E->control.clapeyron410),"0.0",m);
Phase_change.c:  input_float("transT410",&(E->control.transT410),"0.0",m);
Phase_change.c:    E->control.inv_width410 = 1.0/width;
Phase_change.c:  input_float("Ra_670",&(E->control.Ra_670),"0.0",m);
Phase_change.c:  input_float("clapeyron670",&(E->control.clapeyron670),"0.0",m);
Phase_change.c:  input_float("transT670",&(E->control.transT670),"0.0",m);
Phase_change.c:    E->control.inv_width670 = 1.0/width;
Phase_change.c:  input_float("Ra_cmb",&(E->control.Ra_cmb),"0.0",m);
Phase_change.c:  input_float("clapeyroncmb",&(E->control.clapeyroncmb),"0.0",m);
Phase_change.c:  input_float("transTcmb",&(E->control.transTcmb),"0.0",m);
Phase_change.c:    E->control.inv_widthcmb = 1.0/width;
Phase_change.c:  if (E->control.Ra_410 != 0.0)
Phase_change.c:    phase_change_apply(E, buoy, E->Fas410, E->Fas410_b, E->control.Ra_410,
Phase_change.c:		       E->control.clapeyron410, E->viscosity.z410,
Phase_change.c:		       E->control.transT410, E->control.inv_width410);
Phase_change.c:  if (E->control.Ra_670 != 0.0)
Phase_change.c:    phase_change_apply(E, buoy, E->Fas670, E->Fas670_b, E->control.Ra_670,
Phase_change.c:		       E->control.clapeyron670, E->viscosity.zlm,
Phase_change.c:		       E->control.transT670, E->control.inv_width670);
Phase_change.c:  if (E->control.Ra_cmb != 0.0)
Phase_change.c:    phase_change_apply(E, buoy, E->Fascmb, E->Fascmb_b, E->control.Ra_cmb,
Phase_change.c:		       E->control.clapeyroncmb, E->viscosity.zcmb,
Phase_change.c:		       E->control.transTcmb, E->control.inv_widthcmb);
Phase_change.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Phase_change.c:    for(i=1;i<=E->lmesh.nno;i++)
Phase_change.c:  if (E->control.verbose) {
Phase_change.c:    fprintf(E->fp_out, "Ra=%f, clapeyron=%f, depth=%f, transT=%f, inv_width=%f\n",
Phase_change.c:    fflush(E->fp_out);
Phase_change.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Phase_change.c:    for(i=1;i<=E->lmesh.nno;i++)  {
Phase_change.c:        nz = ((i-1) % E->lmesh.noz) + 1;
Phase_change.c:        dz = (E->sphere.ro-E->sx[m][3][i]) - depth;
Phase_change.c:        e_pressure = dz * E->refstate.rho[nz] * E->refstate.gravity[nz]
Phase_change.c:            - clapeyron * (E->T[m][i] - transT);
Phase_change.c:    for (k=1;k<=E->lmesh.noy;k++)
Phase_change.c:      for (j=1;j<=E->lmesh.nox;j++)  {
Phase_change.c:        for (i=1;i<E->lmesh.noz;i++)   {
Phase_change.c:          n = (k-1)*E->lmesh.noz*E->lmesh.nox + (j-1)*E->lmesh.noz + i;
Phase_change.c:            B_b[m][ns]=(E->sx[m][3][n+1]-E->sx[m][3][n])*(pt5-B[m][n])/(B[m][n+1]-B[m][n])+E->sx[m][3][n];
Phase_change.c:  fprintf(E->fp_out,"output_phase_change_buoyancy\n");
Phase_change.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)        {
Phase_change.c:    fprintf(E->fp_out,"for cap %d\n",E->sphere.capid[m]);
Phase_change.c:    for (j=1;j<=E->lmesh.nno;j++)
Phase_change.c:      fprintf(E->fp_out,"Z = %.6e T = %.6e B[%06d] = %.6e \n",E->sx[m][3][j],E->T[m][j],j,B[m][j]);
Phase_change.c:  fflush(E->fp_out);
Problem_related.c:    (E->solver.read_input_files_for_timesteps)(E,1,1); /* read velocity(1) and output(1) */
Problem_related.c:  (E->solver.read_input_files_for_timesteps)(E,4,1); /* read Rayleigh number for top layers */
Problem_related.c:    (E->solver.read_input_files_for_timesteps)(E,3,1); /* read element material(3) and output(1) */
Problem_related.c:    (E->solver.read_input_files_for_timesteps)(E,5,1); /* read temperature(5) and output(1) */
Problem_related.c:    E->monitor.elapsed_time = 0.0;
Problem_related.c:    if (E->convection.tic_method == -1) {
Problem_related.c:      if(strcmp(E->output.format, "ascii-gz") == 0){
Problem_related.c:	if(E->output.gzdir.vtk_io)
Problem_related.c:		  E->control.data_dir_old,E->monitor.solution_cycles_init,E->parallel.me,E->monitor.solution_cycles_init);
Problem_related.c:		  E->control.data_dir_old,E->monitor.solution_cycles_init,E->parallel.me,E->monitor.solution_cycles_init);
Problem_related.c:	sprintf(output_file, "%s.velo.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Problem_related.c:      sprintf(output_file, "%s.velo.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Problem_related.c:	fprintf(E->fp,"(Problem_related #8) Cannot open %s\n",output_file);
Problem_related.c:      if(sscanf(input_s,"%d %d %f",&ll,&mm,&E->monitor.elapsed_time) != 3) {
Problem_related.c:    if (E->control.zero_elapsed_time) /* set elapsed_time to zero */
Problem_related.c:	E->monitor.elapsed_time = 0.0;
Problem_related.c:    if (E->control.reset_startage)
Problem_related.c:	E->control.start_age = E->monitor.elapsed_time*E->data.scalet;
Problem_related.c:   if (E->data.timedir >= 0) { /* forward convection */
Problem_related.c:      age_in_MY = E->control.start_age - E->monitor.elapsed_time*E->data.scalet;
Problem_related.c:      age_in_MY = E->control.start_age + E->monitor.elapsed_time*E->data.scalet;
Problem_related.c:      if (((age_in_MY+e_4) < 0.0) && (E->monitor.solution_cycles < 1)) {
Problem_related.c:        if (E->parallel.me == 0) fprintf(stderr,"Age = %g Ma, Initial age should not be negative!\n",age_in_MY);
Process_buoyancy.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Process_buoyancy.c:    TG[m] = (float *)malloc((E->lmesh.nsf+2)*sizeof(float));
Process_buoyancy.c:  temp_c = (float *)malloc((E->sphere.hindice+2)*sizeof(float));
Process_buoyancy.c:  temp_s = (float *)malloc((E->sphere.hindice+2)*sizeof(float));
Process_buoyancy.c:  for (p=0;p<E->sphere.hindice;p++) {
Process_buoyancy.c:  if (E->parallel.me<E->parallel.nprocz)  { 
Process_buoyancy.c:    sprintf(output_file,"%s.temp_sph.%d%d",E->control.data_file,E->parallel.me,E->monitor.solution_cycles);
Process_buoyancy.c:    fprintf(fp1,"%d %d %.5e\n",E->monitor.solution_cycles,E->output.llmax,E->monitor.elapsed_time);
Process_buoyancy.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Process_buoyancy.c:    for (k=1;k<=E->lmesh.noz;k++)  {
Process_buoyancy.c:      for (i=1;i<=E->lmesh.noy;i++)
Process_buoyancy.c:        for (j=1;j<=E->lmesh.nox;j++)  {
Process_buoyancy.c:           node = k+(j-1)*E->lmesh.noz+(i-1)*E->lmesh.nox*E->lmesh.noz; 
Process_buoyancy.c:           snode = j+(i-1)*E->lmesh.nox; 
Process_buoyancy.c:           TG[m][snode] = E->T[m][node];
Process_buoyancy.c:      if (E->parallel.me<E->parallel.nprocz)  { 
Process_buoyancy.c:        fprintf(fp1,"%d %.4e \n",k,E->sx[m][3][k]);
Process_buoyancy.c:        for (ll=0;ll<=E->output.llmax;ll++)
Process_buoyancy.c:             p=E->sphere.hindex[ll][mm]; 
Process_buoyancy.c:  if (E->parallel.me<E->parallel.nprocz) 
Process_buoyancy.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)  
Process_buoyancy.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Process_buoyancy.c:    const int nno=E->lmesh.nno;
Process_buoyancy.c:    const int lev = E->mesh.levmax;
Process_buoyancy.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Process_buoyancy.c:    for(e=1;e<=E->lmesh.nel;e++) {
Process_buoyancy.c:          u[i] += VV[3][j]*E->N.vpt[GNVINDEX(j,i)];
Process_buoyancy.c:          T[i] += E->T[m][E->ien[m][e].node[j]]*E->N.vpt[GNVINDEX(j,i)];
Process_buoyancy.c:          dTdz[i] += -E->T[m][E->ien[m][e].node[j]]*E->gNX[m][e].vpt[GNVXINDEX(2,j,i)];
Process_buoyancy.c:        uT += u[i]*T[i]*E->gDA[m][e].vpt[i] + dTdz[i]*E->gDA[m][e].vpt[i];
Process_buoyancy.c:      uT /= E->eco[m][e].area;
Process_buoyancy.c:        flux[m][E->ien[m][e].node[j]] += uT*E->TWW[lev][m][e].node[j];
Process_buoyancy.c:  (E->exchange_node_f)(E,flux,lev);
Process_buoyancy.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Process_buoyancy.c:       flux[m][i] *= E->MASS[lev][m][i];
Process_buoyancy.c:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Process_buoyancy.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Process_buoyancy.c:      for(i=1;i<=E->lmesh.nsf;i++)
Process_buoyancy.c:        E->slice.shflux[m][i]=2*flux[m][E->surf_node[m][i]]-flux[m][E->surf_node[m][i]-1];
Process_buoyancy.c:  if (E->parallel.me_loc[3]==0)
Process_buoyancy.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Process_buoyancy.c:      for(i=1;i<=E->lmesh.nsf;i++)
Process_buoyancy.c:        E->slice.bhflux[m][i] = 2*flux[m][E->surf_node[m][i]-E->lmesh.noz+1]
Process_buoyancy.c:                                - flux[m][E->surf_node[m][i]-E->lmesh.noz+2];
Process_buoyancy.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Process_buoyancy.c:    for(e=1;e<=E->lmesh.snel;e++) {
Process_buoyancy.c:         uT =(E->slice.shflux[m][E->sien[m][e].node[1]] +
Process_buoyancy.c:              E->slice.shflux[m][E->sien[m][e].node[2]] +
Process_buoyancy.c:              E->slice.shflux[m][E->sien[m][e].node[3]] +
Process_buoyancy.c:              E->slice.shflux[m][E->sien[m][e].node[4]])*0.25;
Process_buoyancy.c:         el = e*E->lmesh.elz;
Process_buoyancy.c:         sum_h[0] += uT*E->eco[m][el].area;
Process_buoyancy.c:         sum_h[1] += E->eco[m][el].area;
Process_buoyancy.c:         uT =(E->slice.bhflux[m][E->sien[m][e].node[1]] +
Process_buoyancy.c:              E->slice.bhflux[m][E->sien[m][e].node[2]] +
Process_buoyancy.c:              E->slice.bhflux[m][E->sien[m][e].node[3]] +
Process_buoyancy.c:              E->slice.bhflux[m][E->sien[m][e].node[4]])*0.25;
Process_buoyancy.c:         el = (e-1)*E->lmesh.elz+1;
Process_buoyancy.c:         sum_h[2] += uT*E->eco[m][el].area;
Process_buoyancy.c:         sum_h[3] += E->eco[m][el].area;
Process_buoyancy.c:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)   {
Process_buoyancy.c:    /*     if (E->control.verbose && E->parallel.me==E->parallel.nprocz-1) {
Process_buoyancy.c:	     fprintf(E->fp_out,"surface heat flux= %f %f\n",sum_h[0],E->monitor.elapsed_time);
Process_buoyancy.c:             fflush(E->fp_out);
Process_buoyancy.c:    if (E->parallel.me==E->parallel.nprocz-1) {
Process_buoyancy.c:      //fprintf(E->fp,"surface heat flux= %f\n",sum_h[0]); //commented out because E->fp is only on CPU 0 
Process_buoyancy.c:      if(E->output.write_q_files > 0){
Process_buoyancy.c:	fprintf(E->output.fpqt,"%13.5e %13.5e %13.5e\n",E->monitor.elapsed_time,sum_h[0],sqrt(E->monitor.vdotv));
Process_buoyancy.c:	fflush(E->output.fpqt);
Process_buoyancy.c:  if (E->parallel.me_loc[3]==0)    {
Process_buoyancy.c:/*     if (E->control.verbose && E->parallel.me==0) fprintf(E->fp_out,"bottom heat flux= %f %f\n",sum_h[2],E->monitor.elapsed_time); */
Process_buoyancy.c:    if (E->parallel.me==0) {
Process_buoyancy.c:      fprintf(E->fp,"bottom heat flux= %f\n",sum_h[2]);
Process_buoyancy.c:      if(E->output.write_q_files > 0){
Process_buoyancy.c:	fprintf(E->output.fpqb,"%13.5e %13.5e %13.5e\n",
Process_buoyancy.c:		E->monitor.elapsed_time,sum_h[2],sqrt(E->monitor.vdotv));
Process_buoyancy.c:	fflush(E->output.fpqb);
Process_buoyancy.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Process_buoyancy.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)      {
Process_buoyancy.c:	S1[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Process_buoyancy.c:	S2[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Process_buoyancy.c:	S3[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Process_buoyancy.c:    for(m=1;m<=E->sphere.caps_per_proc;m++) {
Process_buoyancy.c:	for(i=1;i<=E->lmesh.nno;i++) {
Process_buoyancy.c:	    S1[m][i] = E->T[m][i];
Process_buoyancy.c:	    S2[m][i] = E->sphere.cap[m].V[1][i]*E->sphere.cap[m].V[1][i]
Process_buoyancy.c:          	+ E->sphere.cap[m].V[2][i]*E->sphere.cap[m].V[2][i];
Process_buoyancy.c:	    S3[m][i] = E->sphere.cap[m].V[3][i]*E->sphere.cap[m].V[3][i];
Process_buoyancy.c:    return_horiz_ave_f(E,S1,E->Have.T);
Process_buoyancy.c:    return_horiz_ave_f(E,S2,E->Have.V[1]);
Process_buoyancy.c:    return_horiz_ave_f(E,S3,E->Have.V[2]);
Process_buoyancy.c:    if (E->composition.on) {
Process_buoyancy.c:        for(n=0; n<E->composition.ncomp; n++) {
Process_buoyancy.c:            for(m=1;m<=E->sphere.caps_per_proc;m++) {
Process_buoyancy.c:                for(i=1;i<=E->lmesh.nno;i++)
Process_buoyancy.c:                    S1[m][i] = E->composition.comp_node[m][n][i];
Process_buoyancy.c:            return_horiz_ave_f(E,S1,E->Have.C[n]);
Process_buoyancy.c:    for(m=1;m<=E->sphere.caps_per_proc;m++) {
Process_buoyancy.c:    for (i=1;i<=E->lmesh.noz;i++) {
Process_buoyancy.c:	E->Have.V[1][i] = sqrt(E->Have.V[1][i]);
Process_buoyancy.c:	E->Have.V[2][i] = sqrt(E->Have.V[2][i]);
Regional_boundary_conditions.c:  for(lv=E->mesh.gridmax;lv>=E->mesh.gridmin;lv--)
Regional_boundary_conditions.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)     {
Regional_boundary_conditions.c:      noz = E->lmesh.NOZ[lv];
Regional_boundary_conditions.c:      if(E->mesh.topvbc == 0) {
Regional_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,1,0.0,VBX,0,lv,j);
Regional_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,VBZ,1,lv,j);
Regional_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,2,0.0,VBY,0,lv,j);
Regional_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,1,E->control.VBXtopval,SBX,1,lv,j);
Regional_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,SBZ,0,lv,j);
Regional_boundary_conditions.c:	horizontal_bc(E,E->sphere.cap[j].VB,noz,2,E->control.VBYtopval,SBY,1,lv,j);
Regional_boundary_conditions.c:      else if(E->mesh.topvbc == 1) {
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,E->control.VBXtopval,VBX,1,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,VBZ,1,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,E->control.VBYtopval,VBY,1,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,0.0,SBX,0,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,SBZ,0,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,0.0,SBY,0,lv,j);
Regional_boundary_conditions.c:	if(E->control.vbcs_file)   {
Regional_boundary_conditions.c:	  if((lv == E->mesh.gridmin) && (j == E->sphere.caps_per_proc))
Regional_boundary_conditions.c:      else if(E->mesh.topvbc == 2) {
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,0.0,VBX,0,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,VBZ,0,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,0.0,VBY,0,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,1,E->control.VBXtopval,SBX,1,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,3,0.0,SBZ,1,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,noz,2,E->control.VBYtopval,SBY,1,lv,j);
Regional_boundary_conditions.c:      if(E->mesh.botvbc == 0) {
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,0.0,VBX,0,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,VBZ,1,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,0.0,VBY,0,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,E->control.VBXbotval,SBX,1,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,SBZ,0,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,E->control.VBYbotval,SBY,1,lv,j);
Regional_boundary_conditions.c:      else if(E->mesh.botvbc == 1) {
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,E->control.VBXbotval,VBX,1,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,VBZ,1,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,E->control.VBYbotval,VBY,1,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,1,0.0,SBX,0,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,3,0.0,SBZ,0,lv,j);
Regional_boundary_conditions.c:        horizontal_bc(E,E->sphere.cap[j].VB,1,2,0.0,SBY,0,lv,j);
Regional_boundary_conditions.c:      if(E->control.side_sbcs)
Regional_boundary_conditions.c:      if(E->control.verbose) {
Regional_boundary_conditions.c:	for (j=1;j<=E->sphere.caps_per_proc;j++)
Regional_boundary_conditions.c:	  for (node=1;node<=E->lmesh.nno;node++)
Regional_boundary_conditions.c:	    fprintf(E->fp_out,"m=%d VB== %d %g %g %g flag %u %u %u\n",j,node,E->sphere.cap[j].VB[1][node],E->sphere.cap[j].VB[2][node],E->sphere.cap[j].VB[3][node],E->node[j][node]&VBX,E->node[j][node]&VBY,E->node[j][node]&VBZ);
Regional_boundary_conditions.c:	fflush(E->fp_out);
Regional_boundary_conditions.c:  lev = E->mesh.levmax;
Regional_boundary_conditions.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)    {
Regional_boundary_conditions.c:    noz = E->lmesh.noz;
Regional_boundary_conditions.c:    if(E->mesh.toptbc == 1)    {
Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,TBZ,1,lev,j);
Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,FBZ,0,lev,j);
Regional_boundary_conditions.c:      if(E->control.tbcs_file)   {
Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,TBZ,0,lev,j);
Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,noz,3,E->control.TBCtopval,FBZ,1,lev,j);
Regional_boundary_conditions.c:    if(E->mesh.bottbc == 1)    {
Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,TBZ,1,lev,j);
Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,FBZ,0,lev,j);
Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,TBZ,0,lev,j);
Regional_boundary_conditions.c:      horizontal_bc(E,E->sphere.cap[j].TB,1,3,E->control.TBCbotval,FBZ,1,lev,j);
Regional_boundary_conditions.c:    if((E->control.temperature_bound_adj==1) || (E->control.lith_age_time==1))  {
Regional_boundary_conditions.c:   E->temperatures_conform_bcs = temperatures_conform_bcs;
Regional_boundary_conditions.c:  const int dims=E->mesh.nsd;
Regional_boundary_conditions.c:  if (E->parallel.me_loc[1]==0 || E->parallel.me_loc[1]==E->parallel.nprocx-1)
Regional_boundary_conditions.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)
Regional_boundary_conditions.c:    for(j=1;j<=E->lmesh.noy;j++)
Regional_boundary_conditions.c:      for(i=1;i<=E->lmesh.noz;i++)  {
Regional_boundary_conditions.c:        node1 = i + (j-1)*E->lmesh.noz*E->lmesh.nox;
Regional_boundary_conditions.c:        node2 = node1 + (E->lmesh.nox-1)*E->lmesh.noz;
Regional_boundary_conditions.c:        ii = i + E->lmesh.nzs - 1;
Regional_boundary_conditions.c:        if (E->parallel.me_loc[1]==0 )  {
Regional_boundary_conditions.c:           E->sphere.cap[m].VB[1][node1] = 0.0;
Regional_boundary_conditions.c:           if((ii != 1) && (ii != E->mesh.noz))
Regional_boundary_conditions.c:              E->sphere.cap[m].VB[3][node1] = 0.0;
Regional_boundary_conditions.c:        if (E->parallel.me_loc[1]==E->parallel.nprocx-1)  {
Regional_boundary_conditions.c:           E->sphere.cap[m].VB[1][node2] = 0.0;
Regional_boundary_conditions.c:           if((ii != 1) && (ii != E->mesh.noz))
Regional_boundary_conditions.c:              E->sphere.cap[m].VB[3][node2] = 0.0;
Regional_boundary_conditions.c:    if (E->parallel.me_loc[2]==0)
Regional_boundary_conditions.c:     for (m=1;m<=E->sphere.caps_per_proc;m++)
Regional_boundary_conditions.c:      for(j=1;j<=E->lmesh.nox;j++)
Regional_boundary_conditions.c:        for(i=1;i<=E->lmesh.noz;i++)       {
Regional_boundary_conditions.c:          node1 = i + (j-1)*E->lmesh.noz;
Regional_boundary_conditions.c:          ii = i + E->lmesh.nzs - 1;
Regional_boundary_conditions.c:          E->sphere.cap[m].VB[2][node1] = 0.0;
Regional_boundary_conditions.c:          if((ii != 1) && (ii != E->mesh.noz))
Regional_boundary_conditions.c:            E->sphere.cap[m].VB[3][node1] = 0.0;
Regional_boundary_conditions.c:    if (E->parallel.me_loc[2]==E->parallel.nprocy-1)
Regional_boundary_conditions.c:     for (m=1;m<=E->sphere.caps_per_proc;m++)
Regional_boundary_conditions.c:      for(j=1;j<=E->lmesh.nox;j++)
Regional_boundary_conditions.c:        for(i=1;i<=E->lmesh.noz;i++)       {
Regional_boundary_conditions.c:          node2 = (E->lmesh.noy-1)*E->lmesh.noz*E->lmesh.nox + i + (j-1)*E->lmesh.noz;
Regional_boundary_conditions.c:          ii = i + E->lmesh.nzs - 1;
Regional_boundary_conditions.c:          E->sphere.cap[m].VB[2][node2] = 0.0;
Regional_boundary_conditions.c:          if((ii != 1) && (ii != E->mesh.noz))
Regional_boundary_conditions.c:            E->sphere.cap[m].VB[3][node2] = 0.0;
Regional_boundary_conditions.c:  for(level=E->mesh.levmax;level>=E->mesh.levmin;level--) {
Regional_boundary_conditions.c:    if ( (E->control.CONJ_GRAD && level==E->mesh.levmax) ||E->control.NMULTIGRID)  {
Regional_boundary_conditions.c:    noz = E->lmesh.NOZ[level] ;
Regional_boundary_conditions.c:    noy = E->lmesh.NOY[level] ;
Regional_boundary_conditions.c:    nox = E->lmesh.NOX[level] ;
Regional_boundary_conditions.c:     for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Regional_boundary_conditions.c:       if (E->parallel.me_loc[1]==0 || E->parallel.me_loc[1]==E->parallel.nprocx-1) {
Regional_boundary_conditions.c:          ii = i + E->lmesh.NZS[level] - 1;
Regional_boundary_conditions.c:          if (E->parallel.me_loc[1]==0 )  {
Regional_boundary_conditions.c:            E->NODE[level][m][node1] = E->NODE[level][m][node1] | VBX;
Regional_boundary_conditions.c:            E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~SBX);
Regional_boundary_conditions.c:            if((ii!=1) && (ii!=E->mesh.NOZ[level])) {
Regional_boundary_conditions.c:               E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~VBY);
Regional_boundary_conditions.c:               E->NODE[level][m][node1] = E->NODE[level][m][node1] | SBY;
Regional_boundary_conditions.c:               E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~VBZ);
Regional_boundary_conditions.c:               E->NODE[level][m][node1] = E->NODE[level][m][node1] | SBZ;
Regional_boundary_conditions.c:          if (E->parallel.me_loc[1]==E->parallel.nprocx-1)  {
Regional_boundary_conditions.c:            E->NODE[level][m][node2] = E->NODE[level][m][node2] | VBX;
Regional_boundary_conditions.c:            E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~SBX);
Regional_boundary_conditions.c:            if((ii!=1) && (ii!=E->mesh.NOZ[level])) {
Regional_boundary_conditions.c:              E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~VBY);
Regional_boundary_conditions.c:              E->NODE[level][m][node2] = E->NODE[level][m][node2] | SBY;
Regional_boundary_conditions.c:              E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~VBZ);
Regional_boundary_conditions.c:              E->NODE[level][m][node2] = E->NODE[level][m][node2] | SBZ;
Regional_boundary_conditions.c:      if (E->parallel.me_loc[2]==0)
Regional_boundary_conditions.c:            ii = i + E->lmesh.NZS[level] - 1;
Regional_boundary_conditions.c:            jj = j + E->lmesh.NXS[level] - 1;
Regional_boundary_conditions.c:            E->NODE[level][m][node1] = E->NODE[level][m][node1] | VBY;
Regional_boundary_conditions.c:            E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~SBY);
Regional_boundary_conditions.c:            if((ii!= 1) && (ii != E->mesh.NOZ[level]))  {
Regional_boundary_conditions.c:                E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~VBZ);
Regional_boundary_conditions.c:                E->NODE[level][m][node1] = E->NODE[level][m][node1] | SBZ;
Regional_boundary_conditions.c:            if((jj!=1) && (jj!=E->mesh.NOX[level]) && (ii!=1) && (ii!=E->mesh.NOZ[level])){
Regional_boundary_conditions.c:                E->NODE[level][m][node1] = E->NODE[level][m][node1] & (~VBX);
Regional_boundary_conditions.c:                E->NODE[level][m][node1] = E->NODE[level][m][node1] | SBX;
Regional_boundary_conditions.c:      if (E->parallel.me_loc[2]==E->parallel.nprocy-1)
Regional_boundary_conditions.c:            ii = i + E->lmesh.NZS[level] - 1;
Regional_boundary_conditions.c:            jj = j + E->lmesh.NXS[level] - 1;
Regional_boundary_conditions.c:            E->NODE[level][m][node2] = E->NODE[level][m][node2] | VBY;
Regional_boundary_conditions.c:            E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~SBY);
Regional_boundary_conditions.c:            if((ii!= 1) && (ii != E->mesh.NOZ[level]))  {
Regional_boundary_conditions.c:                E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~VBZ);
Regional_boundary_conditions.c:                E->NODE[level][m][node2] = E->NODE[level][m][node2] | SBZ;
Regional_boundary_conditions.c:            if((jj!=1) && (jj!=E->mesh.NOX[level]) && (ii!=1) && (ii!=E->mesh.NOZ[level])){
Regional_boundary_conditions.c:                E->NODE[level][m][node2] = E->NODE[level][m][node2] & (~VBX);
Regional_boundary_conditions.c:                E->NODE[level][m][node2] = E->NODE[level][m][node2] | SBX;
Regional_boundary_conditions.c:  const int dims=E->mesh.nsd;
Regional_boundary_conditions.c:   if (E->parallel.me_loc[1]==0 || E->parallel.me_loc[1]==E->parallel.nprocx-1)
Regional_boundary_conditions.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Regional_boundary_conditions.c:    for(j=1;j<=E->lmesh.noy;j++)
Regional_boundary_conditions.c:      for(i=1;i<=E->lmesh.noz;i++) {
Regional_boundary_conditions.c:        node1 = i + (j-1)*E->lmesh.noz*E->lmesh.nox;
Regional_boundary_conditions.c:        node2 = node1 + (E->lmesh.nox-1)*E->lmesh.noz;
Regional_boundary_conditions.c:        if (E->parallel.me_loc[1]==0 )                   {
Regional_boundary_conditions.c:          E->node[m][node1] = E->node[m][node1] & (~TBX);
Regional_boundary_conditions.c:          E->node[m][node1] = E->node[m][node1] | FBX;
Regional_boundary_conditions.c:          E->sphere.cap[m].TB[1][node1] = 0.0;
Regional_boundary_conditions.c:        if (E->parallel.me_loc[1]==E->parallel.nprocx-1)   {
Regional_boundary_conditions.c:          E->node[m][node2] = E->node[m][node2] & (~TBX);
Regional_boundary_conditions.c:          E->node[m][node2] = E->node[m][node2] | FBX;
Regional_boundary_conditions.c:          E->sphere.cap[m].TB[1][node2] = 0.0;
Regional_boundary_conditions.c:    if (E->parallel.me_loc[2]==0)
Regional_boundary_conditions.c:     for(m=1;m<=E->sphere.caps_per_proc;m++)
Regional_boundary_conditions.c:      for(j=1;j<=E->lmesh.nox;j++)
Regional_boundary_conditions.c:        for(i=1;i<=E->lmesh.noz;i++) {
Regional_boundary_conditions.c:          node1 = i + (j-1)*E->lmesh.noz;
Regional_boundary_conditions.c:          E->node[m][node1] = E->node[m][node1] & (~TBY);
Regional_boundary_conditions.c:              E->node[m][node1] = E->node[m][node1] | FBY;
Regional_boundary_conditions.c:              E->sphere.cap[m].TB[2][node1] = 0.0;
Regional_boundary_conditions.c:    if (E->parallel.me_loc[2]==E->parallel.nprocy-1)
Regional_boundary_conditions.c:     for(m=1;m<=E->sphere.caps_per_proc;m++)
Regional_boundary_conditions.c:      for(j=1;j<=E->lmesh.nox;j++)
Regional_boundary_conditions.c:        for(i=1;i<=E->lmesh.noz;i++) {
Regional_boundary_conditions.c:          node2 = i +(j-1)*E->lmesh.noz + (E->lmesh.noy-1)*E->lmesh.noz*E->lmesh.nox;
Regional_boundary_conditions.c:          E->node[m][node2] = E->node[m][node2] & (~TBY);
Regional_boundary_conditions.c:          E->node[m][node2] = E->node[m][node2] | FBY;
Regional_boundary_conditions.c:          E->sphere.cap[m].TB[3][node2] = 0.0;
Regional_boundary_conditions.c:  if(dirn > E->mesh.nsd)
Regional_boundary_conditions.c:      rowl = E->lmesh.NOZ[level];
Regional_boundary_conditions.c:  if ( (ROW==1 && E->parallel.me_loc[3]==0) ||
Regional_boundary_conditions.c:       (ROW==E->lmesh.NOZ[level] && E->parallel.me_loc[3]==E->parallel.nprocz-1) ) {
Regional_boundary_conditions.c:      for(j=1;j<=E->lmesh.NOY[level];j++)
Regional_boundary_conditions.c:    	for(i=1;i<=E->lmesh.NOX[level];i++)     {
Regional_boundary_conditions.c:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+(j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Regional_boundary_conditions.c:    	  E->NODE[level][m][node] = E->NODE[level][m][node] & (~ mask);
Regional_boundary_conditions.c:      for(j=1;j<=E->lmesh.NOY[level];j++)
Regional_boundary_conditions.c:        for(i=1;i<=E->lmesh.NOX[level];i++)       {
Regional_boundary_conditions.c:    	  node = rowl+(i-1)*E->lmesh.NOZ[level]+(j-1)*E->lmesh.NOX[level]*E->lmesh.NOZ[level];
Regional_boundary_conditions.c:    	  E->NODE[level][m][node] = E->NODE[level][m][node] | (mask);
Regional_boundary_conditions.c:    	  if(level==E->mesh.levmax)   /* NB */
Regional_boundary_conditions.c:  const int dims=E->mesh.nsd;
Regional_boundary_conditions.c:  fprintf(E->fp,"Periodic boundary conditions\n");
Regional_boundary_conditions.c: const int dims=E->mesh.nsd;
Regional_boundary_conditions.c: fprintf(E->fp,"pERIodic temperature boundary conditions\n");
Regional_geometry_cartesian.c:  E->mesh.nsd = 2;
Regional_geometry_cartesian.c:  E->mesh.dof = 2;
Regional_geometry_cartesian.c:  E->mesh.nsd = 2;
Regional_geometry_cartesian.c:  E->mesh.dof = 3;
Regional_geometry_cartesian.c:  E->mesh.nsd = 3;
Regional_geometry_cartesian.c:  E->mesh.dof = 3;
Regional_geometry_cartesian.c:  E->mesh.nsd = 3;
Regional_geometry_cartesian.c:  E->mesh.dof = 3;
Regional_geometry_cartesian.c:  E->sphere.caps = 1;
Regional_geometry_cartesian.c:  E->sphere.max_connections = 6;
Regional_obsolete.c:  E->parallel.me = 0;
Regional_obsolete.c:  E->parallel.nproc = 1;
Regional_obsolete.c:  E->parallel.me_loc[1] = 0;
Regional_obsolete.c:  E->parallel.me_loc[2] = 0;
Regional_obsolete.c:  E->parallel.me_loc[3] = 0;
Regional_obsolete.c:  MPI_Comm_rank(E->parallel.world, &(E->parallel.me) );
Regional_obsolete.c:  MPI_Comm_size(E->parallel.world, &(E->parallel.nproc) );
Regional_obsolete.c:  const int dims = E->mesh.nsd;
Regional_obsolete.c:  if (E->parallel.nprocz==1)  {
Regional_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"scatter_to_nlayer should not be called\n");
Regional_obsolete.c:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Regional_obsolete.c:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Regional_obsolete.c:    SD = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Regional_obsolete.c:    rootid = E->parallel.me_sph*E->parallel.nprocz; /* which is the bottom cpu */
Regional_obsolete.c:    for (j=0;j<E->parallel.nprocz;j++) {
Regional_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_obsolete.c:    if (E->parallel.me==rootid)
Regional_obsolete.c:      for (d=0;d<E->parallel.nprocz;d++)  {
Regional_obsolete.c:        for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Regional_obsolete.c:          k1 = k + d*E->lmesh.ELZ[lev];
Regional_obsolete.c:          for (j=1;j<=E->lmesh.NOY[lev];j++)
Regional_obsolete.c:            for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Regional_obsolete.c:              node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Regional_obsolete.c:              node1= k1+ (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Regional_obsolete.c:	  MPI_Send(SD,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],rootid,E->parallel.world);
Regional_obsolete.c:	  for (i=0;i<=E->lmesh.NEQ[lev];i++)
Regional_obsolete.c:      MPI_Recv(AUo[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,rootid,E->parallel.world,&status);
Regional_obsolete.c:  const int dims = E->mesh.nsd;
Regional_obsolete.c:  if (E->parallel.nprocz==1)  {
Regional_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Regional_obsolete.c:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Regional_obsolete.c:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Regional_obsolete.c:    RV = (double *)malloc((E->lmesh.NEQ[lev])*sizeof(double));
Regional_obsolete.c:    rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Regional_obsolete.c:    for (j=0;j<E->parallel.nprocz;j++) {
Regional_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_obsolete.c:    if (E->parallel.me!=rootid)
Regional_obsolete.c:      MPI_Send(AUi[m],E->lmesh.NEQ[lev],MPI_DOUBLE,rootid,E->parallel.me,E->parallel.world);
Regional_obsolete.c:      for (d=0;d<E->parallel.nprocz;d++) {
Regional_obsolete.c:	  MPI_Recv(RV,E->lmesh.NEQ[lev],MPI_DOUBLE,processors[d],processors[d],E->parallel.world,&status);
Regional_obsolete.c:	  for (node=0;node<E->lmesh.NEQ[lev];node++)
Regional_obsolete.c:	for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Regional_obsolete.c:	  k1 = k + d*E->lmesh.ELZ[lev];
Regional_obsolete.c:	  for (j=1;j<=E->lmesh.NOY[lev];j++)
Regional_obsolete.c:	    for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Regional_obsolete.c:	      node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Regional_obsolete.c:	      node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Regional_obsolete.c:  if (E->parallel.nprocz==1)  {
Regional_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Regional_obsolete.c:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz + 1;
Regional_obsolete.c:    NNO = NOZ*E->lmesh.NOX[lev]*E->lmesh.NOY[lev];
Regional_obsolete.c:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Regional_obsolete.c:    RV = (float *)malloc((E->lmesh.NNO[lev]+2)*sizeof(float));
Regional_obsolete.c:    rootid = E->parallel.me_sph*E->parallel.nprocz; /* which is the bottom cpu */
Regional_obsolete.c:    for (j=0;j<E->parallel.nprocz;j++) {
Regional_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_obsolete.c:    if (E->parallel.me!=rootid) {
Regional_obsolete.c:      MPI_Send(AUi[m],E->lmesh.NNO[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Regional_obsolete.c:      for (d=0;d<E->parallel.nprocz;d++) {
Regional_obsolete.c:	  MPI_Recv(RV,E->lmesh.NNO[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Regional_obsolete.c:	  for (node=1;node<=E->lmesh.NNO[lev];node++)
Regional_obsolete.c:	for (k=1;k<=E->lmesh.NOZ[lev];k++)   {
Regional_obsolete.c:	  k1 = k + d*E->lmesh.ELZ[lev];
Regional_obsolete.c:	  for (j=1;j<=E->lmesh.NOY[lev];j++)
Regional_obsolete.c:	    for (i=1;i<=E->lmesh.NOX[lev];i++)   {
Regional_obsolete.c:	      node = k + (i-1)*E->lmesh.NOZ[lev] + (j-1)*E->lmesh.NOZ[lev]*E->lmesh.NOX[lev];
Regional_obsolete.c:	      node1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.NOX[lev];
Regional_obsolete.c:  if (E->parallel.nprocz==1)  {
Regional_obsolete.c:    if (E->parallel.me==0) fprintf(stderr,"gather_to_1layer should not be called\n");
Regional_obsolete.c:    NOZ = E->lmesh.ELZ[lev]*E->parallel.nprocz;
Regional_obsolete.c:    NNO = NOZ*E->lmesh.ELX[lev]*E->lmesh.ELY[lev];
Regional_obsolete.c:    processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Regional_obsolete.c:    RV = (float *)malloc((E->lmesh.NEL[lev]+2)*sizeof(float));
Regional_obsolete.c:    rootid = E->parallel.me_sph*E->parallel.nprocz;    /* which is the bottom cpu */
Regional_obsolete.c:    for (j=0;j<E->parallel.nprocz;j++) {
Regional_obsolete.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_obsolete.c:    if (E->parallel.me!=rootid) {
Regional_obsolete.c:      MPI_Send(AUi[m],E->lmesh.NEL[lev]+1,MPI_FLOAT,rootid,E->parallel.me,E->parallel.world);
Regional_obsolete.c:      for (d=0;d<E->parallel.nprocz;d++) {
Regional_obsolete.c:	  MPI_Recv(RV,E->lmesh.NEL[lev]+1,MPI_FLOAT,processors[d],processors[d],E->parallel.world,&status);
Regional_obsolete.c:	  for (e=1;e<=E->lmesh.NEL[lev];e++)
Regional_obsolete.c:	for (k=1;k<=E->lmesh.ELZ[lev];k++)   {
Regional_obsolete.c:	  k1 = k + d*E->lmesh.ELZ[lev];
Regional_obsolete.c:	  for (j=1;j<=E->lmesh.ELY[lev];j++)
Regional_obsolete.c:	    for (i=1;i<=E->lmesh.ELX[lev];i++)   {
Regional_obsolete.c:	      e = k + (i-1)*E->lmesh.ELZ[lev] + (j-1)*E->lmesh.ELZ[lev]*E->lmesh.ELX[lev];
Regional_obsolete.c:	      e1 = k1 + (i-1)*NOZ + (j-1)*NOZ*E->lmesh.ELX[lev];
Regional_obsolete.c:  if (E->parallel.nprocxy==1)   return;
Regional_obsolete.c:  nsl = E->sphere.nsf+1;
Regional_obsolete.c:  me = E->parallel.me;
Regional_obsolete.c:    for (i=1;i<E->parallel.nprocxy;i++)
Regional_obsolete.c:      RG[i] = ( float *)malloc((E->sphere.nsf+1)*sizeof(float));
Regional_obsolete.c:  for (i=1;i<=E->parallel.nprocxy;i++)  {
Regional_obsolete.c:    to_everyone = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Regional_obsolete.c:      MPI_Isend(TG,nsl,MPI_FLOAT,to_everyone,mst,E->parallel.world,&request[idb-1]);
Regional_obsolete.c:  for (i=1;i<=E->parallel.nprocxy;i++)  {
Regional_obsolete.c:    from_proc = E->parallel.nprocz*(i-1) + E->parallel.me_loc[3];
Regional_obsolete.c:      MPI_Irecv(RG[idb],nsl,MPI_FLOAT,from_proc,mst,E->parallel.world,&request[idb-1]);
Regional_obsolete.c:  for (i=1;i<E->parallel.nprocxy;i++)
Regional_obsolete.c:    for (j=1;j<=E->sphere.nsf; j++)  {
Regional_obsolete.c:  nox=E->lmesh.nox;
Regional_obsolete.c:  noz=E->lmesh.noz;
Regional_obsolete.c:  noy=E->lmesh.noy;
Regional_obsolete.c:  lev=E->mesh.levmax;
Regional_obsolete.c:  if(E->advection.timesteps>1)  {
Regional_obsolete.c:    fxx1=fxx1+E->advection.timestep*vxx1;
Regional_obsolete.c:    fxx2=fxx2+E->advection.timestep*vxx1;
Regional_obsolete.c:  if (E->parallel.me_loc[3] == E->parallel.nprocz-1 ) {
Regional_obsolete.c:	fyy=E->SX[lev][1][1][nodel];
Regional_obsolete.c:	  E->sphere.cap[1].VB[1][nodel]=0.0;
Regional_obsolete.c:	  E->sphere.cap[1].VB[2][nodel]=-vvc;
Regional_obsolete.c:	  E->sphere.cap[1].VB[3][nodel]=0.0;
Regional_obsolete.c:	  if (E->SX[lev][1][2][nodel]>=0.00 && E->SX[lev][1][2][nodel]<= fxx1) {
Regional_obsolete.c:	    E->sphere.cap[1].VB[1][nodel]=0.0;
Regional_obsolete.c:	    E->sphere.cap[1].VB[2][nodel]=vvo;
Regional_obsolete.c:	    E->sphere.cap[1].VB[3][nodel]=0.0;
Regional_obsolete.c:	  else if ( E->SX[lev][1][2][nodel]>fxx1 && E->SX[lev][1][2][nodel]<fxx2) {
Regional_obsolete.c:	    E->sphere.cap[1].VB[1][nodel]=0.0;
Regional_obsolete.c:	    E->sphere.cap[1].VB[2][nodel]=vxx1;
Regional_obsolete.c:	    E->sphere.cap[1].VB[3][nodel]=0.0;
Regional_obsolete.c:	  else if ( E->SX[lev][1][2][nodel]>=fxx2) {
Regional_obsolete.c:	    E->sphere.cap[1].VB[1][nodel]=0.0;
Regional_obsolete.c:	    E->sphere.cap[1].VB[2][nodel]=vvc;
Regional_obsolete.c:	    E->sphere.cap[1].VB[3][nodel]=0.0;
Regional_obsolete.c:  }    /* end of E->parallel.me_loc[3]   */
Regional_obsolete.c:  size2= (E->lmesh.nno+1)*sizeof(float);
Regional_obsolete.c:  sprintf(output_file,"%s.%05d.SZZ",E->control.data_file,file_number);
Regional_obsolete.c:  if (E->parallel.me==proc_loc)  {
Regional_obsolete.c:    sprintf(output_file,"%s.%s_intp",E->control.data_file,filen);
Regional_obsolete.c:      fprintf(E->fp,"(Output.c #7) Cannot open %s\n",output_file);
Regional_obsolete.c:    for (i=E->sphere.nox;i>=1;i--)
Regional_obsolete.c:      for (j=1;j<=E->sphere.noy;j++)  {
Regional_obsolete.c:        node = i + (j-1)*E->sphere.nox;
Regional_obsolete.c:        t = 90-E->sphere.sx[1][node]*rad;
Regional_obsolete.c:        f = E->sphere.sx[2][node]*rad;
Regional_obsolete.c:    fprintf(E->fp,"lmaxx=%.4e lminx=%.4e for %s\n",maxx,minx,filen);
Regional_obsolete.c:    sprintf(output_file,"%s.%s_sharm",E->control.data_file,filen);
Regional_obsolete.c:      fprintf(E->fp,"(Output.c #8) Cannot open %s\n",output_file);
Regional_obsolete.c:    for (ll=0;ll<=E->output.llmax;ll++)
Regional_obsolete.c:        i = E->sphere.hindex[ll][mm];
Regional_obsolete.c:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)      {
Regional_obsolete.c:    sprintf(output_file,"%s.surf.%d.%d",E->control.data_file,E->parallel.me,cycles);
Regional_obsolete.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Regional_obsolete.c:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Regional_obsolete.c:      for(i=1;i<=E->lmesh.nsf;i++)   {
Regional_obsolete.c:	s = i*E->lmesh.noz;
Regional_obsolete.c:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpg[j][i],E->slice.shflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Regional_obsolete.c:  if (E->parallel.me_loc[3]==0)      {
Regional_obsolete.c:    sprintf(output_file,"%s.botm.%d.%d",E->control.data_file,E->parallel.me,cycles);
Regional_obsolete.c:    for(j=1;j<=E->sphere.caps_per_proc;j++)  {
Regional_obsolete.c:      fprintf(fp2,"%3d %7d\n",j,E->lmesh.nsf);
Regional_obsolete.c:      for(i=1;i<=E->lmesh.nsf;i++)  {
Regional_obsolete.c:	s = (i-1)*E->lmesh.noz + 1;
Regional_obsolete.c:        fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->slice.tpgb[j][i],E->slice.bhflux[j][i],E->sphere.cap[j].V[1][s],E->sphere.cap[j].V[2][s]);
Regional_obsolete.c:/*    if (E->parallel.me<E->parallel.nprocz)  { */
Regional_obsolete.c:/*      sprintf(output_file,"%s.ave_r.%d.%d",E->control.data_file,E->parallel.me,cycles); */
Regional_obsolete.c:/*            fprintf(E->fp,"(Output.c #6) Cannot open %s\n",output_file); */
Regional_obsolete.c:/*      for(j=1;j<=E->lmesh.noz;j++)  { */
Regional_obsolete.c:/*          fprintf(fp2,"%.4e %.4e %.4e %.4e\n",E->sx[1][3][j],E->Have.T[j],E->Have.V[1][j],E->Have.V[2][j]); */
Regional_obsolete.c:  const int lev = E->mesh.levmax;
Regional_obsolete.c:  const int nsd = E->mesh.nsd;
Regional_obsolete.c:  // E->sphere.caps_per_proc. Later, when elemental viscosity is written
Regional_obsolete.c:  int size2 = (E->lmesh.nel+1)*sizeof(float);
Regional_obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_obsolete.c:    VN[m]=(float *)malloc((1+E->lmesh.nel*vpts)*sizeof(float));
Regional_obsolete.c:  for(i=1;i<=E->lmesh.nel;i++)
Regional_obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_obsolete.c:  sprintf(output_file,"%s.visc.%d.%d",E->control.data_file,E->parallel.me,cycles);
Regional_obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_obsolete.c:    VE[m]=(float *)malloc((1+E->lmesh.nno)*sizeof(float));
Regional_obsolete.c:  for(j=1;j<=E->sphere.caps_per_proc;j++) {
Regional_obsolete.c:    fprintf(fp1,"%3d %7d\n",j,E->lmesh.nno);
Regional_obsolete.c:    for(i=1;i<=E->lmesh.nno;i++)
Regional_obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_obsolete.c:    record_h = E->control.record_every/10;  */
Regional_obsolete.c:    record_h = E->control.record_every;
Regional_obsolete.c:/*    if ( ((ii % record_h) == 0) || E->control.DIRECTII)    { */
Regional_obsolete.c:    if ( (ii == 0) || ((ii % record_h) == 0) || E->control.DIRECTII)    {
Regional_obsolete.c:/*    if ( ((ii % E->control.record_every) == 0) || E->control.DIRECTII)  { */
Regional_obsolete.c:    if ( ((ii == 0) || ((ii % E->control.record_every) == 0))
Regional_obsolete.c:		|| E->control.DIRECTII)     {
Regional_obsolete.c:    if ( (ii == 0) || ((ii % E->control.record_every) == 0)
Regional_obsolete.c:		|| E->control.DIRECTII)     {
Regional_obsolete.c:      get_STD_topo(E,E->slice.tpg,E->slice.tpgb,E->slice.divg,E->slice.vort,ii);
Regional_obsolete.c:  const int dims=E->mesh.nsd;
Regional_obsolete.c:  const int nno=E->lmesh.nno;
Regional_obsolete.c:  lev = E->mesh.levmax;
Regional_obsolete.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Regional_obsolete.c:      if (node%E->lmesh.noz==0)   {
Regional_obsolete.c:        i = node/E->lmesh.noz;
Regional_obsolete.c:        SV[(i-1)*2+1] = E->sphere.cap[m].V[1][node];
Regional_obsolete.c:        SV[(i-1)*2+2] = E->sphere.cap[m].V[2][node];
Regional_parallel_related.c:  me = E->parallel.me;
Regional_parallel_related.c:  surf_proc_per_cap = E->parallel.nprocx * E->parallel.nprocy;
Regional_parallel_related.c:  proc_per_cap = surf_proc_per_cap * E->parallel.nprocz;
Regional_parallel_related.c:  total_proc = E->sphere.caps * proc_per_cap;
Regional_parallel_related.c:  E->parallel.total_surf_proc = E->sphere.caps * surf_proc_per_cap;
Regional_parallel_related.c:  if ( total_proc != E->parallel.nproc ) {
Regional_parallel_related.c:    if (E->parallel.me==0) fprintf(stderr,"!!!! # of requested CPU is incorrect \n");
Regional_parallel_related.c:  j = me % E->parallel.nprocz;
Regional_parallel_related.c:  E->parallel.me_loc[3] = j;
Regional_parallel_related.c:  k = (me - j)/E->parallel.nprocz % E->parallel.nprocx;
Regional_parallel_related.c:  E->parallel.me_loc[1] = k;
Regional_parallel_related.c:  i = ((me - j)/E->parallel.nprocz - k)/E->parallel.nprocx % E->parallel.nprocy;
Regional_parallel_related.c:  E->parallel.me_loc[2] = i;
Regional_parallel_related.c:  E->sphere.caps_per_proc = 1;
Regional_parallel_related.c:  pid_surf = me/E->parallel.nprocz;
Regional_parallel_related.c:  i = cases[E->sphere.caps_per_proc];
Regional_parallel_related.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Regional_parallel_related.c:    E->sphere.capid[j] = 1;
Regional_parallel_related.c:  E->parallel.loc2proc_map = (int ****) malloc(E->sphere.caps*sizeof(int ***));
Regional_parallel_related.c:  for (m=0;m<E->sphere.caps;m++)  {
Regional_parallel_related.c:    E->parallel.loc2proc_map[m] = (int ***) malloc(E->parallel.nprocx*sizeof(int **));
Regional_parallel_related.c:    for (i=0;i<E->parallel.nprocx;i++) {
Regional_parallel_related.c:      E->parallel.loc2proc_map[m][i] = (int **) malloc(E->parallel.nprocy*sizeof(int *));
Regional_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++)
Regional_parallel_related.c:	E->parallel.loc2proc_map[m][i][j] = (int *) malloc(E->parallel.nprocz*sizeof(int));
Regional_parallel_related.c:  for (m=0;m<E->sphere.caps;m++)
Regional_parallel_related.c:    for (i=0;i<E->parallel.nprocx;i++)
Regional_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++)
Regional_parallel_related.c:	for (k=0;k<E->parallel.nprocz;k++) {
Regional_parallel_related.c:	    E->parallel.loc2proc_map[m][i][j][k] = m*proc_per_cap
Regional_parallel_related.c:	      + j*E->parallel.nprocx*E->parallel.nprocz
Regional_parallel_related.c:	      + i*E->parallel.nprocz + k;
Regional_parallel_related.c:  if (E->control.verbose) {
Regional_parallel_related.c:    fprintf(E->fp_out,"me=%d loc1=%d loc2=%d loc3=%d\n",me,E->parallel.me_loc[1],E->parallel.me_loc[2],E->parallel.me_loc[3]);
Regional_parallel_related.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Regional_parallel_related.c:      fprintf(E->fp_out,"capid[%d]=%d \n",j,E->sphere.capid[j]);
Regional_parallel_related.c:    for (m=0;m<E->sphere.caps;m++)
Regional_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++)
Regional_parallel_related.c:	for (i=0;i<E->parallel.nprocx;i++)
Regional_parallel_related.c:	  for (k=0;k<E->parallel.nprocz;k++)
Regional_parallel_related.c:	    fprintf(E->fp_out,"loc2proc_map[cap=%d][x=%d][y=%d][z=%d] = %d\n",
Regional_parallel_related.c:		    m,i,j,k,E->parallel.loc2proc_map[m][i][j][k]);
Regional_parallel_related.c:    fflush(E->fp_out);
Regional_parallel_related.c:  E->exchange_node_d = exchange_node_d;
Regional_parallel_related.c:  E->exchange_node_f = exchange_node_f;
Regional_parallel_related.c:  processors = (int *) malloc((E->parallel.total_surf_proc+1)*sizeof(int));
Regional_parallel_related.c:  k = E->parallel.me_loc[3];
Regional_parallel_related.c:  for (m=0;m<E->sphere.caps;m++)
Regional_parallel_related.c:    for (i=0;i<E->parallel.nprocx;i++)
Regional_parallel_related.c:      for (j=0;j<E->parallel.nprocy;j++) {
Regional_parallel_related.c:	processors[n] = E->parallel.loc2proc_map[m][i][j][k];
Regional_parallel_related.c:  if (E->control.verbose) {
Regional_parallel_related.c:    fprintf(E->fp_out,"horizontal group of me=%d loc3=%d\n",E->parallel.me,E->parallel.me_loc[3]);
Regional_parallel_related.c:    for (j=0;j<E->parallel.total_surf_proc;j++) {
Regional_parallel_related.c:      fprintf(E->fp_out,"%d proc=%d\n",j,processors[j]);
Regional_parallel_related.c:    fflush(E->fp_out);
Regional_parallel_related.c:  MPI_Comm_group(E->parallel.world, &world_g);
Regional_parallel_related.c:  MPI_Group_incl(world_g, E->parallel.total_surf_proc, processors, &horizon_g);
Regional_parallel_related.c:  MPI_Comm_create(E->parallel.world, horizon_g, &(E->parallel.horizontal_comm));
Regional_parallel_related.c:  processors = (int *)malloc((E->parallel.nprocz+2)*sizeof(int));
Regional_parallel_related.c:  m = E->sphere.capid[1] - 1;  /* assume 1 cap per proc. */
Regional_parallel_related.c:  i = E->parallel.me_loc[1];
Regional_parallel_related.c:  j = E->parallel.me_loc[2];
Regional_parallel_related.c:  for (k=0;k<E->parallel.nprocz;k++) {
Regional_parallel_related.c:      processors[k] = E->parallel.loc2proc_map[m][i][j][k];
Regional_parallel_related.c:  if (E->control.verbose) {
Regional_parallel_related.c:    fprintf(E->fp_out,"vertical group of me=%d loc1=%d loc2=%d\n",E->parallel.me,E->parallel.me_loc[1],E->parallel.me_loc[2]);
Regional_parallel_related.c:    for (k=0;k<E->parallel.nprocz;k++) {
Regional_parallel_related.c:      fprintf(E->fp_out,"%d proc=%d\n",k,processors[k]);
Regional_parallel_related.c:    fflush(E->fp_out);
Regional_parallel_related.c:  MPI_Comm_group(E->parallel.world, &world_g);
Regional_parallel_related.c:  MPI_Group_incl(world_g, E->parallel.nprocz, processors, &vertical_g);
Regional_parallel_related.c:  MPI_Comm_create(E->parallel.world, vertical_g, &(E->parallel.vertical_comm));
Regional_parallel_related.c:  me = E->parallel.me;
Regional_parallel_related.c:  E->lmesh.elx = E->mesh.elx/E->parallel.nprocx;
Regional_parallel_related.c:  E->lmesh.elz = E->mesh.elz/E->parallel.nprocz;
Regional_parallel_related.c:  E->lmesh.ely = E->mesh.ely/E->parallel.nprocy;
Regional_parallel_related.c:  E->lmesh.nox = E->lmesh.elx + 1;
Regional_parallel_related.c:  E->lmesh.noz = E->lmesh.elz + 1;
Regional_parallel_related.c:  E->lmesh.noy = E->lmesh.ely + 1;
Regional_parallel_related.c:  E->lmesh.exs = E->parallel.me_loc[1]*E->lmesh.elx;
Regional_parallel_related.c:  E->lmesh.eys = E->parallel.me_loc[2]*E->lmesh.ely;
Regional_parallel_related.c:  E->lmesh.ezs = E->parallel.me_loc[3]*E->lmesh.elz;
Regional_parallel_related.c:  E->lmesh.nxs = E->parallel.me_loc[1]*E->lmesh.elx+1;
Regional_parallel_related.c:  E->lmesh.nys = E->parallel.me_loc[2]*E->lmesh.ely+1;
Regional_parallel_related.c:  E->lmesh.nzs = E->parallel.me_loc[3]*E->lmesh.elz+1;
Regional_parallel_related.c:  E->lmesh.nno = E->lmesh.noz*E->lmesh.nox*E->lmesh.noy;
Regional_parallel_related.c:  E->lmesh.nel = E->lmesh.ely*E->lmesh.elx*E->lmesh.elz;
Regional_parallel_related.c:  E->lmesh.npno = E->lmesh.nel;
Regional_parallel_related.c:  E->lmesh.nsf = E->lmesh.nno/E->lmesh.noz;
Regional_parallel_related.c:  E->lmesh.snel = E->lmesh.elx*E->lmesh.ely;
Regional_parallel_related.c:  for(i=E->mesh.levmax;i>=E->mesh.levmin;i--)   {
Regional_parallel_related.c:     if (E->control.NMULTIGRID)  {
Regional_parallel_related.c:        nox = E->mesh.mgunitx * (int) pow(2.0,(double)i) + 1;
Regional_parallel_related.c:        noy = E->mesh.mgunity * (int) pow(2.0,(double)i) + 1;
Regional_parallel_related.c:        noz = E->lmesh.elz/(int)pow(2.0,(double)(E->mesh.levmax-i))+1;
Regional_parallel_related.c:        E->parallel.redundant[i]=0;
Regional_parallel_related.c:        { noz = E->lmesh.noz;
Regional_parallel_related.c:          noy = E->mesh.mgunity * (int) pow(2.0,(double)i) + 1;
Regional_parallel_related.c:          nox = E->mesh.mgunitx * (int) pow(2.0,(double)i) + 1;
Regional_parallel_related.c:          if(i<E->mesh.levmax) noz=2;
Regional_parallel_related.c:     E->lmesh.ELX[i] = nox-1;
Regional_parallel_related.c:     E->lmesh.ELY[i] = noy-1;
Regional_parallel_related.c:     E->lmesh.ELZ[i] = noz-1;
Regional_parallel_related.c:     E->lmesh.NOZ[i] = noz;
Regional_parallel_related.c:     E->lmesh.NOY[i] = noy;
Regional_parallel_related.c:     E->lmesh.NOX[i] = nox;
Regional_parallel_related.c:     E->lmesh.NNO[i] = nox * noz * noy;
Regional_parallel_related.c:     E->lmesh.NNOV[i] = E->lmesh.NNO[i];
Regional_parallel_related.c:     E->lmesh.SNEL[i] = E->lmesh.ELX[i]*E->lmesh.ELY[i];
Regional_parallel_related.c:     E->lmesh.NEL[i] = (nox-1) * (noz-1) * (noy-1);
Regional_parallel_related.c:     E->lmesh.NPNO[i] = E->lmesh.NEL[i] ;
Regional_parallel_related.c:     E->lmesh.NEQ[i] = E->mesh.nsd * E->lmesh.NNOV[i] ;
Regional_parallel_related.c:     E->lmesh.EXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i];
Regional_parallel_related.c:     E->lmesh.EYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i];
Regional_parallel_related.c:     E->lmesh.EZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i];
Regional_parallel_related.c:     E->lmesh.NXS[i] = E->parallel.me_loc[1]*E->lmesh.ELX[i]+1;
Regional_parallel_related.c:     E->lmesh.NYS[i] = E->parallel.me_loc[2]*E->lmesh.ELY[i]+1;
Regional_parallel_related.c:     E->lmesh.NZS[i] = E->parallel.me_loc[3]*E->lmesh.ELZ[i]+1;
Regional_parallel_related.c:fprintf(stderr,"b %d %d %d %d %d %d %d\n",E->parallel.me,E->parallel.me_loc[1],E->parallel.me_loc[2],E->parallel.me_loc[3],E->lmesh.nzs,E->lmesh.nys,E->lmesh.noy);
Regional_parallel_related.c:  for(lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)   {
Regional_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_parallel_related.c:      nel = E->lmesh.NEL[lev];
Regional_parallel_related.c:      elx = E->lmesh.ELX[lev];
Regional_parallel_related.c:      elz = E->lmesh.ELZ[lev];
Regional_parallel_related.c:      ely = E->lmesh.ELY[lev];
Regional_parallel_related.c:      nox = E->lmesh.NOX[lev];
Regional_parallel_related.c:      noy = E->lmesh.NOY[lev];
Regional_parallel_related.c:      noz = E->lmesh.NOZ[lev];
Regional_parallel_related.c:      nno = E->lmesh.NNO[lev];
Regional_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] =  node;
Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Regional_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Regional_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] =  node;
Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Regional_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Regional_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Regional_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Regional_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Regional_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Regional_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Regional_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Regional_parallel_related.c:        E->parallel.NODE[lev][m][++lnode].bound[ii] = node;
Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | OFFSIDE;
Regional_parallel_related.c:      E->parallel.NUM_NNO[lev][m].bound[ii] = lnode;
Regional_parallel_related.c:    if (E->parallel.me_loc[1]!=E->parallel.nprocx-1)
Regional_parallel_related.c:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[2];lnode++) {
Regional_parallel_related.c:        node = E->parallel.NODE[lev][m][lnode].bound[2];
Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Regional_parallel_related.c:    if (E->parallel.me_loc[2]!=E->parallel.nprocy-1)
Regional_parallel_related.c:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[4];lnode++) {
Regional_parallel_related.c:        node = E->parallel.NODE[lev][m][lnode].bound[4];
Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Regional_parallel_related.c:    if (E->parallel.me_loc[3]!=E->parallel.nprocz-1)
Regional_parallel_related.c:      for (lnode=1;lnode<=E->parallel.NUM_NNO[lev][m].bound[6];lnode++) {
Regional_parallel_related.c:        node = E->parallel.NODE[lev][m][lnode].bound[6];
Regional_parallel_related.c:        E->NODE[lev][m][node] = E->NODE[lev][m][node] | SKIP;
Regional_parallel_related.c:if (E->control.verbose) {
Regional_parallel_related.c: fprintf(E->fp_out,"output_shared_nodes %d \n",E->parallel.me);
Regional_parallel_related.c: for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)
Regional_parallel_related.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)      {
Regional_parallel_related.c:    fprintf(E->fp_out,"lev=%d  me=%d capid=%d m=%d \n",lev,E->parallel.me,E->sphere.capid[m],m);
Regional_parallel_related.c:      for (i=1;i<=E->parallel.NUM_NNO[lev][m].bound[ii];i++)
Regional_parallel_related.c:        fprintf(E->fp_out,"ii=%d   %d %d \n",ii,i,E->parallel.NODE[lev][m][i].bound[ii]);
Regional_parallel_related.c:    for (node=1;node<=E->lmesh.NNO[lev];node++)
Regional_parallel_related.c:      if((E->NODE[lev][m][node] & SKIP)) {
Regional_parallel_related.c:        fprintf(E->fp_out,"skip %d %d \n",lnode,node);
Regional_parallel_related.c: fflush(E->fp_out);
Regional_parallel_related.c:  const int dims=E->mesh.nsd;
Regional_parallel_related.c:  me = E->parallel.me;
Regional_parallel_related.c:  nproczl = E->parallel.nprocz;
Regional_parallel_related.c:  nprocyl = E->parallel.nprocy;
Regional_parallel_related.c:  nprocxl = E->parallel.nprocx;
Regional_parallel_related.c:  lx = E->parallel.me_loc[1];
Regional_parallel_related.c:  ly = E->parallel.me_loc[2];
Regional_parallel_related.c:  lz = E->parallel.me_loc[3];
Regional_parallel_related.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Regional_parallel_related.c:    nox = E->lmesh.NOX[lev];
Regional_parallel_related.c:    noz = E->lmesh.NOZ[lev];
Regional_parallel_related.c:    noy = E->lmesh.NOY[lev];
Regional_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Regional_parallel_related.c:      cap = E->sphere.capid[m] - 1;  /* which cap I am in (0~11) */
Regional_parallel_related.c:        E->parallel.NUM_PASS[lev][m].bound[ii] = 1;
Regional_parallel_related.c:        if(E->parallel.me_loc[1]==0 && i==1)
Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:        else if(E->parallel.me_loc[1]==nprocxl-1 && i==2)
Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:        if (E->parallel.NUM_PASS[lev][m].bound[ii] == 1)  {
Regional_parallel_related.c:          /*E->parallel.PROCESSOR[lev][m].pass[kkk]=me-((i==1)?1:-1)*nproczl; */
Regional_parallel_related.c:          E->parallel.PROCESSOR[lev][m].pass[kkk]=E->parallel.loc2proc_map[cap][lx-dir][ly][lz];
Regional_parallel_related.c:              E->parallel.NUM_NODE[lev][m].pass[kkk] = E->parallel.NUM_NNO[lev][m].bound[ii];
Regional_parallel_related.c:          for (k=1;k<=E->parallel.NUM_NODE[lev][m].pass[kkk];k++)   {
Regional_parallel_related.c:            node = E->parallel.NODE[lev][m][lnode].bound[ii];
Regional_parallel_related.c:            E->parallel.EXCHANGE_NODE[lev][m][k].pass[kkk] = node;
Regional_parallel_related.c:                         E->parallel.EXCHANGE_ID[lev][m][++jj].pass[kkk] = E->ID[lev][m][node].doff[doff];
Regional_parallel_related.c:              E->parallel.NUM_NEQ[lev][m].pass[kkk] = jj;
Regional_parallel_related.c:        E->parallel.NUM_PASS[lev][m].bound[ii] = 1;
Regional_parallel_related.c:        if(E->parallel.me_loc[2]==0 && k==1)
Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:        else if(E->parallel.me_loc[2]==nprocyl-1 && k==2)
Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:        if(E->parallel.NUM_PASS[lev][m].bound[ii] == 1)  {
Regional_parallel_related.c:          /*E->parallel.PROCESSOR[lev][m].pass[kkk]=me-((k==1)?1:-1)*nprocxl*nproczl; */
Regional_parallel_related.c:          E->parallel.PROCESSOR[lev][m].pass[kkk]=E->parallel.loc2proc_map[cap][lx][ly-dir][lz];
Regional_parallel_related.c:          E->parallel.NUM_NODE[lev][m].pass[kkk] = E->parallel.NUM_NNO[lev][m].bound[ii];
Regional_parallel_related.c:          for (kk=1;kk<=E->parallel.NUM_NODE[lev][m].pass[kkk];kk++)   {
Regional_parallel_related.c:            node = E->parallel.NODE[lev][m][lnode].bound[ii];
Regional_parallel_related.c:            E->parallel.EXCHANGE_NODE[lev][m][kk].pass[kkk] = node;
Regional_parallel_related.c:                         E->parallel.EXCHANGE_ID[lev][m][++jj].pass[kkk] = E->ID[lev][m][node].doff[doff];
Regional_parallel_related.c:              E->parallel.NUM_NEQ[lev][m].pass[kkk] = jj;
Regional_parallel_related.c:        E->parallel.NUM_PASS[lev][m].bound[ii] = 1;
Regional_parallel_related.c:        if(E->parallel.me_loc[3]==0 && j==1)
Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:        else if(E->parallel.me_loc[3]==nproczl-1 && j==2)
Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:        if(E->parallel.NUM_PASS[lev][m].bound[ii] == 1)  {
Regional_parallel_related.c:          /*E->parallel.PROCESSOR[lev][m].pass[kkk]=me-((j==1)?1:-1);*/
Regional_parallel_related.c:          E->parallel.PROCESSOR[lev][m].pass[kkk]=E->parallel.loc2proc_map[cap][lx][ly][lz-dir];
Regional_parallel_related.c:          E->parallel.NUM_NODE[lev][m].pass[kkk] = E->parallel.NUM_NNO[lev][m].bound[ii];
Regional_parallel_related.c:          for (kk=1;kk<=E->parallel.NUM_NODE[lev][m].pass[kkk];kk++)   {
Regional_parallel_related.c:            node = E->parallel.NODE[lev][m][lnode].bound[ii];
Regional_parallel_related.c:            E->parallel.EXCHANGE_NODE[lev][m][kk].pass[kkk] = node;
Regional_parallel_related.c:                         E->parallel.EXCHANGE_ID[lev][m][++jj].pass[kkk] = E->ID[lev][m][node].doff[doff];
Regional_parallel_related.c:              E->parallel.NUM_NEQ[lev][m].pass[kkk] = jj;
Regional_parallel_related.c:      E->parallel.TNUM_PASS[lev][m] = kkk;
Regional_parallel_related.c:  if(E->control.verbose) {
Regional_parallel_related.c:    for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--) {
Regional_parallel_related.c:      fprintf(E->fp_out,"output_communication route surface for lev=%d \n",lev);
Regional_parallel_related.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Regional_parallel_related.c:    fprintf(E->fp_out,"  me= %d cap=%d pass  %d \n",E->parallel.me,E->sphere.capid[m],E->parallel.TNUM_PASS[lev][m]);
Regional_parallel_related.c:    for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Regional_parallel_related.c:      fprintf(E->fp_out,"proc %d and pass  %d to proc %d with %d eqn and %d node\n",E->parallel.me,k,E->parallel.PROCESSOR[lev][m].pass[k],E->parallel.NUM_NEQ[lev][m].pass[k],E->parallel.NUM_NODE[lev][m].pass[k]);
Regional_parallel_related.c:/*    fprintf(E->fp_out,"Eqn:\n");  */
Regional_parallel_related.c:/*    for (ii=1;ii<=E->parallel.NUM_NEQ[lev][m].pass[k];ii++)  */
Regional_parallel_related.c:/*      fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_ID[lev][m][ii].pass[k]);  */
Regional_parallel_related.c:/*    fprintf(E->fp_out,"Node:\n");  */
Regional_parallel_related.c:/*    for (ii=1;ii<=E->parallel.NUM_NODE[lev][m].pass[k];ii++)  */
Regional_parallel_related.c:/*      fprintf(E->fp_out,"%d %d\n",ii,E->parallel.EXCHANGE_NODE[lev][m][ii].pass[k]);  */
Regional_parallel_related.c:    fflush(E->fp_out);
Regional_parallel_related.c:  const int dims=E->mesh.nsd;
Regional_parallel_related.c:  me = E->parallel.me;
Regional_parallel_related.c:  nprocz = E->parallel.nprocz;
Regional_parallel_related.c:  nprocxl = E->parallel.nprocx;
Regional_parallel_related.c:  nprocyl = E->parallel.nprocy;
Regional_parallel_related.c:  nproczl = E->parallel.nprocz;
Regional_parallel_related.c:  for(lev=E->mesh.gridmax;lev>=E->mesh.gridmin;lev--)       {
Regional_parallel_related.c:    nox = E->lmesh.NOX[lev];
Regional_parallel_related.c:    noz = E->lmesh.NOZ[lev];
Regional_parallel_related.c:    noy = E->lmesh.NOY[lev];
Regional_parallel_related.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)    {
Regional_parallel_related.c:        E->parallel.NUM_PASS[lev][m].bound[ii] = 1;
Regional_parallel_related.c:        if(E->parallel.me_loc[1]==0 && i==1)
Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:        else if(E->parallel.me_loc[1]==nprocxl-1 && i==2)
Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:        for (p=1;p<=E->parallel.NUM_PASS[lev][m].bound[ii];p++)  {
Regional_parallel_related.c:          E->parallel.sPROCESSOR[lev][m].pass[kkk]=me-((i==1)?1:-1)*nproczl;
Regional_parallel_related.c:              E->parallel.NUM_sNODE[lev][m].pass[kkk] =
Regional_parallel_related.c:                          E->parallel.NUM_NNO[lev][m].bound[ii]/noz;
Regional_parallel_related.c:          for (k=1;k<=E->parallel.NUM_sNODE[lev][m].pass[kkk];k++)   {
Regional_parallel_related.c:            node = (E->parallel.NODE[lev][m][lnode].bound[ii]-1)/noz+1;
Regional_parallel_related.c:            E->parallel.EXCHANGE_sNODE[lev][m][k].pass[kkk] = node;
Regional_parallel_related.c:        E->parallel.NUM_PASS[lev][m].bound[ii] = 1;
Regional_parallel_related.c:        if(E->parallel.me_loc[2]==0 && k==1)
Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:        else if(E->parallel.me_loc[2]==nprocyl-1 && k==2)
Regional_parallel_related.c:          E->parallel.NUM_PASS[lev][m].bound[ii] = 0;
Regional_parallel_related.c:        for (p=1;p<=E->parallel.NUM_PASS[lev][m].bound[ii];p++)  {
Regional_parallel_related.c:          E->parallel.sPROCESSOR[lev][m].pass[kkk]=me-((k==1)?1:-1)*nprocxl*nproczl;
Regional_parallel_related.c:              E->parallel.NUM_sNODE[lev][m].pass[kkk] =
Regional_parallel_related.c:                          E->parallel.NUM_NNO[lev][m].bound[ii]/noz;
Regional_parallel_related.c:          for (kk=1;kk<=E->parallel.NUM_sNODE[lev][m].pass[kkk];kk++)   {
Regional_parallel_related.c:            node = (E->parallel.NODE[lev][m][lnode].bound[ii]-1)/noz+1;
Regional_parallel_related.c:            E->parallel.EXCHANGE_sNODE[lev][m][kk].pass[kkk] = node;
Regional_parallel_related.c:    E->parallel.sTNUM_PASS[lev][m] = kkk;
Regional_parallel_related.c:   for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Regional_parallel_related.c:     for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:       sizeofk = (1+E->parallel.NUM_NEQ[lev][m].pass[k])*sizeof(double);
Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Regional_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:     sizeofk = (1+E->parallel.NUM_NEQ[lev][m].pass[k])*sizeof(double);
Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[k];j++)
Regional_parallel_related.c:       S[k][j-1] = U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[k] ];
Regional_parallel_related.c:     MPI_Sendrecv(S[k],E->parallel.NUM_NEQ[lev][m].pass[k],MPI_DOUBLE,
Regional_parallel_related.c:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:		  R[k],E->parallel.NUM_NEQ[lev][m].pass[k],MPI_DOUBLE,
Regional_parallel_related.c:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:		  E->parallel.world,&status);
Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_NEQ[lev][m].pass[k];j++)
Regional_parallel_related.c:       U[m][ E->parallel.EXCHANGE_ID[lev][m][j].pass[k] ] += R[k][j-1];
Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Regional_parallel_related.c: for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Regional_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:     sizeofk = (1+E->parallel.NUM_NODE[lev][m].pass[k])*sizeof(double);
Regional_parallel_related.c: for(m=1;m<=E->sphere.caps_per_proc;m++)     {
Regional_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Regional_parallel_related.c:       S[k][j-1] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ];
Regional_parallel_related.c:     MPI_Sendrecv(S[k],E->parallel.NUM_NODE[lev][m].pass[k],MPI_DOUBLE,
Regional_parallel_related.c:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:		  R[k],E->parallel.NUM_NODE[lev][m].pass[k],MPI_DOUBLE,
Regional_parallel_related.c:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:		  E->parallel.world,&status);
Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Regional_parallel_related.c:       U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += R[k][j-1];
Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Regional_parallel_related.c: for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Regional_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:     sizeofk = (1+E->parallel.NUM_NODE[lev][m].pass[k])*sizeof(float);
Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)     {
Regional_parallel_related.c:   for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)   {
Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Regional_parallel_related.c:       S[k][j-1] = U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ];
Regional_parallel_related.c:     MPI_Sendrecv(S[k],E->parallel.NUM_NODE[lev][m].pass[k],MPI_FLOAT,
Regional_parallel_related.c:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:		  R[k],E->parallel.NUM_NODE[lev][m].pass[k],MPI_FLOAT,
Regional_parallel_related.c:		  E->parallel.PROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:		  E->parallel.world,&status);
Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_NODE[lev][m].pass[k];j++)
Regional_parallel_related.c:       U[m][ E->parallel.EXCHANGE_NODE[lev][m][j].pass[k] ] += R[k][j-1];
Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Regional_parallel_related.c: for (k=1;k<=E->parallel.TNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)    {
Regional_parallel_related.c:   for (k=1;k<=E->parallel.sTNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:     sizeofk = (1+2*E->parallel.NUM_sNODE[lev][m].pass[k])*sizeof(float);
Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Regional_parallel_related.c:   for (k=1;k<=E->parallel.sTNUM_PASS[lev][m];k++)  {
Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_sNODE[lev][m].pass[k];j++)  {
Regional_parallel_related.c:       S[k][j-1] = U1[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ];
Regional_parallel_related.c:       S[k][j-1+E->parallel.NUM_sNODE[lev][m].pass[k]]
Regional_parallel_related.c:	 = U2[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ];
Regional_parallel_related.c:     MPI_Sendrecv(S[k],2*E->parallel.NUM_sNODE[lev][m].pass[k],MPI_FLOAT,
Regional_parallel_related.c:		  E->parallel.sPROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:		  R[k],2*E->parallel.NUM_sNODE[lev][m].pass[k],MPI_FLOAT,
Regional_parallel_related.c:		  E->parallel.sPROCESSOR[lev][m].pass[k],1,
Regional_parallel_related.c:		  E->parallel.world,&status);
Regional_parallel_related.c:     for (j=1;j<=E->parallel.NUM_sNODE[lev][m].pass[k];j++)   {
Regional_parallel_related.c:       U1[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] += R[k][j-1];
Regional_parallel_related.c:       U2[m][ E->parallel.EXCHANGE_sNODE[lev][m][j].pass[k] ] +=
Regional_parallel_related.c:	 R[k][j-1+E->parallel.NUM_sNODE[lev][m].pass[k]];
Regional_parallel_related.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Regional_parallel_related.c: for (k=1;k<=E->parallel.sTNUM_PASS[lev][m];k++)  {
Regional_read_input_from_files.c:    const int dims=E->mesh.nsd;
Regional_read_input_from_files.c:    /*if( E->parallel.me == 0)  
Regional_read_input_from_files.c:    nox=E->mesh.nox;
Regional_read_input_from_files.c:    noy=E->mesh.noy;
Regional_read_input_from_files.c:    noz=E->mesh.noz;
Regional_read_input_from_files.c:    nox1=E->lmesh.nox;
Regional_read_input_from_files.c:    noz1=E->lmesh.noz;
Regional_read_input_from_files.c:    noy1=E->lmesh.noy;
Regional_read_input_from_files.c:    elx=E->lmesh.elx;
Regional_read_input_from_files.c:    elz=E->lmesh.elz;
Regional_read_input_from_files.c:    ely=E->lmesh.ely;
Regional_read_input_from_files.c:    emax=E->mesh.elx*E->mesh.elz*E->mesh.ely;
Regional_read_input_from_files.c:      if(!E->control.ggrd.vtop_control){	/* regular input */
Regional_read_input_from_files.c:      sprintf(output_file1,"%s%0.0f",E->control.velocity_boundary_file,newage1);
Regional_read_input_from_files.c:      sprintf(output_file2,"%s%0.0f",E->control.velocity_boundary_file,newage2);
Regional_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #4) Cannot open %s\n",output_file1);
Regional_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #5) Cannot open %s\n",output_file2);
Regional_read_input_from_files.c:      if((E->parallel.me==0) && (output==1))   {
Regional_read_input_from_files.c:         fprintf(E->fp,"Velocity: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Regional_read_input_from_files.c:         fprintf(E->fp,"Velocity: File1 = %s\n",output_file1);
Regional_read_input_from_files.c:           fprintf(E->fp,"Velocity: File2 = %s\n",output_file2);
Regional_read_input_from_files.c:           fprintf(E->fp,"Velocity: File2 = No file inputted (negative age)\n");
Regional_read_input_from_files.c:      if(!E->control.ggrd.age_control){	/* regular input */
Regional_read_input_from_files.c:        sprintf(output_file1,"%s%0.0f",E->control.lith_age_file,newage1);
Regional_read_input_from_files.c:        sprintf(output_file2,"%s%0.0f",E->control.lith_age_file,newage2);
Regional_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #6) Cannot open %s\n",output_file1);
Regional_read_input_from_files.c:            fprintf(E->fp,"(Problem_related #7) Cannot open %s\n",output_file2);            exit(8);
Regional_read_input_from_files.c:        if((E->parallel.me==0) && (output==1))   {
Regional_read_input_from_files.c:          fprintf(E->fp,"Age: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Regional_read_input_from_files.c:          fprintf(E->fp,"Age: File1 = %s\n",output_file1);
Regional_read_input_from_files.c:            fprintf(E->fp,"Age: File2 = %s\n",output_file2);
Regional_read_input_from_files.c:            fprintf(E->fp,"Age: File2 = No file inputted (negative age)\n");
Regional_read_input_from_files.c:	if(!E->control.ggrd.mat_control){
Regional_read_input_from_files.c:        sprintf(output_file1,"%s%0.0f.0",E->control.mat_file,newage1);
Regional_read_input_from_files.c:        sprintf(output_file2,"%s%0.0f.0",E->control.mat_file,newage2);
Regional_read_input_from_files.c:          fprintf(E->fp,"(Problem_related #8) Cannot open %s\n",output_file1);
Regional_read_input_from_files.c:            fprintf(E->fp,"(Problem_related #9) Cannot open %s\n",output_file2);
Regional_read_input_from_files.c:        if((E->parallel.me==0) && (output==1))   {
Regional_read_input_from_files.c:          fprintf(E->fp,"Mat: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Regional_read_input_from_files.c:          fprintf(E->fp,"Mat: File1 = %s\n",output_file1);
Regional_read_input_from_files.c:            fprintf(E->fp,"Mat: File2 = %s\n",output_file2);
Regional_read_input_from_files.c:            fprintf(E->fp,"Mat: File2 = No file inputted (negative age)\n");
Regional_read_input_from_files.c:        sprintf(output_file1,"%s%0.0f",E->control.temperature_boundary_file,newage1);
Regional_read_input_from_files.c:        sprintf(output_file2,"%s%0.0f",E->control.temperature_boundary_file,newage2);
Regional_read_input_from_files.c:            fprintf(E->fp,"(Problem_related #10) Cannot open %s\n",output_file1);
Regional_read_input_from_files.c:            fprintf(E->fp,"(Problem_related #11) Cannot open %s\n",output_file2);
Regional_read_input_from_files.c:        if((E->parallel.me==0) && (output==1))   {
Regional_read_input_from_files.c:           fprintf(E->fp,"Surface Temperature: Starting Age = %g, Elapsed time = %g, Current Age = %g\n",E->control.start_age,E->monitor.elapsed_time,age);
Regional_read_input_from_files.c:           fprintf(E->fp,"Surface Temperature: File1 = %s\n",output_file1);
Regional_read_input_from_files.c:             fprintf(E->fp,"Surface Temperature: File2 = %s\n",output_file2);
Regional_read_input_from_files.c:             fprintf(E->fp,"Surface Temperature: File2 = No file inputted (negative age)\n");
Regional_read_input_from_files.c:      if(E->control.ggrd.vtop_control){
Regional_read_input_from_files.c:         VB1[1][i]=E->data.timedir*VB1[1][i];
Regional_read_input_from_files.c:         VB1[2][i]=E->data.timedir*VB1[2][i];
Regional_read_input_from_files.c:             VB2[1][i]=E->data.timedir*VB2[1][i];
Regional_read_input_from_files.c:             VB2[2][i]=E->data.timedir*VB2[2][i];
Regional_read_input_from_files.c:      if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Regional_read_input_from_files.c:                nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Regional_read_input_from_files.c:                    E->sphere.cap[1].VB[1][nodel] = (VB1[1][nodeg] + (VB2[1][nodeg]-VB1[1][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Regional_read_input_from_files.c:                    E->sphere.cap[1].VB[2][nodel] = (VB1[2][nodeg] + (VB2[2][nodeg]-VB1[2][nodeg])/(newage2-newage1)*(age-newage1))*E->data.scalev;
Regional_read_input_from_files.c:                    E->sphere.cap[1].VB[3][nodel] = 0.0;
Regional_read_input_from_files.c:                    E->sphere.cap[1].VB[1][nodel] = VB1[1][nodeg]*E->data.scalev;
Regional_read_input_from_files.c:                    E->sphere.cap[1].VB[2][nodel] = VB1[2][nodeg]*E->data.scalev;
Regional_read_input_from_files.c:                    E->sphere.cap[1].VB[3][nodel] = 0.0;
Regional_read_input_from_files.c:      }   /* end of E->parallel.me_loc[3]==E->parallel.nprocz-1   */
Regional_read_input_from_files.c:	if(E->control.ggrd.age_control){
Regional_read_input_from_files.c:              E->age_t[node] = (inputage1 + (inputage2-inputage1)/(newage2-newage1)*(age-newage1))/E->data.scalet;
Regional_read_input_from_files.c:              E->age_t[node] = inputage1;
Regional_read_input_from_files.c:	if(E->control.ggrd.mat_control){
Regional_read_input_from_files.c:            nodea = E->ien[1][el].node[2];
Regional_read_input_from_files.c:              E->mat[1][el] = llayer;
Regional_read_input_from_files.c:                el = j + (i-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Regional_read_input_from_files.c:                elg = E->lmesh.ezs+j + (E->lmesh.exs+i-1)*E->mesh.elz + (E->lmesh.eys+k-1)*E->mesh.elz*E->mesh.elx;
Regional_read_input_from_files.c:                E->VIP[1][el] = VIP1[elg]+(VIP2[elg]-VIP1[elg])/(newage2-newage1)*(age-newage1);
Regional_read_input_from_files.c:                /* E->mat[1][el] = LL1[elg]; */ /*use the mat numbers base on radius*/
Regional_read_input_from_files.c:      if(E->control.ggrd.ray_control)
Regional_read_input_from_files.c:         /* if( E->parallel.me == 0)  
Regional_read_input_from_files.c:      if(E->parallel.me_loc[3]==E->parallel.nprocz-1 )  {
Regional_read_input_from_files.c:                nodeg = E->lmesh.nxs+i-1 + (E->lmesh.nys+k-2)*nox;
Regional_read_input_from_files.c:                    E->sphere.cap[1].TB[1][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Regional_read_input_from_files.c:                    E->sphere.cap[1].TB[2][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Regional_read_input_from_files.c:                    E->sphere.cap[1].TB[3][nodel] = (TB1[nodeg] + (TB2[nodeg]-TB1[nodeg])/(newage2-newage1)*(age-newage1));
Regional_read_input_from_files.c:                    E->sphere.cap[1].TB[1][nodel] = TB1[nodeg];
Regional_read_input_from_files.c:                    E->sphere.cap[1].TB[2][nodel] = TB1[nodeg];
Regional_read_input_from_files.c:                    E->sphere.cap[1].TB[3][nodel] = TB1[nodeg];
Regional_read_input_from_files.c:      }   /* end of E->parallel.me_loc[3]==E->parallel.nprocz-1   */
Regional_solver.c:    E->solver.velocity_boundary_conditions = regional_velocity_boundary_conditions;
Regional_solver.c:    E->solver.temperature_boundary_conditions = regional_temperature_boundary_conditions;
Regional_solver.c:    E->solver.set_2dc_defaults = regional_set_2dc_defaults;
Regional_solver.c:    E->solver.set_2pt5dc_defaults = regional_set_2pt5dc_defaults;
Regional_solver.c:    E->solver.set_3dc_defaults = regional_set_3dc_defaults;
Regional_solver.c:    E->solver.set_3dsphere_defaults = regional_set_3dsphere_defaults;
Regional_solver.c:    E->solver.lith_age_read_files = regional_lith_age_read_files;
Regional_solver.c:    E->solver.parallel_processor_setup = regional_parallel_processor_setup;
Regional_solver.c:    E->solver.parallel_domain_decomp0 = regional_parallel_domain_decomp0;
Regional_solver.c:    E->solver.parallel_domain_boundary_nodes = regional_parallel_domain_boundary_nodes;
Regional_solver.c:    E->solver.parallel_communication_routs_v = regional_parallel_communication_routs_v;
Regional_solver.c:    E->solver.parallel_communication_routs_s = regional_parallel_communication_routs_s;
Regional_solver.c:    E->solver.exchange_id_d = regional_exchange_id_d;
Regional_solver.c:    E->solver.read_input_files_for_timesteps = regional_read_input_files_for_timesteps;
Regional_solver.c:    E->solver.node_locations = regional_node_locations;
Regional_solver.c:    E->solver.construct_boundary = regional_construct_boundary;
Regional_sphere_related.c:  gnox=E->mesh.nox;
Regional_sphere_related.c:  gnoy=E->mesh.noy;
Regional_sphere_related.c:  gnoz=E->mesh.noz;
Regional_sphere_related.c:  nox=E->lmesh.nox;
Regional_sphere_related.c:  noy=E->lmesh.noy;
Regional_sphere_related.c:  noz=E->lmesh.noz;
Regional_sphere_related.c:  nprocxl=E->parallel.nprocx;
Regional_sphere_related.c:  nprocyl=E->parallel.nprocy;
Regional_sphere_related.c:  nproczl=E->parallel.nprocz;
Regional_sphere_related.c:  temp = max(E->mesh.NOY[E->mesh.levmax],E->mesh.NOX[E->mesh.levmax]);
Regional_sphere_related.c:  E->sphere.cap[1].theta[1] = E->control.theta_min;
Regional_sphere_related.c:  E->sphere.cap[1].theta[2] = E->control.theta_max;
Regional_sphere_related.c:  E->sphere.cap[1].theta[3] = E->control.theta_max;
Regional_sphere_related.c:  E->sphere.cap[1].theta[4] = E->control.theta_min;
Regional_sphere_related.c:  E->sphere.cap[1].fi[1] = E->control.fi_min;
Regional_sphere_related.c:  E->sphere.cap[1].fi[2] = E->control.fi_min;
Regional_sphere_related.c:  E->sphere.cap[1].fi[3] = E->control.fi_max;
Regional_sphere_related.c:  E->sphere.cap[1].fi[4] = E->control.fi_max;
Regional_sphere_related.c:  if(E->control.coor==1) {
Regional_sphere_related.c:    for(i=E->mesh.gridmin;i<=E->mesh.gridmax;i++)  {
Regional_sphere_related.c:    temp = E->mesh.NOY[E->mesh.levmax]*E->mesh.NOX[E->mesh.levmax];
Regional_sphere_related.c:    sprintf(output_file,"%s",E->control.coor_file);
Regional_sphere_related.c:      fprintf(E->fp,"(Sphere_related #1) Cannot open %s\n",output_file);
Regional_sphere_related.c:        if(fscanf(fp,"%d %e",&nn,&theta1[E->mesh.gridmax][i]) != 2) {
Regional_sphere_related.c:            fprintf(E->fp,"Error while reading coor_file '%s'\n",output_file);
Regional_sphere_related.c:    E->control.theta_min = theta1[E->mesh.gridmax][1];
Regional_sphere_related.c:    E->control.theta_max = theta1[E->mesh.gridmax][gnox];
Regional_sphere_related.c:        if(fscanf(fp,"%d %e",&nn,&fi1[E->mesh.gridmax][i]) != 2) {
Regional_sphere_related.c:            fprintf(E->fp,"Error while reading coor_file '%s'\n",output_file);
Regional_sphere_related.c:    E->control.fi_min = fi1[E->mesh.gridmax][1];
Regional_sphere_related.c:    E->control.fi_max = fi1[E->mesh.gridmax][gnoy];
Regional_sphere_related.c:    E->sphere.cap[1].theta[1] = E->control.theta_min;
Regional_sphere_related.c:    E->sphere.cap[1].theta[2] = E->control.theta_max;
Regional_sphere_related.c:    E->sphere.cap[1].theta[3] = E->control.theta_max;
Regional_sphere_related.c:    E->sphere.cap[1].theta[4] = E->control.theta_min;
Regional_sphere_related.c:    E->sphere.cap[1].fi[1] = E->control.fi_min;
Regional_sphere_related.c:    E->sphere.cap[1].fi[2] = E->control.fi_min;
Regional_sphere_related.c:    E->sphere.cap[1].fi[3] = E->control.fi_max;
Regional_sphere_related.c:    E->sphere.cap[1].fi[4] = E->control.fi_max;
Regional_sphere_related.c:    for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Regional_sphere_related.c:      if (E->control.NMULTIGRID)
Regional_sphere_related.c:        step = (int) pow(2.0,(double)(E->mesh.levmax-lev));
Regional_sphere_related.c:      for (i=1;i<=E->mesh.NOX[lev];i++)
Regional_sphere_related.c:	theta1[lev][i] = theta1[E->mesh.gridmax][(i-1)*step+1];
Regional_sphere_related.c:      for (i=1;i<=E->mesh.NOY[lev];i++)
Regional_sphere_related.c:	fi1[lev][i] = fi1[E->mesh.gridmax][(i-1)*step+1];
Regional_sphere_related.c:  for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Regional_sphere_related.c:     elx = E->lmesh.ELX[lev];
Regional_sphere_related.c:     ely = E->lmesh.ELY[lev];
Regional_sphere_related.c:     nox = E->lmesh.NOX[lev];
Regional_sphere_related.c:     noy = E->lmesh.NOY[lev];
Regional_sphere_related.c:     noz = E->lmesh.NOZ[lev];
Regional_sphere_related.c:             nodesx = E->lmesh.NXS[lev]+j-1;
Regional_sphere_related.c:             nodesy = E->lmesh.NYS[lev]+k-1;
Regional_sphere_related.c:                E->SX[lev][m][1][node] = theta1[lev][nodesx];
Regional_sphere_related.c:                E->SX[lev][m][2][node] = fi1[lev][nodesy];
Regional_sphere_related.c:                E->SX[lev][m][3][node] = E->sphere.R[lev][i];
Regional_sphere_related.c:                E->X[lev][m][1][node] =
Regional_sphere_related.c:                            E->sphere.R[lev][i]*sin(theta1[lev][nodesx])*cos(fi1[lev][nodesy]);
Regional_sphere_related.c:                E->X[lev][m][2][node] =
Regional_sphere_related.c:                            E->sphere.R[lev][i]*sin(theta1[lev][nodesx])*sin(fi1[lev][nodesy]);
Regional_sphere_related.c:                E->X[lev][m][3][node] =
Regional_sphere_related.c:                            E->sphere.R[lev][i]*cos(theta1[lev][nodesx]);
Regional_sphere_related.c:  for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)  {
Regional_sphere_related.c: else if((E->control.coor==0) || (E->control.coor==2)|| (E->control.coor==3))   {
Regional_sphere_related.c:  x[i] = (double *) malloc((E->parallel.nproc+1)*sizeof(double));
Regional_sphere_related.c:  y[i] = (double *) malloc((E->parallel.nproc+1)*sizeof(double));
Regional_sphere_related.c:  z[i] = (double *) malloc((E->parallel.nproc+1)*sizeof(double));
Regional_sphere_related.c:  temp = E->lmesh.NOY[E->mesh.levmax]*E->lmesh.NOX[E->mesh.levmax];
Regional_sphere_related.c:     tt[1] = E->sphere.cap[m].theta[1]+(E->sphere.cap[m].theta[2] -E->sphere.cap[m].theta[1])/nprocxl*(E->parallel.me_loc[1]);
Regional_sphere_related.c:     tt[2] = E->sphere.cap[m].theta[1]+(E->sphere.cap[m].theta[2] -E->sphere.cap[m].theta[1])/nprocxl*(E->parallel.me_loc[1]+1);
Regional_sphere_related.c:     ff[1] = E->sphere.cap[m].fi[1]+(E->sphere.cap[m].fi[4] -E->sphere.cap[1].fi[1])/nprocyl*(E->parallel.me_loc[2]);
Regional_sphere_related.c:     ff[3] = E->sphere.cap[m].fi[1]+(E->sphere.cap[m].fi[4] -E->sphere.cap[1].fi[1])/nprocyl*(E->parallel.me_loc[2]+1);
Regional_sphere_related.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Regional_sphere_related.c:     elx = E->lmesh.ELX[lev];
Regional_sphere_related.c:     ely = E->lmesh.ELY[lev];
Regional_sphere_related.c:     nox = E->lmesh.NOX[lev];
Regional_sphere_related.c:     noy = E->lmesh.NOY[lev];
Regional_sphere_related.c:     noz = E->lmesh.NOZ[lev];
Regional_sphere_related.c:                E->SX[lev][m][1][node] = SX[0][nodes];
Regional_sphere_related.c:                E->SX[lev][m][2][node] = SX[1][nodes];
Regional_sphere_related.c:                E->SX[lev][m][3][node] = E->sphere.R[lev][i];
Regional_sphere_related.c:                E->X[lev][m][1][node] =
Regional_sphere_related.c:                            E->sphere.R[lev][i]*sin(SX[0][nodes])*cos(SX[1][nodes]);
Regional_sphere_related.c:                E->X[lev][m][2][node] =
Regional_sphere_related.c:                            E->sphere.R[lev][i]*sin(SX[0][nodes])*sin(SX[1][nodes]);
Regional_sphere_related.c:                E->X[lev][m][3][node] =
Regional_sphere_related.c:                            E->sphere.R[lev][i]*cos(SX[0][nodes]);
Regional_tracer_advection.c:    if (E->sphere.caps_per_proc>1) {
Regional_tracer_advection.c:    sprintf(output_file,"%s.tracer_log.%d",E->control.data_file,E->parallel.me);
Regional_tracer_advection.c:    E->trace.fpt=fopen(output_file,"w");
Regional_tracer_advection.c:    E->trace.istat_isend=0;
Regional_tracer_advection.c:    E->trace.istat_iempty=0;
Regional_tracer_advection.c:    E->trace.istat_elements_checked=0;
Regional_tracer_advection.c:    E->trace.istat1=0;
Regional_tracer_advection.c:    E->trace.box_cushion=0.00001;
Regional_tracer_advection.c:    E->trace.number_of_basic_quantities=12;
Regional_tracer_advection.c:    E->trace.number_of_extra_quantities = 0;
Regional_tracer_advection.c:    if (E->trace.nflavors > 0)
Regional_tracer_advection.c:        E->trace.number_of_extra_quantities += 1;
Regional_tracer_advection.c:    E->trace.number_of_tracer_quantities =
Regional_tracer_advection.c:        E->trace.number_of_basic_quantities +
Regional_tracer_advection.c:        E->trace.number_of_extra_quantities;
Regional_tracer_advection.c:    if (E->trace.number_of_basic_quantities>99) {
Regional_tracer_advection.c:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of basic in tracer_defs.h\n");
Regional_tracer_advection.c:        fflush(E->trace.fpt);
Regional_tracer_advection.c:    if (E->trace.number_of_extra_quantities>99) {
Regional_tracer_advection.c:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of extraq in tracer_defs.h\n");
Regional_tracer_advection.c:        fflush(E->trace.fpt);
Regional_tracer_advection.c:    if (E->trace.number_of_tracer_quantities>99) {
Regional_tracer_advection.c:        fprintf(E->trace.fpt,"ERROR(initialize_trace)-increase 2nd position size of rlater in tracer_defs.h\n");
Regional_tracer_advection.c:        fflush(E->trace.fpt);
Regional_tracer_advection.c:    if (E->composition.on)
Regional_tracer_advection.c:    fprintf(E->trace.fpt, "Tracer intiailization takes %f seconds.\n",
Regional_tracer_advection.c:    fprintf(E->trace.fpt,"\nTracing Activated! (proc: %d)\n",E->parallel.me);
Regional_tracer_advection.c:    fprintf(E->trace.fpt,"   Allen K. McNamara 12-2003\n\n");
Regional_tracer_advection.c:    if (E->trace.ic_method==0) {
Regional_tracer_advection.c:        fprintf(E->trace.fpt,"Generating New Tracer Array\n");
Regional_tracer_advection.c:        fprintf(E->trace.fpt,"Tracers per element: %d\n",E->trace.itperel);
Regional_tracer_advection.c:    if (E->trace.ic_method==1) {
Regional_tracer_advection.c:        fprintf(E->trace.fpt,"Reading tracer file %s\n",E->trace.tracer_file);
Regional_tracer_advection.c:    if (E->trace.ic_method==2) {
Regional_tracer_advection.c:        fprintf(E->trace.fpt,"Read individual tracer files\n");
Regional_tracer_advection.c:    fprintf(E->trace.fpt,"Number of tracer flavors: %d\n", E->trace.nflavors);
Regional_tracer_advection.c:    if (E->trace.nflavors && E->trace.ic_method==0) {
Regional_tracer_advection.c:        fprintf(E->trace.fpt,"Initialized tracer flavors by: %d\n", E->trace.ic_method_for_flavors);
Regional_tracer_advection.c:        if (E->trace.ic_method_for_flavors == 0) {
Regional_tracer_advection.c:            fprintf(E->trace.fpt,"Layered tracer flavors\n");
Regional_tracer_advection.c:            for (i=0; i<E->trace.nflavors-1; i++)
Regional_tracer_advection.c:                fprintf(E->trace.fpt,"Interface Height: %d %f\n",i,E->trace.z_interface[i]);
Regional_tracer_advection.c:	else if((E->trace.ic_method_for_flavors == 1)||(E->trace.ic_method_for_flavors == 99)) {
Regional_tracer_advection.c:          fprintf(E->trace.fpt,"ggrd not implemented et for regional, flavor method= %d\n",
Regional_tracer_advection.c:		  E->trace.ic_method_for_flavors);
Regional_tracer_advection.c:	  fflush(E->trace.fpt);
Regional_tracer_advection.c:            fprintf(E->trace.fpt,"Sorry-This IC methods for Flavors are Unavailable %d\n",E->trace.ic_method_for_flavors);
Regional_tracer_advection.c:            fflush(E->trace.fpt);
Regional_tracer_advection.c:    for (i=0; i<E->trace.nflavors-2; i++) {
Regional_tracer_advection.c:        if (E->trace.z_interface[i] < E->trace.z_interface[i+1]) {
Regional_tracer_advection.c:            fprintf(E->trace.fpt,"Sorry - The %d-th z_interface is smaller than the next one.\n", i);
Regional_tracer_advection.c:            fflush(E->trace.fpt);
Regional_tracer_advection.c:    fprintf(E->trace.fpt,"Box Cushion: %f\n",E->trace.box_cushion);
Regional_tracer_advection.c:    fprintf(E->trace.fpt,"Number of Basic Quantities: %d\n",
Regional_tracer_advection.c:            E->trace.number_of_basic_quantities);
Regional_tracer_advection.c:    fprintf(E->trace.fpt,"Number of Extra Quantities: %d\n",
Regional_tracer_advection.c:            E->trace.number_of_extra_quantities);
Regional_tracer_advection.c:    fprintf(E->trace.fpt,"Total Number of Tracer Quantities: %d\n",
Regional_tracer_advection.c:            E->trace.number_of_tracer_quantities);
Regional_tracer_advection.c:    if (E->trace.itracer_warnings==0) {
Regional_tracer_advection.c:        fprintf(E->trace.fpt,"\n WARNING EXITS ARE TURNED OFF! TURN THEM ON!\n");
Regional_tracer_advection.c:        fflush(E->trace.fpt);
Regional_tracer_advection.c:    nox=E->lmesh.nox;
Regional_tracer_advection.c:    noy=E->lmesh.noy;
Regional_tracer_advection.c:    noz=E->lmesh.noz;
Regional_tracer_advection.c:    E->trace.x_space=(double*) malloc(nox*sizeof(double));
Regional_tracer_advection.c:    E->trace.y_space=(double*) malloc(noy*sizeof(double));
Regional_tracer_advection.c:    E->trace.z_space=(double*) malloc(noz*sizeof(double));
Regional_tracer_advection.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Regional_tracer_advection.c:	    E->trace.x_space[i]=E->sx[m][1][i*noz+1];
Regional_tracer_advection.c:	    E->trace.y_space[j]=E->sx[m][2][j*nox*noz+1];
Regional_tracer_advection.c:	    E->trace.z_space[k]=E->sx[m][3][k+1];
Regional_tracer_advection.c:	fprintf(E->trace.fpt, "i=%d x=%e\n", i, E->trace.x_space[i]);
Regional_tracer_advection.c:	fprintf(E->trace.fpt, "j=%d y=%e\n", j, E->trace.y_space[j]);
Regional_tracer_advection.c:	fprintf(E->trace.fpt, "k=%d z=%e\n", k, E->trace.z_space[k]);
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.7, 0));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.7, 1));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.7, 2));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.7, 3));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.7, 4));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.56, 0));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.56, 1));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.56, 2));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.99, 2));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.99, 3));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_neighbors(E->trace.z_space, noz, 0.99, 4));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.5));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 1.1));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.55));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 1.0));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.551));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.99));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.7));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.75));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.775));
Regional_tracer_advection.c:    fprintf(stderr, "%d\n", isearch_all(E->trace.z_space, noz, 0.7750001));
Regional_tracer_advection.c:    elx = E->lmesh.elx;
Regional_tracer_advection.c:    ely = E->lmesh.ely;
Regional_tracer_advection.c:    elz = E->lmesh.elz;
Regional_tracer_advection.c:	ii = isearch_neighbors(E->trace.x_space, elx+1, theta, i);
Regional_tracer_advection.c:	jj = isearch_neighbors(E->trace.y_space, ely+1, phi, j);
Regional_tracer_advection.c:	kk = isearch_neighbors(E->trace.z_space, elz+1, rad, k);
Regional_tracer_advection.c:    ii = isearch_all(E->trace.x_space, elx+1, theta);
Regional_tracer_advection.c:    jj = isearch_all(E->trace.y_space, ely+1, phi);
Regional_tracer_advection.c:    kk = isearch_all(E->trace.z_space, elz+1, rad);
Regional_tracer_advection.c:    theta_min = E->trace.theta_cap[icap][2];
Regional_tracer_advection.c:    theta_max = E->trace.theta_cap[icap][4];
Regional_tracer_advection.c:    phi_min = E->trace.phi_cap[icap][2];
Regional_tracer_advection.c:    phi_max = E->trace.phi_cap[icap][4];
Regional_tracer_advection.c:    elx = E->lmesh.elx;
Regional_tracer_advection.c:    ely = E->lmesh.ely;
Regional_tracer_advection.c:    elz = E->lmesh.elz;
Regional_tracer_advection.c:    tr_dx = theta - E->trace.x_space[i];
Regional_tracer_advection.c:    dx = E->trace.x_space[i+1] - E->trace.x_space[i];
Regional_tracer_advection.c:    tr_dy = phi - E->trace.y_space[j];
Regional_tracer_advection.c:    dy = E->trace.y_space[j+1] - E->trace.y_space[j];
Regional_tracer_advection.c:    tr_dz = rad - E->trace.z_space[k];
Regional_tracer_advection.c:    dz = E->trace.z_space[k+1] - E->trace.z_space[k];
Regional_tracer_advection.c:    fprintf(E->trace.fpt, "dr=(%e,%e,%e)  tr_dr=(%e,%e,%e)\n",
Regional_tracer_advection.c:    fprintf(E->trace.fpt, "shp: %e %e %e %e %e %e %e %e\n",
Regional_tracer_advection.c:    fprintf(E->trace.fpt, "sum(shp): %e\n",
Regional_tracer_advection.c:    fflush(E->trace.fpt);
Regional_tracer_advection.c:        fprintf(E->trace.fpt, "VV: %e %e %e %e %e %e %e %e: %e\n",
Regional_tracer_advection.c:        tmp += E->sx[m][1][E->ien[m][nelem].node[n]] * shp[n];
Regional_tracer_advection.c:    fprintf(E->trace.fpt, "THETA: %e -> %e\n", theta, tmp);
Regional_tracer_advection.c:    fflush(E->trace.fpt);
Regional_tracer_advection.c:    if (*theta > E->control.theta_max - E->trace.box_cushion) {
Regional_tracer_advection.c:        *theta = E->control.theta_max - E->trace.box_cushion;
Regional_tracer_advection.c:    if (*theta < E->control.theta_min + E->trace.box_cushion) {
Regional_tracer_advection.c:        *theta = E->control.theta_min + E->trace.box_cushion;
Regional_tracer_advection.c:    if (*phi > E->control.fi_max - E->trace.box_cushion) {
Regional_tracer_advection.c:        *phi = E->control.fi_max - E->trace.box_cushion;
Regional_tracer_advection.c:    if (*phi < E->control.fi_min + E->trace.box_cushion) {
Regional_tracer_advection.c:        *phi = E->control.fi_min + E->trace.box_cushion;
Regional_tracer_advection.c:    if (*rad > E->sphere.ro - E->trace.box_cushion) {
Regional_tracer_advection.c:        *rad = E->sphere.ro - E->trace.box_cushion;
Regional_tracer_advection.c:    if (*rad < E->sphere.ri + E->trace.box_cushion) {
Regional_tracer_advection.c:        *rad = E->sphere.ri + E->trace.box_cushion;
Regional_tracer_advection.c:    /* This part only works if E->sphere.caps_per_proc==1 */
Regional_tracer_advection.c:    int lev = E->mesh.levmax;
Regional_tracer_advection.c:    E->trace.istat_isend = E->trace.ilater[j];
Regional_tracer_advection.c:    for (d=0; d<E->mesh.nsd; d++) {
Regional_tracer_advection.c:        bounds[d][0] = E->sx[j][d+1][1];
Regional_tracer_advection.c:        bounds[d][1] = E->sx[j][d+1][E->lmesh.nno];
Regional_tracer_advection.c:        if (E->parallel.NUM_PASS[lev][j].bound[kk] == 1) {
Regional_tracer_advection.c:            ngbr_rank[kk] = E->parallel.PROCESSOR[lev][j].pass[ipass];
Regional_tracer_advection.c:    for (kk=1; kk<=E->trace.istat_isend; kk++) {
Regional_tracer_advection.c:        fprintf(E->trace.fpt, "tracer#=%d xx=(%g,%g,%g)\n", kk,
Regional_tracer_advection.c:                E->trace.rlater[j][0][kk],
Regional_tracer_advection.c:                E->trace.rlater[j][1][kk],
Regional_tracer_advection.c:                E->trace.rlater[j][2][kk]);
Regional_tracer_advection.c:    for (d=0; d<E->mesh.nsd; d++) {
Regional_tracer_advection.c:        fprintf(E->trace.fpt, "bounds(dim=%d) = (%e, %e)\n",
Regional_tracer_advection.c:        fprintf(E->trace.fpt, "pass=%d  neighbor_rank=%d\n",
Regional_tracer_advection.c:    fflush(E->trace.fpt);
Regional_tracer_advection.c:    max_send_size = max(2*E->trace.ilater[j], E->trace.ntracers[j]/100);
Regional_tracer_advection.c:    itemp_size = max_send_size * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:        fprintf(E->trace.fpt,"Error(lost souls)-no memory (u388)\n");
Regional_tracer_advection.c:        fflush(E->trace.fpt);
Regional_tracer_advection.c:        fprintf(E->trace.fpt,"Error(lost souls)-no memory (u389)\n");
Regional_tracer_advection.c:        fflush(E->trace.fpt);
Regional_tracer_advection.c:    for (d=0; d<E->mesh.nsd; d++) {
Regional_tracer_advection.c:        int original_size = E->trace.ilater[j];
Regional_tracer_advection.c:        while (kk<=E->trace.ilater[j]) {
Regional_tracer_advection.c:            coord = E->trace.rlater[j][d][kk];
Regional_tracer_advection.c:                itemp_size = isize * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:                    fprintf(E->trace.fpt,"Error(lost souls)-no memory (s4)\n");
Regional_tracer_advection.c:                    fflush(E->trace.fpt);
Regional_tracer_advection.c:                    fprintf(E->trace.fpt,"Error(lost souls)-no memory (s5)\n");
Regional_tracer_advection.c:                    fflush(E->trace.fpt);
Regional_tracer_advection.c:                fprintf(E->trace.fpt,"Expanding physical memory of send to "
Regional_tracer_advection.c:        if ((isend[0] + isend[1] + E->trace.ilater[j]) != original_size) {
Regional_tracer_advection.c:            fprintf(E->trace.fpt, "original_size: %d, rlater_size: %d, "
Regional_tracer_advection.c:                    original_size, E->trace.ilater[j], kk);
Regional_tracer_advection.c:                fprintf(E->trace.fpt, "dim:%d side:%d kk=%d coord[kk]=%e\n",
Regional_tracer_advection.c:                        send[i][kk*E->trace.number_of_tracer_quantities+d]);
Regional_tracer_advection.c:        fflush(E->trace.fpt);
Regional_tracer_advection.c:                          11, E->parallel.world, &request[idb++]);
Regional_tracer_advection.c:                          11, E->parallel.world, &request[idb++]);
Regional_tracer_advection.c:                fprintf(E->trace.fpt, "%d: %d send %d to proc %d\n",
Regional_tracer_advection.c:                fprintf(E->trace.fpt, "%d: %d recv %d from proc %d\n",
Regional_tracer_advection.c:            isize = irecv[i] * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:                fprintf(E->trace.fpt, "Error(lost souls)-no memory (c721)\n");
Regional_tracer_advection.c:                fflush(E->trace.fpt);
Regional_tracer_advection.c:                isize = isend[i] * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:                          12, E->parallel.world, &request[idb++]);
Regional_tracer_advection.c:                isize = irecv[i] * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:                          12, E->parallel.world, &request[idb++]);
Regional_tracer_advection.c:                fprintf(E->trace.fpt, "recv: %d %e %e %e\n",
Regional_tracer_advection.c:                        recv[i][(kk-1)*E->trace.number_of_tracer_quantities],
Regional_tracer_advection.c:                        recv[i][(kk-1)*E->trace.number_of_tracer_quantities+1],
Regional_tracer_advection.c:                        recv[i][(kk-1)*E->trace.number_of_tracer_quantities+2]);
Regional_tracer_advection.c:        fflush(E->trace.fpt);
Regional_tracer_advection.c:    if (E->trace.ilater[j] > 0) {
Regional_tracer_advection.c:        fprintf(E->trace.fpt, "Error(regional_lost_souls) lost tracers\n");
Regional_tracer_advection.c:        for (kk=1; kk<=E->trace.ilater[j]; kk++) {
Regional_tracer_advection.c:            fprintf(E->trace.fpt, "lost #%d xx=(%e, %e, %e)\n", kk,
Regional_tracer_advection.c:                    E->trace.rlater[j][0][kk],
Regional_tracer_advection.c:                    E->trace.rlater[j][1][kk],
Regional_tracer_advection.c:                    E->trace.rlater[j][2][kk]);
Regional_tracer_advection.c:        fflush(E->trace.fpt);
Regional_tracer_advection.c:    E->trace.lost_souls_time += CPU_time0() - begin_time;
Regional_tracer_advection.c:    isend_position = (*send_size) * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:    for (pp=0; pp<E->trace.number_of_tracer_quantities; pp++) {
Regional_tracer_advection.c:        send[ipos] = E->trace.rlater[j][pp][kk];
Regional_tracer_advection.c:    ilast_tracer = E->trace.ilater[j];
Regional_tracer_advection.c:    for (pp=0; pp<E->trace.number_of_tracer_quantities; pp++) {
Regional_tracer_advection.c:        E->trace.rlater[j][pp][kk] = E->trace.rlater[j][pp][ilast_tracer];
Regional_tracer_advection.c:    E->trace.ilater[j]--;
Regional_tracer_advection.c:        ipos = kk * E->trace.number_of_tracer_quantities;
Regional_tracer_advection.c:        fprintf(E->trace.fpt, "kk=%d, inside=%d, xx=(%e, %e, %e)\n",
Regional_tracer_advection.c:        fprintf(E->trace.fpt, "before: %d %d\n",
Regional_tracer_advection.c:                E->trace.ilater[j], E->trace.ntracers[j]);
Regional_tracer_advection.c:            E->trace.ntracers[j]++;
Regional_tracer_advection.c:            ilast = E->trace.ntracers[j];
Regional_tracer_advection.c:            if (E->trace.ntracers[j] > (E->trace.max_ntracers[j]-5))
Regional_tracer_advection.c:            for (pp=0; pp<E->trace.number_of_basic_quantities; pp++)
Regional_tracer_advection.c:                E->trace.basicq[j][pp][ilast] = recv[ipos+pp];
Regional_tracer_advection.c:            ipos += E->trace.number_of_basic_quantities;
Regional_tracer_advection.c:            for (pp=0; pp<E->trace.number_of_extra_quantities; pp++)
Regional_tracer_advection.c:                E->trace.extraq[j][pp][ilast] = recv[ipos+pp];
Regional_tracer_advection.c:                fprintf(E->trace.fpt, "Error(regional lost souls) - "
Regional_tracer_advection.c:                fprintf(E->trace.fpt, "theta, phi, rad: %f %f %f\n",
Regional_tracer_advection.c:                fflush(E->trace.fpt);
Regional_tracer_advection.c:            E->trace.ielement[j][ilast] = iel;
Regional_tracer_advection.c:            if (E->trace.ilatersize[j]==0) {
Regional_tracer_advection.c:                E->trace.ilatersize[j]=E->trace.max_ntracers[j]/5;
Regional_tracer_advection.c:                for (kk=0;kk<E->trace.number_of_tracer_quantities;kk++) {
Regional_tracer_advection.c:                    if ((E->trace.rlater[j][kk]=(double *)malloc(E->trace.ilatersize[j]*sizeof(double)))==NULL) {
Regional_tracer_advection.c:                        fprintf(E->trace.fpt,"AKM(put_found_tracers)-no memory (%d)\n",kk);
Regional_tracer_advection.c:                        fflush(E->trace.fpt);
Regional_tracer_advection.c:            E->trace.ilater[j]++;
Regional_tracer_advection.c:            ilast = E->trace.ilater[j];
Regional_tracer_advection.c:            if (E->trace.ilater[j] > (E->trace.ilatersize[j]-5))
Regional_tracer_advection.c:            for (pp=0; pp<E->trace.number_of_tracer_quantities; pp++)
Regional_tracer_advection.c:                E->trace.rlater[j][pp][ilast] = recv[ipos+pp];
Regional_tracer_advection.c:        fprintf(E->trace.fpt, "after: %d %d\n",
Regional_tracer_advection.c:                E->trace.ilater[j], E->trace.ntracers[j]);
Regional_tracer_advection.c:        fflush(E->trace.fpt);
Regional_version_dependent.c:  rr = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Regional_version_dependent.c:  RR = (double *)  malloc((E->mesh.noz+1)*sizeof(double));
Regional_version_dependent.c:  nox=E->mesh.nox;
Regional_version_dependent.c:  noy=E->mesh.noy;
Regional_version_dependent.c:  noz=E->mesh.noz;
Regional_version_dependent.c:  switch(E->control.coor)    {	
Regional_version_dependent.c:    dr = (E->sphere.ro-E->sphere.ri)/(E->mesh.noz-1);
Regional_version_dependent.c:    for (k=1;k<=E->mesh.noz;k++)  {
Regional_version_dependent.c:      rr[k] = E->sphere.ri + (k-1)*dr;
Regional_version_dependent.c:    sprintf(output_file,"%s",E->control.coor_file);
Regional_version_dependent.c:      fprintf(E->fp,"(Nodal_mesh.c #1) Cannot open %s\n",output_file);
Regional_version_dependent.c:    for (k=1;k<=E->mesh.noz;k++)  {
Regional_version_dependent.c:    E->sphere.ri = rr[1];
Regional_version_dependent.c:    E->sphere.ro = rr[E->mesh.noz];
Regional_version_dependent.c:  for (i=1;i<=E->lmesh.noz;i++)  {
Regional_version_dependent.c:      k = E->lmesh.nzs+i-1;
Regional_version_dependent.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Regional_version_dependent.c:    if (E->control.NMULTIGRID)
Regional_version_dependent.c:        step = (int) pow(2.0,(double)(E->mesh.levmax-lev));
Regional_version_dependent.c:      for (i=1;i<=E->lmesh.NOZ[lev];i++)
Regional_version_dependent.c:         E->sphere.R[lev][i] = RR[(i-1)*step+1];
Regional_version_dependent.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Regional_version_dependent.c:  if (E->control.verbose) {
Regional_version_dependent.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++) {
Regional_version_dependent.c:    fprintf(E->fp_out,"output_coordinates before rotation %d \n",lev);
Regional_version_dependent.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)  {
Regional_version_dependent.c:      fprintf(E->fp_out,"output_coordinates for cap %d %d\n",j,E->lmesh.NNO[lev]);
Regional_version_dependent.c:      for (i=1;i<=E->lmesh.NNO[lev];i++)
Regional_version_dependent.c:        if(i%E->lmesh.NOZ[lev]==1)
Regional_version_dependent.c:             fprintf(E->fp_out,"%d %d %g %g %g\n",j,i,E->SX[lev][j][1][i],E->SX[lev][j][2][i],E->SX[lev][j][3][i]);
Regional_version_dependent.c:    fflush(E->fp_out);
Regional_version_dependent.c:  if(E->data.use_ellipse)
Regional_version_dependent.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)
Regional_version_dependent.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Regional_version_dependent.c:      for (i=1;i<=E->lmesh.NNO[lev];i++)  {
Regional_version_dependent.c:        E->SinCos[lev][j][0][i] = sin(E->SX[lev][j][1][i]);
Regional_version_dependent.c:        E->SinCos[lev][j][1][i] = sin(E->SX[lev][j][2][i]);
Regional_version_dependent.c:        E->SinCos[lev][j][2][i] = cos(E->SX[lev][j][1][i]);
Regional_version_dependent.c:        E->SinCos[lev][j][3][i] = cos(E->SX[lev][j][2][i]);
Regional_version_dependent.c:  if (E->parallel.me_loc[3]==E->parallel.nprocz-1)  {
Regional_version_dependent.c:    sprintf(output_file,"coord.%d",E->parallel.me);
Regional_version_dependent.c:          fprintf(E->fp,"(Nodal_mesh.c #2) Cannot open %s\n",output_file);
Regional_version_dependent.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Regional_version_dependent.c:      for(i=1;i<=E->lmesh.noy;i++) {
Regional_version_dependent.c:        for(j=1;j<=E->lmesh.nox;j++)  {
Regional_version_dependent.c:           node=1+(j-1)*E->lmesh.noz+(i-1)*E->lmesh.nox*E->lmesh.noz;
Regional_version_dependent.c:           t1 = 90.0-E->sx[m][1][node]/M_PI*180.0;
Regional_version_dependent.c:           f1 = E->sx[m][2][node]/M_PI*180.0;
Regional_version_dependent.c:      for(j=1;j<=E->lmesh.nox;j++)  {
Regional_version_dependent.c:        for(i=1;i<=E->lmesh.noy;i++) {
Regional_version_dependent.c:           node=1+(j-1)*E->lmesh.noz+(i-1)*E->lmesh.nox*E->lmesh.noz;
Regional_version_dependent.c:           t1 = 90.0-E->sx[m][1][node]/M_PI*180.0;
Regional_version_dependent.c:           f1 = E->sx[m][2][node]/M_PI*180.0;
Regional_version_dependent.c:  if (E->control.verbose) {
Regional_version_dependent.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)   {
Regional_version_dependent.c:    fprintf(E->fp_out,"output_coordinates after rotation %d \n",lev);
Regional_version_dependent.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)
Regional_version_dependent.c:      for (i=1;i<=E->lmesh.NNO[lev];i++)
Regional_version_dependent.c:        if(i%E->lmesh.NOZ[lev]==1)
Regional_version_dependent.c:             fprintf(E->fp_out,"%d %d %g %g %g\n",j,i,E->SX[lev][j][1][i],E->SX[lev][j][2][i],E->SX[lev][j][3][i]);
Regional_version_dependent.c:    fflush(E->fp_out);
Regional_version_dependent.c:  const int dims=E->mesh.nsd;
Regional_version_dependent.c:  int max_size = E->lmesh.elx*E->lmesh.ely*E->lmesh.elz
Regional_version_dependent.c:    - (E->lmesh.elx-2)*(E->lmesh.ely-2)*(E->lmesh.elz-2) + 1;
Regional_version_dependent.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_version_dependent.c:    E->boundary.element[m] = (int *)malloc(max_size*sizeof(int));
Regional_version_dependent.c:      E->boundary.normal[m][d] = (int *)malloc(max_size*sizeof(int));
Regional_version_dependent.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Regional_version_dependent.c:    for(k=1; k<=E->lmesh.ely; k++)
Regional_version_dependent.c:      for(j=1; j<=E->lmesh.elx; j++)
Regional_version_dependent.c:	for(i=1; i<=E->lmesh.elz; i++) {
Regional_version_dependent.c:	  if((E->parallel.me_loc[1] == 0) && (j == 1)) {
Regional_version_dependent.c:	  if((E->parallel.me_loc[1] == E->parallel.nprocx - 1)
Regional_version_dependent.c:	     && (j == E->lmesh.elx)) {
Regional_version_dependent.c:	  if((E->parallel.me_loc[2] == 0) && (k == 1)) {
Regional_version_dependent.c:	  if((E->parallel.me_loc[2] == E->parallel.nprocy - 1)
Regional_version_dependent.c:	     && (k == E->lmesh.ely)) {
Regional_version_dependent.c:	  if((E->parallel.me_loc[3] == 0) && (i == 1)) {
Regional_version_dependent.c:	  if((E->parallel.me_loc[3] == E->parallel.nprocz - 1)
Regional_version_dependent.c:	     && (i == E->lmesh.elz)) {
Regional_version_dependent.c:	    el = i + (j-1)*E->lmesh.elz + (k-1)*E->lmesh.elz*E->lmesh.elx;
Regional_version_dependent.c:	    E->boundary.element[m][count] = el;
Regional_version_dependent.c:	      E->boundary.normal[m][d][count] = normalFlag[d];
Regional_version_dependent.c:    E->boundary.nel = count - 1;
Sea_Level_Equation.c: * Sets E->slice.oceanload and E->slice.incr_oceanload based on
Sea_Level_Equation.c: *     E->potential[0] (geoid) and E->slice.surf[3] (topo).
Sea_Level_Equation.c:        scale_geoid =  4.0*M_PI * E->data.grav_const * E->data.density
Sea_Level_Equation.c:                     * E->sphere.dradius * E->sphere.dradius ; // dim'ful pot.
Sea_Level_Equation.c:        scale_geoid /= E->data.grav_acc;                       // dim'ful geoid
Sea_Level_Equation.c:        scale_geoid /= E->sphere.dradius ;                     // dimless geoid
Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++) {
Sea_Level_Equation.c:            E->slice_ve.total_dynamic_oceanload[m] = (double *)
Sea_Level_Equation.c:                              malloc((E->lmesh.nsf+2)*sizeof(double));
Sea_Level_Equation.c:            E->slice_ve.init_oceanload[m] = (double *)
Sea_Level_Equation.c:                              malloc((E->lmesh.nsf+2)*sizeof(double));
Sea_Level_Equation.c:            for (j=1;j<=E->lmesh.nsf;j++) {
Sea_Level_Equation.c:                E->slice_ve.total_dynamic_oceanload[m][j] = 0.0 ;
Sea_Level_Equation.c:                E->slice_ve.init_oceanload[m][j] = 0.0 ;
Sea_Level_Equation.c:if (E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)    
Sea_Level_Equation.c:          E->slice_ve.init_oceanload[m][j]= E->slice_ve.total_dynamic_oceanload[m][j];
Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)  {
Sea_Level_Equation.c:            topo = E->slice_ve.surf[3][m][j] ;
Sea_Level_Equation.c:            geoid = scale_geoid*E->potential[0][m][j] ;
Sea_Level_Equation.c:            E->Xsurf[3][m][j] = (geoid - topo) * E->slice_ve.ocean_fcn[m][j] ;
Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)  {
Sea_Level_Equation.c:            i = j*E->lmesh.noz;
Sea_Level_Equation.c:            topo = E->slice_ve.surf[3][m][j] + E->U[m][E->id[m][i].doff[3]] ;
Sea_Level_Equation.c:            geoid = scale_geoid*E->potential[0][m][j] ;
Sea_Level_Equation.c:            E->Xsurf[3][m][j] = geoid - topo ;
Sea_Level_Equation.c:        remove_average(E,E->Xsurf[3],1); // should have no average in order
Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)  
Sea_Level_Equation.c:            E->Xsurf[3][m][j] *= E->slice_ve.ocean_fcn[m][j] ;
Sea_Level_Equation.c:    nu_volume = total_surface_integral( E, E->Xsurf[3], 1) ; 
Sea_Level_Equation.c:    c =  -nu_volume / E->ve_data_cont.ocean_area ;
Sea_Level_Equation.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:    for (j=1;j<=E->lmesh.nsf;j++)
Sea_Level_Equation.c:        E->slice_ve.total_dynamic_oceanload[m][j] = 1000.0/917.4*E->ve_data_cont.ice_stress_scale *
Sea_Level_Equation.c:                       ( E->Xsurf[3][m][j] + ( c * E->slice_ve.ocean_fcn[m][j] )) ;
Sea_Level_Equation.c:    if (E->ve_data_cont.SLE_lmax)  
Sea_Level_Equation.c:        truncate_Ylm_expansion(E, E->slice_ve.total_dynamic_oceanload, 
Sea_Level_Equation.c:                                  E->ve_data_cont.SLE_lmax );
Sea_Level_Equation.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:    for (j=1;j<=E->lmesh.nsf;j++)
Sea_Level_Equation.c:        E->slice_ve.dynamic_oceanload[m][j]= E->slice_ve.total_dynamic_oceanload[m][j]
Sea_Level_Equation.c:                                        - E->slice_ve.init_oceanload[m][j] ;
Sea_Level_Equation.c:    remove_average(E,E->slice_ve.dynamic_oceanload,1);
Sea_Level_Equation.c:    if (verbose && E->parallel.me==E->parallel.nprocz-1)
Sea_Level_Equation.c:        fp = (i==0)? stderr : E->fp_out ;
Sea_Level_Equation.c:                    E->ve_data_cont.tau*E->monitor.elapsed_time );    // time
Sea_Level_Equation.c:                    c * E->sphere.dradius,                // eust. SL (meters)
Sea_Level_Equation.c:                    nu_volume , E->ve_data_cont.ocean_area );
Sea_Level_Equation.c:        E->ve_data_cont.ocean_area = total_surface_integral( E, E->slice_ve.ocean_fcn, 1) ;
Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Sea_Level_Equation.c:            E->slice_ve.total_static_oceanload[m] = (double *)
Sea_Level_Equation.c:                              malloc((E->lmesh.nsf+2)*sizeof(double));
Sea_Level_Equation.c:            for (n=1;n<=E->lmesh.nsf;n++)
Sea_Level_Equation.c:                E->slice_ve.total_static_oceanload[m][n] = 0.0;
Sea_Level_Equation.c:    ice_volume += E->ve_data_cont.incr_ice_volume ;
Sea_Level_Equation.c:        E->ve_data_cont.ocean_area += E->ve_data_cont.incr_ocean_area ;
Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)    
Sea_Level_Equation.c:            E->slice_ve.ocean_fcn[m][j] += E->slice_ve.incr_ocean_fcn[m][j] ;
Sea_Level_Equation.c:    c =  -ice_volume / E->ve_data_cont.ocean_area * E->ve_data_cont.ice_stress_scale ;
Sea_Level_Equation.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:    for (j=1;j<=E->lmesh.nsf;j++)
Sea_Level_Equation.c:        E->Xsurf[3][m][j] = c * E->slice_ve.ocean_fcn[m][j] ;  
Sea_Level_Equation.c:    if (E->ve_data_cont.SLE_lmax) 
Sea_Level_Equation.c:        truncate_Ylm_expansion(E, E->Xsurf[3], E->ve_data_cont.SLE_lmax );
Sea_Level_Equation.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:    for (j=1;j<=E->lmesh.nsf;j++) {
Sea_Level_Equation.c:        E->slice_ve.static_oceanload[m][j] = E->Xsurf[3][m][j]
Sea_Level_Equation.c:                                        - E->slice_ve.total_static_oceanload[m][j];
Sea_Level_Equation.c:        E->slice_ve.total_static_oceanload[m][j] = E->Xsurf[3][m][j] ;
Sea_Level_Equation.c:    remove_average(E,E->slice_ve.static_oceanload,1);
Sea_Level_Equation.c:    if (verbose && E->parallel.me==E->parallel.nprocz-1)
Sea_Level_Equation.c:       fp = (i==0)? stderr : E->fp_out ;
Sea_Level_Equation.c:               E->ve_data_cont.tau*E->monitor.elapsed_time ,          // time
Sea_Level_Equation.c:               c/E->ve_data_cont.ice_stress_scale * E->sphere.dradius // Eus SL (meters)
Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Sea_Level_Equation.c:            E->slice_ve.ocean_fcn[m] = (double *)
Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Sea_Level_Equation.c:            E->slice_ve.incr_ocean_fcn[m] = (double *)
Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Sea_Level_Equation.c:            E->slice_ve.ocean_fcn_prev[m] = (double *)
Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Sea_Level_Equation.c:            E->slice_ve.ocean_fcn_next[m] = (double *)
Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Sea_Level_Equation.c:            for (n=1;n<=E->lmesh.nsf;n++)  {  
Sea_Level_Equation.c:                E->slice_ve.ocean_fcn[m][n]      = 0.0;
Sea_Level_Equation.c:                E->slice_ve.incr_ocean_fcn[m][n] = 0.0;
Sea_Level_Equation.c:                E->slice_ve.ocean_fcn_prev[m][n] = 0.0;
Sea_Level_Equation.c:                E->slice_ve.ocean_fcn_next[m][n] = 0.0;
Sea_Level_Equation.c:                        E->ve_data_cont.ocean_file, E->parallel.me, start_epoch);
Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)  {
Sea_Level_Equation.c:            E->slice_ve.ocean_fcn_prev[m][j] = (float)temp0 ;
Sea_Level_Equation.c:            E->slice_ve.ocean_fcn[m][j] = E->slice_ve.ocean_fcn_prev[m][j] ;
Sea_Level_Equation.c:        total_time = E->ve_data_cont.tau*E->monitor.elapsed_time;
Sea_Level_Equation.c:        i = (total_time - E->ve_data_cont.stages_time[0]);
Sea_Level_Equation.c:        // note: if E->control.stage==0 (during glaciation),   i<0 (returns)
Sea_Level_Equation.c:        //       if E->control.stage==1 (during deglaciation), check ifile
Sea_Level_Equation.c:        //       if E->control.stage==2 (after deglaciation),  see next block
Sea_Level_Equation.c:    if (E->ve_data_cont.stage==2)  {                 // completed deglaciation 
Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++) 
Sea_Level_Equation.c:            E->slice_ve.incr_ocean_fcn[m][j] = 0.0;    // 0 => no more change
Sea_Level_Equation.c:        E->ve_data_cont.incr_ocean_area = 0.0 ;
Sea_Level_Equation.c:        E->ve_data_cont.incr_ice_volume = 0.0  ;
Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)  
Sea_Level_Equation.c:            E->slice_ve.ocean_fcn_prev[m][j] = E->slice_ve.ocean_fcn_next[m][j];   
Sea_Level_Equation.c:    sprintf(outfile,"%s.%d.time%d", E->ve_data_cont.ocean_file,E->parallel.me,ifile);
Sea_Level_Equation.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:    for (j=1;j<=E->lmesh.nsf;j++)  {
Sea_Level_Equation.c:        E->slice_ve.ocean_fcn_next[m][j] = (float)temp0 ;
Sea_Level_Equation.c:    if (ifile==1) steps_per_epoch = E->ve_data_cont.stages_step[0];
Sea_Level_Equation.c:    else  steps_per_epoch =  1000.0/E->ve_data_cont.tau   // nondim 1kyr
Sea_Level_Equation.c:                             / E->ve_data_cont.stages_timestep[E->ve_data_cont.stage] ;
Sea_Level_Equation.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:    for (j=1;j<=E->lmesh.nsf;j++) 
Sea_Level_Equation.c:        E->slice_ve.incr_ocean_fcn[m][j] = ( E->slice_ve.ocean_fcn_next[m][j]
Sea_Level_Equation.c:                                         -E->slice_ve.ocean_fcn_prev[m][j]) 
Sea_Level_Equation.c:    E->ve_data_cont.incr_ocean_area=total_surface_integral(E,E->slice_ve.incr_ocean_fcn,1);
Sea_Level_Equation.c:    E->ve_data_cont.incr_ice_volume = (ice_volume[ifile] - ice_volume[ifile-1]) 
Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Sea_Level_Equation.c:            E->slice_ve.ocean_fcn[m] = (double *)
Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Sea_Level_Equation.c:            E->slice_ve.incr_ocean_fcn[m] = (double *)
Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Sea_Level_Equation.c:            E->slice_ve.ocean_fcn_prev[m] = (double *)
Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Sea_Level_Equation.c:            E->slice_ve.ocean_fcn_next[m] = (double *)
Sea_Level_Equation.c:                          malloc((E->lmesh.nsf+2)*sizeof(double));
Sea_Level_Equation.c:            for (n=1;n<=E->lmesh.nsf;n++)  {  
Sea_Level_Equation.c:                E->slice_ve.ocean_fcn[m][n]      = 0.0;
Sea_Level_Equation.c:                E->slice_ve.incr_ocean_fcn[m][n] = 0.0;
Sea_Level_Equation.c:                E->slice_ve.ocean_fcn_prev[m][n] = 0.0;
Sea_Level_Equation.c:                E->slice_ve.ocean_fcn_next[m][n] = 0.0;
Sea_Level_Equation.c:   if (E->ve_data_cont.DIRECT == 0 && been_here!=0)
Sea_Level_Equation.c:   ifile = E->ve_data_cont.stage + 1;
Sea_Level_Equation.c:           E->ve_data_cont.ocean_file, E->sphere.elx,E->sphere.ely, ifile-1);
Sea_Level_Equation.c:       read_reg_grids(E,outfile,E->slice_ve.ocean_fcn_prev);
Sea_Level_Equation.c:       for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:         for (j=1;j<=E->lmesh.nsf;j++)  
Sea_Level_Equation.c:            E->slice_ve.ocean_fcn[m][j] = E->slice_ve.ocean_fcn_prev[m][j];   
Sea_Level_Equation.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:        for (j=1;j<=E->lmesh.nsf;j++)  
Sea_Level_Equation.c:            E->slice_ve.ocean_fcn_prev[m][j] = E->slice_ve.ocean_fcn_next[m][j];   
Sea_Level_Equation.c:        step_prev = E->ve_data_cont.stages_step[E->ve_data_cont.stage-1];
Sea_Level_Equation.c:            E->ve_data_cont.ocean_file, E->sphere.elx,E->sphere.ely, ifile);
Sea_Level_Equation.c:   read_reg_grids(E,outfile,E->slice_ve.ocean_fcn_next);
Sea_Level_Equation.c:    steps_per_epoch = E->ve_data_cont.stages_step[E->ve_data_cont.stage] - step_prev;
Sea_Level_Equation.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Sea_Level_Equation.c:    for (j=1;j<=E->lmesh.nsf;j++) 
Sea_Level_Equation.c:        E->slice_ve.incr_ocean_fcn[m][j] = ( E->slice_ve.ocean_fcn_next[m][j]
Sea_Level_Equation.c:                                         -E->slice_ve.ocean_fcn_prev[m][j]) 
Sea_Level_Equation.c:    E->ve_data_cont.incr_ocean_area=total_surface_integral(E,E->slice_ve.incr_ocean_fcn,1);
Sea_Level_Equation.c:    ice_volume_new=total_surface_integral(E,E->slice_ve.ice_height_curr,1);
Sea_Level_Equation.c:    ice_volume_old=total_surface_integral(E,E->slice_ve.ice_height_prev,1);
Sea_Level_Equation.c:    E->ve_data_cont.incr_ice_volume = (ice_volume_new - ice_volume_old) 
Sea_Level_Equation.c:    if (E->parallel.me==0) fprintf(E->fp,"ICE_Volume %g %g\n",ice_volume_new,ice_volume_old);
Shape_functions.c:    { E->N.vpt[i] = 0.0; 
Shape_functions.c:      E->Nx.vpt[i] = 0.0;
Shape_functions.c:      E->Nx.vpt[GNVI+i] = 0.0;
Shape_functions.c:      E->Nx.vpt[2*GNVI+i] = 0.0; 
Shape_functions.c:    { E->N.ppt[i] = 0.0; 
Shape_functions.c:      E->Nx.ppt[i] = 0.0;
Shape_functions.c:      E->Nx.ppt[GNPI+i] = 0.0;
Shape_functions.c:      E->Nx.ppt[2*GNPI+i] = 0.0; 
Shape_functions.c:    { E->M.vpt[i] = 0.0; 
Shape_functions.c:      E->Mx.vpt[i] = 0.0;
Shape_functions.c:      E->Mx.vpt[GN1VI+i] = 0.0;
Shape_functions.c:    { E->M.ppt[i] = 0.0; 
Shape_functions.c:      E->Mx.ppt[i] = 0.0;
Shape_functions.c:      E->Mx.ppt[GN1PI+i] = 0.0;
Shape_functions.c:    { E->L.vpt[i] = 0.0; 
Shape_functions.c:      E->Lx.vpt[i] = 0.0;
Shape_functions.c:      E->Lx.vpt[GN1VI+i] = 0.0;
Shape_functions.c:    { E->NM.vpt[i] = 0.0; 
Shape_functions.c:      E->NMx.vpt[i] = 0.0;
Shape_functions.c:      E->NMx.vpt[GNVI+i] = 0.0;
Shape_functions.c:      E->NMx.vpt[2*GNVI+i] = 0.0; 
Shape_functions.c:  for(i=1;i<=enodes[E->mesh.nsd];i++)   {
Shape_functions.c:      for(j=1;j<=vpoints[E->mesh.nsd];j++)  { 
Shape_functions.c:         E->N.vpt[GNVINDEX(i,j)] = 1.0;
Shape_functions.c:         for(d=1;d<=E->mesh.nsd;d++)   
Shape_functions.c:             E->N.vpt[GNVINDEX(i,j)] *=  
Shape_functions.c:         for(dd=1;dd<=E->mesh.nsd;dd++) {
Shape_functions.c:             E->Nx.vpt[GNVXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],g_point[j].x[dd-1]);
Shape_functions.c:             for(d=1;d<=E->mesh.nsd;d++)
Shape_functions.c:                   E->Nx.vpt[GNVXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],g_point[j].x[d-1]);
Shape_functions.c:      for(j=1;j<=ppoints[E->mesh.nsd];j++)  {
Shape_functions.c:         E->N.ppt[GNPINDEX(i,j)] = 1.0;
Shape_functions.c:         for(d=1;d<=E->mesh.nsd;d++) 
Shape_functions.c:            E->N.ppt[GNPINDEX(i,j)] *=  
Shape_functions.c:         for(dd=1;dd<=E->mesh.nsd;dd++) {
Shape_functions.c:            E->Nx.ppt[GNPXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],p_point[j].x[dd-1]);
Shape_functions.c:            for(d=1;d<=E->mesh.nsd;d++)
Shape_functions.c:                  E->Nx.ppt[GNPXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],p_point[j].x[d-1]); 
Shape_functions.c:  for(j=1;j<=onedvpoints[E->mesh.nsd];j++)
Shape_functions.c:    for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Shape_functions.c:       E->M.vpt[GMVINDEX(j,k)] = 1.0;
Shape_functions.c:       E->L.vpt[GMVINDEX(j,k)] = 1.0;
Shape_functions.c:       for(d=1;d<=E->mesh.nsd-1;d++) {
Shape_functions.c:          E->M.vpt[GMVINDEX(j,k)] *= lpoly(bb[d-1][j],s_point[k].x[d-1]);
Shape_functions.c:          E->L.vpt[GMVINDEX(j,k)] *= lpoly(bb[d-1][j],l_1d[k].x[d-1]);
Shape_functions.c:       for(dd=1;dd<=E->mesh.nsd-1;dd++) {
Shape_functions.c:          E->Mx.vpt[GMVXINDEX(dd-1,j,k)] = lpolydash(bb[dd-1][j],s_point[k].x[d-1]);
Shape_functions.c:          E->Lx.vpt[GMVXINDEX(dd-1,j,k)] = lpolydash(bb[dd-1][j],l_1d[k].x[d-1]);
Shape_functions.c:          for(d=1;d<=E->mesh.nsd-1;d++)
Shape_functions.c:                E->Mx.vpt[GMVXINDEX(dd-1,j,k)] *= lpoly(bb[d-1][j],s_point[k].x[d-1]);
Shape_functions.c:                E->Lx.vpt[GMVXINDEX(dd-1,j,k)] *= lpoly(bb[d-1][j],l_1d[k].x[d-1]);
Shape_functions.c:  for(i=1;i<=enodes[E->mesh.nsd];i++)   {
Shape_functions.c:      for(j=1;j<=vpoints[E->mesh.nsd];j++)   {
Shape_functions.c:         E->NM.vpt[GNVINDEX(i,j)] = 1.0;
Shape_functions.c:         for(d=1;d<=E->mesh.nsd;d++)   
Shape_functions.c:             E->NM.vpt[GNVINDEX(i,j)] *=  
Shape_functions.c:         for(dd=1;dd<=E->mesh.nsd;dd++)                 {
Shape_functions.c:            E->NMx.vpt[GNVXINDEX(dd-1,i,j)] = lpolydash(bb[dd-1][i],s_point[j].x[dd-1]);
Shape_functions.c:            for(d=1;d<=E->mesh.nsd;d++)
Shape_functions.c:                  E->NMx.vpt[GNVXINDEX(dd-1,i,j)] *= lpoly(bb[d-1][i],s_point[j].x[d-1]); 
Size_does_matter.c:    const int dims = E->mesh.nsd;
Size_does_matter.c:                x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]
Size_does_matter.c:                    * E->N.vpt[GNVINDEX(i,k)];
Size_does_matter.c:                    dxda[d][e] += E->X[lev][m][e][E->IEN[lev][m][el].node[i]]
Size_does_matter.c:                        * E->Nx.vpt[GNVXINDEX(d-1,i,k)];
Size_does_matter.c:        jacobian = determinant(dxda, E->mesh.nsd);
Size_does_matter.c:        E->GDA[lev][m][el].vpt[k] = jacobian;
Size_does_matter.c:                        E->Nx.vpt[GNVXINDEX(e-1,j,k)] *cof[e][d];
Size_does_matter.c:                E->GNX[lev][m][el].vpt[GNVXINDEX(d-1,j,k)]
Size_does_matter.c:                x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]
Size_does_matter.c:                    * E->N.ppt[GNPINDEX(i,k)];
Size_does_matter.c:                    dxda[d][e] += E->X[lev][m][e][E->IEN[lev][m][el].node[i]]
Size_does_matter.c:                        * E->Nx.ppt[GNPXINDEX(d-1,i,k)];
Size_does_matter.c:        jacobian = determinant(dxda,E->mesh.nsd);
Size_does_matter.c:        E->GDA[lev][m][el].ppt[k] = jacobian;
Size_does_matter.c:                cof[d][e]=cofactor(dxda,d,e,E->mesh.nsd);
Size_does_matter.c:                        E->Nx.ppt[GNPXINDEX(e-1,j,k)]*cof[e][d];
Size_does_matter.c:                E->GNX[lev][m][el].ppt[GNPXINDEX(d-1,j,k)]
Size_does_matter.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)
Size_does_matter.c:        for(lev=E->mesh.levmax; lev>=E->mesh.levmin; lev--)
Size_does_matter.c:            for(el=1; el<=E->lmesh.NEL[lev]; el++) {
Size_does_matter.c:    const int dims = E->mesh.nsd;
Size_does_matter.c:                x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]
Size_does_matter.c:                    * E->N.vpt[GNVINDEX(i,k)];
Size_does_matter.c:    const int dims = E->mesh.nsd;
Size_does_matter.c:                x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[i]]
Size_does_matter.c:                    * E->N.ppt[GNPINDEX(i,k)];
Size_does_matter.c:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:  to = theta_g(E->eco[m][el].centre[1],E);
Size_does_matter.c:  to = E->eco[m][el].centre[1];	
Size_does_matter.c:  fo = E->eco[m][el].centre[2];
Size_does_matter.c:    node = E->ien[m][el].node[s];
Size_does_matter.c:    xx[1][i] = E->x[m][1][node]*dxdy[1][1]
Size_does_matter.c:             + E->x[m][2][node]*dxdy[1][2]
Size_does_matter.c:             + E->x[m][3][node]*dxdy[1][3];
Size_does_matter.c:    xx[2][i] = E->x[m][1][node]*dxdy[2][1]
Size_does_matter.c:             + E->x[m][2][node]*dxdy[2][2]
Size_does_matter.c:             + E->x[m][3][node]*dxdy[2][3];
Size_does_matter.c:    xx[3][i] = E->x[m][1][node]*dxdy[3][1]
Size_does_matter.c:             + E->x[m][2][node]*dxdy[3][2]
Size_does_matter.c:             + E->x[m][3][node]*dxdy[3][3];
Size_does_matter.c:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Size_does_matter.c:      E->surf_det[m][k] = (double *)malloc((1+E->lmesh.snel)*sizeof(double));
Size_does_matter.c:  for (m=1;m<=E->sphere.caps_per_proc;m++) {
Size_does_matter.c:  r2 = 1.0 / (E->sx[m][3][E->lmesh.elz+1] * E->sx[m][3][E->lmesh.elz+1]);
Size_does_matter.c:  for (es=1;es<=E->lmesh.snel;es++)   {
Size_does_matter.c:    el = es * E->lmesh.elz;
Size_does_matter.c:      for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:        for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:        for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:          for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:             dxda[d][e] += xx[e][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:      jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:      E->surf_det[m][k][es] = jacobian * r2;
Size_does_matter.c:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Size_does_matter.c:	E->boundary.det[m][side][d] = (double *)malloc((1+E->boundary.nel)*sizeof(double));
Size_does_matter.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Size_does_matter.c:    for (es=1;es<=E->boundary.nel;es++) {
Size_does_matter.c:      el = E->boundary.element[m][es];
Size_does_matter.c:	  for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:	    for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:	    for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:	      for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:		dxda[d][e] += xx[sidedim[side][e]][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:	  jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:	  E->boundary.det[m][side][k][es] = jacobian;
Size_does_matter.c:	      E->boundary.det[m][side][1][es],
Size_does_matter.c:	      E->boundary.det[m][side][2][es],
Size_does_matter.c:	      E->boundary.det[m][side][3][es],
Size_does_matter.c:	      E->boundary.det[m][side][4][es],
Size_does_matter.c:	      E->boundary.det[m][side][1][es]+
Size_does_matter.c:	      E->boundary.det[m][side][2][es]+
Size_does_matter.c:	      E->boundary.det[m][side][3][es]+
Size_does_matter.c:	      E->boundary.det[m][side][4][es]);
Size_does_matter.c:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:      for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:	for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:	for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:	  for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:	    dxda[d][e] += xx[e][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:      jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:    const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:    to = theta_g(E->eco[m][el].centre[1],E);
Size_does_matter.c:    to = E->eco[m][el].centre[1]; 
Size_does_matter.c:    fo = E->eco[m][el].centre[2];
Size_does_matter.c:            node = E->ien[m][el].node[e];
Size_does_matter.c:            xx[1][i] = E->x[m][1][node]*dxdy[1][1]
Size_does_matter.c:                + E->x[m][2][node]*dxdy[1][2]
Size_does_matter.c:                + E->x[m][3][node]*dxdy[1][3];
Size_does_matter.c:            xx[2][i] = E->x[m][1][node]*dxdy[2][1]
Size_does_matter.c:                + E->x[m][2][node]*dxdy[2][2]
Size_does_matter.c:                + E->x[m][3][node]*dxdy[2][3];
Size_does_matter.c:            xx[3][i] = E->x[m][1][node]*dxdy[3][1]
Size_does_matter.c:                + E->x[m][2][node]*dxdy[3][2]
Size_does_matter.c:                + E->x[m][3][node]*dxdy[3][3];
Size_does_matter.c:            for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:                for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:                for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:                    for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:                        dxda[d][e] += xx[e][i]*E->Lx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:            jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:  const int dims=E->mesh.nsd;
Size_does_matter.c:            x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[a]]
Size_does_matter.c:                   *E->N.vpt[GNVINDEX(a,k)];
Size_does_matter.c:          tt = E->SX[lev][m][1][E->IEN[lev][m][el].node[a]];
Size_does_matter.c:          ff = E->SX[lev][m][2][E->IEN[lev][m][el].node[a]];
Size_does_matter.c:            x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[a]]
Size_does_matter.c:                   *E->N.ppt[GNPINDEX(a,k)];
Size_does_matter.c:	  lnode = E->IEN[lev][m][el].node[a];
Size_does_matter.c:	  sintt = E->SinCos[lev][m][0][lnode];
Size_does_matter.c:	  sinff = E->SinCos[lev][m][1][lnode];
Size_does_matter.c:	  costt = E->SinCos[lev][m][2][lnode];
Size_does_matter.c:	  cosff = E->SinCos[lev][m][3][lnode];
Size_does_matter.c:  const int dims=E->mesh.nsd;
Size_does_matter.c:	  x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[a]]
Size_does_matter.c:	    *E->M.vpt[GMVINDEX(aa,k)];
Size_does_matter.c:	lnode = E->IEN[lev][m][el].node[a];
Size_does_matter.c:	sintt = E->SinCos[lev][m][0][lnode];
Size_does_matter.c:	sinff = E->SinCos[lev][m][1][lnode];
Size_does_matter.c:	costt = E->SinCos[lev][m][2][lnode];
Size_does_matter.c:	cosff = E->SinCos[lev][m][3][lnode];
Size_does_matter.c:      for(d=1;d<=E->mesh.nsd;d++)
Size_does_matter.c:       	x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[aa]]
Size_does_matter.c:       	  *E->M.ppt[GMPINDEX(a,k)];
Size_does_matter.c:	lnode = E->IEN[lev][m][el].node[aa];
Size_does_matter.c:	sintt = E->SinCos[lev][m][0][lnode];
Size_does_matter.c:	sinff = E->SinCos[lev][m][1][lnode];
Size_does_matter.c:	costt = E->SinCos[lev][m][2][lnode];
Size_does_matter.c:	cosff = E->SinCos[lev][m][3][lnode];
Size_does_matter.c:	for (i=1;i<=E->mesh.nsd;i++) {
Size_does_matter.c:	  for (j=1;j<=E->mesh.nsd;j++) {
Size_does_matter.c:  const int dims=E->mesh.nsd;
Size_does_matter.c: for (lev=E->mesh.gridmin;lev<=E->mesh.gridmax;lev++)
Size_does_matter.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Size_does_matter.c:    nel_surface = E->lmesh.NEL[lev]/E->lmesh.ELZ[lev];
Size_does_matter.c:      el = es*E->lmesh.ELZ[lev];
Size_does_matter.c:            x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[a]]
Size_does_matter.c:                   *E->N.vpt[GNVINDEX(a,k)];
Size_does_matter.c:	  lnode = E->IEN[lev][m][el].node[a];
Size_does_matter.c:	  sintt = E->SinCos[lev][m][0][lnode];
Size_does_matter.c:	  sinff = E->SinCos[lev][m][1][lnode];
Size_does_matter.c:	  costt = E->SinCos[lev][m][2][lnode];
Size_does_matter.c:	  cosff = E->SinCos[lev][m][3][lnode];
Size_does_matter.c:              E->CC[lev][m][es].vpt[BVINDEX(i,j,a,k)] =
Size_does_matter.c:              E->CCX[lev][m][es].vpt[BVXINDEX(i,j,1,a,k)] =
Size_does_matter.c:              E->CCX[lev][m][es].vpt[BVXINDEX(i,j,2,a,k)] =
Size_does_matter.c:            x[d] += E->X[lev][m][d][E->IEN[lev][m][el].node[a]]
Size_does_matter.c:                   *E->N.ppt[GNPINDEX(a,k)];
Size_does_matter.c:	  lnode = E->IEN[lev][m][el].node[a];
Size_does_matter.c:	  sintt = E->SinCos[lev][m][0][lnode];
Size_does_matter.c:	  sinff = E->SinCos[lev][m][1][lnode];
Size_does_matter.c:	  costt = E->SinCos[lev][m][2][lnode];
Size_does_matter.c:	  cosff = E->SinCos[lev][m][3][lnode];
Size_does_matter.c:              E->CC[lev][m][es].ppt[BPINDEX(i,j,a,k)] =
Size_does_matter.c:              E->CCX[lev][m][es].ppt[BPXINDEX(i,j,1,a,k)] =
Size_does_matter.c:              E->CCX[lev][m][es].ppt[BPXINDEX(i,j,2,a,k)] =
Size_does_matter.c:    const int vpts=vpoints[E->mesh.nsd];
Size_does_matter.c:    for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Size_does_matter.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Size_does_matter.c:            for(node=1;node<=E->lmesh.NNO[lev];node++)
Size_does_matter.c:                E->MASS[lev][m][node] = 0.0;
Size_does_matter.c:            for(e=1;e<=E->lmesh.NEL[lev];e++)  {
Size_does_matter.c:                for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:                    n[node] = E->IEN[lev][m][e].node[node];
Size_does_matter.c:                for(i=1;i<=E->mesh.nsd;i++)  {
Size_does_matter.c:                    for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:                        centre[i] += E->X[lev][m][i][n[node]];
Size_does_matter.c:                    centre[i] = centre[i]/enodes[E->mesh.nsd];
Size_does_matter.c:                E->ECO[lev][m][e].centre[1] = dx1;
Size_does_matter.c:                E->ECO[lev][m][e].centre[2] = dx2;
Size_does_matter.c:                E->ECO[lev][m][e].centre[3] = dx3;
Size_does_matter.c:                dx1 = max( fabs(E->SX[lev][m][1][n[3]]-E->SX[lev][m][1][n[1]]),
Size_does_matter.c:                           fabs(E->SX[lev][m][1][n[2]]-E->SX[lev][m][1][n[4]]) );
Size_does_matter.c:                E->ECO[lev][m][e].size[1] = dx1*E->ECO[lev][m][e].centre[3];
Size_does_matter.c:                dx1 = fabs(E->SX[lev][m][2][n[3]]-E->SX[lev][m][2][n[1]]);
Size_does_matter.c:                    dx1 = min(E->SX[lev][m][2][n[3]],E->SX[lev][m][2][n[1]]) + 2.0*M_PI -
Size_does_matter.c:                        max(E->SX[lev][m][2][n[3]],E->SX[lev][m][2][n[1]]) ;
Size_does_matter.c:                dx2 = fabs(E->SX[lev][m][2][n[2]]-E->SX[lev][m][2][n[4]]);
Size_does_matter.c:                    dx2 = min(E->SX[lev][m][2][n[2]],E->SX[lev][m][2][n[4]]) + 2.0*M_PI -
Size_does_matter.c:                        max(E->SX[lev][m][2][n[2]],E->SX[lev][m][2][n[4]]) ;
Size_does_matter.c:                E->ECO[lev][m][e].size[2] = dx2*E->ECO[lev][m][e].centre[3]
Size_does_matter.c:                    *sin(E->ECO[lev][m][e].centre[1]);
Size_does_matter.c:                dx3 = 0.25*(fabs(E->SX[lev][m][3][n[5]]+E->SX[lev][m][3][n[6]]
Size_does_matter.c:                                 +E->SX[lev][m][3][n[7]]+E->SX[lev][m][3][n[8]]
Size_does_matter.c:                                 -E->SX[lev][m][3][n[1]]-E->SX[lev][m][3][n[2]]
Size_does_matter.c:                                 -E->SX[lev][m][3][n[3]]-E->SX[lev][m][3][n[4]]));
Size_does_matter.c:                E->ECO[lev][m][e].size[3] = dx3;
Size_does_matter.c:                    area += g_point[nint].weight[E->mesh.nsd-1] * E->GDA[lev][m][e].vpt[nint];
Size_does_matter.c:                E->ECO[lev][m][e].area = area;
Size_does_matter.c:                for(node=1;node<=enodes[E->mesh.nsd];node++)  {
Size_does_matter.c:                        temp[node] += E->GDA[lev][m][e].vpt[nint]*g_point[nint].weight[E->mesh.nsd-1]
Size_does_matter.c:                            *E->N.vpt[GNVINDEX(node,nint)];       /* int Na dV */
Size_does_matter.c:                for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:                    E->MASS[lev][m][E->IEN[lev][m][e].node[node]] += temp[node];
Size_does_matter.c:                for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:                    E->TWW[lev][m][e].node[node] = temp[node];
Size_does_matter.c:        if(lev == E->mesh.levmax)
Size_does_matter.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)
Size_does_matter.c:                for(node=1;node<=E->lmesh.NNO[lev];node++)
Size_does_matter.c:                    E->NMass[m][node] = E->MASS[lev][m][node];
Size_does_matter.c:        if (E->control.NMULTIGRID||E->mesh.levmax==lev)
Size_does_matter.c:            (E->exchange_node_d)(E,E->MASS[lev],lev);
Size_does_matter.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Size_does_matter.c:            for(node=1;node<=E->lmesh.NNO[lev];node++)
Size_does_matter.c:                E->MASS[lev][m][node] = 1.0/E->MASS[lev][m][node];
Size_does_matter.c:    for (m=1;m<=E->sphere.caps_per_proc;m++) {
Size_does_matter.c:        for(node=1;node<=E->lmesh.nno;node++)
Size_does_matter.c:            E->TMass[m][node] = 0.0;
Size_does_matter.c:        for(e=1;e<=E->lmesh.nel;e++)  {
Size_does_matter.c:            for(node=1;node<=enodes[E->mesh.nsd];node++) {
Size_does_matter.c:                nz = ((E->ien[m][e].node[node]-1) % E->lmesh.noz) + 1;
Size_does_matter.c:                    temp[node] += E->refstate.rho[nz]
Size_does_matter.c:                        * E->refstate.heat_capacity[nz]
Size_does_matter.c:                        * E->gDA[m][e].vpt[nint]
Size_does_matter.c:                        * g_point[nint].weight[E->mesh.nsd-1]
Size_does_matter.c:                        * E->N.vpt[GNVINDEX(node,nint)];
Size_does_matter.c:            for(node=1;node<=enodes[E->mesh.nsd];node++)
Size_does_matter.c:                E->TMass[m][E->ien[m][e].node[node]] += temp[node];
Size_does_matter.c:    (E->exchange_node_d)(E,E->TMass,E->mesh.levmax);
Size_does_matter.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Size_does_matter.c:        for(node=1;node<=E->lmesh.nno;node++)
Size_does_matter.c:            E->TMass[m][node] = 1.0 / E->TMass[m][node];
Size_does_matter.c:    E->lmesh.volume = 0;
Size_does_matter.c:    E->mesh.volume = 0;
Size_does_matter.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Size_does_matter.c:        for(e=1;e<=E->lmesh.nel;e++)
Size_does_matter.c:            E->lmesh.volume += E->eco[m][e].area;
Size_does_matter.c:    MPI_Allreduce(&E->lmesh.volume, &E->mesh.volume, 1, MPI_DOUBLE,
Size_does_matter.c:                  MPI_SUM, E->parallel.world);
Size_does_matter.c:    if (E->control.verbose)  {
Size_does_matter.c:        fprintf(E->fp_out, "rank=%d my_volume=%e total_volume=%e\n",
Size_does_matter.c:                E->parallel.me, E->lmesh.volume, E->mesh.volume);
Size_does_matter.c:        for(lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Size_does_matter.c:            fprintf(E->fp_out,"output_mass lev=%d\n",lev);
Size_does_matter.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Size_does_matter.c:                fprintf(E->fp_out,"m=%d %d \n",E->sphere.capid[m],m);
Size_does_matter.c:                for(e=1;e<=E->lmesh.NEL[lev];e++)
Size_does_matter.c:                    fprintf(E->fp_out,"%d %g \n",e,E->ECO[lev][m][e].area);
Size_does_matter.c:                for (node=1;node<=E->lmesh.NNO[lev];node++)
Size_does_matter.c:                    fprintf(E->fp_out,"Mass[%d]= %g \n",node,E->MASS[lev][m][node]);
Size_does_matter.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Size_does_matter.c:            fprintf(E->fp_out,"m=%d %d \n",E->sphere.capid[m],m);
Size_does_matter.c:            for (node=1;node<=E->lmesh.nno;node++)
Size_does_matter.c:                fprintf(E->fp_out,"TMass[%d]= %g \n",node,E->TMass[m][node]);
Size_does_matter.c:        fflush(E->fp_out);
Size_does_matter.c:  lev = E->mesh.levmax;
Size_does_matter.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Size_does_matter.c:    for(e=1;e<=E->lmesh.snel;e++)          {
Size_does_matter.c:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:  el = (ic==1)?(ee*E->lmesh.ELZ[lev]):((ee-1)*E->lmesh.ELZ[lev]+1);
Size_does_matter.c:  to = E->ECO[lev][m][el].centre[1];
Size_does_matter.c:  fo = E->ECO[lev][m][el].centre[2];
Size_does_matter.c://fprintf(stderr,"aaa %d %d %g %g %g\n",E->parallel.me,el,to,fo,dxdy[3][3]);
Size_does_matter.c:     node = E->IEN[lev][m][el].node[e];
Size_does_matter.c:     xx[1][i] = E->X[lev][m][1][node]*dxdy[1][1]
Size_does_matter.c:              + E->X[lev][m][2][node]*dxdy[1][2]
Size_does_matter.c:              + E->X[lev][m][3][node]*dxdy[1][3];
Size_does_matter.c:     xx[2][i] = E->X[lev][m][1][node]*dxdy[2][1]
Size_does_matter.c:              + E->X[lev][m][2][node]*dxdy[2][2]
Size_does_matter.c:              + E->X[lev][m][3][node]*dxdy[2][3];
Size_does_matter.c:     xx[3][i] = E->X[lev][m][1][node]*dxdy[3][1]
Size_does_matter.c:              + E->X[lev][m][2][node]*dxdy[3][2]
Size_does_matter.c:              + E->X[lev][m][3][node]*dxdy[3][3];
Size_does_matter.c:    E->gDA0[m][ee].vpt[oned+1] = 0.0;
Size_does_matter.c:    E->gDA1[m][ee].vpt[oned+1] = 0.0;
Size_does_matter.c:     for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:       for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:       for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:         for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:             dxda[d][e] += xx[e][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:     jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:       E->gDA0[m][ee].vpt[k] = jacobian;
Size_does_matter.c:       E->gDA0[m][ee].vpt[1+oned] += jacobian;
Size_does_matter.c:       E->gDA1[m][ee].vpt[k] = jacobian;
Size_does_matter.c:       E->gDA1[m][ee].vpt[1+oned] += jacobian;
Size_does_matter.c:  const int oned = onedvpoints[E->mesh.nsd];
Size_does_matter.c:  to = E->ECO[lev][m][el].centre[1];
Size_does_matter.c:  fo = E->ECO[lev][m][el].centre[2];
Size_does_matter.c:     node = E->IEN[lev][m][el].node[e];
Size_does_matter.c:     xx[1][i] = E->X[lev][m][1][node]*dxdy[1][1]
Size_does_matter.c:              + E->X[lev][m][2][node]*dxdy[1][2]
Size_does_matter.c:              + E->X[lev][m][3][node]*dxdy[1][3];
Size_does_matter.c:     xx[2][i] = E->X[lev][m][1][node]*dxdy[2][1]
Size_does_matter.c:              + E->X[lev][m][2][node]*dxdy[2][2]
Size_does_matter.c:              + E->X[lev][m][3][node]*dxdy[2][3];
Size_does_matter.c:     xx[3][i] = E->X[lev][m][1][node]*dxdy[3][1]
Size_does_matter.c:              + E->X[lev][m][2][node]*dxdy[3][2]
Size_does_matter.c:              + E->X[lev][m][3][node]*dxdy[3][3];
Size_does_matter.c:     for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:       for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:       for(d=1;d<=E->mesh.nsd-1;d++)
Size_does_matter.c:         for(e=1;e<=E->mesh.nsd-1;e++)
Size_does_matter.c:             dxda[d][e] += xx[e][i]*E->Mx.vpt[GMVXINDEX(d-1,i,k)];
Size_does_matter.c:     jacobian = determinant(dxda,E->mesh.nsd-1);
Size_does_matter.c:  const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Size_does_matter.c:   for(k=1;k<=vpoints[E->mesh.nsd];k++)  {
Size_does_matter.c:            dxda[d][e] += E->NMx.vpt[GNVXINDEX(d-1,i,k)]
Size_does_matter.c:                * E->x[m][e][E->ien[m][el].node[i]];
Size_does_matter.c:        jacobian = sqrt(abs(determinant(cof,E->mesh.nsd)))/cof[3][3]; 
Size_does_matter.c: for (n=1;n<=E->lmesh.nsf;n++)   {
Size_does_matter.c:   t[1] = E->SX[lev][m][1][n*E->lmesh.NOZ[lev]];
Size_does_matter.c:   f[1] = E->SX[lev][m][2][n*E->lmesh.NOZ[lev]];
Size_does_matter.c:   for (mm=0; mm<=E->output.llmax; mm++)      {
Size_does_matter.c:     E->Tbl_cs[m][mm][n] = cos(mm*f[1]);
Size_does_matter.c:     E->Tbl_sn[m][mm][n] = sin(mm*f[1]);
Size_does_matter.c:   for (ll=0;ll<=E->output.llmax;ll++)
Size_does_matter.c:       p = E->sphere.hindex[ll][mm];
Size_does_matter.c:       E->Tbl_lm[m][p][n] = modified_plgndr_a(ll,mm,t[1]);
Size_does_matter.c: for(k1=1;k1<=onedvpoints[E->mesh.nsd];k1++)   {
Size_does_matter.c:   t[k1] = E->sx[m][1][E->ien[m][e*E->lmesh.elz].node[k1+4]];
Size_does_matter.c:   f[k1] = E->sx[m][2][E->ien[m][e*E->lmesh.elz].node[k1+4]];
Size_does_matter.c: for (mm=0; mm<=E->output.llmax; mm++)                 
Size_does_matter.c:   for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Size_does_matter.c:     E->Sph_Harm_Tblcs[m][mm][e].cs[k] = 0.0;
Size_does_matter.c:     E->Sph_Harm_Tblcs[m][mm][e].sn[k] = 0.0;
Size_does_matter.c:     for(k1=1;k1<=onedvpoints[E->mesh.nsd];k1++)   {
Size_does_matter.c:       E->Sph_Harm_Tblcs[m][mm][e].cs[k]+=cos(mm*f[k1])*E->M.vpt[GMVINDEX(k1,k)];
Size_does_matter.c:       E->Sph_Harm_Tblcs[m][mm][e].sn[k]+=sin(mm*f[k1])*E->M.vpt[GMVINDEX(k1,k)];
Size_does_matter.c: for (ll=0;ll<=E->output.llmax;ll++)
Size_does_matter.c:     p = E->sphere.hindex[ll][mm];
Size_does_matter.c:     for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Size_does_matter.c:       E->Sph_Harm_Tbllm[m][p][e].lm[k] = 0.0;
Size_does_matter.c:       for(k1=1;k1<=onedvpoints[E->mesh.nsd];k1++)   {
Size_does_matter.c:         E->Sph_Harm_Tbllm[m][p][e].lm[k]+= modified_plgndr_a(ll,mm,t[k1])*E->M.vpt[GMVINDEX(k1,k)];
Solver_conj_grad.c:  E->control.CONJ_GRAD = 1;
Solver_conj_grad.c:  E->build_forcing_term =   assemble_forces_iterative;
Solver_conj_grad.c:  E->solve_stokes_problem = solve_constrained_flow_iterative;
Solver_conj_grad.c:  E->solver_allocate_vars = cg_allocate_vars;
Solver_conj_grad.c:  strip_bcs_from_residual(E,E->F,E->mesh.levmax);
Solver_multigrid.c:  E->control.NMULTIGRID = 1;
Solver_multigrid.c:  E->build_forcing_term =   assemble_forces_iterative;
Solver_multigrid.c:  E->solve_stokes_problem = solve_constrained_flow_iterative;
Solver_multigrid.c:  E->solver_allocate_vars = mg_allocate_vars;
Solver_multigrid.c:    const int dims = E->mesh.nsd;
Solver_multigrid.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:    for (lev=E->mesh.levmax;lev>E->mesh.levmin;lev--) {
Solver_multigrid.c:      for(el=1;el<=E->lmesh.NEL[sl_minus];el++)
Solver_multigrid.c:          node_coarse = E->IEN[sl_minus][m][el].node[i];
Solver_multigrid.c:          node_fine=E->IEN[lev][m][E->EL[sl_minus][m][el].sub[i]].node[i];
Solver_multigrid.c:            E->SX[sl_minus][m][j][node_coarse] = E->SX[lev][m][j][node_fine];
Solver_multigrid.c:    const int dims = E->mesh.nsd;
Solver_multigrid.c:    if(start_lev == E->mesh.levmin)   {
Solver_multigrid.c:        fprintf(E->fp,"Warning, attempting to project below lowest level\n");
Solver_multigrid.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:      for(el=1;el<=E->lmesh.NEL[sl_minus];el++)
Solver_multigrid.c:          node_coarse = E->IEN[sl_minus][m][el].node[i];
Solver_multigrid.c:          node_fine=E->IEN[start_lev][m][E->EL[sl_minus][m][el].sub[i]].node[i];
Solver_multigrid.c:    const int dims = E->mesh.nsd;
Solver_multigrid.c:    if(start_lev == E->mesh.levmin)   {
Solver_multigrid.c:        fprintf(E->fp,"Warning, attempting to project below lowest level\n");
Solver_multigrid.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:      for(el=1;el<=E->lmesh.NEL[sl_minus];el++)
Solver_multigrid.c:          node_coarse = E->IEN[sl_minus][m][el].node[i];
Solver_multigrid.c:          node_fine=E->IEN[start_lev][m][E->EL[sl_minus][m][el].sub[i]].node[i];
Solver_multigrid.c:            eqn_fine   = E->ID[start_lev][m][node_fine].doff[j];
Solver_multigrid.c:            eqn_coarse = E->ID[sl_minus][m][node_coarse].doff[j];
Solver_multigrid.c:    const int dims = E->mesh.nsd;
Solver_multigrid.c:    const int neq = E->lmesh.NEQ[sl_plus];
Solver_multigrid.c:    const int nels = E->lmesh.NEL[start_lev];
Solver_multigrid.c:    assert(start_lev != E->mesh.levmax  /* un_injection */);
Solver_multigrid.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:          node = E->IEN[start_lev][m][el].node[i];
Solver_multigrid.c:	  node_plus=E->IEN[sl_plus][m][E->EL[start_lev][m][el].sub[i]].node[i];
Solver_multigrid.c:	  eqn1 = E->ID[start_lev][m][node].doff[1];
Solver_multigrid.c:	  eqn2 = E->ID[start_lev][m][node].doff[2];
Solver_multigrid.c:	  eqn3 = E->ID[start_lev][m][node].doff[3];
Solver_multigrid.c:	  eqn_plus1 = E->ID[sl_plus][m][node_plus].doff[1];
Solver_multigrid.c:	  eqn_plus2 = E->ID[sl_plus][m][node_plus].doff[2];
Solver_multigrid.c:	  eqn_plus3 = E->ID[sl_plus][m][node_plus].doff[3];
Solver_multigrid.c:    const int dims =E->mesh.nsd;
Solver_multigrid.c:    const int nox = E->lmesh.NOX[level];
Solver_multigrid.c:    const int noz = E->lmesh.NOZ[level];
Solver_multigrid.c:    const int noy = E->lmesh.NOY[level];
Solver_multigrid.c:    const int high_eqn = E->lmesh.NEQ[level];
Solver_multigrid.c:    if (start_lev==E->mesh.levmax) return;
Solver_multigrid.c:    un_inject_vector(E,start_lev,AU,E->temp); /*  information from lower level */
Solver_multigrid.c:    fill_in_gaps(E,E->temp,level);
Solver_multigrid.c:    from_xyz_to_rtf(E,level,E->temp,AU);      /* get back to rtf coordinates */
Solver_multigrid.c:    const int nsd=E->mesh.nsd;
Solver_multigrid.c:  lv = E->mesh.levmax;
Solver_multigrid.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Solver_multigrid.c:    viscU[m]=(float *)malloc((1+E->lmesh.NNO[lv])*sizeof(float));
Solver_multigrid.c:    viscD[m]=(float *)malloc((1+vpts*E->lmesh.NEL[lv-1])*sizeof(float));
Solver_multigrid.c:  for(lv=E->mesh.levmax;lv>E->mesh.levmin;lv--)     {
Solver_multigrid.c:    if (E->viscosity.smooth_cycles==1)  {
Solver_multigrid.c:      visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:      visc_from_nodes_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:    else if (E->viscosity.smooth_cycles==2)   {
Solver_multigrid.c:      visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:      inject_scalar_e(E,lv,viscU,E->EVI[sl_minus]);
Solver_multigrid.c:    else if (E->viscosity.smooth_cycles==3)   {
Solver_multigrid.c:      visc_from_gint_to_ele(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:      visc_from_ele_to_gint(E,viscD,E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:    else if (E->viscosity.smooth_cycles==0)  {
Solver_multigrid.c:/*      visc_from_gint_to_nodes(E,E->EVI[lv],viscU,lv);
Solver_multigrid.c:      visc_from_nodes_to_gint(E,viscD,E->EVI[sl_minus],sl_minus); */
Solver_multigrid.c:      inject_scalar(E,lv,E->VI[lv],E->VI[sl_minus]);
Solver_multigrid.c:      visc_from_nodes_to_gint(E,E->VI[sl_minus],E->EVI[sl_minus],sl_minus);
Solver_multigrid.c:/*        for(m=1;m<=E->sphere.caps_per_proc;m++) {
Solver_multigrid.c:            for (i=1;i<=E->lmesh.NEL[lv-1];i++)
Solver_multigrid.c:               fprintf (E->fp_out,"%d %g\n",i,viscD[m][i]);
Solver_multigrid.c:            for (i=1;i<=E->lmesh.NEL[lv];i++)
Solver_multigrid.c:               fprintf (E->fp_out,"%d %g\n",i,viscU[m][i]);
Solver_multigrid.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Solver_multigrid.c:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Solver_multigrid.c:    const int dims=E->mesh.nsd;
Solver_multigrid.c:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:    const int vpts=vpoints[E->mesh.nsd];
Solver_multigrid.c: for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:                e = E->EL[sl_minus][m][el].sub[i];
Solver_multigrid.c:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Solver_multigrid.c:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:    const int vpts=vpoints[E->mesh.nsd];
Solver_multigrid.c: for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:                e = E->EL[sl_minus][m][el].sub[i];
Solver_multigrid.c:    const int nno_minus=E->lmesh.NNO[start_lev-1];
Solver_multigrid.c:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Solver_multigrid.c:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c: for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:                node1 = E->EL[sl_minus][m][el].sub[i];
Solver_multigrid.c:                    node=E->IEN[start_lev][m][node1].node[j];
Solver_multigrid.c:                node= E->IEN[sl_minus][m][el].node[i];
Solver_multigrid.c:                AD[m][node] += w * E->TWW[sl_minus][m][el].node[i];
Solver_multigrid.c:   (E->exchange_node_f)(E,AD,sl_minus);
Solver_multigrid.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:       AD[m][i] *= E->MASS[sl_minus][m][i];
Solver_multigrid.c:    const int neq_minus=E->lmesh.NEQ[start_lev-1];
Solver_multigrid.c:    const int nno_minus=E->lmesh.NNO[start_lev-1];
Solver_multigrid.c:    const int nels_minus=E->lmesh.NEL[start_lev-1];
Solver_multigrid.c:    const int  dims=E->mesh.nsd;
Solver_multigrid.c:    const int ends=enodes[E->mesh.nsd];
Solver_multigrid.c:   if (start_lev==E->mesh.levmin) return;
Solver_multigrid.c:      from_rtf_to_xyz(E,start_lev,AU,E->temp);
Solver_multigrid.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:        E->temp1[m][i] = 0.0;
Solver_multigrid.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:                node= E->IEN[sl_minus][m][el].node[i];
Solver_multigrid.c:		e1 = E->EL[sl_minus][m][el].sub[i];
Solver_multigrid.c:		    node1=E->IEN[start_lev][m][e1].node[j];
Solver_multigrid.c:		    average1 += E->temp[m][E->ID[start_lev][m][node1].doff[1]];
Solver_multigrid.c:		    average2 += E->temp[m][E->ID[start_lev][m][node1].doff[2]];
Solver_multigrid.c:		    average3 += E->temp[m][E->ID[start_lev][m][node1].doff[3]];
Solver_multigrid.c:		w = weight*E->TWW[sl_minus][m][el].node[i];
Solver_multigrid.c:		E->temp1[m][E->ID[sl_minus][m][node].doff[1]] += w * average1;
Solver_multigrid.c:		E->temp1[m][E->ID[sl_minus][m][node].doff[2]] += w * average2;
Solver_multigrid.c:	 	E->temp1[m][E->ID[sl_minus][m][node].doff[3]] += w * average3;
Solver_multigrid.c:   (E->solver.exchange_id_d)(E, E->temp1, sl_minus);
Solver_multigrid.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:       E->temp1[m][E->ID[sl_minus][m][i].doff[1]] *= E->MASS[sl_minus][m][i];
Solver_multigrid.c:       E->temp1[m][E->ID[sl_minus][m][i].doff[2]] *= E->MASS[sl_minus][m][i];
Solver_multigrid.c:       E->temp1[m][E->ID[sl_minus][m][i].doff[3]] *= E->MASS[sl_minus][m][i];
Solver_multigrid.c:   from_xyz_to_rtf(E,sl_minus,E->temp1,AD);
Solver_multigrid.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:   for (i=1;i<=E->lmesh.NNO[level];i++)  {
Solver_multigrid.c:     eqn1 = E->ID[level][m][i].doff[1];
Solver_multigrid.c:     eqn2 = E->ID[level][m][i].doff[2];
Solver_multigrid.c:     eqn3 = E->ID[level][m][i].doff[3];
Solver_multigrid.c:     sint = E->SinCos[level][m][0][i];
Solver_multigrid.c:     sinf = E->SinCos[level][m][1][i];
Solver_multigrid.c:     cost = E->SinCos[level][m][2][i];
Solver_multigrid.c:     cosf = E->SinCos[level][m][3][i];
Solver_multigrid.c: for (m=1;m<=E->sphere.caps_per_proc;m++)
Solver_multigrid.c:   for (i=1;i<=E->lmesh.NNO[level];i++)  {
Solver_multigrid.c:     eqn1 = E->ID[level][m][i].doff[1];
Solver_multigrid.c:     eqn2 = E->ID[level][m][i].doff[2];
Solver_multigrid.c:     eqn3 = E->ID[level][m][i].doff[3];
Solver_multigrid.c:     sint = E->SinCos[level][m][0][i];
Solver_multigrid.c:     sinf = E->SinCos[level][m][1][i];
Solver_multigrid.c:     cost = E->SinCos[level][m][2][i];
Solver_multigrid.c:     cosf = E->SinCos[level][m][3][i];
Solver_multigrid.c:    const int dims =E->mesh.nsd;
Solver_multigrid.c:    const int nox = E->lmesh.NOX[level];
Solver_multigrid.c:    const int noz = E->lmesh.NOZ[level];
Solver_multigrid.c:    const int noy = E->lmesh.NOY[level];
Solver_multigrid.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)       {
Solver_multigrid.c:	      eqn0=E->ID[level][m][node0].doff[1];
Solver_multigrid.c:	      eqn1=E->ID[level][m][node1].doff[1];
Solver_multigrid.c:	      eqn2=E->ID[level][m][node2].doff[1];
Solver_multigrid.c:	      eqn0=E->ID[level][m][node0].doff[2];
Solver_multigrid.c:	      eqn1=E->ID[level][m][node1].doff[2];
Solver_multigrid.c:	      eqn2=E->ID[level][m][node2].doff[2];
Solver_multigrid.c:	      eqn0=E->ID[level][m][node0].doff[3];
Solver_multigrid.c:	      eqn1=E->ID[level][m][node1].doff[3];
Solver_multigrid.c:	      eqn2=E->ID[level][m][node2].doff[3];
Solver_multigrid.c:	        eqn0=E->ID[level][m][node0].doff[1];
Solver_multigrid.c:	        eqn1=E->ID[level][m][node1].doff[1];
Solver_multigrid.c:	        eqn2=E->ID[level][m][node2].doff[1];
Solver_multigrid.c:	        eqn0=E->ID[level][m][node0].doff[2];
Solver_multigrid.c:	        eqn1=E->ID[level][m][node1].doff[2];
Solver_multigrid.c:	        eqn2=E->ID[level][m][node2].doff[2];
Solver_multigrid.c:	        eqn0=E->ID[level][m][node0].doff[3];
Solver_multigrid.c:	        eqn1=E->ID[level][m][node1].doff[3];
Solver_multigrid.c:	        eqn2=E->ID[level][m][node2].doff[3];
Solver_multigrid.c:       x1 = E->sphere.R[level][j] - E->sphere.R[level][j-1];
Solver_multigrid.c:       x2 = E->sphere.R[level][j+1] - E->sphere.R[level][j];
Solver_multigrid.c:	        eqn0=E->ID[level][m][node0].doff[1];
Solver_multigrid.c:	        eqn1=E->ID[level][m][node1].doff[1];
Solver_multigrid.c:	        eqn2=E->ID[level][m][node2].doff[1];
Solver_multigrid.c:	        eqn0=E->ID[level][m][node0].doff[2];
Solver_multigrid.c:	        eqn1=E->ID[level][m][node1].doff[2];
Solver_multigrid.c:	        eqn2=E->ID[level][m][node2].doff[2];
Solver_multigrid.c:	        eqn0=E->ID[level][m][node0].doff[3];
Solver_multigrid.c:	        eqn1=E->ID[level][m][node1].doff[3];
Solver_multigrid.c:	        eqn2=E->ID[level][m][node2].doff[3];
Sphere_harmonics.c:    for (ll=0;ll<=E->output.llmax;ll++)
Sphere_harmonics.c:            E->sphere.hindex[ll][mm] = i;
Sphere_harmonics.c:    E->sphere.hindice = i;
Sphere_harmonics.c:        E->sphere.harm_geoid[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:        E->sphere.harm_geoid_from_bncy[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:        E->sphere.harm_geoid_from_bncy_botm[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:        E->sphere.harm_geoid_from_tpgt[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:        E->sphere.harm_geoid_from_tpgb[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:        E->sphere.harm_tpgt[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:        E->sphere.harm_tpgb[i]=(float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:    proc_loc = E->parallel.me_loc[3];
Sphere_harmonics.c:    sphere_expansion_VE(E,ic,TG,sphc,sphs,E->output.llmax);
Sphere_harmonics.c:    for (i=0;i<E->sphere.hindice;i++)    {
Sphere_harmonics.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)
Sphere_harmonics.c:        for (es=1;es<=E->lmesh.snel;es++)   {
Sphere_harmonics.c:            for (ll=0;ll<=E->output.llmax;ll++)
Sphere_harmonics.c:                    p = E->sphere.hindex[ll][mm];
Sphere_harmonics.c:                    for(nint=1;nint<=onedvpoints[E->mesh.nsd];nint++)   {
Sphere_harmonics.c:                        for(d=1;d<=onedvpoints[E->mesh.nsd];d++)   {
Sphere_harmonics.c:                            j = E->sien[m][es].node[d];
Sphere_harmonics.c:                            sphc[p] += TG[m][E->sien[m][es].node[d]]
Sphere_harmonics.c:                                * E->sphere.tablesplm[m][j][p]
Sphere_harmonics.c:                                * E->sphere.tablescosf[m][j][mm]
Sphere_harmonics.c:                                * E->M.vpt[GMVINDEX(d,nint)]
Sphere_harmonics.c:                                * E->surf_det[m][nint][es];
Sphere_harmonics.c:                            sphs[p] += TG[m][E->sien[m][es].node[d]]
Sphere_harmonics.c:                                * E->sphere.tablesplm[m][j][p]
Sphere_harmonics.c:                                * E->sphere.tablessinf[m][j][mm]
Sphere_harmonics.c:                                * E->M.vpt[GMVINDEX(d,nint)]
Sphere_harmonics.c:                                * E->surf_det[m][nint][es];
Sphere_harmonics.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Sphere_harmonics.c:        TT[m] = (float *) malloc ((E->lmesh.nsf+1)*sizeof(float));
Sphere_harmonics.c:    sph_harm[0] = (float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:    sph_harm[1] = (float*)malloc(E->sphere.hindice*sizeof(float));
Sphere_harmonics.c:    for(k=1;k<=E->lmesh.noz;k++)  {
Sphere_harmonics.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Sphere_harmonics.c:            for(i=1;i<=E->lmesh.noy;i++)
Sphere_harmonics.c:                for(j=1;j<=E->lmesh.nox;j++)  {
Sphere_harmonics.c:                    node= k + (j-1)*E->lmesh.noz + (i-1)*E->lmesh.nox*E->lmesh.noz;
Sphere_harmonics.c:                    p = j + (i-1)*E->lmesh.nox;
Sphere_harmonics.c:                    TT[m][p] = E->T[m][node];
Sphere_harmonics.c:        if(E->parallel.me < E->parallel.nprocz) {
Sphere_harmonics.c:            for (ll=0;ll<=E->output.llmax;ll++)
Sphere_harmonics.c:                    p = E->sphere.hindex[ll][mm];
Sphere_harmonics.c:                            k+E->lmesh.nzs-1, ll, mm,
Sphere_harmonics.c:  E->sphere.sphc[0] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:  E->sphere.sphc[1] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:  E->sphere.sphs[0] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:  E->sphere.sphs[1] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:  E->sphere.sphc[2] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:  E->sphere.sphc[3] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:  E->sphere.sphc[4] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:  E->sphere.sphc[5] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:  E->sphere.sphs[2] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:  E->sphere.sphs[3] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:  E->sphere.sphs[4] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:  E->sphere.sphs[5] = (double *)malloc((E->sphere.hindice+3)*sizeof(double));
Sphere_harmonics.c:  for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Sphere_harmonics.c:    for (mm=0;mm<=E->output.llmax;mm++)  {
Sphere_harmonics.c:      E->Sph_Harm_Tblcs[m][mm] = (struct SPH1 *) malloc((E->lmesh.snel+2)*sizeof(struct SPH1));
Sphere_harmonics.c:      E->Tbl_cs[m][mm] = (float *) malloc((E->lmesh.nsf+2)*sizeof(float));
Sphere_harmonics.c:      E->Tbl_sn[m][mm] = (float *) malloc((E->lmesh.nsf+2)*sizeof(float));
Sphere_harmonics.c:    for (p=0;p<E->sphere.hindice;p++)    {
Sphere_harmonics.c:      E->Sph_Harm_Tbllm[m][p] = (struct SPH2 *) malloc((E->lmesh.snel+2)*sizeof(struct SPH2));
Sphere_harmonics.c:      E->Tbl_lm[m][p] = (float *) malloc((E->lmesh.nsf+2)*sizeof(float));
Sphere_harmonics.c: lev = E->mesh.levmax;
Sphere_harmonics.c: for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Sphere_harmonics.c:    for (e=1;e<=E->lmesh.snel;e++)   {
Sphere_harmonics.c: for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Sphere_harmonics.c:        E->sphere.tablesplm[m]   = (double **) malloc((E->lmesh.nsf+1)*sizeof(double*));
Sphere_harmonics.c:        E->sphere.tablescosf[m] = (double **) malloc((E->lmesh.nsf+1)*sizeof(double*));
Sphere_harmonics.c:        E->sphere.tablessinf[m] = (double **) malloc((E->lmesh.nsf+1)*sizeof(double*));
Sphere_harmonics.c:        for (i=1;i<=E->lmesh.nsf;i++)   {
Sphere_harmonics.c:            E->sphere.tablesplm[m][i]= (double *)malloc((E->sphere.hindice)*sizeof(double));
Sphere_harmonics.c:            E->sphere.tablescosf[m][i]= (double *)malloc((E->output.llmax+1)*sizeof(double));
Sphere_harmonics.c:            E->sphere.tablessinf[m][i]= (double *)malloc((E->output.llmax+1)*sizeof(double));
Sphere_harmonics.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Sphere_harmonics.c:        for (j=1;j<=E->lmesh.nsf;j++)  {
Sphere_harmonics.c:            node = j*E->lmesh.noz;
Sphere_harmonics.c:            f=E->sx[m][2][node];
Sphere_harmonics.c:            t=E->sx[m][1][node];
Sphere_harmonics.c:            for (mm=0;mm<=E->output.llmax;mm++)   {
Sphere_harmonics.c:                E->sphere.tablescosf[m][j][mm] = cos( mmf );
Sphere_harmonics.c:                E->sphere.tablessinf[m][j][mm] = sin( mmf );
Sphere_harmonics.c:            for (ll=0;ll<=E->output.llmax;ll++)
Sphere_harmonics.c:                    p = E->sphere.hindex[ll][mm];
Sphere_harmonics.c:                    E->sphere.tablesplm[m][j][p] = modified_plgndr_a(ll,mm,t) ;
Sphere_harmonics.c:    const int lev=E->mesh.levmax;
Sphere_harmonics.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Sphere_harmonics.c:   for (i=0;i<E->sphere.hindice;i++)    {
Sphere_harmonics.c:   for (j=1;j<=E->sphere.caps_per_proc;j++)
Sphere_harmonics.c:     for (es=1;es<=E->lmesh.snel;es++) {
Sphere_harmonics.c:       el = (ic==1)?(E->lmesh.elz*es):(E->lmesh.elz*(es-1)+1);
Sphere_harmonics.c:       for(k1=1;k1<=onedvpoints[E->mesh.nsd];k1++)   {
Sphere_harmonics.c:         t[k1] = E->sx[1][j][E->ien[j][el].node[k1+j1]];
Sphere_harmonics.c:         f[k1] = E->sx[2][j][E->ien[j][el].node[k1+j1]];
Sphere_harmonics.c:       for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Sphere_harmonics.c:         for(k1=1;k1<=onedvpoints[E->mesh.nsd];k1++)   
Sphere_harmonics.c:           temp0[k] += TG[j][E->sien[j][es].node[k1]] * E->M.vpt[GMVINDEX(k1,k)];
Sphere_harmonics.c:         area += E->gDA1[j][es].vpt[5];
Sphere_harmonics.c:         for(k=1;k<=onedvpoints[E->mesh.nsd];k++)
Sphere_harmonics.c:           temp0[k] = temp0[k]*E->gDA1[j][es].vpt[k];
Sphere_harmonics.c:         area += E->gDA0[j][es].vpt[5];
Sphere_harmonics.c:         for(k=1;k<=onedvpoints[E->mesh.nsd];k++)
Sphere_harmonics.c:           temp0[k] = temp0[k]*E->gDA0[j][es].vpt[k];
Sphere_harmonics.c:           p = E->sphere.hindex[ll][mm];
Sphere_harmonics.c:           for(k=1;k<=onedvpoints[E->mesh.nsd];k++)   {
Sphere_harmonics.c:/*             for(k1=1;k1<=onedvpoints[E->mesh.nsd];k1++)   {
Sphere_harmonics.c:                temp1[k] += cos(mm*f[k1]) * E->M.vpt[GMVINDEX(k1,k)];
Sphere_harmonics.c:                temp2[k] += sin(mm*f[k1]) * E->M.vpt[GMVINDEX(k1,k)];
Sphere_harmonics.c:                temp3[k] += modified_plgndr_a(ll,mm,t[k1]) * E->M.vpt[GMVINDEX(k1,k)];
Sphere_harmonics.c:             sphc[p]+=temp0[k]*E->Sph_Harm_Tblcs[j][mm][es].cs[k]*E->Sph_Harm_Tbllm[j][p][es].lm[k];
Sphere_harmonics.c:             sphs[p]+=temp0[k]*E->Sph_Harm_Tblcs[j][mm][es].sn[k]*E->Sph_Harm_Tbllm[j][p][es].lm[k];
Sphere_harmonics.c:   sphs[E->sphere.hindice] = area;
Sphere_harmonics.c:   area = sphs[E->sphere.hindice];
Sphere_harmonics.c:   for (i=0;i<E->sphere.hindice;i++)    {
Sphere_util.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Sphere_util.c:        ia[2] = E->lmesh.noz*E->lmesh.nox-E->lmesh.noz+1;
Sphere_util.c:        ia[3] = E->lmesh.nno-E->lmesh.noz+1;
Sphere_util.c:        ia[4] = ia[3]-E->lmesh.noz*(E->lmesh.nox-1);
Sphere_util.c:            xx[1][i] = E->x[m][1][ia[i]]/E->sx[m][3][ia[1]];
Sphere_util.c:            xx[2][i] = E->x[m][2][ia[i]]/E->sx[m][3][ia[1]];
Sphere_util.c:            xx[3][i] = E->x[m][3][ia[i]]/E->sx[m][3][ia[1]];
Sphere_util.c:            E->sphere.angle[m][i] = angle[i];
Sphere_util.c:        E->sphere.area[m] = area_sphere_cap(angle);
Sphere_util.c:        for (lev=E->mesh.levmax;lev>=E->mesh.levmin;lev--)
Sphere_util.c:            for (es=1;es<=E->lmesh.SNEL[lev];es++)              {
Sphere_util.c:                el = (es-1)*E->lmesh.ELZ[lev]+1;
Sphere_util.c:                    ia[i] = E->IEN[lev][m][el].node[i];
Sphere_util.c:                    xx[1][i] = E->X[lev][m][1][ia[i]]/E->SX[lev][m][3][ia[1]];
Sphere_util.c:                    xx[2][i] = E->X[lev][m][2][ia[i]]/E->SX[lev][m][3][ia[1]];
Sphere_util.c:                    xx[3][i] = E->X[lev][m][3][ia[i]]/E->SX[lev][m][3][ia[1]];
Sphere_util.c:                    E->sphere.angle1[lev][m][i][es] = angle[i];
Sphere_util.c:                E->sphere.area1[lev][m][es] = area_sphere_cap(angle);
Sphere_util.c:/*              fprintf(E->fp_out,"lev%d %d %.6e %.6e %.6e %.6e %.6e\n",lev,es,angle[1],angle[2],angle[3],angle[4],E->sphere.area1[lev][m][es]); */
Sphere_util.c:        ia[i] = E->IEN[lev][m][el].node[i];
Sphere_util.c:    es = (el-1)/E->lmesh.ELZ[lev]+1;
Sphere_util.c:        xx[1] = E->X[lev][m][1][ia[i]]/E->SX[lev][m][3][ia[1]];
Sphere_util.c:        xx[2] = E->X[lev][m][2][ia[i]]/E->SX[lev][m][3][ia[1]];
Sphere_util.c:        xx[3] = E->X[lev][m][3][ia[i]]/E->SX[lev][m][3][ia[1]];
Sphere_util.c:        angle1[i]= E->sphere.angle1[lev][m][i][es];
Stokes_flow_Incomp.c:    cycles=E->control.p_iterations;
Stokes_flow_Incomp.c:    if (!E->ve_data_cont.compressible)   {     // incompressible VE
Stokes_flow_Incomp.c:       solve_Ahat_p_fhat(E,E->U,E->P,E->F,E->control.accuracy,&cycles);
Stokes_flow_Incomp.c:       p_to_nodes(E,E->P,E->NP,E->mesh.levmax);
Stokes_flow_Incomp.c:    else if (E->ve_data_cont.compressible)   {  // compressible VE
Stokes_flow_Incomp.c:       solve_Ahat_fhat(E,E->U,E->F,E->control.accuracy,&cycles);
Stokes_flow_Incomp.c:    cycles=E->control.p_iterations;
Stokes_flow_Incomp.c:    solve_Ahat_p_fhat(E,E->U,E->P,E->F,E->control.accuracy,&cycles);
Stokes_flow_Incomp.c:    p_to_nodes(E,E->P,E->NP,E->mesh.levmax);
Stokes_flow_Incomp.c:     * This norm is ~= E->monitor.momentum_residual */
Stokes_flow_Incomp.c:    const int lev = E->mesh.levmax;
Stokes_flow_Incomp.c:    const int neq = E->lmesh.neq;
Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Stokes_flow_Incomp.c:    assemble_grad_p(E, P, E->u1, lev);
Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:            r2[m][i] = F[m][i] - E->u1[m][i] - r1[m][i];
Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Stokes_flow_Incomp.c:    fprintf(E->fp, "(%03d) %5.1f s v=%e p=%e "
Stokes_flow_Incomp.c:            E->monitor.solution_cycles);
Stokes_flow_Incomp.c:            E->monitor.solution_cycles);
Stokes_flow_Incomp.c:    if(E->control.inv_gruneisen == 0)
Stokes_flow_Incomp.c:        if(strcmp(E->control.uzawa, "cg") == 0)
Stokes_flow_Incomp.c:        else if(strcmp(E->control.uzawa, "bicg") == 0)
Stokes_flow_Incomp.c:    const int npno = E->lmesh.npno;
Stokes_flow_Incomp.c:    const int neq = E->lmesh.neq;
Stokes_flow_Incomp.c:    const int lev = E->mesh.levmax;
Stokes_flow_Incomp.c:    const int gneq = E->mesh.neq;
Stokes_flow_Incomp.c:    const int gnpno = E->mesh.npno;
Stokes_flow_Incomp.c:      for (m=1; m<=E->sphere.caps_per_proc; m++)   
Stokes_flow_Incomp.c:    if (E->parallel.me==0) {
Stokes_flow_Incomp.c:      fprintf(E->fp,"initial residue of momentum equation F %.9e %d %d\n",v_res,gneq,E->monitor.solution_cycles);
Stokes_flow_Incomp.c:      fprintf(stderr,"initial residue of momentum equation F %.9e %d %d\n",v_res,gneq,E->monitor.solution_cycles);
Stokes_flow_Incomp.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Stokes_flow_Incomp.c:    valid = solve_del2_u(E, E->u1, F, aimp, lev);
Stokes_flow_Incomp.c:    if(!valid && (E->parallel.me==0)) {
Stokes_flow_Incomp.c:            fputs("Warning: solver not converging! 1\n", E->fp);
Stokes_flow_Incomp.c:    strip_bcs_from_residual(E, E->u1, lev);
Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:                V[m][j] = E->u1[m][j];
Stokes_flow_Incomp.c:      fflush(E->fp);
Stokes_flow_Incomp.c:      fprintf(stderr,"Au=F solve after %g seconds for step %d\n",CPU_time0()-time0,E->monitor.solution_cycles);
Stokes_flow_Incomp.c:    const int npno = E->lmesh.npno;
Stokes_flow_Incomp.c:    const int neq = E->lmesh.neq;
Stokes_flow_Incomp.c:    const int lev = E->mesh.levmax;
Stokes_flow_Incomp.c:    const int gneq = E->mesh.neq;
Stokes_flow_Incomp.c:    const int gnpno = E->mesh.npno;
Stokes_flow_Incomp.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)   {
Stokes_flow_Incomp.c:    v_res = sqrt(E->monitor.fdotf/gneq);
Stokes_flow_Incomp.c:    if (E->parallel.me==0) {
Stokes_flow_Incomp.c:      fprintf(E->fp,"initial residue of momentum equation F %.9e %d %d\n",v_res,gneq,E->monitor.solution_cycles);
Stokes_flow_Incomp.c:      fprintf(stderr,"initial residue of momentum equation F %.9e %d %d\n",v_res,gneq,E->monitor.solution_cycles);
Stokes_flow_Incomp.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Stokes_flow_Incomp.c:    if(E->control.inv_gruneisen != 0) {
Stokes_flow_Incomp.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Stokes_flow_Incomp.c:    aimp = imp*v_res*E->control.sob_tolerance;    //one order higher accuracy
Stokes_flow_Incomp.c:    if(E->control.inv_gruneisen == 0)
Stokes_flow_Incomp.c:    if(E->control.inv_gruneisen != 0)
Stokes_flow_Incomp.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Stokes_flow_Incomp.c:    E->monitor.vdotv = sqrt(global_vdot(E, V,V,lev)/gneq);
Stokes_flow_Incomp.c:    E->monitor.incompressibility = residual/E->monitor.vdotv; 
Stokes_flow_Incomp.c:    if (E->control.print_convergence && E->parallel.me==0)  {
Stokes_flow_Incomp.c:      fprintf(E->fp,"AhatP (%03d) after %g seconds with div/v=%.3e for step %d\n",count,CPU_time0()-time0,E->monitor.incompressibility,E->monitor.solution_cycles);
Stokes_flow_Incomp.c:      fflush(E->fp);
Stokes_flow_Incomp.c:      fprintf(stderr,"AhatP (%03d) after %g seconds with div/v=%.3e for step %d\n",count,CPU_time0()-time0,E->monitor.incompressibility,E->monitor.solution_cycles);
Stokes_flow_Incomp.c:                                   E->monitor.incompressibility); */
Stokes_flow_Incomp.c://           (E->monitor.incompressibility > E->control.tole_comp) && (dvelocity > imp || dpressure > imp))) {
Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:                z1[m][j] = E->BPI[lev][m][j] * r1[m][j];
Stokes_flow_Incomp.c:            for (m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:        aimp = imp*v_res*E->control.sob_tolerance;
Stokes_flow_Incomp.c:        valid = solve_del2_u(E, E->u1, F, aimp, lev);
Stokes_flow_Incomp.c:        if(!valid && (E->parallel.me==0)) {
Stokes_flow_Incomp.c:            fputs("Warning: solver not converging! 1\n", E->fp);
Stokes_flow_Incomp.c:        strip_bcs_from_residual(E, E->u1, lev);
Stokes_flow_Incomp.c:        assemble_div_u(E, E->u1, F, lev);
Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:                V[m][j] -= alpha * E->u1[m][j];
Stokes_flow_Incomp.c:        E->monitor.vdotv = global_vdot(E, V,V,lev);
Stokes_flow_Incomp.c:        E->monitor.incompressibility=sqrt((gneq/gnpno)*(1e-32+global_pdot(E,F,F,lev)/(1e-32+E->monitor.vdotv)));
Stokes_flow_Incomp.c:        dvelocity = alpha * sqrt(global_vdot(E, E->u1,E->u1,lev)/(1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:        if (E->control.print_convergence && E->parallel.me==0)  {
Stokes_flow_Incomp.c:      fprintf(E->fp,"AhatP (%03d) after %g seconds with div/v=%.3e dv/v=%.3e dp/p=%.3e for step %d\n",count,CPU_time0()-time0,E->monitor.incompressibility,dvelocity,dpressure,E->monitor.solution_cycles);
Stokes_flow_Incomp.c:      fflush(E->fp);
Stokes_flow_Incomp.c:      fprintf(stderr,"AhatP (%03d) after %g seconds with div/v=%.3e dv/v=%.3e dp/p=%.3e for step %d\n",count,CPU_time0()-time0,E->monitor.incompressibility,dvelocity,dpressure,E->monitor.solution_cycles);
Stokes_flow_Incomp.c:                                       E->monitor.incompressibility); */
Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++) {
Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Stokes_flow_Incomp.c:    npno = E->lmesh.npno;
Stokes_flow_Incomp.c:    neq = E->lmesh.neq;
Stokes_flow_Incomp.c:    lev = E->mesh.levmax;
Stokes_flow_Incomp.c:    for (m=1; m<=E->sphere.caps_per_proc; m++)   {
Stokes_flow_Incomp.c:    v_res = E->monitor.fdotf;
Stokes_flow_Incomp.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Stokes_flow_Incomp.c:    E->monitor.vdotv = global_v_norm2(E, V);
Stokes_flow_Incomp.c:    E->monitor.incompressibility = sqrt(global_div_norm2(E, r1)
Stokes_flow_Incomp.c:                                        / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:    v_norm = sqrt(E->monitor.vdotv);
Stokes_flow_Incomp.c:    p_norm = sqrt(E->monitor.pdotp);
Stokes_flow_Incomp.c:    if (E->control.print_convergence && E->parallel.me==0)  {
Stokes_flow_Incomp.c:                                   E->monitor.incompressibility);
Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:           (E->monitor.incompressibility > imp) &&
Stokes_flow_Incomp.c:            fprintf(E->fp, "BiCGstab method failed!!\n");
Stokes_flow_Incomp.c:            for (m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:            for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:                pt[m][j] = E->BPI[lev][m][j] * p2[m][j];
Stokes_flow_Incomp.c:        if(!valid && (E->parallel.me==0)) {
Stokes_flow_Incomp.c:            fputs("Warning: solver not converging! 1\n", E->fp);
Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:                st[m][j] = E->BPI[lev][m][j] * s0[m][j];
Stokes_flow_Incomp.c:        valid = solve_del2_u(E, E->u1, F, imp*v_res, lev);
Stokes_flow_Incomp.c:        if(!valid && (E->parallel.me==0)) {
Stokes_flow_Incomp.c:            fputs("Warning: solver not converging! 2\n", E->fp);
Stokes_flow_Incomp.c:        strip_bcs_from_residual(E, E->u1, lev);
Stokes_flow_Incomp.c:        assemble_div_rho_u(E, E->u1, t0, lev);
Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:                F[m][j] = alpha * u0[m][j] + omega * E->u1[m][j];
Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:        E->monitor.vdotv = global_v_norm2(E, V);
Stokes_flow_Incomp.c:        E->monitor.pdotp = global_p_norm2(E, P);
Stokes_flow_Incomp.c:        v_norm = sqrt(E->monitor.vdotv);
Stokes_flow_Incomp.c:        p_norm = sqrt(E->monitor.pdotp);
Stokes_flow_Incomp.c:        dvelocity = sqrt(global_v_norm2(E, F) / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:        dpressure = sqrt(global_p_norm2(E, s0) / (1e-32 + E->monitor.pdotp));
Stokes_flow_Incomp.c:        E->monitor.incompressibility = sqrt(global_div_norm2(E, t0)
Stokes_flow_Incomp.c:                                            / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:        if(E->control.print_convergence && E->parallel.me==0) {
Stokes_flow_Incomp.c:                                       E->monitor.incompressibility);
Stokes_flow_Incomp.c:	if(E->control.only_check_vel_convergence){
Stokes_flow_Incomp.c:	  E->monitor.incompressibility = dvelocity;
Stokes_flow_Incomp.c:        for(m=1; m<=E->sphere.caps_per_proc; m++) {
Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Stokes_flow_Incomp.c:    const int npno = E->lmesh.npno;
Stokes_flow_Incomp.c:    const int neq = E->lmesh.neq;
Stokes_flow_Incomp.c:    const int lev = E->mesh.levmax;
Stokes_flow_Incomp.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Stokes_flow_Incomp.c:    cycles = E->control.p_iterations;
Stokes_flow_Incomp.c:                         imp * E->monitor.fdotf);
Stokes_flow_Incomp.c:          (num_of_loop <= E->control.compress_iter_maxstep)) {
Stokes_flow_Incomp.c:        for (m=1;m<=E->sphere.caps_per_proc;m++) {
Stokes_flow_Incomp.c:        assemble_div_rho_u(E, V, E->u1, lev);
Stokes_flow_Incomp.c:        div_res = sqrt(global_div_norm2(E, E->u1) / (1e-32 + E->monitor.vdotv));
Stokes_flow_Incomp.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Stokes_flow_Incomp.c:                               (1.0e-32 + E->monitor.vdotv) );
Stokes_flow_Incomp.c:        for (m=1;m<=E->sphere.caps_per_proc;m++)
Stokes_flow_Incomp.c:                               (1.0e-32 + E->monitor.pdotp) );
Stokes_flow_Incomp.c:        if(E->parallel.me == 0) {
Stokes_flow_Incomp.c:            fprintf(E->fp, "itercg -- div(rho*v)/v=%.2e dv/v=%.2e and dp/p=%.2e loop %d\n\n", div_res, relative_err_v, relative_err_p, num_of_loop);
Stokes_flow_Incomp.c:	if(E->control.only_check_vel_convergence){
Stokes_flow_Incomp.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)   {
Stokes_flow_Incomp.c:    int neq = E->lmesh.neq;
Stokes_flow_Incomp.c:    int lev = E->mesh.levmax;
Stokes_flow_Incomp.c:    assemble_grad_p(E, P, E->u1, lev);
Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:            F[m][i] = F[m][i] - E->u1[m][i];
Stokes_flow_Incomp.c:    assemble_del2_u(E, V, E->u1, lev, 1);
Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:            F[m][i] = F[m][i] - E->u1[m][i];
Stokes_flow_Incomp.c:    valid = solve_del2_u(E, E->u1, F, acc, lev);
Stokes_flow_Incomp.c:    if(!valid && (E->parallel.me==0)) {
Stokes_flow_Incomp.c:        fputs("Warning: solver not converging! 0\n", E->fp);
Stokes_flow_Incomp.c:    strip_bcs_from_residual(E, E->u1, lev);
Stokes_flow_Incomp.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Stokes_flow_Incomp.c:            V[m][i] += E->u1[m][i];
Topo_gravity.c:    //if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Topo_gravity.c:   for(m=1;m<=E->sphere.caps_per_proc;m++)
Topo_gravity.c:     for(snode=1;snode<=E->lmesh.nsf;snode++)   {
Topo_gravity.c:        node = E->surf_node[m][snode];
Topo_gravity.c:        tpgb[m][snode] =  2*SZZ[m][node-E->lmesh.noz+1]- SZZ[m][node-E->lmesh.noz+2];
Topo_gravity.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)
Topo_gravity.c:                for(m=1;m<=E->sphere.caps_per_proc;m++)
Topo_gravity.c:                        for(snode=1;snode<=E->lmesh.nsf;snode++) {
Topo_gravity.c:                                node = E->surf_node[m][snode];
Topo_gravity.c:                                /*freesurf[m][snode] += 0.5*(E->sphere.cap[m].V[3][node]+E->sphere.cap[m].Vprev[3][node])*E->advection.timestep;*/
Topo_gravity.c:                                freesurf[m][snode] += E->sphere.cap[m].V[3][node]*E->advection.timestep;
Topo_gravity.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Topo_gravity.c:    SXX[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:    SYY[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:    SXY[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:    SXZ[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:    SZY[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:    SZZ[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:    divv[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:    vorv[m] = (float *)malloc((E->lmesh.nno+1)*sizeof(float));
Topo_gravity.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Topo_gravity.c:    for(i=1;i<=E->lmesh.nno;i++) {
Topo_gravity.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)        {
Topo_gravity.c:/*   stride = E->lmesh.nsf*6; */
Topo_gravity.c:/*   for(m=1;m<=E->sphere.caps_per_proc;m++) */
Topo_gravity.c:/*     for (node=1;node<=E->lmesh.nno;node++) */
Topo_gravity.c:/*       if ( (node%E->lmesh.noz)==0 )  { */
Topo_gravity.c:/*         i = node/E->lmesh.noz; */
Topo_gravity.c:/*         E->stress[m][(i-1)*6+1] = SXX[m][node]; */
Topo_gravity.c:/*         E->stress[m][(i-1)*6+2] = SYY[m][node]; */
Topo_gravity.c:/*         E->stress[m][(i-1)*6+3] = SZZ[m][node]; */
Topo_gravity.c:/*         E->stress[m][(i-1)*6+4] = SXY[m][node]; */
Topo_gravity.c:/*         E->stress[m][(i-1)*6+5] = SXZ[m][node]; */
Topo_gravity.c:/*         E->stress[m][(i-1)*6+6] = SZY[m][node]; */
Topo_gravity.c:/*      else if ( ((node+1)%E->lmesh.noz)==0 )  { */
Topo_gravity.c:/*         i = (node+1)/E->lmesh.noz; */
Topo_gravity.c:/*         E->stress[m][stride+(i-1)*6+1] = SXX[m][node]; */
Topo_gravity.c:/*         E->stress[m][stride+(i-1)*6+2] = SYY[m][node]; */
Topo_gravity.c:/*         E->stress[m][stride+(i-1)*6+3] = SZZ[m][node]; */
Topo_gravity.c:/*         E->stress[m][stride+(i-1)*6+4] = SXY[m][node]; */
Topo_gravity.c:/*         E->stress[m][stride+(i-1)*6+5] = SXZ[m][node]; */
Topo_gravity.c:/*         E->stress[m][stride+(i-1)*6+6] = SZY[m][node]; */
Topo_gravity.c:  const int dims=E->mesh.nsd;
Topo_gravity.c:  const int lev=E->mesh.levmax;
Topo_gravity.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Topo_gravity.c:    for(e=1;e<=E->lmesh.nel;e++)  {
Topo_gravity.c:      dOmega = &(E->gDA[m][e]);	/* Jacobian at integration points */
Topo_gravity.c:      GNx = &(E->gNX[m][e]);	/* derivatives of shape functions at
Topo_gravity.c:        pre[j] =  E->EVi[m][(e-1)*vpts+j]*dOmega->vpt[j];
Topo_gravity.c:          tww[i] += dOmega->vpt[j] * g_point[j].weight[E->mesh.nsd-1]
Topo_gravity.c:            * E->N.vpt[GNVINDEX(i,j)];
Topo_gravity.c:                        + VV[3][i]*E->N.vpt[GNVINDEX(i,j)] )*rtf[3][j];
Topo_gravity.c:                         + VV[1][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j]))/sin(rtf[1][j])
Topo_gravity.c:                        + VV[3][i]*E->N.vpt[GNVINDEX(i,j)] )*rtf[3][j];
Topo_gravity.c:                         - VV[2][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j]))/sin(rtf[1][j])
Topo_gravity.c:                                                                      *GNx->vpt[GNVXINDEX(0,i,j)]-VV[1][i]*E->N.vpt[GNVINDEX(i,j)]);
Topo_gravity.c:                                                                      *GNx->vpt[GNVXINDEX(1,i,j)]/sin(rtf[1][j])-VV[2][i]*E->N.vpt[GNVINDEX(i,j)]);
Topo_gravity.c:                                   + VV[1][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j])/sin(rtf[1][j])
Topo_gravity.c:              + VV[2][i]*E->N.vpt[GNVINDEX(i,j)]*cos(rtf[1][j])
Topo_gravity.c:      if(E->control.inv_gruneisen != 0) { /* isotropic component */
Topo_gravity.c:      Sxx /= E->eco[m][e].area;
Topo_gravity.c:      Syy /= E->eco[m][e].area;
Topo_gravity.c:      Szz /= E->eco[m][e].area;
Topo_gravity.c:      Sxy /= E->eco[m][e].area;
Topo_gravity.c:      Sxz /= E->eco[m][e].area;
Topo_gravity.c:      Szy /= E->eco[m][e].area;
Topo_gravity.c:      div /= E->eco[m][e].area;
Topo_gravity.c:      vor /= E->eco[m][e].area;
Topo_gravity.c:      Szz -= E->P[m][e];
Topo_gravity.c:      Sxx -= E->P[m][e];
Topo_gravity.c:      Syy -= E->P[m][e];
Topo_gravity.c:        node = E->ien[m][e].node[i]; /* assign to global nodes */
Topo_gravity.c:  (E->exchange_node_f)(E,SXX,lev);
Topo_gravity.c:  (E->exchange_node_f)(E,SYY,lev);
Topo_gravity.c:  (E->exchange_node_f)(E,SZZ,lev);
Topo_gravity.c:  (E->exchange_node_f)(E,SXY,lev);
Topo_gravity.c:  (E->exchange_node_f)(E,SXZ,lev);
Topo_gravity.c:  (E->exchange_node_f)(E,SZY,lev);
Topo_gravity.c:  (E->exchange_node_f)(E,divv,lev);
Topo_gravity.c:  (E->exchange_node_f)(E,vorv,lev);
Topo_gravity.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Topo_gravity.c:    for(node=1;node<=E->lmesh.nno;node++)   {
Topo_gravity.c:      mass_fac = E->Mass[m][node]*stress_scaling;
Topo_gravity.c:      mass_fac = E->Mass[m][node]*velo_scaling;
Topo_gravity.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Topo_gravity.c:    for (node=1;node<=E->lmesh.nno;node++) {
Topo_gravity.c:      E->gstress[m][(node-1)*6+1] = SXX[m][node];
Topo_gravity.c:      E->gstress[m][(node-1)*6+2] = SYY[m][node];
Topo_gravity.c:      E->gstress[m][(node-1)*6+3] = SZZ[m][node];
Topo_gravity.c:      E->gstress[m][(node-1)*6+4] = SXY[m][node];
Topo_gravity.c:      E->gstress[m][(node-1)*6+5] = SXZ[m][node];
Topo_gravity.c:      E->gstress[m][(node-1)*6+6] = SZY[m][node];
Topo_gravity.c:                                   {0, 4, 2, 6}, /* E-W sides */
Topo_gravity.c:  if(E->control.side_sbcs) {
Topo_gravity.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Topo_gravity.c:      for(i=1; i<=E->lmesh.noy; i++)
Topo_gravity.c:        for(j=1; j<=E->lmesh.nox; j++)
Topo_gravity.c:          for(k=1; k<=E->lmesh.noz; k++) {
Topo_gravity.c:            n = k+(j-1)*E->lmesh.noz+(i-1)*E->lmesh.nox*E->lmesh.noz;
Topo_gravity.c:            for(d=1; d<=E->mesh.nsd; d++)
Topo_gravity.c:              if(E->node[m][n] & sbc_flag[d]) {
Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][2]] = E->sbc.SB[m][SIDE_WEST][d][ E->sbc.node[m][n] ];
Topo_gravity.c:                if(i==E->lmesh.noy)
Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][2]] = E->sbc.SB[m][SIDE_EAST][d][ E->sbc.node[m][n] ];
Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][1]] = E->sbc.SB[m][SIDE_NORTH][d][ E->sbc.node[m][n] ];
Topo_gravity.c:                if(j==E->lmesh.nox)
Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][1]] = E->sbc.SB[m][SIDE_SOUTH][d][ E->sbc.node[m][n] ];
Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][3]] = E->sbc.SB[m][SIDE_BOTTOM][d][ E->sbc.node[m][n] ];
Topo_gravity.c:                if(k==E->lmesh.noz)
Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][3]] = E->sbc.SB[m][SIDE_TOP][d][ E->sbc.node[m][n] ];
Topo_gravity.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Topo_gravity.c:      for(i=1; i<=E->lmesh.noy; i++)
Topo_gravity.c:        for(j=1; j<=E->lmesh.nox; j++)
Topo_gravity.c:          for(k=1; k<=E->lmesh.noz; k++) {
Topo_gravity.c:            n = k+(j-1)*E->lmesh.noz+(i-1)*E->lmesh.nox*E->lmesh.noz;
Topo_gravity.c:            for(d=1; d<=E->mesh.nsd; d++)
Topo_gravity.c:              if(E->node[m][n] & sbc_flag[d]) {
Topo_gravity.c:                if(i==1 || i==E->lmesh.noy)
Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][2]] = E->sphere.cap[m].VB[d][n];
Topo_gravity.c:                if(j==1 || j==E->lmesh.nox)
Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][1]] = E->sphere.cap[m].VB[d][n];
Topo_gravity.c:                if(k==1 || k==E->lmesh.noz)
Topo_gravity.c:                  E->gstress[m][(n-1)*6+stress_index[d][3]] = E->sphere.cap[m].VB[d][n];
Topo_gravity.c:     * E->buoyancy needs to be converted to density (-therm_exp*ref_T/Ra/g)
Topo_gravity.c:    nxnz = E->lmesh.nox*E->lmesh.noz;
Topo_gravity.c:    radius_m = E->data.radius_km*1e3;
Topo_gravity.c:    scaling2 = -E->data.therm_exp*E->data.ref_temperature*E->data.density
Topo_gravity.c:        / E->control.Atemp;
Topo_gravity.c:    scaling = 4.0 * M_PI * 1.0e3 * E->data.radius_km * E->data.grav_const
Topo_gravity.c:        / E->data.grav_acc;
Topo_gravity.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Topo_gravity.c:        TT[m] = (float *) malloc ((E->lmesh.nsf+1)*sizeof(float));
Topo_gravity.c:    geoid[0] = (float*)malloc(E->sphere.hindice*sizeof(float));
Topo_gravity.c:    geoid[1] = (float*)malloc(E->sphere.hindice*sizeof(float));
Topo_gravity.c:    for (p = 0; p < E->sphere.hindice; p++) {
Topo_gravity.c:    for(k=1;k<E->lmesh.noz;k++)  {
Topo_gravity.c:        grav = 0.5 * (E->refstate.gravity[k] + E->refstate.gravity[k+1]);
Topo_gravity.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Topo_gravity.c:            for(i=1;i<=E->lmesh.noy;i++)
Topo_gravity.c:                for(j=1;j<=E->lmesh.nox;j++)  {
Topo_gravity.c:                    node= k + (j-1)*E->lmesh.noz + (i-1)*nxnz;
Topo_gravity.c:                    p = j + (i-1)*E->lmesh.nox;
Topo_gravity.c:                    TT[m][p] = (E->buoyancy[m][node]+E->buoyancy[m][node+1])
Topo_gravity.c:        dlayer = (E->sx[1][3][k+1]-E->sx[1][3][k])*radius_m;
Topo_gravity.c:        radius = (E->sx[1][3][k+1]+E->sx[1][3][k])*0.5;
Topo_gravity.c:        for (ll=1;ll<=E->output.llmax;ll++) {
Topo_gravity.c:            conb = radius * pow(E->sphere.ri/radius, ((double)(ll)));
Topo_gravity.c:                p = E->sphere.hindex[ll][mm];
Topo_gravity.c:        //if(E->parallel.me==0)  fprintf(stderr,"layer %d %.5e %g %g %g\n",k,radius,dlayer,con1,con2);
Topo_gravity.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Topo_gravity.c:     * E->slice.tpg is essentailly non-dimensional stress(rr) and need
Topo_gravity.c:    stress_scaling = E->data.ref_viscosity*E->data.therm_diff/
Topo_gravity.c:        (E->data.radius_km*E->data.radius_km*1e6);
Topo_gravity.c:    den_contrast1 = E->data.density*E->refstate.rho[E->lmesh.noz] - E->data.density_above;
Topo_gravity.c:    den_contrast2 = E->data.density_below - E->data.density*E->refstate.rho[1];
Topo_gravity.c:    grav1 = E->refstate.gravity[E->lmesh.noz] * E->data.grav_acc;
Topo_gravity.c:    grav2 = E->refstate.gravity[1] * E->data.grav_acc;
Topo_gravity.c:    scaling = 4.0 * M_PI * 1.0e3 * E->data.radius_km * E->data.grav_const
Topo_gravity.c:        / E->data.grav_acc;
Topo_gravity.c:    if (E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Topo_gravity.c:        sphere_expansion(E, E->slice.tpg, tpgt[0], tpgt[1]);
Topo_gravity.c:            for (i=0; i<E->sphere.hindice; i++) {
Topo_gravity.c:    if (E->parallel.me_loc[3] == 0) {
Topo_gravity.c:        sphere_expansion(E, E->slice.tpgb, tpgb[0], tpgb[1]);
Topo_gravity.c:            for (i=0; i<E->sphere.hindice; i++) {
Topo_gravity.c:    broadcast_vertical(E, tpgt[0], tpgt[1], E->parallel.nprocz-1);
Topo_gravity.c:    den_contrast1 = E->data.density*E->refstate.rho[E->lmesh.noz] - E->data.density_above;
Topo_gravity.c:    den_contrast2 = E->data.density_below - E->data.density*E->refstate.rho[1];
Topo_gravity.c:    for (i = 0; i < E->sphere.hindice; i++) {
Topo_gravity.c:    if (E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Topo_gravity.c:        scaling = 4.0 * M_PI * 1.0e3 * E->data.radius_km * E->data.grav_const
Topo_gravity.c:            / E->data.grav_acc;
Topo_gravity.c:            for (ll=2; ll<=E->output.llmax; ll++)   {
Topo_gravity.c:                    i = E->sphere.hindex[ll][mm];
Topo_gravity.c:    if (E->parallel.me_loc[3] == 0) {
Topo_gravity.c:        scaling = 1.0e3 * 4.0 * M_PI * E->data.radius_km * E->data.grav_const
Topo_gravity.c:            / (E->data.grav_acc * E->refstate.gravity[1]);
Topo_gravity.c:            for (ll=2; ll<=E->output.llmax; ll++)   {
Topo_gravity.c:                con2 = con1 * pow(E->sphere.ri, ((double)(ll+2)));
Topo_gravity.c:                    i = E->sphere.hindex[ll][mm];
Topo_gravity.c:    broadcast_vertical(E, geoid_tpgt[0], geoid_tpgt[1], E->parallel.nprocz-1);
Topo_gravity.c:    ri = E->sphere.ri;
Topo_gravity.c:    den_contrast1 = E->data.density*E->refstate.rho[E->lmesh.noz] - E->data.density_above;
Topo_gravity.c:    den_contrast2 = E->data.density_below - E->data.density*E->refstate.rho[1];
Topo_gravity.c:    grav1 = E->refstate.gravity[E->lmesh.noz] * E->data.grav_acc;
Topo_gravity.c:    grav2 = E->refstate.gravity[1] * E->data.grav_acc;
Topo_gravity.c:    con4 = 4.0*M_PI*E->data.grav_const*E->data.radius_km*1000;
Topo_gravity.c:    for (i = 0; i < E->sphere.hindice; i++) {
Topo_gravity.c:    for (ll=2;ll<=E->output.llmax;ll++)   {
Topo_gravity.c:        a11 = den_contrast1*E->data.grav_acc - E->data.density*b1;
Topo_gravity.c:        a12 =                                - E->data.density*a1;
Topo_gravity.c:        a22 = den_contrast2*(E->data.grav_acc-a2);
Topo_gravity.c:            i = E->sphere.hindex[ll][mm];
Topo_gravity.c:            c1_0 = geoid_bncy[0][i]*E->data.density*grav1;
Topo_gravity.c:            c1_1 = geoid_bncy[1][i]*E->data.density*grav1;
Topo_gravity.c:    broadcast_vertical(E, geoid_tpgt[0], geoid_tpgt[1], E->parallel.nprocz-1);
Topo_gravity.c:    geoid_from_buoyancy(E, E->sphere.harm_geoid_from_bncy,
Topo_gravity.c:                        E->sphere.harm_geoid_from_bncy_botm);
Topo_gravity.c:    expand_topo_sph_harm(E, E->sphere.harm_tpgt, E->sphere.harm_tpgb);
Topo_gravity.c:    if(E->control.self_gravitation)
Topo_gravity.c:                                     E->sphere.harm_tpgt,
Topo_gravity.c:                                     E->sphere.harm_tpgb,
Topo_gravity.c:                                     E->sphere.harm_geoid_from_bncy,
Topo_gravity.c:                                     E->sphere.harm_geoid_from_bncy_botm,
Topo_gravity.c:                                     E->sphere.harm_geoid_from_tpgt,
Topo_gravity.c:                                     E->sphere.harm_geoid_from_tpgb);
Topo_gravity.c:        geoid_from_topography(E, E->sphere.harm_tpgt, E->sphere.harm_tpgb,
Topo_gravity.c:                              E->sphere.harm_geoid_from_tpgt,
Topo_gravity.c:                              E->sphere.harm_geoid_from_tpgb);
Topo_gravity.c:    if (E->parallel.me == (E->parallel.nprocz-1))  {
Topo_gravity.c:            for (p = 0; p < E->sphere.hindice; p++) {
Topo_gravity.c:                E->sphere.harm_geoid[i][p]
Topo_gravity.c:                    = E->sphere.harm_geoid_from_bncy[i][p]
Topo_gravity.c:                    + E->sphere.harm_geoid_from_tpgt[i][p]
Topo_gravity.c:                    + E->sphere.harm_geoid_from_tpgb[i][p];
Topo_gravity.c:    const int dims=E->mesh.nsd;
Topo_gravity.c:    const int noz=E->lmesh.noz;
Topo_gravity.c:    const int noy=E->lmesh.noy;
Topo_gravity.c:    const int nno=E->lmesh.nno;
Topo_gravity.c:    const int elz = E->lmesh.elz;
Topo_gravity.c:    const int ely = E->lmesh.ely;
Topo_gravity.c:    const int lev=E->mesh.levmax;
Topo_gravity.c:    const int lnsf=E->lmesh.nsf;
Topo_gravity.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)          {
Topo_gravity.c:  for(j=1;j<=E->sphere.caps_per_proc;j++)          {
Topo_gravity.c:    for(els=1;els<=E->lmesh.snel;els++) {
Topo_gravity.c:      el = E->surf_element[j][els];
Topo_gravity.c:           res[m]  = eltf[m]  - E->elt_del[lev][j][el].g[m][0]  * E->P[j][el];
Topo_gravity.c:           resb[m] = eltfb[m] - E->elt_del[lev][j][elb].g[m][0]* E->P[j][elb];
Topo_gravity.c://           res[m]  = eltf[m] - eltg[m][0]  * E->P[j][el];
Topo_gravity.c://           resb[m] = eltfb[m] - eltgb[m][0]* E->P[j][elb];
Topo_gravity.c:                nodes = E->sien[j][els].node[1];
Topo_gravity.c:                nodes = E->sien[j][els].node[2];
Topo_gravity.c:                nodes = E->sien[j][els].node[3];
Topo_gravity.c:                nodes = E->sien[j][els].node[4];
Topo_gravity.c:                nodes = E->sien[j][els].node[1];
Topo_gravity.c:                nodes = E->sien[j][els].node[2];
Topo_gravity.c:                nodes = E->sien[j][els].node[3];
Topo_gravity.c:                nodes = E->sien[j][els].node[4];
Topo_gravity.c:    for(els=1;els<=E->lmesh.snel;els++) {
Topo_gravity.c:       el = E->surf_element[j][els];
Topo_gravity.c:                * E->L.vpt[GMVINDEX(m,n)] * E->L.vpt[GMVINDEX(m,n)];
Topo_gravity.c:                * E->L.vpt[GMVINDEX(m,n)] * E->L.vpt[GMVINDEX(m,n)];
Topo_gravity.c:            SL[j][E->sien[j][els].node[m]] += eltTL[m-1];
Topo_gravity.c:            SU[j][E->sien[j][els].node[m]] += eltTU[m-1];
Topo_gravity.c:  if(E->parallel.me_loc[3] == 0) {
Topo_gravity.c:  if(E->sphere.caps == 12)
Topo_gravity.c:      full_exchange_snode_f(E,RL,SL,E->mesh.levmax);
Topo_gravity.c:      regional_exchange_snode_f(E,RL,SL,E->mesh.levmax);
Topo_gravity.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)
Topo_gravity.c:      for(i=1;i<=E->lmesh.nsf;i++)
Topo_gravity.c:  if(E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Topo_gravity.c:  if(E->sphere.caps == 12)
Topo_gravity.c:      full_exchange_snode_f(E,RU,SU,E->mesh.levmax);
Topo_gravity.c:      regional_exchange_snode_f(E,RU,SU,E->mesh.levmax);
Topo_gravity.c:  for (j=1;j<=E->sphere.caps_per_proc;j++)
Topo_gravity.c:      for(i=1;i<=E->lmesh.nsf;i++)
Topo_gravity.c:    for (j=1;j<=E->sphere.caps_per_proc;j++)   {
Tracer_setup.c:    int m=E->parallel.me;
Tracer_setup.c:    input_boolean("tracer",&(E->control.tracer),"off",m);
Tracer_setup.c:		  &(E->control.tracer_enriched),"off",m);
Tracer_setup.c:    if(E->control.tracer_enriched){
Tracer_setup.c:      if(!E->control.tracer)	/* check here so that we can get away
Tracer_setup.c:      input_float("Q0_enriched",&(E->control.Q0ER),"0.0",m);
Tracer_setup.c:	       E->control.Q0,E->control.Q0ER);
Tracer_setup.c:      //if(E->composition.ncomp != 1)
Tracer_setup.c:    if(E->control.tracer) {
Tracer_setup.c:        input_int("tracer_ic_method",&(E->trace.ic_method),"0,0,nomax",m);
Tracer_setup.c:        if (E->trace.ic_method==0){
Tracer_setup.c:            input_int("tracers_per_element",&(E->trace.itperel),"10,0,nomax",m);
Tracer_setup.c:        else if (E->trace.ic_method==1)
Tracer_setup.c:            input_string("tracer_file",E->trace.tracer_file,"tracer.dat",m);
Tracer_setup.c:        else if (E->trace.ic_method==2) {
Tracer_setup.c:        input_int("tracer_flavors",&(E->trace.nflavors),"0,0,nomax",m);
Tracer_setup.c:		  &(E->trace.ic_method_for_flavors),"0,0,nomax",m);
Tracer_setup.c:        if (E->trace.nflavors > 1) {
Tracer_setup.c:            switch(E->trace.ic_method_for_flavors){
Tracer_setup.c:                E->trace.z_interface = (double*) malloc((E->trace.nflavors-1)
Tracer_setup.c:                for(i=0; i<E->trace.nflavors-1; i++)
Tracer_setup.c:                    E->trace.z_interface[i] = 0.7;
Tracer_setup.c:                input_double_vector("z_interface", E->trace.nflavors-1,
Tracer_setup.c:                                    E->trace.z_interface, m);
Tracer_setup.c:	      input_string("ictracer_grd_file",E->trace.ggrd_file,"",m); /* file from which to read */
Tracer_setup.c:	      input_int("ictracer_grd_layers",&(E->trace.ggrd_layers),"2",m); /* 
Tracer_setup.c:                fprintf(stderr,"ic_method_for_flavors %i undefined (1 and 99 only for ggrd mode)\n",E->trace.ic_method_for_flavors);
Tracer_setup.c:        input_boolean("itracer_warnings",&(E->trace.itracer_warnings),"on",m);
Tracer_setup.c:        if(E->parallel.nprocxy == 12)
Tracer_setup.c:   E->trace.advection_time = 0;
Tracer_setup.c:   E->trace.find_tracers_time = 0;
Tracer_setup.c:   E->trace.lost_souls_time = 0;
Tracer_setup.c:   if(E->parallel.nprocxy == 1) {
Tracer_setup.c:       E->problem_tracer_setup = regional_tracer_setup;
Tracer_setup.c:       E->trace.keep_within_bounds = regional_keep_within_bounds;
Tracer_setup.c:       E->trace.get_velocity = regional_get_velocity;
Tracer_setup.c:       E->trace.iget_element = regional_iget_element;
Tracer_setup.c:       E->problem_tracer_setup = full_tracer_setup;
Tracer_setup.c:       E->trace.keep_within_bounds = full_keep_within_bounds;
Tracer_setup.c:       E->trace.get_velocity = full_get_velocity;
Tracer_setup.c:       E->trace.iget_element = full_iget_element;
Tracer_setup.c:    if (E->trace.nflavors > 0)
Tracer_setup.c:    if (E->composition.on) {
Tracer_setup.c:    E->trace.advection_time += CPU_time0() - begin_time;
Tracer_setup.c:    E->trace.istat_isend=0;
Tracer_setup.c:    E->trace.istat_elements_checked=0;
Tracer_setup.c:    E->trace.istat1=0;
Tracer_setup.c:    if ((E->monitor.solution_cycles % 20) == 0) {
Tracer_setup.c:        fprintf(E->trace.fpt, "STEP %d\n", E->monitor.solution_cycles);
Tracer_setup.c:        fprintf(E->trace.fpt, "Advecting tracers takes %f seconds.\n",
Tracer_setup.c:                E->trace.advection_time - E->trace.find_tracers_time);
Tracer_setup.c:        fprintf(E->trace.fpt, "Finding element takes %f seconds.\n",
Tracer_setup.c:                E->trace.find_tracers_time - E->trace.lost_souls_time);
Tracer_setup.c:        fprintf(E->trace.fpt, "Exchanging lost tracers takes %f seconds.\n",
Tracer_setup.c:                E->trace.lost_souls_time);
Tracer_setup.c:    if(E->control.verbose){
Tracer_setup.c:      fprintf(E->trace.fpt,"Number of times for all element search  %d\n",E->trace.istat1);
Tracer_setup.c:      fprintf(E->trace.fpt,"Number of tracers sent to other processors: %d\n",E->trace.istat_isend);
Tracer_setup.c:      fprintf(E->trace.fpt,"Number of times element columns are checked: %d \n",E->trace.istat_elements_checked);
Tracer_setup.c:      if (E->composition.on) {
Tracer_setup.c:        fprintf(E->trace.fpt,"Empty elements filled with old compositional "
Tracer_setup.c:                "values: %d (%f percent)\n", E->trace.istat_iempty,
Tracer_setup.c:                (100.0*E->trace.istat_iempty)/E->lmesh.nel);
Tracer_setup.c:        E->trace.istat_iempty=0;
Tracer_setup.c:        if (E->parallel.me==0) {
Tracer_setup.c:            fprintf(E->fp,"composition: %e",E->monitor.elapsed_time);
Tracer_setup.c:            for (i=0; i<E->composition.ncomp; i++)
Tracer_setup.c:                fprintf(E->fp," %e", E->composition.bulk_composition[i]);
Tracer_setup.c:            fprintf(E->fp,"\n");
Tracer_setup.c:            fprintf(E->fp,"composition_error_fraction: %e",E->monitor.elapsed_time);
Tracer_setup.c:            for (i=0; i<E->composition.ncomp; i++)
Tracer_setup.c:                fprintf(E->fp," %e", E->composition.error_fraction[i]);
Tracer_setup.c:            fprintf(E->fp,"\n");
Tracer_setup.c:      fflush(E->trace.fpt);
Tracer_setup.c:    dt=E->advection.timestep;
Tracer_setup.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:        numtracers=E->trace.ntracers[j];
Tracer_setup.c:            theta0=E->trace.basicq[j][0][kk];
Tracer_setup.c:            phi0=E->trace.basicq[j][1][kk];
Tracer_setup.c:            rad0=E->trace.basicq[j][2][kk];
Tracer_setup.c:            x0=E->trace.basicq[j][3][kk];
Tracer_setup.c:            y0=E->trace.basicq[j][4][kk];
Tracer_setup.c:            z0=E->trace.basicq[j][5][kk];
Tracer_setup.c:            nelem=E->trace.ielement[j][kk];
Tracer_setup.c:            (E->trace.get_velocity)(E,j,nelem,theta0,phi0,rad0,velocity_vector);
Tracer_setup.c:            (E->trace.keep_within_bounds)(E,&x_pred,&y_pred,&z_pred,&theta_pred,&phi_pred,&rad_pred);
Tracer_setup.c:            E->trace.basicq[j][0][kk]=theta_pred;
Tracer_setup.c:            E->trace.basicq[j][1][kk]=phi_pred;
Tracer_setup.c:            E->trace.basicq[j][2][kk]=rad_pred;
Tracer_setup.c:            E->trace.basicq[j][3][kk]=x_pred;
Tracer_setup.c:            E->trace.basicq[j][4][kk]=y_pred;
Tracer_setup.c:            E->trace.basicq[j][5][kk]=z_pred;
Tracer_setup.c:            E->trace.basicq[j][6][kk]=x0;
Tracer_setup.c:            E->trace.basicq[j][7][kk]=y0;
Tracer_setup.c:            E->trace.basicq[j][8][kk]=z0;
Tracer_setup.c:            E->trace.basicq[j][9][kk]=velocity_vector[1];  /* Vx */
Tracer_setup.c:            E->trace.basicq[j][10][kk]=velocity_vector[2];  /* Vy */
Tracer_setup.c:            E->trace.basicq[j][11][kk]=velocity_vector[3];  /* Vz */
Tracer_setup.c:    dt=E->advection.timestep;
Tracer_setup.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:        for (kk=1;kk<=E->trace.ntracers[j];kk++) {
Tracer_setup.c:            theta_pred=E->trace.basicq[j][0][kk];
Tracer_setup.c:            phi_pred=E->trace.basicq[j][1][kk];
Tracer_setup.c:            rad_pred=E->trace.basicq[j][2][kk];
Tracer_setup.c:            x_pred=E->trace.basicq[j][3][kk];
Tracer_setup.c:            y_pred=E->trace.basicq[j][4][kk];
Tracer_setup.c:            z_pred=E->trace.basicq[j][5][kk];
Tracer_setup.c:            x0=E->trace.basicq[j][6][kk];
Tracer_setup.c:            y0=E->trace.basicq[j][7][kk];
Tracer_setup.c:            z0=E->trace.basicq[j][8][kk];
Tracer_setup.c:            Vx0=E->trace.basicq[j][9][kk];
Tracer_setup.c:            Vy0=E->trace.basicq[j][10][kk];
Tracer_setup.c:            Vz0=E->trace.basicq[j][11][kk];
Tracer_setup.c:            nelem=E->trace.ielement[j][kk];
Tracer_setup.c:            (E->trace.get_velocity)(E,j,nelem,theta_pred,phi_pred,rad_pred,velocity_vector);
Tracer_setup.c:            (E->trace.keep_within_bounds)(E,&x_cor,&y_cor,&z_cor,&theta_cor,&phi_cor,&rad_cor);
Tracer_setup.c:            E->trace.basicq[j][0][kk]=theta_cor;
Tracer_setup.c:            E->trace.basicq[j][1][kk]=phi_cor;
Tracer_setup.c:            E->trace.basicq[j][2][kk]=rad_cor;
Tracer_setup.c:            E->trace.basicq[j][3][kk]=x_cor;
Tracer_setup.c:            E->trace.basicq[j][4][kk]=y_cor;
Tracer_setup.c:            E->trace.basicq[j][5][kk]=z_cor;
Tracer_setup.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:        E->trace.ilater[j]=E->trace.ilatersize[j]=0;
Tracer_setup.c:        E->trace.istat1=0;
Tracer_setup.c:            E->trace.istat_ichoice[j][kk]=0;
Tracer_setup.c:        num_tracers=E->trace.ntracers[j];
Tracer_setup.c:            theta=E->trace.basicq[j][0][it];
Tracer_setup.c:            phi=E->trace.basicq[j][1][it];
Tracer_setup.c:            rad=E->trace.basicq[j][2][it];
Tracer_setup.c:            x=E->trace.basicq[j][3][it];
Tracer_setup.c:            y=E->trace.basicq[j][4][it];
Tracer_setup.c:            z=E->trace.basicq[j][5][it];
Tracer_setup.c:            iprevious_element=E->trace.ielement[j][it];
Tracer_setup.c:            iel=(E->trace.iget_element)(E,j,iprevious_element,x,y,z,theta,phi,rad);
Tracer_setup.c:            fprintf(E->trace.fpt,"BB. kk %d %d %d %d %f %f %f %f %f %f\n",kk,j,iprevious_element,iel,x,y,z,theta,phi,rad);
Tracer_setup.c:            fflush(E->trace.fpt);
Tracer_setup.c:            E->trace.ielement[j][it]=iel;
Tracer_setup.c:    if (E->parallel.nprocxy == 12)
Tracer_setup.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:        if (E->trace.ilatersize[j]>0) {
Tracer_setup.c:            for (kk=0;kk<=((E->trace.number_of_tracer_quantities)-1);kk++) {
Tracer_setup.c:                free(E->trace.rlater[j][kk]);
Tracer_setup.c:    E->trace.find_tracers_time += CPU_time0() - begin_time;
Tracer_setup.c:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Tracer_setup.c:        for (flavor=0; flavor<E->trace.nflavors; flavor++)
Tracer_setup.c:            for (e=1; e<=E->lmesh.nel; e++)
Tracer_setup.c:                E->trace.ntracer_flavor[j][flavor][e] = 0;
Tracer_setup.c:        numtracers=E->trace.ntracers[j];
Tracer_setup.c:            e = E->trace.ielement[j][kk];
Tracer_setup.c:            flavor = E->trace.extraq[j][0][kk];
Tracer_setup.c:            E->trace.ntracer_flavor[j][flavor][e]++;
Tracer_setup.c:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Tracer_setup.c:        for (e=1; e<=E->lmesh.nel; e++) {
Tracer_setup.c:            fprintf(E->trace.fpt, "element=%d ntracer_flaver =", e);
Tracer_setup.c:            for (flavor=0; flavor<E->trace.nflavors; flavor++) {
Tracer_setup.c:                fprintf(E->trace.fpt, " %d",
Tracer_setup.c:                        E->trace.ntracer_flavor[j][flavor][e]);
Tracer_setup.c:            fprintf(E->trace.fpt, "\n");
Tracer_setup.c:    fflush(E->trace.fpt);
Tracer_setup.c:    if (E->trace.ic_method==0)
Tracer_setup.c:    else if (E->trace.ic_method==1)
Tracer_setup.c:    else if (E->trace.ic_method==2)
Tracer_setup.c:        fprintf(E->trace.fpt,"Not ready for other inputs yet\n");
Tracer_setup.c:        fflush(E->trace.fpt);
Tracer_setup.c:    E->trace.ilast_tracer_count = isum_tracers(E);
Tracer_setup.c:    fprintf(E->trace.fpt, "Sum of Tracers: %d\n", E->trace.ilast_tracer_count);
Tracer_setup.c:    if(E->parallel.me==0)
Tracer_setup.c:        fprintf(stderr, "Sum of Tracers: %d\n", E->trace.ilast_tracer_count);
Tracer_setup.c:    if (E->trace.nflavors > 0)
Tracer_setup.c:    if (E->parallel.me==0) fprintf(stderr,"Making Tracer Array\n");
Tracer_setup.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:        processor_fraction=E->lmesh.volume/E->mesh.volume;
Tracer_setup.c:        tracers_cap=E->mesh.nel*E->trace.itperel*processor_fraction;
Tracer_setup.c:          fprintf(stderr,"AA: proc frac: %f (%d) %d %d %f %f\n",processor_fraction,tracers_cap,E->lmesh.nel,E->parallel.nprocz, E->sx[j][3][E->lmesh.noz],E->sx[j][3][1]);
Tracer_setup.c:        fprintf(E->trace.fpt,"\nGenerating %d Tracers\n",tracers_cap);
Tracer_setup.c:    if (E->trace.nflavors) init_tracer_flavors(E);
Tracer_setup.c:    /* One must loop over E->X to find the min/max, since the 8 corner */
Tracer_setup.c:    xmin = ymin = zmin = E->sphere.ro;
Tracer_setup.c:    xmax = ymax = zmax = -E->sphere.ro;
Tracer_setup.c:    for (kk=1; kk<=E->lmesh.nno; kk++) {
Tracer_setup.c:        x = E->x[j][1][kk];
Tracer_setup.c:        y = E->x[j][2][kk];
Tracer_setup.c:        z = E->x[j][3][kk];
Tracer_setup.c:    while (E->trace.ntracers[j]<tracers_cap) {
Tracer_setup.c:            fprintf(E->trace.fpt,"Error(make_tracer_array)-too many tries?\n");
Tracer_setup.c:            fprintf(E->trace.fpt,"%d %d %d\n",max_tries,number_of_tries,RAND_MAX);
Tracer_setup.c:            fflush(E->trace.fpt);
Tracer_setup.c:        if (rad>=E->sx[j][3][E->lmesh.noz]) continue;
Tracer_setup.c:        if (rad<E->sx[j][3][1]) continue;
Tracer_setup.c:        if (E->parallel.nprocxy==1)
Tracer_setup.c:        (E->trace.keep_within_bounds)(E,&x,&y,&z,&theta,&phi,&rad);
Tracer_setup.c:        E->trace.ntracers[j]++;
Tracer_setup.c:        kk=E->trace.ntracers[j];
Tracer_setup.c:        E->trace.basicq[j][0][kk]=theta;
Tracer_setup.c:        E->trace.basicq[j][1][kk]=phi;
Tracer_setup.c:        E->trace.basicq[j][2][kk]=rad;
Tracer_setup.c:        E->trace.basicq[j][3][kk]=x;
Tracer_setup.c:        E->trace.basicq[j][4][kk]=y;
Tracer_setup.c:        E->trace.basicq[j][5][kk]=z;
Tracer_setup.c:    fptracer=fopen(E->trace.tracer_file,"r");
Tracer_setup.c:        fprintf(stderr,"Error while reading file '%s'\n", E->trace.tracer_file);
Tracer_setup.c:    fprintf(E->trace.fpt,"%d Tracers, %d columns in file \n",
Tracer_setup.c:    if (E->trace.number_of_extra_quantities+3 != ncolumns) {
Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(read tracer file)-wrong # of columns\n");
Tracer_setup.c:        fflush(E->trace.fpt);
Tracer_setup.c:    iestimate=number_of_tracers/E->parallel.nproc + icushion;
Tracer_setup.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:            ncol = 3 + E->trace.number_of_extra_quantities;
Tracer_setup.c:                fprintf(E->trace.fpt,"ERROR(read tracer file) - wrong input file format: %s\n", E->trace.tracer_file);
Tracer_setup.c:                fflush(E->trace.fpt);
Tracer_setup.c:            (E->trace.keep_within_bounds)(E,&x,&y,&z,&theta,&phi,&rad);
Tracer_setup.c:            if (E->parallel.nprocz>1) icheck=icheck_processor_shell(E,j,rad);
Tracer_setup.c:            if (E->parallel.nprocxy==1)
Tracer_setup.c:            E->trace.ntracers[j]++;
Tracer_setup.c:            if (E->trace.ntracers[j]>=(E->trace.max_ntracers[j]-5)) expand_tracer_arrays(E,j);
Tracer_setup.c:            E->trace.basicq[j][0][E->trace.ntracers[j]]=theta;
Tracer_setup.c:            E->trace.basicq[j][1][E->trace.ntracers[j]]=phi;
Tracer_setup.c:            E->trace.basicq[j][2][E->trace.ntracers[j]]=rad;
Tracer_setup.c:            E->trace.basicq[j][3][E->trace.ntracers[j]]=x;
Tracer_setup.c:            E->trace.basicq[j][4][E->trace.ntracers[j]]=y;
Tracer_setup.c:            E->trace.basicq[j][5][E->trace.ntracers[j]]=z;
Tracer_setup.c:            for (i=0; i<E->trace.number_of_extra_quantities; i++)
Tracer_setup.c:                E->trace.extraq[j][i][E->trace.ntracers[j]]=buffer[i+3];
Tracer_setup.c:        fprintf(E->trace.fpt,"Number of tracers in this cap is: %d\n",
Tracer_setup.c:                E->trace.ntracers[j]);
Tracer_setup.c:        for (kk=1; kk<=E->trace.ntracers[j]; kk++) {
Tracer_setup.c:            fprintf(E->trace.fpt, "tracer#=%d sph_coord=(%g,%g,%g)", kk,
Tracer_setup.c:                    E->trace.basicq[j][0][kk],
Tracer_setup.c:                    E->trace.basicq[j][1][kk],
Tracer_setup.c:                    E->trace.basicq[j][2][kk]);
Tracer_setup.c:            fprintf(E->trace.fpt, "   extraq=");
Tracer_setup.c:            for (i=0; i<E->trace.number_of_extra_quantities; i++)
Tracer_setup.c:                fprintf(E->trace.fpt, " %g", E->trace.extraq[j][i][kk]);
Tracer_setup.c:            fprintf(E->trace.fpt, "\n");
Tracer_setup.c:        fflush(E->trace.fpt);
Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(read_tracer_file) - tracers != number in file\n");
Tracer_setup.c:        fprintf(E->trace.fpt,"Tracers in system: %d\n", icheck);
Tracer_setup.c:        fprintf(E->trace.fpt,"Tracers in file: %d\n", number_of_tracers);
Tracer_setup.c:        fflush(E->trace.fpt);
Tracer_setup.c:    if (E->trace.number_of_extra_quantities>99) {
Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-increase size of extra[]\n");
Tracer_setup.c:        fflush(E->trace.fpt);
Tracer_setup.c:    if(strcmp(E->output.format, "ascii-gz") == 0){
Tracer_setup.c:	      E->control.data_dir_old,E->monitor.solution_cycles_init,E->parallel.me,E->monitor.solution_cycles_init);
Tracer_setup.c:      sprintf(output_file,"%s.tracer.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-gziped file not found %s\n",output_file);
Tracer_setup.c:        fflush(E->trace.fpt);
Tracer_setup.c:    sprintf(output_file,"%s.tracer.%d.%d",E->control.old_P_file,E->parallel.me,E->monitor.solution_cycles_init);
Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-file not found %s\n",output_file);
Tracer_setup.c:        fflush(E->trace.fpt);
Tracer_setup.c:    for(j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:        if (E->trace.number_of_extra_quantities+3 != ncolumns) {
Tracer_setup.c:            fprintf(E->trace.fpt,"ERROR(read_old_tracer_file)-wrong # of columns\n");
Tracer_setup.c:            fflush(E->trace.fpt);
Tracer_setup.c:        E->trace.ntracers[j]=numtracers;
Tracer_setup.c:            ncol = 3 + E->trace.number_of_extra_quantities;
Tracer_setup.c:                fprintf(E->trace.fpt,"ERROR(read_old_tracer_file) - wrong input file format: %s\n", output_file);
Tracer_setup.c:                fflush(E->trace.fpt);
Tracer_setup.c:            (E->trace.keep_within_bounds)(E,&x,&y,&z,&theta,&phi,&rad);
Tracer_setup.c:            E->trace.basicq[j][0][kk]=theta;
Tracer_setup.c:            E->trace.basicq[j][1][kk]=phi;
Tracer_setup.c:            E->trace.basicq[j][2][kk]=rad;
Tracer_setup.c:            E->trace.basicq[j][3][kk]=x;
Tracer_setup.c:            E->trace.basicq[j][4][kk]=y;
Tracer_setup.c:            E->trace.basicq[j][5][kk]=z;
Tracer_setup.c:            for (i=0; i<E->trace.number_of_extra_quantities; i++)
Tracer_setup.c:                E->trace.extraq[j][i][kk]=buffer[i+3];
Tracer_setup.c:        for (kk=1; kk<=E->trace.ntracers[j]; kk++) {
Tracer_setup.c:            fprintf(E->trace.fpt, "tracer#=%d sph_coord=(%g,%g,%g)", kk,
Tracer_setup.c:                    E->trace.basicq[j][0][kk],
Tracer_setup.c:                    E->trace.basicq[j][1][kk],
Tracer_setup.c:                    E->trace.basicq[j][2][kk]);
Tracer_setup.c:            fprintf(E->trace.fpt, "   extraq=");
Tracer_setup.c:            for (i=0; i<E->trace.number_of_extra_quantities; i++)
Tracer_setup.c:                fprintf(E->trace.fpt, " %g", E->trace.extraq[j][i][kk]);
Tracer_setup.c:            fprintf(E->trace.fpt, "\n");
Tracer_setup.c:        fflush(E->trace.fpt);
Tracer_setup.c:        fprintf(E->trace.fpt,"Read %d tracers from file %s\n",numtracers,output_file);
Tracer_setup.c:        fflush(E->trace.fpt);
Tracer_setup.c:    if(strcmp(E->output.format, "ascii-gz") == 0)
Tracer_setup.c:    iold_number = E->trace.ilast_tracer_count;
Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(check_sum)-break in conservation %d %d\n",
Tracer_setup.c:        fflush(E->trace.fpt);
Tracer_setup.c:        if (E->trace.itracer_warnings)
Tracer_setup.c:    E->trace.ilast_tracer_count = number;
Tracer_setup.c:    for (j=1; j<=E->sphere.caps_per_proc; j++)
Tracer_setup.c:        imycount = imycount + E->trace.ntracers[j];
Tracer_setup.c:    MPI_Allreduce(&imycount,&iallcount,1,MPI_INT,MPI_SUM,E->parallel.world);
Tracer_setup.c:    switch(E->trace.ic_method_for_flavors){
Tracer_setup.c:      for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:	number_of_tracers = E->trace.ntracers[j];
Tracer_setup.c:	  rad = E->trace.basicq[j][2][kk];
Tracer_setup.c:          flavor = E->trace.nflavors - 1;
Tracer_setup.c:          for (i=0; i<E->trace.nflavors-1; i++) {
Tracer_setup.c:              if (rad > E->trace.z_interface[i]) {
Tracer_setup.c:          E->trace.extraq[j][0][kk] = flavor;
Tracer_setup.c:	      E->trace.ic_method_for_flavors);
Tracer_setup.c:      fprintf(stderr,"ic_method_for_flavors %i undefined\n",E->trace.ic_method_for_flavors);
Tracer_setup.c:/* which is later used by (E->trace.icheck_cap)()                            */
Tracer_setup.c:    nox=E->lmesh.nox;
Tracer_setup.c:    noy=E->lmesh.noy;
Tracer_setup.c:    noz=E->lmesh.noz;
Tracer_setup.c:    lev = E->mesh.levmax;
Tracer_setup.c:    for (j=1; j<=E->sphere.caps_per_proc; j++) {
Tracer_setup.c:                xx[n] = E->sx[j][d+1][node[i]];
Tracer_setup.c:        num_ngb = E->parallel.TNUM_PASS[lev][j];
Tracer_setup.c:            neighbor_proc = E->parallel.PROCESSOR[lev][j].pass[kk];
Tracer_setup.c:                      tag, E->parallel.world, &request[idb]);
Tracer_setup.c:                      tag, E->parallel.world, &request[idb]);
Tracer_setup.c:         *      1) E->sphere.caps_per_proc==1
Tracer_setup.c:         *      2) E->mesh.nsd==3
Tracer_setup.c:                rad = E->sphere.ro;
Tracer_setup.c:                E->trace.xcap[kk][i] = x;
Tracer_setup.c:                E->trace.ycap[kk][i] = y;
Tracer_setup.c:                E->trace.zcap[kk][i] = z;
Tracer_setup.c:                E->trace.theta_cap[kk][i] = theta;
Tracer_setup.c:                E->trace.phi_cap[kk][i] = phi;
Tracer_setup.c:                E->trace.rad_cap[kk][i] = rad;
Tracer_setup.c:                E->trace.cos_theta[kk][i] = cos(theta);
Tracer_setup.c:                E->trace.sin_theta[kk][i] = sin(theta);
Tracer_setup.c:                E->trace.cos_phi[kk][i] = cos(phi);
Tracer_setup.c:                E->trace.sin_phi[kk][i] = sin(phi);
Tracer_setup.c:                neighbor_proc = E->parallel.me;
Tracer_setup.c:                neighbor_proc = E->parallel.PROCESSOR[lev][1].pass[kk];
Tracer_setup.c:                fprintf(E->trace.fpt, "pass=%d rank=%d corner=%d "
Tracer_setup.c:                        E->trace.theta_cap[kk][i],
Tracer_setup.c:                        E->trace.phi_cap[kk][i],
Tracer_setup.c:                        E->trace.rad_cap[kk][i]);
Tracer_setup.c:        fflush(E->trace.fpt);
Tracer_setup.c:    E->trace.max_ntracers[j]=number_of_tracers+number_of_tracers/4;
Tracer_setup.c:    E->trace.ntracers[j]=0;
Tracer_setup.c:    if ((E->trace.ielement[j]=(int *) malloc(E->trace.max_ntracers[j]*sizeof(int)))==NULL) {
Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(make tracer array)-no memory 1a\n");
Tracer_setup.c:        fflush(E->trace.fpt);
Tracer_setup.c:    for (kk=1;kk<E->trace.max_ntracers[j];kk++)
Tracer_setup.c:        E->trace.ielement[j][kk]=-99;
Tracer_setup.c:    for (kk=0;kk<E->trace.number_of_basic_quantities;kk++) {
Tracer_setup.c:        if ((E->trace.basicq[j][kk]=(double *)malloc(E->trace.max_ntracers[j]*sizeof(double)))==NULL) {
Tracer_setup.c:            fprintf(E->trace.fpt,"ERROR(initialize tracer arrays)-no memory 1b.%d\n",kk);
Tracer_setup.c:            fflush(E->trace.fpt);
Tracer_setup.c:    for (kk=0;kk<E->trace.number_of_extra_quantities;kk++) {
Tracer_setup.c:        if ((E->trace.extraq[j][kk]=(double *)malloc(E->trace.max_ntracers[j]*sizeof(double)))==NULL) {
Tracer_setup.c:            fprintf(E->trace.fpt,"ERROR(initialize tracer arrays)-no memory 1c.%d\n",kk);
Tracer_setup.c:            fflush(E->trace.fpt);
Tracer_setup.c:    if (E->trace.nflavors > 0) {
Tracer_setup.c:        E->trace.ntracer_flavor[j]=(int **)malloc(E->trace.nflavors*sizeof(int*));
Tracer_setup.c:        for (kk=0;kk<E->trace.nflavors;kk++) {
Tracer_setup.c:            if ((E->trace.ntracer_flavor[j][kk]=(int *)malloc((E->lmesh.nel+1)*sizeof(int)))==NULL) {
Tracer_setup.c:                fprintf(E->trace.fpt,"ERROR(initialize tracer arrays)-no memory 1c.%d\n",kk);
Tracer_setup.c:                fflush(E->trace.fpt);
Tracer_setup.c:    fprintf(E->trace.fpt,"Physical size of tracer arrays (max_ntracers): %d\n",
Tracer_setup.c:            E->trace.max_ntracers[j]);
Tracer_setup.c:    fflush(E->trace.fpt);
Tracer_setup.c:    inewsize=E->trace.max_ntracers[j]+E->trace.max_ntracers[j]/5+icushion;
Tracer_setup.c:    if ((E->trace.ielement[j]=(int *)realloc(E->trace.ielement[j],inewsize*sizeof(int)))==NULL) {
Tracer_setup.c:        fprintf(E->trace.fpt,"ERROR(expand tracer arrays )-no memory (ielement)\n");
Tracer_setup.c:        fflush(E->trace.fpt);
Tracer_setup.c:    for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++) {
Tracer_setup.c:        if ((E->trace.basicq[j][kk]=(double *)realloc(E->trace.basicq[j][kk],inewsize*sizeof(double)))==NULL) {
Tracer_setup.c:            fprintf(E->trace.fpt,"ERROR(expand tracer arrays )-no memory (%d)\n",kk);
Tracer_setup.c:            fflush(E->trace.fpt);
Tracer_setup.c:    for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++) {
Tracer_setup.c:        if ((E->trace.extraq[j][kk]=(double *)realloc(E->trace.extraq[j][kk],inewsize*sizeof(double)))==NULL) {
Tracer_setup.c:            fprintf(E->trace.fpt,"ERROR(expand tracer arrays )-no memory 78 (%d)\n",kk);
Tracer_setup.c:            fflush(E->trace.fpt);
Tracer_setup.c:    fprintf(E->trace.fpt,"Expanding physical memory of ielement, basicq, and extraq to %d from %d\n",
Tracer_setup.c:            inewsize,E->trace.max_ntracers[j]);
Tracer_setup.c:    E->trace.max_ntracers[j]=inewsize;
Tracer_setup.c:    for (j=1;j<=E->sphere.caps_per_proc;j++) {
Tracer_setup.c:        iempty_space=(E->trace.max_ntracers[j]-E->trace.ntracers[j]);
Tracer_setup.c:        if (iempty_space>(E->trace.ntracers[j]+icushion)) {
Tracer_setup.c:            inewsize=E->trace.ntracers[j]+E->trace.ntracers[j]/4+icushion;
Tracer_setup.c:                fprintf(E->trace.fpt,"Error(reduce tracer arrays)-something up (hdf3)\n");
Tracer_setup.c:                fflush(E->trace.fpt);
Tracer_setup.c:            if ((E->trace.ielement[j]=(int *)realloc(E->trace.ielement[j],inewsize*sizeof(int)))==NULL) {
Tracer_setup.c:                fprintf(E->trace.fpt,"ERROR(reduce tracer arrays )-no memory (ielement)\n");
Tracer_setup.c:                fflush(E->trace.fpt);
Tracer_setup.c:            for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++) {
Tracer_setup.c:                if ((E->trace.basicq[j][kk]=(double *)realloc(E->trace.basicq[j][kk],inewsize*sizeof(double)))==NULL) {
Tracer_setup.c:                    fprintf(E->trace.fpt,"AKM(reduce tracer arrays )-no memory (%d)\n",kk);
Tracer_setup.c:                    fflush(E->trace.fpt);
Tracer_setup.c:            for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++) {
Tracer_setup.c:                if ((E->trace.extraq[j][kk]=(double *)realloc(E->trace.extraq[j][kk],inewsize*sizeof(double)))==NULL) {
Tracer_setup.c:                    fprintf(E->trace.fpt,"AKM(reduce tracer arrays )-no memory 783 (%d)\n",kk);
Tracer_setup.c:                    fflush(E->trace.fpt);
Tracer_setup.c:            fprintf(E->trace.fpt,"Reducing physical memory of ielement, basicq, and extraq to %d from %d\n",
Tracer_setup.c:                    E->trace.max_ntracers[j],inewsize);
Tracer_setup.c:            E->trace.max_ntracers[j]=inewsize;
Tracer_setup.c:    if (E->trace.ilatersize[j]==0) {
Tracer_setup.c:        E->trace.ilatersize[j]=E->trace.max_ntracers[j]/5;
Tracer_setup.c:        for (kk=0;kk<=((E->trace.number_of_tracer_quantities)-1);kk++) {
Tracer_setup.c:            if ((E->trace.rlater[j][kk]=(double *)malloc(E->trace.ilatersize[j]*sizeof(double)))==NULL) {
Tracer_setup.c:                fprintf(E->trace.fpt,"AKM(put_away_later)-no memory (%d)\n",kk);
Tracer_setup.c:                fflush(E->trace.fpt);
Tracer_setup.c:    E->trace.ilater[j]++;
Tracer_setup.c:    if (E->trace.ilater[j] >= (E->trace.ilatersize[j]-5)) expand_later_array(E,j);
Tracer_setup.c:    for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++)
Tracer_setup.c:        E->trace.rlater[j][kk][E->trace.ilater[j]]=E->trace.basicq[j][kk][it];
Tracer_setup.c:    for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++)
Tracer_setup.c:        E->trace.rlater[j][E->trace.number_of_basic_quantities+kk][E->trace.ilater[j]]=E->trace.extraq[j][kk][it];
Tracer_setup.c:    inewsize=E->trace.ilatersize[j]+E->trace.ilatersize[j]/5+icushion;
Tracer_setup.c:    for (kk=0;kk<=((E->trace.number_of_tracer_quantities)-1);kk++) {
Tracer_setup.c:        if ((E->trace.rlater[j][kk]=(double *)realloc(E->trace.rlater[j][kk],inewsize*sizeof(double)))==NULL) {
Tracer_setup.c:            fprintf(E->trace.fpt,"AKM(expand later array )-no memory (%d)\n",kk);
Tracer_setup.c:            fflush(E->trace.fpt);
Tracer_setup.c:    fprintf(E->trace.fpt,"Expanding physical memory of rlater to %d from %d\n",
Tracer_setup.c:            inewsize,E->trace.ilatersize[j]);
Tracer_setup.c:    E->trace.ilatersize[j]=inewsize;
Tracer_setup.c:    ilast_tracer=E->trace.ntracers[j];
Tracer_setup.c:    E->trace.ielement[j][it]=E->trace.ielement[j][ilast_tracer];
Tracer_setup.c:    for (kk=0;kk<=((E->trace.number_of_basic_quantities)-1);kk++)
Tracer_setup.c:        E->trace.basicq[j][kk][it]=E->trace.basicq[j][kk][ilast_tracer];
Tracer_setup.c:    for (kk=0;kk<=((E->trace.number_of_extra_quantities)-1);kk++)
Tracer_setup.c:        E->trace.extraq[j][kk][it]=E->trace.extraq[j][kk][ilast_tracer];
Tracer_setup.c:    E->trace.ntracers[j]--;
Tracer_setup.c:    const int noz = E->lmesh.noz;
Tracer_setup.c:    const int nprocz = E->parallel.nprocz;
Tracer_setup.c:    top_r = E->sx[j][3][noz];
Tracer_setup.c:    bottom_r = E->sx[j][3][1];
Tracer_setup.c:    if ( (rad<=top_r) && (E->parallel.me_loc[3]==nprocz-1) ) return 1;
Tracer_setup.c:    int me = E->parallel.me;
Tracer_setup.c:    fprintf(E->trace.fpt, "Should not be here\n");
Tracer_setup.c:    fprintf(E->trace.fpt, "Error(check_shell) nprocessor: %d, radius: %f\n",
Tracer_setup.c:    fflush(E->trace.fpt);
Visco_elastic.c:       E->monitor.length_scale = E->data.layer_km/E->mesh.layer[2]; /* km */
Visco_elastic.c:       E->monitor.time_scale = pow(E->data.layer_km*1000.0,2.0)/
Visco_elastic.c:            (E->data.therm_diff*3600.0*24.0*365.25*1.0e6);   /* Million years */
Visco_elastic.c:    if (E->ve_data_cont.SELFG)   {
Visco_elastic.c:      // calculate E->incr_potential[0/1] from slice.surf/botm[2]
Visco_elastic.c:      calculate_potential( E, E->slice_ve.surf[2], E->slice_ve.botm[2],
Visco_elastic.c:                       E->incr_potential[0], E->incr_potential[1], 1 );
Visco_elastic.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Visco_elastic.c:      for (i=1;i<=E->lmesh.nsf;i++)   {
Visco_elastic.c:        E->init_potential[1][m][i] += E->incr_potential[1][m][i];
Visco_elastic.c:        E->init_potential[0][m][i] += E->incr_potential[0][m][i];
Visco_elastic.c:      if (E->ve_data_cont.polar_wander) {
Visco_elastic.c:         E->ve_data_cont.PW[0] += E->ve_data_cont.PW_incr[0];
Visco_elastic.c:         E->ve_data_cont.PW[1] += E->ve_data_cont.PW_incr[1];
Visco_elastic.c:if (E->parallel.me==0) fprintf(E->fp,"m0m1 in process_new_ve %g %g\n",E->ve_data_cont.PW_incr[0],E->ve_data_cont.PW_incr[1]);
Visco_elastic.c:    if (E->ve_data_cont.Heaviside==1) {  // single harmonic for benchmark
Visco_elastic.c: *       E->slice.surf/botm[1]    incr deformation (from E->U)
Visco_elastic.c: *       E->slice.surf/botm[2]    incr stresses    (no iceload)
Visco_elastic.c: *       E->slice.surf/botm[3]    cum  deformation (+= surf/botm[1])
Visco_elastic.c: *       E->slice.load[0/2]       cum  stresses, w/ iceload (+= surf/botm[2])
Visco_elastic.c:    lev=E->mesh.levmax;
Visco_elastic.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:      for (i=1;i<=E->lmesh.nno;i++)  {
Visco_elastic.c:         sint = E->SinCos[lev][m][0][i];
Visco_elastic.c:         sinf = E->SinCos[lev][m][1][i];
Visco_elastic.c:         cost = E->SinCos[lev][m][2][i];
Visco_elastic.c:         cosf = E->SinCos[lev][m][3][i];
Visco_elastic.c:         ux = E->sphere.cap[m].V[1][i]*cost*cosf
Visco_elastic.c:            - E->sphere.cap[m].V[2][i]*sinf
Visco_elastic.c:            + E->sphere.cap[m].V[3][i]*sint*cosf;
Visco_elastic.c:         uy = E->sphere.cap[m].V[1][i]*cost*sinf
Visco_elastic.c:            + E->sphere.cap[m].V[2][i]*cosf
Visco_elastic.c:            + E->sphere.cap[m].V[3][i]*sint*sinf;
Visco_elastic.c:         uz =-E->sphere.cap[m].V[1][i]*sint
Visco_elastic.c:            + E->sphere.cap[m].V[3][i]*cost;
Visco_elastic.c:         E->X[lev][m][1][i] += ux;
Visco_elastic.c:         E->X[lev][m][2][i] += uy;
Visco_elastic.c:         E->X[lev][m][3][i] += uz;
Visco_elastic.c:         E->SX[lev][m][3][i] += E->U[m][E->id[m][i].doff[3]];
Visco_elastic.c:         E->SX[lev][m][1][i] = acos(E->X[lev][m][3][i]/E->SX[lev][m][3][i]);
Visco_elastic.c:         E->SX[lev][m][2][i] = myatan(E->X[lev][m][2][i],E->X[lev][m][1][i]);
Visco_elastic.c:         E->SinCos[lev][m][0][i] = sin(E->SX[lev][m][1][i]);
Visco_elastic.c:         E->SinCos[lev][m][1][i] = sin(E->SX[lev][m][2][i]);
Visco_elastic.c:         E->SinCos[lev][m][2][i] = cos(E->SX[lev][m][1][i]);
Visco_elastic.c:         E->SinCos[lev][m][3][i] = cos(E->SX[lev][m][2][i]);
Visco_elastic.c:  if (E->control.NMULTIGRID||E->control.EMULTIGRID)   {
Visco_elastic.c:    if (E->monitor.solution_cycles%E->ve_data_cont.KERNEL==0 || E->ve_data_cont.DIRECT)  {
Visco_elastic.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)  {
Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:            for (i=1;i<=E->lmesh.nsf;i++)  {
Visco_elastic.c:                node = i*E->lmesh.noz;
Visco_elastic.c:                E->slice_ve.surf[1][m][i] = E->U[m][E->id[m][node].doff[3]];
Visco_elastic.c:            remove_average(E,E->slice_ve.surf[1],1);
Visco_elastic.c:            if (E->ve_data_cont.Heaviside==1)  {   /* single-harmonic */
Visco_elastic.c:                for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:                for (i=1;i<=E->lmesh.nsf;i++)
Visco_elastic.c:                    E->slice_ve.surf[2][m][i] = E->slice_ve.surf[1][m][i]
Visco_elastic.c:                                            *E->ve_data_cont.surf_scaling;
Visco_elastic.c:            else if (E->ve_data_cont.Heaviside==2) {    /* ice-model  */
Visco_elastic.c:                for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:                for (i=1;i<=E->lmesh.nsf;i++)
Visco_elastic.c:                    E->slice_ve.surf[2][m][i] = E->slice_ve.surf[1][m][i]
Visco_elastic.c:                                              *E->ve_data_cont.surf_scaling 
Visco_elastic.c:                                            + E->slice_ve.dynamic_oceanload[m][i];
Visco_elastic.c:        if (E->parallel.me_loc[3]==0)  {
Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:            for (i=1;i<=E->lmesh.nsf;i++)  {
Visco_elastic.c:                node = (i-1)*E->lmesh.noz+1;
Visco_elastic.c:                E->slice_ve.botm[1][m][i] = E->U[m][E->id[m][node].doff[3]];
Visco_elastic.c:            remove_average(E,E->slice_ve.botm[1],0);
Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:            for (i=1;i<=E->lmesh.nsf;i++)  {
Visco_elastic.c:                E->slice_ve.botm[2][m][i] = E->slice_ve.botm[1][m][i]
Visco_elastic.c:                                        *E->ve_data_cont.botm_scaling;
Visco_elastic.c:        if (E->ve_data_cont.change_of_load==0) 
Visco_elastic.c:        load_to_CM_grav( E, E->slice_ve.surf[2], E->slice_ve.botm[2], count );
Visco_elastic.c:        shift_U_to_CM(E, E->slice_ve.surf[1], E->slice_ve.botm[1]);
Visco_elastic.c://        if (E->parallel.me_loc[3]==E->parallel.nprocz-1) 
Visco_elastic.c://            shift_to_CM(E, E->slice_ve.surf[1] );
Visco_elastic.c://        if (E->parallel.me_loc[3]==0) 
Visco_elastic.c://            shift_to_CM(E, E->slice_ve.botm[1] );
Visco_elastic.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)  {
Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:            for (i=1;i<=E->lmesh.nsf;i++) {
Visco_elastic.c:                E->slice_ve.surf[3][m][i] += E->slice_ve.surf[1][m][i];
Visco_elastic.c:                E->slice_ve.load[0][m][i] += E->slice_ve.surf[2][m][i];
Visco_elastic.c:        if (E->parallel.me_loc[3]==0)  {
Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:            for (i=1;i<=E->lmesh.nsf;i++)  {
Visco_elastic.c:                E->slice_ve.botm[3][m][i] += E->slice_ve.botm[1][m][i];
Visco_elastic.c:                E->slice_ve.load[2][m][i] += E->slice_ve.botm[2][m][i];
Visco_elastic.c:  for (lev=E->mesh.levmin;lev<=E->mesh.levmax;lev++)  {
Visco_elastic.c:    nox = E->lmesh.NOX[lev];
Visco_elastic.c:    noy = E->lmesh.NOY[lev];
Visco_elastic.c:    noz = E->lmesh.NOZ[lev];
Visco_elastic.c:    nno = E->lmesh.NNO[lev];
Visco_elastic.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:          E->X[lev][m][1][i] = E->SX[lev][m][3][i]*sin(E->SX[lev][m][1][i])*cos(E->SX[lev][m][2][i]);
Visco_elastic.c:          E->X[lev][m][2][i] = E->SX[lev][m][3][i]*sin(E->SX[lev][m][1][i])*sin(E->SX[lev][m][2][i]);
Visco_elastic.c:          E->X[lev][m][3][i] = E->SX[lev][m][3][i]*cos(E->SX[lev][m][1][i]);
Visco_elastic.c:    for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:        E->SinCos[lev][m][0][i] = sin(E->SX[lev][m][1][i]);
Visco_elastic.c:        E->SinCos[lev][m][1][i] = sin(E->SX[lev][m][2][i]);
Visco_elastic.c:        E->SinCos[lev][m][2][i] = cos(E->SX[lev][m][1][i]);
Visco_elastic.c:        E->SinCos[lev][m][3][i] = cos(E->SX[lev][m][2][i]);
Visco_elastic.c:    nsf  = E->lmesh.nsf;
Visco_elastic.c: if(E->ve_data_cont.apply_potential==0) {    // surface loading
Visco_elastic.c:    const1 = (2*E->convection.perturb_ll[0]+1)*E->data.grav_acc/(4.0*M_PI*E->data.grav_const*E->sphere.dradius*E->data.density);
Visco_elastic.c:    const2 = (2*E->convection.perturb_ll[0]+1);
Visco_elastic.c:    const3 = const1/sqrt(E->convection.perturb_ll[0]*(E->convection.perturb_ll[0]+1));
Visco_elastic.c: else if(E->ve_data_cont.apply_potential==1) {    // apply potential loading
Visco_elastic.c:    const1 = E->data.grav_acc/(4.0*M_PI*E->data.grav_const*E->sphere.dradius*E->data.density);
Visco_elastic.c:    const3 = const1/sqrt(E->convection.perturb_ll[0]*(E->convection.perturb_ll[0]+1));
Visco_elastic.c: if ( been_here ==0 || (ii % (E->control.record_every) == 0) || ii==E->advection.max_timesteps)    {
Visco_elastic.c:   if (E->parallel.me==E->parallel.nprocz-1)  {  // only for one cpu
Visco_elastic.c:      for (ll=0;ll<=E->output.llmax;ll++)
Visco_elastic.c:        i = E->sphere.hindex[ll][mm];
Visco_elastic.c:        if (ll==E->convection.perturb_ll[0]&&mm==E->convection.perturb_mm[0]) {
Visco_elastic.c:          h_love = E->sphere.sphc[2][i];
Visco_elastic.c:          k_love = E->sphere.sphc[3][i];
Visco_elastic.c:          if (fabs(E->sphere.sphs[2][i]) > hdispersion_err) 
Visco_elastic.c:                       hdispersion_err = fabs(E->sphere.sphs[2][i]);
Visco_elastic.c:          if (fabs(E->sphere.sphs[3][i]) > kdispersion_err) 
Visco_elastic.c:                       kdispersion_err = fabs(E->sphere.sphs[3][i]);
Visco_elastic.c:          if (fabs(E->sphere.sphc[2][i]) > hdispersion_err) 
Visco_elastic.c:                       hdispersion_err = fabs(E->sphere.sphc[2][i]);
Visco_elastic.c:          if (fabs(E->sphere.sphs[2][i]) > hdispersion_err) 
Visco_elastic.c:                       hdispersion_err = fabs(E->sphere.sphs[2][i]);
Visco_elastic.c:          if (fabs(E->sphere.sphc[3][i]) > kdispersion_err) 
Visco_elastic.c:                       kdispersion_err = fabs(E->sphere.sphc[3][i]);
Visco_elastic.c:          if (fabs(E->sphere.sphs[3][i]) > kdispersion_err) 
Visco_elastic.c:                       kdispersion_err = fabs(E->sphere.sphs[3][i]);
Visco_elastic.c:     h_love = h_love*const1/E->convection.perturb_mag[0];
Visco_elastic.c:     hdispersion_err = hdispersion_err*const1/E->convection.perturb_mag[0];
Visco_elastic.c:     k_love = k_love*const2/E->convection.perturb_mag[0] - 1.0;
Visco_elastic.c:     kdispersion_err = kdispersion_err*const2/E->convection.perturb_mag[0];
Visco_elastic.c:    if (E->parallel.me_loc[3] == E->parallel.nprocz-1) {
Visco_elastic.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Visco_elastic.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Visco_elastic.c:      for (i=1;i<=E->lmesh.nsf;i++)  {
Visco_elastic.c:        j = E->surf_node[m][i];
Visco_elastic.c:        ve1[m][i]=E->sphere.cap[m].total_VS[1][i];
Visco_elastic.c:        ve2[m][i]=E->sphere.cap[m].total_VS[2][i];
Visco_elastic.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Visco_elastic.c:      for (i=1;i<=E->lmesh.nsf;i++)  {
Visco_elastic.c:    l_love = sqrt(l_love)*const3/E->convection.perturb_mag[0];
Visco_elastic.c:   if (E->parallel.me==E->parallel.nprocz-1)  {  // only for one cpu
Visco_elastic.c:     fprintf(E->fp_LN,"%d %.4e %.6e %.6e %.6e %.6e %.6e\n",ii,E->monitor.elapsed_time,h_love,hdispersion_err,k_love,kdispersion_err,l_love);
Visco_elastic.c:     fflush(E->fp_LN);
Visco_elastic.c:    for (m=1;m<=E->sphere.caps_per_proc;m++) {
Visco_elastic.c:       for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:         stress[m] = (float *) malloc ((E->lmesh.nno + 1)*sizeof(float));
Visco_elastic.c:       visc_h = (float *) malloc ((E->lmesh.noz + 1)*sizeof(float));
Visco_elastic.c:       stress_h = (float *) malloc ((E->lmesh.noz + 1)*sizeof(float));
Visco_elastic.c:    if ( been_here ==0 || (ii % (5*E->control.record_every) == 0) || ii==E->advection.max_timesteps)    {
Visco_elastic.c:      return_horiz_ave_f(E,E->Vi,visc_h);
Visco_elastic.c:      ele_to_nodes(E,E->S2inv,stress,E->mesh.levmax);
Visco_elastic.c:      if (E->parallel.me<E->parallel.nprocz)  {
Visco_elastic.c:                   E->control.data_file,E->parallel.me,ii);
Visco_elastic.c:                    ii,  E->lmesh.noz,                                // timstep
Visco_elastic.c:                    E->ve_data_cont.tau*E->monitor.elapsed_time, // current time (years)
Visco_elastic.c:                    E->ve_data_cont.tau*E->advection.timestep);  // length of timestep
Visco_elastic.c:        for (j=1;j<=E->lmesh.noz;j++)
Visco_elastic.c:          fprintf(fp,"%.5e %.5e %.5e\n",E->sx[m][3][j],visc_h[j],stress_h[j]);
Visco_elastic.c:                   E->control.data_file,E->parallel.me,ii);
Visco_elastic.c:                    ii,  E->lmesh.nno,                                // timstep
Visco_elastic.c:                    E->ve_data_cont.tau*E->monitor.elapsed_time, // current time (years)
Visco_elastic.c:                    E->ve_data_cont.tau*E->advection.timestep);  // length of timestep
Visco_elastic.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:        for (j=1;j<=E->lmesh.nno;j++)
Visco_elastic.c:          fprintf(fp,"%.5e %.5e\n",E->Vi[m][j],stress[m][j]);
Visco_elastic.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)  {
Visco_elastic.c:                     E->control.data_file,E->parallel.me);
Visco_elastic.c:            fprintf(fp,"%05d %.5e\n",ii,E->ve_data_cont.tau*E->monitor.elapsed_time);
Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  {
Visco_elastic.c:                for (j=1;j<=E->lmesh.nsf;j++)  { 
Visco_elastic.c:                    i=j*E->lmesh.noz;
Visco_elastic.c:                    E->Xsurf[1][m][j] = E->SX[E->mesh.levmax][m][1][i];
Visco_elastic.c:                    E->Xsurf[2][m][j] = E->SX[E->mesh.levmax][m][2][i];
Visco_elastic.c:                                E->Xsurf[1][m][j],E->Xsurf[2][m][j]);
Visco_elastic.c://                for (j=1;j<=E->lmesh.noz;j++)  { 
Visco_elastic.c://                    fprintf(fp,"%.5e\n",E->SX[E->mesh.levmax][m][3][j]); 
Visco_elastic.c:                sphere_expansion_output(E,1,E->slice_ve.surf[3],
Visco_elastic.c:                        E->sphere.sphc[2],E->sphere.sphs[2],
Visco_elastic.c:                        E->monitor.solution_cycles,"tps");
Visco_elastic.c:                for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:                for (j=1;j<=E->lmesh.nsf;j++)
Visco_elastic.c:                    E->Xsurf[3][m][j] =  E->incr_potential[0][m][j]  
Visco_elastic.c:                                       + E->incr_potential[2][m][j] ;
Visco_elastic.c:                sphere_expansion_output(E,1,E->Xsurf[3],
Visco_elastic.c:                        E->sphere.sphc[3],E->sphere.sphs[3],
Visco_elastic.c:                        E->monitor.solution_cycles,"pttl");
Visco_elastic.c:                if (E->ve_data_cont.SLE) {
Visco_elastic.c:                    for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:                    for (j=1;j<=E->lmesh.nsf;j++)
Visco_elastic.c:                        E->Xsurf[3][m][j] =  E->slice_ve.static_oceanload[m][j]
Visco_elastic.c:                                           + E->slice_ve.dynamic_oceanload[m][j];
Visco_elastic.c:                    sphere_expansion_output(E,1,E->Xsurf[3],
Visco_elastic.c:                            E->sphere.sphc[0],E->sphere.sphs[0],
Visco_elastic.c:                            E->monitor.solution_cycles,"oceanload");
Visco_elastic.c:                    fp = (i==0)? stderr : E->fp_out ;
Visco_elastic.c:    if ( ((ii % E->control.record_every) == 0) || (ii == E->advection.max_timesteps))    {
Visco_elastic.c:        if (E->parallel.me_loc[3]==E->parallel.nprocz-1)  {
Visco_elastic.c:            //       E->control.data_file2,E->parallel.me,ii);
Visco_elastic.c:                   E->control.data_file,E->parallel.me,ii);
Visco_elastic.c:                    E->ve_data_cont.tau*E->monitor.elapsed_time, // current time (years)
Visco_elastic.c:                    E->ve_data_cont.tau*E->advection.timestep,  // length of timestep
Visco_elastic.c:              E->ve_data_cont.PW[0],E->ve_data_cont.PW[1], // cumu. polar motion
Visco_elastic.c:              E->ve_data_cont.PW_incr[0],E->ve_data_cont.PW_incr[1]); // polar motion
Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:            for (j=1;j<=E->lmesh.nsf;j++)
Visco_elastic.c:                E->Xsurf[3][m][j] =  E->incr_potential[0][m][j]  
Visco_elastic.c:                                   + E->incr_potential[2][m][j] ;
Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:            for (j=1;j<=E->lmesh.nsf;j++)  { 
Visco_elastic.c:                i=j*E->lmesh.noz;
Visco_elastic.c:                E->Xsurf[1][m][j] = E->SX[E->mesh.levmax][m][1][i];
Visco_elastic.c:                E->Xsurf[2][m][j] = E->SX[E->mesh.levmax][m][2][i];
Visco_elastic.c:                E->Xsurf[3][m][j] = E->SX[E->mesh.levmax][m][3][i]; */
Visco_elastic.c:                   E->slice_ve.surf[3][m][j],       // total topography
Visco_elastic.c:                   E->slice_ve.surf[1][m][j],       // incr topo
Visco_elastic.c:                   E->init_potential[0][m][j],   // total potential
Visco_elastic.c:                   E->incr_potential[0][m][j],   // incr potential
Visco_elastic.c:                   E->slice_ve.total_static_oceanload[m][j]  // oceanload
Visco_elastic.c:                   /E->ve_data_cont.ice_stress_scale,        // (nondim height)
Visco_elastic.c:                   E->slice_ve.total_dynamic_oceanload[m][j] //   
Visco_elastic.c:                   /E->ve_data_cont.ice_stress_scale         // 
Visco_elastic.c:                        E->slice_ve.surf[3][m][j],       // total topography
Visco_elastic.c:                        E->slice_ve.surf[1][m][j],       // incr topo
Visco_elastic.c:                        E->init_potential[0][m][j],   // total potential
Visco_elastic.c:                        E->Xsurf[3][m][j],           // incr potential
Visco_elastic.c:                        //E->incr_potential[0][m][j]);  // incr potential due to loads change only
Visco_elastic.c:                        E->sphere.cap[m].total_VS[1][j],        
Visco_elastic.c:                        E->sphere.cap[m].V[1][i],        
Visco_elastic.c:                        E->sphere.cap[m].total_VS[2][j],        
Visco_elastic.c:                        E->sphere.cap[m].V[2][i]);        
Visco_elastic.c:            sphere_expansion_output(E,1, E->slice_ve.surf[3],
Visco_elastic.c:                                         E->sphere.sphc[2], E->sphere.sphs[2],
Visco_elastic.c:                                         E->monitor.solution_cycles, "tps");
Visco_elastic.c:            sphere_expansion_output(E,1, E->slice_ve.surf[1],
Visco_elastic.c:                                         E->sphere.sphc[0],E->sphere.sphs[0],
Visco_elastic.c:                                         E->monitor.solution_cycles,"vtps");
Visco_elastic.c:            sphere_expansion_output(E,1, E->init_potential[0],
Visco_elastic.c:                                         E->sphere.sphc[3],E->sphere.sphs[3],
Visco_elastic.c:                                         E->monitor.solution_cycles,"pttl");
Visco_elastic.c:            sphere_expansion_output(E,1, E->Xsurf[3],
Visco_elastic.c:                                         E->sphere.sphc[0],E->sphere.sphs[0],
Visco_elastic.c:                                         E->monitor.solution_cycles,"pttldot");
Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)
Visco_elastic.c:                for (j=1;j<=E->lmesh.nsf;j++)  { 
Visco_elastic.c:                    i=j*E->lmesh.noz;
Visco_elastic.c:                    E->Xsurf[1][m][j] = E->sphere.cap[m].total_VS[1][j];
Visco_elastic.c:                    E->Xsurf[2][m][j] = E->sphere.cap[m].total_VS[2][j];
Visco_elastic.c:            sphere_expansion_output(E,1, E->Xsurf[1],
Visco_elastic.c:                                         E->sphere.sphc[4],E->sphere.sphs[4],
Visco_elastic.c:                                         E->monitor.solution_cycles,"utheta");
Visco_elastic.c:            sphere_expansion_output(E,1, E->Xsurf[2],
Visco_elastic.c:                                         E->sphere.sphc[5],E->sphere.sphs[5],
Visco_elastic.c:                                         E->monitor.solution_cycles,"ufi");
Visco_elastic.c:        if (E->parallel.me_loc[3]==0)  {
Visco_elastic.c:                             E->control.data_file2,E->parallel.me,ii);
Visco_elastic.c:            //                 E->control.data_file,E->parallel.me,ii);
Visco_elastic.c:            fprintf(fp,"%05d %.5e\n",ii,E->monitor.elapsed_time);
Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:                for (j=1;j<=E->lmesh.nsf;j++)  { 
Visco_elastic.c:                    i=(j-1)*E->lmesh.noz+1;
Visco_elastic.c:                    E->Xsurf[1][m][j] = E->SX[E->mesh.levmax][m][1][i];
Visco_elastic.c:                    E->Xsurf[2][m][j] = E->SX[E->mesh.levmax][m][2][i];
Visco_elastic.c:                    E->Xsurf[3][m][j] = E->SX[E->mesh.levmax][m][3][i];
Visco_elastic.c:                               E->Xsurf[1][m][j],E->Xsurf[2][m][j],
Visco_elastic.c:                               E->slice_ve.botm[3][m][j],
Visco_elastic.c:                               E->U[m][E->id[m][i].doff[3]],E->potential[m][i]);
Visco_elastic.c:            sphere_expansion_output(E,0,E->slice_ve.botm[3],
Visco_elastic.c:                                        E->sphere.sphc[0],E->sphere.sphs[0],
Visco_elastic.c:                                        E->monitor.solution_cycles,"tpb");
Visco_elastic.c:            for (m=1;m<=E->sphere.caps_per_proc;m++)  
Visco_elastic.c:                for (j=1;j<=E->lmesh.nsf;j++)  { 
Visco_elastic.c:                    i=(j-1)*E->lmesh.noz+1;
Visco_elastic.c:                    E->Xsurf[3][m][j] = E->U[m][E->id[m][i].doff[3]];
Visco_elastic.c:            sphere_expansion_output(E,0,E->Xsurf[3],
Visco_elastic.c:                                     E->sphere.sphc[0],E->sphere.sphs[0],
Visco_elastic.c:                                     E->monitor.solution_cycles,"vtpb");
Visco_elastic.c: timea = E->monitor.elapsed_time;
Visco_elastic.c:  const int vpts = vpoints[E->mesh.nsd];
Visco_elastic.c:for (m=1;m<=E->sphere.caps_per_proc;m++)
Visco_elastic.c:  for (i=1;i<=E->lmesh.nel;i++)   {
Visco_elastic.c:    alpha = E->Maxwelltime[m][i]/(2.0*visc)*E->advection.timestep;
Visco_elastic.c:      evisc[m][(i-1)*vpts+j]=E->Maxwelltime[m][i]/(1.0+alpha);
Visco_elastic.c:    E->Maxwelltime[m][i] = (1.0-alpha)/(1.0+alpha);
Visco_elastic.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Visco_elastic.c:    const int nno=E->lmesh.nno;
Visco_elastic.c:    const int lev=E->mesh.levmax;
Visco_elastic.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)      {
Visco_elastic.c:    for(e=1;e<=E->lmesh.nel;e++)  {
Visco_elastic.c:      gnxx = E->gNX[m][e].vpt;
Visco_elastic.c:      get_rtf_at_vpts(E,m,E->mesh.levmax,e,rtf);
Visco_elastic.c:      if ((e-1)%E->lmesh.elz==0)
Visco_elastic.c:        construct_c3x3matrix_el(E,e,&Cc,&Ccx,E->mesh.levmax,m,0);
Visco_elastic.c:        Visc = E->EVi[m][(e-1)*vpts+j];
Visco_elastic.c:                 +E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(1,k,1,i,j)]
Visco_elastic.c:                 +E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(3,k,i,j)]);
Visco_elastic.c:                (E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(1,k,i,j)]*ct
Visco_elastic.c:                +E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(3,k,i,j)]
Visco_elastic.c:                 +E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(2,k,2,i,j)])/sinaa);
Visco_elastic.c:                +E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(2,k,1,i,j)]
Visco_elastic.c:                -ct*Cc.vpt[BVINDEX(2,k,i,j)]*E->N.vpt[GNVINDEX(i,j)]
Visco_elastic.c:                +(E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(1,k,2,i,j)]
Visco_elastic.c:                +(E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(3,k,1,i,j)]
Visco_elastic.c:                 -E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(1,k,i,j)]));
Visco_elastic.c:                -rtf[3][j]*E->N.vpt[GNVINDEX(i,j)]*Cc.vpt[BVINDEX(2,k,i,j)]
Visco_elastic.c:                +rtf[3][j]/sinaa*(E->N.vpt[GNVINDEX(i,j)]*Ccx.vpt[BVXINDEX(3,k,2,i,j)]+gnxx[GNVXINDEX(1,i,j)]*Cc.vpt[BVINDEX(3,k,i,j)]));
Visco_elastic.c:        E->Sxx[m][(e-1)*vpts+j]=2.0*Visc*Sxyz1 + E->Maxwelltime[m][e]*E->Sxx[m][(e-1)*vpts+j];
Visco_elastic.c:        E->Syy[m][(e-1)*vpts+j]=2.0*Visc*Sxyz2 + E->Maxwelltime[m][e]*E->Syy[m][(e-1)*vpts+j];
Visco_elastic.c:        E->Szz[m][(e-1)*vpts+j]=2.0*Visc*Sxyz3 + E->Maxwelltime[m][e]*E->Szz[m][(e-1)*vpts+j];
Visco_elastic.c:        E->Sxy[m][(e-1)*vpts+j]=    Visc*Sxyz4 + E->Maxwelltime[m][e]*E->Sxy[m][(e-1)*vpts+j];
Visco_elastic.c:        E->Sxz[m][(e-1)*vpts+j]=    Visc*Sxyz5 + E->Maxwelltime[m][e]*E->Sxz[m][(e-1)*vpts+j];
Visco_elastic.c:        E->Szy[m][(e-1)*vpts+j]=    Visc*Sxyz6 + E->Maxwelltime[m][e]*E->Szy[m][(e-1)*vpts+j];
Visco_elastic.c:      E->S2xx[m][e] = E->S2yy[m][e] = E->S2zz[m][e] = E->S2xy[m][e] = E->S2xz[m][e] = E->S2zy[m][e] = 0.0;
Visco_elastic.c:         E->S2xx[m][e] += E->Sxx[m][(e-1)*vpts+j];
Visco_elastic.c:         E->S2yy[m][e] += E->Syy[m][(e-1)*vpts+j];
Visco_elastic.c:         E->S2zz[m][e] += E->Szz[m][(e-1)*vpts+j];
Visco_elastic.c:         E->S2xy[m][e] += E->Sxy[m][(e-1)*vpts+j];
Visco_elastic.c:         E->S2xz[m][e] += E->Sxz[m][(e-1)*vpts+j];
Visco_elastic.c:         E->S2zy[m][e] += E->Szy[m][(e-1)*vpts+j];
Visco_elastic.c:      E->S2xx[m][e] = E->S2xx[m][e]/vpts;
Visco_elastic.c:      E->S2yy[m][e] = E->S2yy[m][e]/vpts;
Visco_elastic.c:      E->S2zz[m][e] = E->S2zz[m][e]/vpts;
Visco_elastic.c:      E->S2xy[m][e] = E->S2xy[m][e]/vpts;
Visco_elastic.c:      E->S2xz[m][e] = E->S2xz[m][e]/vpts;
Visco_elastic.c:      E->S2zy[m][e] = E->S2zy[m][e]/vpts;
Visco_elastic.c:      if (!E->viscosity.SDEPV)  {
Visco_elastic.c:      E->S2inv[m][e]=E->S2xx[m][e]*E->S2xx[m][e]+E->S2xy[m][e]*E->S2xy[m][e]*2.0
Visco_elastic.c:                    +E->S2yy[m][e]*E->S2yy[m][e]+E->S2zy[m][e]*E->S2zy[m][e]*2.0
Visco_elastic.c:                    +E->S2zz[m][e]*E->S2zz[m][e]+E->S2xz[m][e]*E->S2xz[m][e]*2.0;
Visco_elastic.c:      E->S2inv[m][e] = sqrt(0.5*E->S2inv[m][e]);   
Visco_elastic.c:    const int dims=E->mesh.nsd;
Visco_elastic.c:    const int dofs=E->mesh.dof;
Visco_elastic.c:    const int nno=E->mesh.nno;
Visco_elastic.c:    const int lev=E->mesh.levmax;
Visco_elastic.c:    if(E->advection.fixed_timestep != 0.0) {
Visco_elastic.c:      E->advection.timestep = E->advection.fixed_timestep;
Visco_elastic.c:  E->ve_data_cont.DIRECT=0;    // 1: means updating viscosity/stiffness matrix
Visco_elastic.c: for (i=stages;i<E->ve_data_cont.stages;i++) {
Visco_elastic.c:    E->ve_data_cont.stage = i;
Visco_elastic.c:    E->advection.timestep = E->ve_data_cont.stages_timestep[i];
Visco_elastic.c:       been = E->ve_data_cont.stages_step[i-1]+1;
Visco_elastic.c:    if ( E->monitor.solution_cycles < E->ve_data_cont.stages_step[i] )  {
Visco_elastic.c:       E->advection.next_timestep = E->ve_data_cont.stages_timestep[i];
Visco_elastic.c:       if (E->monitor.solution_cycles==been) {  // the 1st step of the stage
Visco_elastic.c:             E->ve_data_cont.DIRECT=1;
Visco_elastic.c:    else if ( E->monitor.solution_cycles == E->ve_data_cont.stages_step[i] )  {
Visco_elastic.c:       if ( i == E->ve_data_cont.stages-1 ) // last stage
Visco_elastic.c:           E->advection.next_timestep = E->advection.timestep ;
Visco_elastic.c:           E->advection.next_timestep = E->ve_data_cont.stages_timestep[i+1];
Visco_elastic.c:  stages = E->ve_data_cont.stage;
Viscosity_structures.c:    int m=E->parallel.me;
Viscosity_structures.c:        E->viscosity.N0[i]=1.0;
Viscosity_structures.c:        E->viscosity.T[i] = 0.0;
Viscosity_structures.c:        E->viscosity.Z[i] = 0.0;
Viscosity_structures.c:        E->viscosity.E[i] = 0.0;
Viscosity_structures.c:	E->viscosity.pdepv_a[i] = 1.e20; /* \sigma_y = min(a + b * (1-r),y) */
Viscosity_structures.c:	E->viscosity.pdepv_b[i] = 0.0;
Viscosity_structures.c:	E->viscosity.pdepv_y[i] = 1.e20;
Viscosity_structures.c:      E->viscosity.cdepv_ff[i] = 1.0; /* flavor factors for CDEPV */
Viscosity_structures.c:    input_boolean("VISC_UPDATE",&(E->viscosity.update_allowed),"on",m);
Viscosity_structures.c:    input_int("rheol",&(E->viscosity.RHEOL),"3",m);
Viscosity_structures.c:    E->viscosity.FROM_FILE = 0;
Viscosity_structures.c:    input_int("3d_visc_from_file",&(E->viscosity.FROM_FILE),"0",m);
Viscosity_structures.c:    if (E->viscosity.FROM_FILE) {
Viscosity_structures.c:      input_string("3d_visc_datafile",E->ve_data_cont.visc_file,"initialize",m);
Viscosity_structures.c:    input_int("compressible",&(E->ve_data_cont.compressible),"0",m);
Viscosity_structures.c:    E->ve_data_cont.1Dmodel_read=0;
Viscosity_structures.c:    input_int("1Dmodel_from_file",&(E->ve_data_cont.1Dmodel_read),"0",m);
Viscosity_structures.c:    if(E->ve_data_cont.1Dmodel_read) {
Viscosity_structures.c:      input_string("1Dmodel_datafile",E->ve_data_cont.1Dmodel_file,"initialize",m);
Viscosity_structures.c:    input_float_vector("visc0",E->viscosity.num_mat,(E->viscosity.N0),m);
Viscosity_structures.c:    input_float_vector("shearModulus",E->viscosity.num_mat,(E->viscosity.G),m);
Viscosity_structures.c:    input_boolean("TDEPV",&(E->viscosity.TDEPV),"on",m);
Viscosity_structures.c:    if (E->viscosity.TDEPV) {
Viscosity_structures.c:        input_float_vector("viscT",E->viscosity.num_mat,(E->viscosity.T),m);
Viscosity_structures.c:        input_float_vector("viscE",E->viscosity.num_mat,(E->viscosity.E),m);
Viscosity_structures.c:        input_float_vector("viscZ",E->viscosity.num_mat,(E->viscosity.Z),m);
Viscosity_structures.c:        input_float("T_sol0",&(E->viscosity.T_sol0),"0.6",m);
Viscosity_structures.c:        input_float("ET_red",&(E->viscosity.ET_red),"0.1",m);
Viscosity_structures.c:    E->viscosity.beta=1.0;
Viscosity_structures.c:    input_float("polar_wander_relax",&(E->viscosity.beta),"1.000",m);
Viscosity_structures.c:    E->viscosity.sdepv_misfit = 1.0;
Viscosity_structures.c:    input_boolean("SDEPV",&(E->viscosity.SDEPV),"off",m);
Viscosity_structures.c:    if (E->viscosity.SDEPV) {
Viscosity_structures.c:      E->viscosity.sdepv_visited = 0;
Viscosity_structures.c:      input_float_vector("sdepv_expt",E->viscosity.num_mat,(E->viscosity.sdepv_expt),m);
Viscosity_structures.c:      input_float_vector("sdepv_trns",E->viscosity.num_mat,(E->viscosity.sdepv_trns),m);
Viscosity_structures.c:      input_float_vector("sdepv_bg",E->viscosity.num_mat,(E->viscosity.sdepv_bg),m);
Viscosity_structures.c:      input_float("sdepv_relax_alpha",&(E->viscosity.alpha),"1.000",m);
Viscosity_structures.c:      for(i=0;i<E->viscosity.num_mat;i++) {
Viscosity_structures.c:        E->viscosity.sdepv_trns[i]=E->viscosity.sdepv_trns[i]/E->ve_data_cont.shear_mod;
Viscosity_structures.c:        E->viscosity.sdepv_bg[i]  =E->viscosity.sdepv_bg[i]  /E->ve_data_cont.shear_mod;
Viscosity_structures.c:    input_boolean("PDEPV",&(E->viscosity.PDEPV),"off",m); /* plasticity addition by TWB */
Viscosity_structures.c:    if (E->viscosity.PDEPV) {
Viscosity_structures.c:      E->viscosity.pdepv_visited = 0;
Viscosity_structures.c:      input_boolean("pdepv_eff",&(E->viscosity.pdepv_eff),"on",m);
Viscosity_structures.c:      input_float_vector("pdepv_a",E->viscosity.num_mat,(E->viscosity.pdepv_a),m);
Viscosity_structures.c:      input_float_vector("pdepv_b",E->viscosity.num_mat,(E->viscosity.pdepv_b),m);
Viscosity_structures.c:      input_float_vector("pdepv_y",E->viscosity.num_mat,(E->viscosity.pdepv_y),m);
Viscosity_structures.c:      input_float("pdepv_offset",&(E->viscosity.pdepv_offset),"0.0",m);
Viscosity_structures.c:      input_float("sdepv_misfit",&(E->viscosity.sdepv_misfit),"0.001",m);
Viscosity_structures.c:    input_boolean("CDEPV",&(E->viscosity.CDEPV),"off",m);
Viscosity_structures.c:    if(E->viscosity.CDEPV){
Viscosity_structures.c:      if(E->control.tracer < 1){
Viscosity_structures.c:      if(E->trace.nflavors > 10)
Viscosity_structures.c:      input_float_vector("cdepv_ff",E->trace.nflavors,
Viscosity_structures.c:			 (E->viscosity.cdepv_ff),m);
Viscosity_structures.c:      for(i=0;i<E->trace.nflavors;i++)
Viscosity_structures.c:	E->viscosity.cdepv_ff[i] = log(E->viscosity.cdepv_ff[i]);
Viscosity_structures.c:    input_boolean("low_visc_channel",&(E->viscosity.channel),"off",m);
Viscosity_structures.c:    input_boolean("low_visc_wedge",&(E->viscosity.wedge),"off",m);
Viscosity_structures.c:    input_float("lv_min_radius",&(E->viscosity.lv_min_radius),"0.9764",m);
Viscosity_structures.c:    input_float("lv_max_radius",&(E->viscosity.lv_max_radius),"0.9921",m);
Viscosity_structures.c:    input_float("lv_channel_thickness",&(E->viscosity.lv_channel_thickness),"0.0047",m);
Viscosity_structures.c:    input_float("lv_reduction",&(E->viscosity.lv_reduction),"0.5",m);
Viscosity_structures.c:    input_boolean("VMAX",&(E->viscosity.MAX),"off",m);
Viscosity_structures.c:    if (E->viscosity.MAX)
Viscosity_structures.c:        input_float("visc_max",&(E->viscosity.max_value),"1e22,1,nomax",m);
Viscosity_structures.c:    input_boolean("VMIN",&(E->viscosity.MIN),"off",m);
Viscosity_structures.c:    if (E->viscosity.MIN)
Viscosity_structures.c:        input_float("visc_min",&(E->viscosity.min_value),"1e20",m);
Viscosity_structures.c:    int m = E->parallel.me;
Viscosity_structures.c:    input_string("Viscosity",E->viscosity.STRUCTURE,"system",m);
Viscosity_structures.c:    input_int ("visc_smooth_method",&(E->viscosity.smooth_cycles),"0",m);
Viscosity_structures.c:    E->viscosity.FROM_SYSTEM = 1;
Viscosity_structures.c:    if (E->viscosity.FROM_SYSTEM)
Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:    if (E->viscosity.SDEPV)  {
Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:          for(e=1;e<=E->lmesh.nel;e++) {
Viscosity_structures.c:            E->EVolder[m][e] = 1.0;
Viscosity_structures.c:            E->EVold[m][e] = 1.0;
Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:          for(e=1;e<=E->lmesh.nel;e++) {
Viscosity_structures.c:            E->EVolder[m][e] = E->EVold[m][e];
Viscosity_structures.c:            E->EVold[m][e] = 0.125*
Viscosity_structures.c: 		(visc[m][E->ien[m][e].node[1]] + visc[m][E->ien[m][e].node[2]]
Viscosity_structures.c: 		+visc[m][E->ien[m][e].node[3]] + visc[m][E->ien[m][e].node[4]]
Viscosity_structures.c: 		+visc[m][E->ien[m][e].node[5]] + visc[m][E->ien[m][e].node[6]]
Viscosity_structures.c: 		+visc[m][E->ien[m][e].node[7]] + visc[m][E->ien[m][e].node[8]]);
Viscosity_structures.c:    if (!E->ve_data_cont.1Dmodel_read) {   // use mat group
Viscosity_structures.c:       if (E->viscosity.FROM_FILE)   // read 3D viscosity
Viscosity_structures.c://    if(E->viscosity.TDEPV)
Viscosity_structures.c://    if(E->viscosity.CDEPV)	/* compositional prefactor */
Viscosity_structures.c:    if(E->viscosity.SDEPV)
Viscosity_structures.c:    if(E->viscosity.PDEPV)	/* "plasticity" */
Viscosity_structures.c://    if(E->viscosity.channel || E->viscosity.wedge)
Viscosity_structures.c:    if(E->viscosity.MAX) {
Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:            for(i=1;i<=E->lmesh.nel;i++)
Viscosity_structures.c:                    if(evisc[m][(i-1)*vpts + j] > E->viscosity.max_value)
Viscosity_structures.c:                        evisc[m][(i-1)*vpts + j] = E->viscosity.max_value;
Viscosity_structures.c:    if(E->viscosity.MIN) {
Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:            for(i=1;i<=E->lmesh.nel;i++)
Viscosity_structures.c:                    if(evisc[m][(i-1)*vpts + j] < E->viscosity.min_value)
Viscosity_structures.c:                        evisc[m][(i-1)*vpts + j] = E->viscosity.min_value;
Viscosity_structures.c:    if (E->control.verbose)  {
Viscosity_structures.c:      fprintf(E->fp_out,"output_evisc0 %d\n",E->monitor.solution_cycles);
Viscosity_structures.c:      for(m=1;m<=E->sphere.caps_per_proc;m++) {
Viscosity_structures.c:        fprintf(E->fp_out,"output_evisc for cap %d\n",E->sphere.capid[m]);
Viscosity_structures.c:      for(i=1;i<=E->lmesh.elz;i++)
Viscosity_structures.c:          fprintf(E->fp_out,"%d %d %f\n",i,E->mat[m][i],evisc[m][(i-1)*vpts+1]);
Viscosity_structures.c:      fflush(E->fp_out);
Viscosity_structures.c:    visc_from_gint_to_nodes(E,evisc,visc,E->mesh.levmax);
Viscosity_structures.c:    if (!E->ve_data_cont.compressible)
Viscosity_structures.c:    else if (E->ve_data_cont.compressible)
Viscosity_structures.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:    for(i=1;i<=E->lmesh.nel;i++)  {   
Viscosity_structures.c:      E->Maxwelltime[m][i] = E->viscosity.G[E->mat[m][i]-1];
Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:    const int lev = E->mesh.levmax;
Viscosity_structures.c:    sprintf(output_file,"%s",E->ve_data_cont.1Dmodel_file);
Viscosity_structures.c:      radius[i] = tmp1*1000.0/E->sphere.dradius;
Viscosity_structures.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:    for (jj=1;jj<=E->lmesh.elz;jj++)  {
Viscosity_structures.c:      rr = (E->sx[m][3][jj]+E->sx[m][3][jj+1])/2.0;
Viscosity_structures.c:      for (i=1;i<=E->lmesh.ely;i++)  
Viscosity_structures.c:      for (j=1;j<=E->lmesh.elx;j++)  {
Viscosity_structures.c:         el = jj + (j-1)*E->lmesh.elz + (i-1)*E->lmesh.elz*E->lmesh.elx;
Viscosity_structures.c:         E->erho[lev][m][el] = tmp1/E->data.density;
Viscosity_structures.c:         E->elambda[lev][m][el] = tmp2/E->ve_data_cont.shear_mod;;
Viscosity_structures.c:         E->esmu[lev][m][el] = tmp3/E->ve_data_cont.shear_mod;;
Viscosity_structures.c:         E->egrav[lev][m][el] = tmp4/E->data.grav_acc;
Viscosity_structures.c:         E->Maxwelltime[m][el] = E->esmu[lev][m][el];
Viscosity_structures.c:         for(k=1;k<=vpoints[E->mesh.nsd];k++)
Viscosity_structures.c:            EEta[m][ (el-1)*vpts+k ] = tmp5/E->data.ref_viscosity;
Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:    sprintf(output_file,"%s",E->ve_data_cont.visc_file);
Viscosity_structures.c:      ave_visc = (float *)malloc((E->lmesh.noz+1)*sizeof(float));
Viscosity_structures.c:      for (m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:         visc_FE[m] = (double *)malloc((E->lmesh.nsf+1)*sizeof(double));
Viscosity_structures.c:      radius_visc[i] = E->sphere.ro-temp1*1000.0/E->sphere.dradius;
Viscosity_structures.c://if(E->parallel.me==0) fprintf(E->fp_out,"visc model radius info %d %g\n",i,radius_visc[i]);
Viscosity_structures.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:    for (jj=1;jj<=E->lmesh.elz;jj++)  {
Viscosity_structures.c:      rr = (E->sx[m][3][jj]+E->sx[m][3][jj+1])/2.0;
Viscosity_structures.c:      sprintf(output_file,"%s",E->ve_data_cont.visc_file);
Viscosity_structures.c://if(E->parallel.me==0) fprintf(stderr,"%d %d %d rr= %g %g %g\n",jj,i1,i2,rr,temp1,temp2);
Viscosity_structures.c:      for (i=1;i<=E->lmesh.ely;i++)  
Viscosity_structures.c:      for (j=1;j<=E->lmesh.elx;j++)  {
Viscosity_structures.c:         ee = j + (i-1)*E->lmesh.elx;      
Viscosity_structures.c:         temp1 =( visc_FE[m][E->sien[m][ee].node[1]] 
Viscosity_structures.c:                + visc_FE[m][E->sien[m][ee].node[2]] 
Viscosity_structures.c:                + visc_FE[m][E->sien[m][ee].node[3]] 
Viscosity_structures.c:                + visc_FE[m][E->sien[m][ee].node[4]])/4.0; 
Viscosity_structures.c:         el = jj + (j-1)*E->lmesh.elz + (i-1)*E->lmesh.elz*E->lmesh.elx;
Viscosity_structures.c:         for(k=1;k<=vpoints[E->mesh.nsd];k++)
Viscosity_structures.c:            EEta[m][ (el-1)*vpts+k ] = temp1/E->data.ref_viscosity;
Viscosity_structures.c:  visc_from_gint_to_nodes(E,EEta,visc,E->mesh.levmax);
Viscosity_structures.c:  for(m=1;m<=E->sphere.caps_per_proc;m++) {
Viscosity_structures.c:    for(k=1;k<=E->lmesh.noz;k++)   {
Viscosity_structures.c:      sprintf(output_file,"visc.%d.%d",k,E->parallel.me);
Viscosity_structures.c:      fprintf(fp1,"%.6e %.6e\n",E->sx[m][3][k],6370.0*(1.0-E->sx[m][3][k]));
Viscosity_structures.c:      for(i=1;i<=E->lmesh.noy;i++)  
Viscosity_structures.c:        for(j=1;j<=E->lmesh.nox;j++)  {
Viscosity_structures.c:          nn=k+(j-1)*E->lmesh.noz+(i-1)*E->lmesh.noz*E->lmesh.nox;
Viscosity_structures.c:          visc[m][nn] = visc[m][nn]*E->data.ref_viscosity;
Viscosity_structures.c:          fprintf(fp1,"%.5e %.5e %.5e\n",90-180*E->sx[m][1][nn]/M_PI,180*E->sx[m][2][nn]/M_PI,visc[m][nn]);
Viscosity_structures.c:          visc[m][nn] = visc[m][nn]/E->data.ref_viscosity;
Viscosity_structures.c:   if (E->parallel.me==0)  {
Viscosity_structures.c:     fprintf(E->fp_out,"average visc vs radius after the interpolation to FE grid\n"); 
Viscosity_structures.c:     for(k=1;k<=E->lmesh.noz;k++)   {
Viscosity_structures.c:       fprintf(E->fp_out,"%d %.5e %.5e\n",k,E->sx[1][3][k],ave_visc[k]*E->data.ref_viscosity); 
Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:        for(i=1;i<=E->lmesh.nel;i++)
Viscosity_structures.c:            for(jj=1;jj<=vpoints[E->mesh.nsd];jj++)
Viscosity_structures.c:                EEta[m][ (i-1)*vpts+jj ] = E->viscosity.N0[E->mat[m][i]-1];
Viscosity_structures.c:      fprintf(E->fp_out,"output_evisc0 %d\n",E->monitor.solution_cycles);
Viscosity_structures.c:      for(m=1;m<=E->sphere.caps_per_proc;m++) {
Viscosity_structures.c:        fprintf(E->fp_out,"output_evisc0 for cap %d\n",E->sphere.capid[m]);
Viscosity_structures.c:      for(i=1;i<=E->lmesh.elz;i++)
Viscosity_structures.c:          fprintf(E->fp_out,"%d %d %f %f\n",i,E->mat[m][i],EEta[m][(i-1)*8+1],EEta[m][(i-1)*8+7]);
Viscosity_structures.c:      fflush(E->fp_out);
Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:    const int ends = enodes[E->mesh.nsd];
Viscosity_structures.c:    const int nel = E->lmesh.nel;
Viscosity_structures.c:    switch (E->viscosity.RHEOL)   {
Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:                l = E->mat[m][i] - 1;
Viscosity_structures.c:                if(E->control.mat_control==0)
Viscosity_structures.c:                    tempa = E->viscosity.N0[l];
Viscosity_structures.c:                else if(E->control.mat_control==1)
Viscosity_structures.c:                    tempa = E->viscosity.N0[l]*E->VIP[m][i];
Viscosity_structures.c:                    TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Viscosity_structures.c:                        temp += TT[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:                        exp( E->viscosity.E[l] * (E->viscosity.T[l] - temp));
Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:                l = E->mat[m][i] - 1;
Viscosity_structures.c:                if(E->control.mat_control==0)
Viscosity_structures.c:                    tempa = E->viscosity.N0[l];
Viscosity_structures.c:                else if(E->control.mat_control==1)
Viscosity_structures.c:                    tempa = E->viscosity.N0[l]*E->VIP[m][i];
Viscosity_structures.c:                    TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Viscosity_structures.c:                        temp += TT[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:                        exp( -temp / E->viscosity.T[l]);
Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:                l = E->mat[m][i] - 1;
Viscosity_structures.c:		if(E->control.mat_control) /* switch moved up here TWB */
Viscosity_structures.c:		  tempa = E->viscosity.N0[l] * E->VIP[m][i];
Viscosity_structures.c:		  tempa = E->viscosity.N0[l];
Viscosity_structures.c:		  TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Viscosity_structures.c:		      temp += min(TT[kk],one) * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:		      exp( E->viscosity.E[l]/(temp+E->viscosity.T[l])
Viscosity_structures.c:			   - E->viscosity.E[l]/(one +E->viscosity.T[l]) );
Viscosity_structures.c:        for(m=1;m<=E->sphere.caps_per_proc;m++)
Viscosity_structures.c:                l = E->mat[m][i] - 1;
Viscosity_structures.c:		if(E->control.mat_control) /* moved this up here TWB */
Viscosity_structures.c:		  tempa = E->viscosity.N0[l] * E->VIP[m][i];
Viscosity_structures.c:		  tempa = E->viscosity.N0[l];
Viscosity_structures.c:                    TT[kk] = E->T[m][E->ien[m][i].node[kk]];
Viscosity_structures.c:                    zz[kk] = (1.-E->sx[m][3][E->ien[m][i].node[kk]]);
Viscosity_structures.c:                        temp += min(TT[kk],one) * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:                        zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:		      exp( (E->viscosity.E[l] +  E->viscosity.Z[l]*zzz )
Viscosity_structures.c:			   / (E->viscosity.T[l]+temp) );
Viscosity_structures.c:                E->viscosity.RHEOL);
Viscosity_structures.c:        fprintf(stderr, "Invalid value of 'rheol=%d'\n", E->viscosity.RHEOL);
Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:    const int nel = E->lmesh.nel;
Viscosity_structures.c:      for(m=1;m<=E->sphere.caps_per_proc;m++)  
Viscosity_structures.c:	  E->S2inv[m][e] = 1.0;
Viscosity_structures.c:      stress_2_inv(E,E->S2inv,1,E->viscosity.iterate);
Viscosity_structures.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)  
Viscosity_structures.c:           l = E->mat[m][e] - 1;
Viscosity_structures.c:           temp1 = (E->S2inv[m][e] + E->viscosity.sdepv_bg[l])/E->viscosity.sdepv_trns[l];
Viscosity_structures.c:           exponent1= E->viscosity.sdepv_expt[l]-one;
Viscosity_structures.c:           temp2 = E->viscosity.sdepv_bg[l]/E->viscosity.sdepv_trns[l];
Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:    const int nel = E->lmesh.nel;
Viscosity_structures.c:    const int ends = enodes[E->mesh.nsd];
Viscosity_structures.c:    for(m=1;m<=E->sphere.caps_per_proc;m++)  {
Viscosity_structures.c:      if(E->viscosity.pdepv_visited){
Viscosity_structures.c:	if(m == E->sphere.caps_per_proc)
Viscosity_structures.c:	  E->viscosity.pdepv_visited = 1;
Viscosity_structures.c:	if((E->parallel.me == 0)&&(E->control.verbose)){
Viscosity_structures.c:	  for(e=0;e < E->viscosity.num_mat;e++)
Viscosity_structures.c:		    e,E->viscosity.pdepv_a[e],E->viscosity.pdepv_b[e],E->viscosity.pdepv_y[e]);
Viscosity_structures.c:	l = E->mat[m][e] -1 ;	/* material of this element */
Viscosity_structures.c:	  zz[kk] = (1.0 - E->sx[m][3][E->ien[m][e].node[kk]]); /* for depth, zz = 1 - r */
Viscosity_structures.c:	    zzz += zz[kk] * E->N.vpt[GNVINDEX(kk,jj)];
Viscosity_structures.c:	  tau = E->viscosity.pdepv_a[l] + zzz * E->viscosity.pdepv_b[l];
Viscosity_structures.c:	  tau = min(tau,  E->viscosity.pdepv_y[l]);
Viscosity_structures.c:	  eta_p = tau/(2.0 * eedot[e] + 1e-7) + E->viscosity.pdepv_offset;
Viscosity_structures.c:	  if(E->viscosity.pdepv_eff){
Viscosity_structures.c:	  //zzz,l,E->viscosity.pdepv_a[l], E->viscosity.pdepv_b[l],E->viscosity.pdepv_y[l],
Viscosity_structures.c:  const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:  const int nel = E->lmesh.nel;
Viscosity_structures.c:  const int ends = enodes[E->mesh.nsd];
Viscosity_structures.c:  for(m=1;m <= E->sphere.caps_per_proc;m++)  {
Viscosity_structures.c:        for(p=0; p<E->composition.ncomp; p++) {
Viscosity_structures.c:                CC[p][kk] = E->composition.comp_node[m][p][E->ien[m][i].node[kk]];
Viscosity_structures.c:            for(p=0; p<E->composition.ncomp; p++) {
Viscosity_structures.c:                    cc_loc[p] += CC[p][kk] * E->N.vpt[GNVINDEX(kk, jj)];
Viscosity_structures.c:            vmean = cbackground * E->viscosity.cdepv_ff[0];
Viscosity_structures.c:            for(p=0; p<E->composition.ncomp; p++) {
Viscosity_structures.c:                vmean += cc_loc[p] * E->viscosity.cdepv_ff[p+1];
Viscosity_structures.c:    const int nel = E->lmesh.nel;
Viscosity_structures.c:    const int dims = E->mesh.nsd;
Viscosity_structures.c:    const int lev = E->mesh.levmax;
Viscosity_structures.c:        GNx = &(E->gNX[m][e]);
Viscosity_structures.c:        if ((E->control.precise_strain_rate) || (theta < 0.09) || (theta > 3.05)) {
Viscosity_structures.c:            if ((e-1)%E->lmesh.elz==0) {
Viscosity_structures.c:                construct_c3x3matrix_el(E,e,&E->element_Cc,&E->element_Ccx,lev,m,1);
Viscosity_structures.c:            get_ba_p(&(E->N), GNx, &E->element_Cc, &E->element_Ccx,
Viscosity_structures.c:                     rtf, E->mesh.nsd, ba);
Viscosity_structures.c:                                   + VV[3][i] * E->N.ppt[GNPINDEX(i, j)])
Viscosity_structures.c:                                    + VV[1][i] * E->N.ppt[GNPINDEX(i, j)]
Viscosity_structures.c:                                   + VV[3][i] * E->N.ppt[GNPINDEX(i, j)])
Viscosity_structures.c:                                    - VV[2][i] * E->N.ppt[GNPINDEX(i, j)]
Viscosity_structures.c:                                       - VV[1][i] * E->N.ppt[GNPINDEX(i, j)]);
Viscosity_structures.c:                                       - VV[2][i] * E->N.ppt[GNPINDEX(i, j)]);
Viscosity_structures.c:        if(E->control.inv_gruneisen != 0) {
Viscosity_structures.c:    const int vpts = vpoints[E->mesh.nsd];
Viscosity_structures.c:    if(E->control.tracer == 0) {
Viscosity_structures.c:        if(E->parallel.me == 0) {
Viscosity_structures.c:            fprintf(E->fp, "Error: low viscosity channel/wedge is turned on, "
Viscosity_structures.c:            fflush(E->fp);
Viscosity_structures.c:    F = (float *)malloc((E->lmesh.nel+1)*sizeof(float));
Viscosity_structures.c:    for(i=1 ; i<=E->lmesh.nel ; i++)
Viscosity_structures.c:    if(E->viscosity.channel)
Viscosity_structures.c:    if(E->viscosity.wedge)
Viscosity_structures.c:    for(i=1 ; i<=E->lmesh.nel ; i++) {
Viscosity_structures.c:            for(m = 1 ; m <= E->sphere.caps_per_proc ; m++) {
Viscosity_structures.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Viscosity_structures.c:        for(e=1; e<=E->lmesh.elz; e++) {
Viscosity_structures.c:            rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Viscosity_structures.c:                              E->sx[m][3][E->ien[m][e].node[8]]);
Viscosity_structures.c:            if(rad_mean >= E->viscosity.lv_min_radius) break;
Viscosity_structures.c:        for(e=E->lmesh.elz; e>=1; e--) {
Viscosity_structures.c:            rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Viscosity_structures.c:                              E->sx[m][3][E->ien[m][e].node[8]]);
Viscosity_structures.c:            if(rad_mean <= E->viscosity.lv_max_radius) break;
Viscosity_structures.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Viscosity_structures.c:        for(k=1; k<=E->lmesh.elx*E->lmesh.ely; k++) {
Viscosity_structures.c:                e = (k-1)*E->lmesh.elz + i;
Viscosity_structures.c:                rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Viscosity_structures.c:                                  E->sx[m][3][E->ien[m][e].node[8]]);
Viscosity_structures.c:                    ee = (k-1)*E->lmesh.elz + ii;
Viscosity_structures.c:                    rr = 0.5 * (E->sx[m][3][E->ien[m][ee].node[1]] +
Viscosity_structures.c:                                E->sx[m][3][E->ien[m][ee].node[8]]);
Viscosity_structures.c:                    if((E->trace.ntracer_flavor[m][flavor][ee] > 0) &&
Viscosity_structures.c:                       (rad_mean <= rr + E->viscosity.lv_channel_thickness)) {
Viscosity_structures.c:                           F[e] = E->viscosity.lv_reduction;
Viscosity_structures.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Viscosity_structures.c:        for(e=1; e<=E->lmesh.nel; e++)
Viscosity_structures.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Viscosity_structures.c:        for(e=1; e<=E->lmesh.elz; e++) {
Viscosity_structures.c:            rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Viscosity_structures.c:                              E->sx[m][3][E->ien[m][e].node[8]]);
Viscosity_structures.c:            if(rad_mean >= E->viscosity.lv_min_radius) break;
Viscosity_structures.c:        for(e=E->lmesh.elz; e>=1; e--) {
Viscosity_structures.c:            rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Viscosity_structures.c:                              E->sx[m][3][E->ien[m][e].node[8]]);
Viscosity_structures.c:            if(rad_mean <= E->viscosity.lv_max_radius) break;
Viscosity_structures.c:    for(m=1; m<=E->sphere.caps_per_proc; m++) {
Viscosity_structures.c:        for(k=1; k<=E->lmesh.elx*E->lmesh.ely; k++) {
Viscosity_structures.c:                e = (k-1)*E->lmesh.elz + i;
Viscosity_structures.c:                rad_mean = 0.5 * (E->sx[m][3][E->ien[m][e].node[1]] +
Viscosity_structures.c:                                  E->sx[m][3][E->ien[m][e].node[8]]);
Viscosity_structures.c:                    ee = (k-1)*E->lmesh.elz + ii;
Viscosity_structures.c:                    if(E->trace.ntracer_flavor[m][flavor][ee] > 0) {
Viscosity_structures.c:                        F[e] = E->viscosity.lv_reduction;
Viscosity_structures.c:    for(m=1; m<=E->sphere.caps_per_proc; m++)
Viscosity_structures.c:        for(e=1; e<=E->lmesh.nel; e++)
Viscosity_structures.c:    const int dims=E->mesh.nsd,dofs=E->mesh.dof;
Viscosity_structures.c:    const int nno=E->lmesh.nno;
Viscosity_structures.c:    const int lev=E->mesh.levmax;
Viscosity_structures.c:   alpha = E->viscosity.alpha;
Viscosity_structures.c:   onep_alpha = 1.0 - E->viscosity.alpha;
Viscosity_structures.c://fprintf(E->fp_out,"in_stress_2_inv %d %d\n",E->monitor.solution_cycles,E->viscosity.iterate);
Viscosity_structures.c:for(m=1;m<=E->sphere.caps_per_proc;m++)      {
Viscosity_structures.c:  for(e=1;e<=E->lmesh.nel;e++)  {
Viscosity_structures.c:        edot[1][1] = E->S2xx[m][e]; 
Viscosity_structures.c:        edot[2][2] = E->S2yy[m][e]; 
Viscosity_structures.c:        edot[3][3] = E->S2zz[m][e];
Viscosity_structures.c:        edot[1][2] = E->S2xy[m][e];
Viscosity_structures.c:        edot[1][3] = E->S2xz[m][e];
Viscosity_structures.c:        edot[2][3] = E->S2zy[m][e];
Viscosity_structures.c:/*        E->S2xx[m][e] = E->Maxwelltime[m][e]*E->S2xx[m][e]; 
Viscosity_structures.c:        E->S2yy[m][e] = E->Maxwelltime[m][e]*E->S2yy[m][e]; 
Viscosity_structures.c:        E->S2zz[m][e] = E->Maxwelltime[m][e]*E->S2zz[m][e]; 
Viscosity_structures.c:        E->S2xy[m][e] = E->Maxwelltime[m][e]*E->S2xy[m][e]; 
Viscosity_structures.c:        E->S2xz[m][e] = E->Maxwelltime[m][e]*E->S2xz[m][e]; 
Viscosity_structures.c:        E->S2zy[m][e] = E->Maxwelltime[m][e]*E->S2zy[m][e]; 
Viscosity_structures.c:      gnxx = E->gNX[m][e].ppt;
Viscosity_structures.c:      get_rtf_at_ppts(E,m,E->mesh.levmax,e,rtf);
Viscosity_structures.c:      if ((e-1)%E->lmesh.elz==0)
Viscosity_structures.c:        construct_c3x3matrix_el(E,e,&Cc,&Ccx,E->mesh.levmax,m,1);
Viscosity_structures.c:                 +E->N.ppt[GNPINDEX(i,1)]*Ccx.ppt[BPXINDEX(1,k,1,i,1)]
Viscosity_structures.c:                 +E->N.ppt[GNPINDEX(i,1)]*Cc.ppt[BPINDEX(3,k,i,1)]);
Viscosity_structures.c:                (E->N.ppt[GNPINDEX(i,1)]*Cc.ppt[BPINDEX(1,k,i,1)]*ct
Viscosity_structures.c:                +E->N.ppt[GNPINDEX(i,1)]*Cc.ppt[BPINDEX(3,k,i,1)]
Viscosity_structures.c:                 +E->N.ppt[GNPINDEX(i,1)]*Ccx.ppt[BPXINDEX(2,k,2,i,1)])/sinaa);
Viscosity_structures.c:                +E->N.ppt[GNPINDEX(i,1)]*Ccx.ppt[BPXINDEX(2,k,1,i,1)]
Viscosity_structures.c:                -ct*Cc.ppt[BPINDEX(2,k,i,1)]*E->N.ppt[GNPINDEX(i,1)]
Viscosity_structures.c:                +(E->N.ppt[GNPINDEX(i,1)]*Ccx.ppt[BPXINDEX(1,k,2,i,1)]
Viscosity_structures.c:                +(E->N.ppt[GNPINDEX(i,1)]*Ccx.ppt[BPXINDEX(3,k,1,i,1)]
Viscosity_structures.c:                 -E->N.ppt[GNPINDEX(i,1)]*Cc.ppt[BPINDEX(1,k,i,1)]));
Viscosity_structures.c:                -rtf[3][1]*E->N.ppt[GNPINDEX(i,1)]*Cc.ppt[BPINDEX(2,k,i,1)]
Viscosity_structures.c:                +rtf[3][1]/sinaa*(E->N.ppt[GNPINDEX(i,1)]*Ccx.ppt[BPXINDEX(3,k,2,i,1)]+gnxx[GNPXINDEX(1,i,1)]*Cc.ppt[BPINDEX(3,k,i,1)]));
Viscosity_structures.c:        visc1=onep_alpha*E->EVolder[m][e]+alpha*E->EVold[m][e];
Viscosity_structures.c:        a = E->Maxwelltime[m][e]/(2.0*visc1)*E->advection.timestep;
Viscosity_structures.c:        visc0 = E->Maxwelltime[m][e]/(1.0+a);
Viscosity_structures.c:        edot[1][1] = 2.0*visc0*Sxyz1 + maxwell0*E->S2xx[m][e]; 
Viscosity_structures.c:        edot[2][2] = 2.0*visc0*Sxyz2 + maxwell0*E->S2yy[m][e]; 
Viscosity_structures.c:        edot[3][3] = 2.0*visc0*Sxyz3 + maxwell0*E->S2zz[m][e];
Viscosity_structures.c:        edot[1][2] =    visc0*Sxyz4  + maxwell0*E->S2xy[m][e];
Viscosity_structures.c:        edot[1][3] =    visc0*Sxyz5  + maxwell0*E->S2xz[m][e];
Viscosity_structures.c:        edot[2][3] =    visc0*Sxyz6  + maxwell0*E->S2zy[m][e];
Viscosity_structures.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)   
Viscosity_structures.c:     for(e=1;e<=E->lmesh.nel;e++)
Viscosity_structures.c:  for(m=1;m<=E->sphere.caps_per_proc;m++)   
Viscosity_structures.c:     for(e=1;e<=E->lmesh.nel;e++)
cgrad_kernel.cu:    for(i=1;i<=E->num_zero_resid;i++)
cgrad_kernel.cu:        Res[E->zero_resid[i]] = 0.0;
cgrad_kernel.cu:    const int nel=E->lmesh.NEL;
cgrad_kernel.cu:    const int neq=E->lmesh.NEQ;
cgrad_kernel.cu:        E->mm[i].n = 0;
cgrad_kernel.cu:        E->mm[i].zero_res = 0;
cgrad_kernel.cu:            ii = E->IEN[e].node[a];
cgrad_kernel.cu:            a1 = E->ID[ii].doff[1];
cgrad_kernel.cu:            a2 = E->ID[ii].doff[2];
cgrad_kernel.cu:            a3 = E->ID[ii].doff[3];
cgrad_kernel.cu:            ++E->mm[a1].n;
cgrad_kernel.cu:            ++E->mm[a2].n;
cgrad_kernel.cu:            ++E->mm[a3].n;
cgrad_kernel.cu:    for(i=1;i<=E->num_zero_resid;i++)
cgrad_kernel.cu:        E->mm[E->zero_resid[i]].zero_res = 1;
cgrad_kernel.cu:    const int nel=E->lmesh.NEL;
cgrad_kernel.cu:    const int neq=E->lmesh.NEQ;
cgrad_kernel.cu:    ot = E->ot;
cgrad_kernel.cu:        E->mm[i].ot_i = ot - E->ot;
cgrad_kernel.cu:        ot += E->mm[i].n;
cgrad_kernel.cu:        E->mm[i].n = 0;
cgrad_kernel.cu:            ii = E->IEN[e].node[a];
cgrad_kernel.cu:            a1 = E->ID[ii].doff[1];
cgrad_kernel.cu:            a2 = E->ID[ii].doff[2];
cgrad_kernel.cu:            a3 = E->ID[ii].doff[3];
cgrad_kernel.cu:            o1 = E->mm[a1].n++;
cgrad_kernel.cu:            o2 = E->mm[a2].n++;
cgrad_kernel.cu:            o3 = E->mm[a3].n++;
cgrad_kernel.cu:            ot = E->ot + E->mm[a1].ot_i + o1;
cgrad_kernel.cu:            ot = E->ot + E->mm[a2].ot_i + o2;
cgrad_kernel.cu:            ot = E->ot + E->mm[a3].ot_i + o3;
cgrad_kernel.cu:        i = blockIdx.x; /* 0 <= i < E->lmesh.NEQ */
cgrad_kernel.cu:        if (strip_bcs && E->mm[i].zero_res) {
cgrad_kernel.cu:            if (o < E->mm[i].n) {
cgrad_kernel.cu:                ot = E->ot + E->mm[i].ot_i + o;
cgrad_kernel.cu:                    nodeb = E->IEN[e].node[b];
cgrad_kernel.cu:                        E->elt_k[e].k[ii+offset] *
cgrad_kernel.cu:                        u[E->ID[nodeb].doff[1]]
cgrad_kernel.cu:                        + E->elt_k[e].k[ii+offset+1] *
cgrad_kernel.cu:                        u[E->ID[nodeb].doff[2]]
cgrad_kernel.cu:                        + E->elt_k[e].k[ii+offset+2] *
cgrad_kernel.cu:                        u[E->ID[nodeb].doff[3]];
cgrad_kernel.cu:    neq=E->lmesh.NEQ;
cgrad_kernel.cu:    int neq = E->lmesh.NEQ;
cgrad_kernel.cu:    int nno = E->lmesh.NNO;
cgrad_kernel.cu:    int nel = E->lmesh.NEL;
cgrad_kernel.cu:    cudaMalloc((void**)&s_E->mm, neq * sizeof(struct matrix_mult));
cgrad_kernel.cu:    cudaMalloc((void**)&s_E->ot, E->n_octoterms * sizeof(struct octoterm));
cgrad_kernel.cu:    cudaMemcpy(s_E->mm, E->mm, neq * sizeof(struct matrix_mult), cudaMemcpyHostToDevice);
cgrad_kernel.cu:    cudaMemcpy(s_E->ot, E->ot, E->n_octoterms * sizeof(struct octoterm), cudaMemcpyHostToDevice);
cgrad_kernel.cu:    cudaMalloc((void**)&s_E->IEN, (nel+2)*sizeof(struct IEN));
cgrad_kernel.cu:    cudaMemcpy(s_E->IEN, E->IEN, (nel+2)*sizeof(struct IEN), cudaMemcpyHostToDevice);
cgrad_kernel.cu:    cudaMalloc((void **)&s_E->ID, (nno+1)*sizeof(struct ID));
cgrad_kernel.cu:    cudaMemcpy(s_E->ID, E->ID, (nno+1)*sizeof(struct ID), cudaMemcpyHostToDevice);
cgrad_kernel.cu:    cudaMalloc((void **)&s_E->elt_k, (nel+1)*sizeof(struct EK));
cgrad_kernel.cu:    cudaMemcpy(s_E->elt_k, E->elt_k, (nel+1)*sizeof(struct EK), cudaMemcpyHostToDevice);
cgrad_kernel.cu:    cudaFree(s_E->mm);
cgrad_kernel.cu:    cudaFree(s_E->ot);
cgrad_kernel.cu:    cudaFree(s_E->IEN);
cgrad_kernel.cu:    cudaFree(s_E->ID);
cgrad_kernel.cu:    cudaFree(s_E->elt_k);
cgrad_kernel.cu:    double *memory = E->memory;
cgrad_kernel.cu:    const int neq = E->lmesh.NEQ;
cgrad_kernel.cu:    assert(memory == E->memory + E->memoryDim);
cgrad_kernel.cu:            z1[i] = E->BI[i] * r1[i];
cgrad_kernel.cu:    neq  = E->lmesh.NEQ;
cgrad_kernel.cu:    cycles = E->control.v_steps_low;
cgrad_kernel.cu:    E->valid = (residual < acc)? 1:0;
cgrad_kernel.cu:    E->monitor.momentum_residual = residual;
cgrad_kernel.cu:    E->control.total_iteration_cycles += count;
cgrad_kernel.cu:    E->control.total_v_solver_calls += 1;
cgrad_kernel.cu:    assert(!E->control.NMULTIGRID);
cgrad_kernel.cu:    assert(!E->control.NASSEMBLE);
cgrad_kernel.cu:    assert(E->sphere.caps_per_proc == CAPS_PER_PROC);
cgrad_kernel.cu:    assert(E->mesh.nsd == NSD);
cgrad_kernel.cu:    assert(E->mesh.levmax == LEVEL);
cgrad_kernel.cu:    assert(E->parallel.nproc == 1);
cgrad_kernel.cu:    assert(E->parallel.TNUM_PASS[LEVEL][M] == 0);
cgrad_kernel.cu:    assert(E->parallel.Skip_neq[LEVEL][M] == 0);
cgrad_kernel.cu:    kE.num_zero_resid = E->num_zero_resid[LEVEL][M];
cgrad_kernel.cu:    kE.zero_resid = E->zero_resid[LEVEL][M];
cgrad_kernel.cu:    kE.lmesh.NEQ = E->lmesh.NEQ[LEVEL];
cgrad_kernel.cu:    kE.lmesh.NNO = E->lmesh.NNO[LEVEL];
cgrad_kernel.cu:    kE.lmesh.NEL = E->lmesh.NEL[LEVEL];
cgrad_kernel.cu:    kE.IEN   = E->IEN[LEVEL][M];
cgrad_kernel.cu:    kE.ID    = E->ID[LEVEL][M];
cgrad_kernel.cu:    kE.elt_k = E->elt_k[LEVEL][M];
cgrad_kernel.cu:    kE.Eqn_k1 = E->Eqn_k1[LEVEL][M];
cgrad_kernel.cu:    kE.Eqn_k2 = E->Eqn_k2[LEVEL][M];
cgrad_kernel.cu:    kE.Eqn_k3 = E->Eqn_k3[LEVEL][M];
cgrad_kernel.cu:    kE.Node_map = E->Node_map[LEVEL][M];
cgrad_kernel.cu:    kE.BI = E->BI[LEVEL][M];
cgrad_kernel.cu:    kE.control.NASSEMBLE = E->control.NASSEMBLE;
cgrad_kernel.cu:    kE.control.v_steps_low = E->control.v_steps_low;
cgrad_kernel.cu:    kE.control.total_iteration_cycles = E->control.total_iteration_cycles; /* in/out */
cgrad_kernel.cu:    kE.control.total_v_solver_calls = E->control.total_v_solver_calls; /* in/out */
cgrad_kernel.cu:    kE.memoryDim += 5 * E->lmesh.NEQ[LEVEL]  + /* r0,r1,r2,z0,z1 */
cgrad_kernel.cu:                    3 * (1+E->lmesh.NEQ[LEVEL]) /* p1,p2,Ap */
cgrad_kernel.cu:    E->control.total_iteration_cycles = kE.control.total_iteration_cycles;
cgrad_kernel.cu:    E->control.total_v_solver_calls = kE.control.total_v_solver_calls;
cgrad_kernel.cu:    E->monitor.momentum_residual = kE.monitor.momentum_residual;
ve_loading.h:    double potential_vary_PW;  // mult this by (eg) E->init_potential to get
ve_loading.h:    double potential_scaling;  // mult this by (eg) E->init_potential to get
